[{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\components\\tabs\\tab-ssf-editor\\TabSSFEditor.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":78,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":78,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `object`.","line":79,"column":32,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":79,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\n\nimport { MenuBar, MenuItem } from \"@/apps/forge/components/common/MenuBar\";\nimport { TabSSFEditorState } from \"@/apps/forge/states/tabs\";\nimport type { SSFObject } from \"@/resource/SSFObject\";\nimport \"@/apps/forge/components/tabs/tab-ssf-editor/TabSSFEditor.scss\";\n\ninterface BaseTabProps {\n  tab: TabSSFEditorState;\n}\n\nexport const TabSSFEditor = function(props: BaseTabProps){\n  const tab = props.tab as TabSSFEditorState;\n  const [ssf, setSsf] = useState(tab.ssf);\n\n  useEffect(() => {\n    const loadHandler = () => setSsf(tab.ssf);\n\n    tab.addEventListener('onEditorFileLoad', loadHandler);\n\n    return () => {\n      tab.removeEventListener('onEditorFileLoad', loadHandler);\n    };\n  }, [tab]);\n\n  const menuItems: MenuItem[] = [\n    {\n      label: 'File',\n      children: [\n        { label: 'Save', onClick: () => tab.save() },\n        { label: 'Save As', onClick: () => tab.saveAs() }\n      ]\n    }\n  ];\n\n  if(!ssf){\n    return (\n      <div className=\"forge-ssf-editor\">\n        <MenuBar items={menuItems} />\n        <div className=\"forge-ssf-editor__loading\">Loading sound set...</div>\n      </div>\n    );\n  }\n\n  const soundSlots = [\n    { id: 0, name: 'Battle Cry 1' },\n    { id: 1, name: 'Battle Cry 2' },\n    { id: 2, name: 'Battle Cry 3' },\n    { id: 3, name: 'Battle Cry 4' },\n    { id: 4, name: 'Battle Cry 5' },\n    { id: 5, name: 'Battle Cry 6' },\n    { id: 6, name: 'Select 1' },\n    { id: 7, name: 'Select 2' },\n    { id: 8, name: 'Select 3' },\n    { id: 9, name: 'Attack Grunt 1' },\n    { id: 10, name: 'Attack Grunt 2' },\n    { id: 11, name: 'Attack Grunt 3' },\n    { id: 12, name: 'Pain Grunt 1' },\n    { id: 13, name: 'Pain Grunt 2' },\n    { id: 14, name: 'Low Health' },\n    { id: 15, name: 'Dead' },\n    { id: 16, name: 'Critical Hit' },\n    { id: 17, name: 'Target Immune' },\n    { id: 18, name: 'Lay Mine' },\n    { id: 19, name: 'Disarm Mine' },\n    { id: 20, name: 'Begin Stealth' },\n    { id: 21, name: 'Begin Search' },\n    { id: 22, name: 'Begin Unlock' },\n    { id: 23, name: 'Unlock Failed' },\n    { id: 24, name: 'Unlock Success' },\n    { id: 25, name: 'Separated from Party' },\n    { id: 26, name: 'Rejoined Party' },\n    { id: 27, name: 'Poisoned' },\n  ];\n\n  /** Clone SSF preserving prototype so React re-renders; avoids unsafe any from Object.assign. */\n  function createSSFClone(source: SSFObject): SSFObject {\n    const proto = Object.getPrototypeOf(source);\n    const base = Object.create(proto) as SSFObject;\n    const src = source as unknown as Record<string, unknown>;\n    const dst = base as unknown as Record<string, unknown>;\n    for (const key of Object.keys(src)) {\n      dst[key] = src[key];\n    }\n    return base;\n  }\n\n  const updateSoundRef = (index: number, value: number) => {\n    if (ssf && ssf.sound_refs[index] !== undefined) {\n      ssf.sound_refs[index] = value;\n      tab.file.unsaved_changes = true;\n      const next: SSFObject = createSSFClone(ssf);\n      setSsf(next);\n    }\n  };\n\n  return (\n    <div className=\"forge-ssf-editor\">\n      <MenuBar items={menuItems} />\n      <div className=\"forge-ssf-editor__content\">\n        <div className=\"ssf-info\">\n          <h3>Sound Set Editor</h3>\n          <p>\n            SSF files map sound slots to dialog.tlk string references.\n            Each slot corresponds to a specific character action or event.\n          </p>\n          <div className=\"ssf-details\">\n            <div className=\"detail-item\">\n              <label>File Type:</label>\n              <span>{ssf.FileType}</span>\n            </div>\n            <div className=\"detail-item\">\n              <label>Version:</label>\n              <span>{ssf.FileVersion}</span>\n            </div>\n            <div className=\"detail-item\">\n              <label>Sound Slots:</label>\n              <span>{ssf.sound_refs.length}</span>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"sound-slots\">\n          <h4>Sound Slot Mappings</h4>\n          <div className=\"slots-grid\">\n            {soundSlots.map((slot) => {\n              const strRef = ssf.sound_refs[slot.id] || 0;\n              const soundResRef = ssf.GetSoundResRef(slot.id) || '(none)';\n\n              return (\n                <div key={slot.id} className=\"sound-slot\">\n                  <div className=\"slot-header\">\n                    <span className=\"slot-id\">[{slot.id}]</span>\n                    <span className=\"slot-name\">{slot.name}</span>\n                  </div>\n                  <div className=\"slot-content\">\n                    <label>StrRef:</label>\n                    <input\n                      title=\"StrRef\"\n                      placeholder=\"Sound string reference here...\"\n                      type=\"number\"\n                      value={strRef}\n                      onChange={(e) => updateSoundRef(slot.id, parseInt(e.target.value) || 0)}\n                      min=\"0\"\n                    />\n                    <span className=\"sound-resref\">{soundResRef}</span>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\NWScriptLanguageService.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":231,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":231,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .push on an `any` value.","line":231,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":231,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":239,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":239,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .push on an `any` value.","line":239,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":239,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":247,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":247,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .push on an `any` value.","line":247,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":247,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":252,"column":61,"nodeType":"Property","messageId":"anyAssignment","endLine":252,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":252,"column":92,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":252,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":252,"column":100,"nodeType":"Property","messageId":"anyAssignment","endLine":252,"endColumn":147},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":252,"column":141,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":252,"endColumn":147},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":252,"column":149,"nodeType":"Property","messageId":"anyAssignment","endLine":252,"endColumn":200},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":252,"column":194,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":252,"endColumn":200},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":512,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":512,"endColumn":101},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":516,"column":25,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":516,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":517,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":517,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":521,"column":81,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":521,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_const on an `any` value.","line":522,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":522,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":524,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":524,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":524,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":524,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":526,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":526,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on an `any` value.","line":528,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":528,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":528,"column":106,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":528,"endColumn":110},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":669,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":669,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":672,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":672,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":672,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":672,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [\"0\"] on an `any` value.","line":672,"column":44,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":672,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":673,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":673,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on an `any` value.","line":673,"column":40,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":673,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":674,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":674,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [1] on an `any` value.","line":674,"column":48,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":674,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":675,"column":56,"nodeType":"Property","messageId":"anyAssignment","endLine":675,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":675,"column":68,"nodeType":"Property","messageId":"anyAssignment","endLine":675,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":677,"column":23,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":677,"endColumn":122},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":677,"column":34,"nodeType":"MemberExpression","messageId":"errorCall","endLine":677,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on a type that cannot be resolved.","line":677,"column":65,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":677,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":678,"column":62,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":678,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":678,"column":78,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":678,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":679,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":679,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":680,"column":25,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":680,"endColumn":106},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on a type that cannot be resolved.","line":680,"column":48,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":680,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .struct_reference on a type that cannot be resolved.","line":680,"column":79,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":680,"endColumn":95},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .properties on a type that cannot be resolved.","line":681,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":681,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":682,"column":27,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":682,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .properties on a type that cannot be resolved.","line":682,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":682,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":683,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":683,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":684,"column":76,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":684,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":688,"column":60,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":688,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":688,"column":83,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":688,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":697,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":697,"endColumn":125},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":697,"column":32,"nodeType":"MemberExpression","messageId":"errorCall","endLine":697,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on a type that cannot be resolved.","line":697,"column":63,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":697,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":699,"column":73,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":699,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":703,"column":58,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":703,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":703,"column":87,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":703,"endColumn":91},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":709,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":709,"endColumn":123},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":709,"column":30,"nodeType":"MemberExpression","messageId":"errorCall","endLine":709,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on a type that cannot be resolved.","line":709,"column":61,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":709,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":715,"column":73,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":715,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":717,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":717,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":717,"column":51,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":717,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":720,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":720,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .arguments on a type that cannot be resolved.","line":789,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":789,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":790,"column":23,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":790,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .arguments on a type that cannot be resolved.","line":790,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":790,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .value on a type that cannot be resolved.","line":792,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":792,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | number | ArgValue`.","line":793,"column":52,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":793,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .value on a type that cannot be resolved.","line":793,"column":60,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":793,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":794,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":794,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":794,"column":68,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":794,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .datatype on a type that cannot be resolved.","line":796,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":796,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":796,"column":68,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":796,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .returntype on a type that cannot be resolved.","line":804,"column":64,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":804,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":804,"column":95,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":804,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1274,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1274,"endColumn":111},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1274,"column":30,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1274,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on a type that cannot be resolved.","line":1274,"column":61,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1274,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1275,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1275,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1277,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1277,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1277,"column":56,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1277,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1279,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1279,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1279,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1279,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1282,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1282,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1289,"column":59,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1289,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1289,"column":79,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1289,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1296,"column":19,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1296,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1297,"column":19,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":1297,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1297,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1297,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1298,"column":19,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":1298,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1298,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1298,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1304,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1304,"endColumn":109},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1304,"column":28,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1304,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .find on a type that cannot be resolved.","line":1304,"column":59,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1304,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":1308,"column":65,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1308,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1310,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1310,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1312,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1312,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1312,"column":56,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1312,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1314,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1314,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1314,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1314,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1317,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1317,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1322,"column":59,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1322,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1322,"column":79,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1322,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1329,"column":19,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":1329,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1330,"column":19,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":1330,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1330,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1330,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1331,"column":19,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":1331,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .source on a type that cannot be resolved.","line":1331,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1331,"endColumn":36}],"suppressedMessages":[],"errorCount":106,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as monacoEditor from \"monaco-editor/esm/vs/editor/editor.api\";\r\n\r\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\r\nimport { FileTypeManager } from \"@/apps/forge/FileTypeManager\";\r\nimport * as KotOR from '@/apps/forge/KotOR';\r\nimport { ForgeState } from \"@/apps/forge/states/ForgeState\";\r\nimport type { TabState } from \"@/apps/forge/states/tabs/TabState\";\r\nimport type { TabTextEditorState } from \"@/apps/forge/states/tabs/TabTextEditorState\";\r\nimport { FunctionNode, StructNode, VariableListNode, VariableNode } from \"@/nwscript/compiler/ASTTypes\";\r\nimport { NWScriptASTBuilder } from \"@/nwscript/compiler/NWScriptASTBuilder\";\r\nimport { NWScriptASTCodeGen } from \"@/nwscript/compiler/NWScriptASTCodeGen\";\r\nimport { NWScriptParser } from \"@/nwscript/compiler/NWScriptParser\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\n\r\n// Format NWScript code using AST\r\nfunction formatNWScript(code: string, options: monacoEditor.languages.FormattingOptions = { tabSize: 2, insertSpaces: true }): string {\r\n  log.trace('formatNWScript entry', { codeLength: code.length, tabSize: options.tabSize, insertSpaces: options.insertSpaces });\r\n  try {\r\n    log.trace('formatNWScript creating parser');\r\n    const parser = new NWScriptParser(ForgeState.nwScriptParser?.nwscript_source, code);\r\n    log.trace('formatNWScript parseAST');\r\n    const ast = parser.parseAST(code);\r\n\r\n    if (!ast) {\r\n      log.trace('formatNWScript no AST');\r\n      log.warn('AST formatting failed, returning original');\r\n      return code;\r\n    }\r\n\r\n    log.trace('formatNWScript AST obtained', { statements: ast.statements?.length ?? 0 });\r\n    log.debug('AST formatting successful, generating code from AST');\r\n    const codeGen = new NWScriptASTCodeGen({\r\n      tabSize: options.tabSize || 2,\r\n      insertSpaces: options.insertSpaces !== false,\r\n    });\r\n    const formatted = codeGen.generate(ast);\r\n    log.trace('formatNWScript generate done', { formattedLength: formatted.length });\r\n    return formatted;\r\n  } catch (error: unknown) {\r\n    const err = error as { name?: string; type?: string };\r\n    log.trace('formatNWScript catch', { name: err?.name, type: err?.type });\r\n    if (err?.name !== 'NWScriptASTBuilderError' && err?.type !== 'parse') {\r\n      log.warn('AST formatting failed, returning original code:', error);\r\n    }\r\n    log.error(error as Error);\r\n    return code;\r\n  }\r\n}\r\n\r\nexport class NWScriptLanguageService {\r\n  private constructor() {}\r\n  private readonly _staticOnly?: undefined;\r\n\r\n  static nwScriptTokenConfig: monacoEditor.languages.IMonarchLanguage | null = null;\r\n\r\n  static initNWScriptLanguage() {\r\n    log.trace('initNWScriptLanguage entry');\r\n    type ArgValue = { x?: number; y?: number; z?: number; type?: string; value?: ArgValue; datatype?: { value?: string } };\r\n    const arg_value_parser = function( value: ArgValue | string | number | undefined ): string | number | undefined {\r\n      log.trace('arg_value_parser', { valueType: typeof value });\r\n      if(typeof value === 'undefined') {\r\n        log.trace('arg_value_parser undefined -> NULL');\r\n        return 'NULL';\r\n      }\r\n      if(typeof value === 'object' && value !== null){\r\n        const v = value as ArgValue;\r\n        if(typeof v.x === 'number' && typeof v.y === 'number' && typeof v.z === 'number'){\r\n          log.trace('arg_value_parser vector');\r\n          return `[${v.x}, ${v.y}, ${v.z}]`;\r\n        }else if(v.type === 'neg'){\r\n          log.trace('arg_value_parser neg');\r\n          return '-' + (arg_value_parser(v.value) ?? '');\r\n        }else if(v?.datatype?.value === 'object'){\r\n          if((v.value as number) === 0x7FFFFFFF) { log.trace('arg_value_parser OBJECT_INVALID'); return 'OBJECT_INVALID'; }\r\n          if((v.value as number) === 0) { log.trace('arg_value_parser OBJECT_SELF'); return 'OBJECT_SELF'; }\r\n          return arg_value_parser(v.value);\r\n        }else if(v?.datatype?.value === 'int' || v?.datatype?.value === 'float' || v?.datatype?.value === 'string' || v?.datatype?.value === 'vector'){\r\n          log.trace('arg_value_parser primitive', v.datatype?.value);\r\n          return arg_value_parser(v.value);\r\n        }\r\n      }else if(typeof value === 'string'){\r\n        log.trace('arg_value_parser string');\r\n        return value;\r\n      }else if(typeof value === 'number'){\r\n        log.trace('arg_value_parser number');\r\n        return value;\r\n      }\r\n      log.trace('arg_value_parser fallback undefined');\r\n      return undefined;\r\n    };\r\n\r\n    log.trace('initNWScriptLanguage register language id nwscript');\r\n    monacoEditor.languages.register({ id: 'nwscript' });\r\n\r\n    const tokenConfig: monacoEditor.languages.IMonarchLanguage = {\r\n      keywords: [\r\n        'int', 'float', 'object', 'vector', 'string', 'void', 'action', \r\n        'default', 'const', 'if', 'else', 'switch', 'case',\r\n        'while', 'do', 'for', 'break', 'continue', 'return', 'struct', 'OBJECT_SELF', 'OBJECT_INVALID',\r\n      ],\r\n\r\n      functions: [\r\n        //'GN_SetListeningPatterns'\r\n      ],\r\n\r\n      engineActions: [] as string[],\r\n\r\n      engineConstants: [] as string[],\r\n\r\n      localFunctions: [] as string[],\r\n\r\n      parenFollows: [\r\n        'if', 'for', 'while', 'switch',\r\n      ],\r\n    \r\n      operators: [\r\n        '=', '??', '||', '&&', '|', '^', '&', '==', '!=', '<=', '>=', '<<',\r\n        '+', '-', '*', '/', '%', '!', '~', '++', '--', '+=',\r\n        '-=', '*=', '/=', '%=', '&=', '|=', '^=', '<<=', '>>=', '>>', '=>', '>>>'\r\n      ],\r\n\r\n      tokenizer: {\r\n        root: [\r\n          // whitespace\r\n          { include: '@whitespace' },\r\n\r\n          // numbers - MUST come before identifiers! Order matters - more specific patterns first\r\n          [/0[xX][0-9a-fA-F_]+/, 'number.hex'],\r\n          [/0[bB][01_]+/, 'number.hex'], // binary: use same theme style as hex\r\n          [/[0-9]+\\.[0-9]+([eE][\\-+]?[0-9]+)?[fFdD]?/, 'number.float'],\r\n          [/[0-9]+/, 'number'],\r\n\r\n          // identifiers and keywords\r\n          [/\\@?[a-zA-Z_][a-zA-Z0-9_]*/, {\r\n            cases: {\r\n              //'@namespaceFollows': { token: 'keyword.$0', next: '@namespace' },\r\n              '@keywords': { token: 'keyword.$0', next: '@qualified' },\r\n              '@engineActions': { token: 'engineAction', next: '@qualified' },\r\n              '@engineConstants': { token: 'engineConstant', next: '@qualified' },\r\n              '@localFunctions': { token: 'localFunction', next: '@qualified' },\r\n              '@functions': { token: 'functions', next: '@qualified' },\r\n              '@default': { token: 'identifier', next: '@qualified' }\r\n            }\r\n          }],\r\n\r\n          // strings\r\n          [/\"([^\"\\\\]|\\\\.)*$/, 'string.invalid'],  // non-teminated string\r\n          [/\"/, { token: 'string.quote', next: '@string' }],\r\n          //[/\\$\\@\"/, { token: 'string.quote', next: '@litinterpstring' }],\r\n          //[/\\@\"/, { token: 'string.quote', next: '@litstring' }],\r\n          //[/\\$\"/, { token: 'string.quote', next: '@interpolatedstring' }],\r\n\r\n          // characters\r\n          [/'[^\\\\']'/, 'string'],\r\n          //[/(')(@escapes)(')/, ['string', 'string.escape', 'string']],\r\n          [/'/, 'string.invalid'],\r\n        ],\r\n\r\n        qualified: [\r\n          [/[a-zA-Z0-9_][\\w]*/, {\r\n            cases: {\r\n              '@keywords': { token: 'keyword.$0' },\r\n              '@engineActions': { token: 'engineAction' },\r\n              '@engineConstants': { token: 'engineConstant' },\r\n              '@localFunctions': { token: 'localFunction' },\r\n              '@functions': { token: 'functions.$0' },\r\n              '@default': 'identifier'\r\n            }\r\n          }],\r\n          [/\\./, 'delimiter'],\r\n          ['', '', '@pop'],\r\n        ],          \r\n        \r\n        comment: [\r\n          [/[^\\/*]+/, 'comment'],\r\n          // [/\\/\\*/,    'comment', '@push' ],    // no nested comments :-(\r\n          ['\\\\*/', 'comment', '@pop'],\r\n          [/[\\/*]/, 'comment']\r\n        ],\r\n\r\n        whitespace: [\r\n          [/^[ \\t\\v\\f]*#((r)|(load))(?=\\s)/, 'directive.csx'],\r\n          [/^[ \\t\\v\\f]*#\\w.*$/, 'namespace.cpp'],\r\n          [/[ \\t\\v\\f\\r\\n]+/, ''],\r\n          [/\\/\\*/, 'comment', '@comment'],\r\n          [/\\/\\/.*$/, 'comment'],\r\n        ],\r\n\r\n        string: [\r\n          [/[^\\\\\"]+/, 'string'],\r\n          //[/@escapes/, 'string.escape'],\r\n          [/\\\\./, 'string.escape.invalid'],\r\n          [/\"/, { token: 'string.quote', next: '@pop' }]\r\n        ],\r\n    \r\n        litstring: [\r\n          [/[^\"]+/, 'string'],\r\n          [/\"\"/, 'string.escape'],\r\n          [/\"/, { token: 'string.quote', next: '@pop' }]\r\n        ],\r\n    \r\n        litinterpstring: [\r\n          [/[^\"{]+/, 'string'],\r\n          [/\"\"/, 'string.escape'],\r\n          [/{{/, 'string.escape'],\r\n          [/}}/, 'string.escape'],\r\n          [/{/, { token: 'string.quote', next: 'root.litinterpstring' }],\r\n          [/\"/, { token: 'string.quote', next: '@pop' }]\r\n        ],\r\n    \r\n        interpolatedstring: [\r\n          [/[^\\\\\"{]+/, 'string'],\r\n          //[/@escapes/, 'string.escape'],\r\n          [/\\\\./, 'string.escape.invalid'],\r\n          [/{{/, 'string.escape'],\r\n          [/}}/, 'string.escape'],\r\n          [/{/, { token: 'string.quote', next: 'root.interpolatedstring' }],\r\n          [/\"/, { token: 'string.quote', next: '@pop' }]\r\n        ],\r\n      }\r\n    };\r\n\r\n    log.trace('initNWScriptLanguage building token config');\r\n    const _nw_types = ForgeState.nwScriptParser.engine_types.slice(0);\r\n    log.trace('initNWScriptLanguage engine_types count', _nw_types.length);\r\n    for(let i = 0; i < _nw_types.length; i++){\r\n      const nw_type = _nw_types[i];\r\n      tokenConfig.keywords.push(nw_type.name);\r\n      log.trace('initNWScriptLanguage keyword', nw_type.name);\r\n    }\r\n\r\n    const _nw_actions = ForgeState.nwScriptParser.engine_actions.slice(0);\r\n    log.trace('initNWScriptLanguage engine_actions count', _nw_actions.length);\r\n    for(let i = 0; i < _nw_actions.length; i++){\r\n      const nw_action = _nw_actions[i];\r\n      tokenConfig.engineActions.push(nw_action.name);\r\n      log.trace('initNWScriptLanguage engineAction', nw_action.name);\r\n    }\r\n\r\n    const _nw_constants = ForgeState.nwScriptParser.engine_constants.slice(0);\r\n    log.trace('initNWScriptLanguage engine_constants count', _nw_constants.length);\r\n    for(let i = 0; i < _nw_constants.length; i++){\r\n      const nw_constant = _nw_constants[i];\r\n      tokenConfig.engineConstants.push(nw_constant.name);\r\n      log.trace('initNWScriptLanguage engineConstant', nw_constant.name);\r\n    }\r\n\r\n    NWScriptLanguageService.nwScriptTokenConfig = tokenConfig;\r\n    log.debug('initNWScriptLanguage token config stored', { keywords: tokenConfig.keywords.length, engineActions: tokenConfig.engineActions.length, engineConstants: tokenConfig.engineConstants.length });\r\n\r\n    log.trace('initNWScriptLanguage setMonarchTokensProvider');\r\n    monacoEditor.languages.setMonarchTokensProvider( 'nwscript', tokenConfig);\r\n\r\n    log.trace('initNWScriptLanguage setLanguageConfiguration');\r\n    monacoEditor.languages.setLanguageConfiguration('nwscript', {\r\n      comments: {\r\n        lineComment: '//',\r\n        blockComment: ['/*', '*/']\r\n      },\r\n      brackets: [\r\n        ['{', '}'],\r\n        ['[', ']'],\r\n        ['(', ')']\r\n      ],\r\n      autoClosingPairs: [\r\n        { open: '[', close: ']' },\r\n        { open: '{', close: '}' },\r\n        { open: '(', close: ')' },\r\n        { open: \"'\", close: \"'\", notIn: ['string', 'comment'] },\r\n        { open: '\"', close: '\"', notIn: ['string'] },\r\n        // { open: '/**', close: ' */', notIn: ['string'] }\r\n      ],\r\n      surroundingPairs: [\r\n        { open: '{', close: '}' },\r\n        { open: '[', close: ']' },\r\n        { open: '(', close: ')' },\r\n        { open: '\"', close: '\"' },\r\n        { open: \"'\", close: \"'\" }\r\n      ],\r\n      onEnterRules: [\r\n        {\r\n          // Inside a /** comment block */\r\n          beforeText: /^\\s*\\/\\*\\*(?!\\/).*$/,\r\n          action: { indentAction: monacoEditor.languages.IndentAction.None, appendText: \" * \" }\r\n        },\r\n        {\r\n          // After a line that starts with \" *\"\r\n          beforeText: /^\\s*\\*(?!\\/).*$/,\r\n          action: { indentAction: monacoEditor.languages.IndentAction.None, appendText: \"* \" }\r\n        },\r\n        {\r\n          // Closing the block\r\n          beforeText: /^\\s*\\*\\/\\s*$/,\r\n          action: { indentAction: monacoEditor.languages.IndentAction.None, removeText: 1 }\r\n        }\r\n      ]\r\n    });\r\n\r\n    log.trace('initNWScriptLanguage defineTheme nwscript-dark');\r\n    monacoEditor.editor.defineTheme('nwscript-dark', {\r\n      base: 'vs-dark',\r\n      inherit: true,\r\n      rules: [\r\n        // { token: 'comment', foreground: 'aaaaaa', fontStyle: 'italic' },\r\n        // { token: 'keyword', foreground: 'ce63eb' },\r\n        // { token: 'operator', foreground: '000000' },\r\n        // { token: 'namespace', foreground: '66afce' },\r\n        { token: 'functions', foreground: 'ce63eb' },\r\n        { token: 'engineAction', foreground: '4EC9B0' },\r\n        { token: 'engineConstant', foreground: 'C586C0' },\r\n        { token: 'localFunction', foreground: 'DCDCAA' },\r\n        // Number literals - order matters, more specific first\r\n        { token: 'number.hex', foreground: 'D7BA7D' },\r\n        { token: 'number.float', foreground: 'CE9178' },\r\n        { token: 'number', foreground: 'B5CEA8' },\r\n        // { token: 'lineComment', foreground: '60cf30' },\r\n        // { token: 'blockComment', foreground: '60cf30' },\r\n        // { token: 'TEXT', foreground: 'FFEE99' },\r\n        // { token: 'NAME', foreground: 'C8C8C8' },\r\n        // { token: 'CONST', foreground: 'C586C0' },\r\n        // { token: 'VOID', foreground: 'C586C0' },\r\n        // { token: 'INT', foreground: 'C586C0' },\r\n        // { token: 'FLOAT', foreground: 'C586C0' },\r\n        // { token: 'OBJECT', foreground: 'C586C0' },\r\n        // { token: 'STRING', foreground: 'C586C0' },\r\n        // { token: 'VECTOR', foreground: 'C586C0' },\r\n        // { token: 'STRUCT', foreground: 'C586C0' },\r\n        // { token: 'FOR', foreground: 'C586C0' },\r\n        // { token: 'IF', foreground: 'C586C0' },\r\n        // { token: 'WHILE', foreground: 'C586C0' },\r\n        // { token: 'DO', foreground: 'C586C0' },\r\n        // { token: 'SWITCH', foreground: 'C586C0' },\r\n        // { token: 'CASE', foreground: 'C586C0' },\r\n        // { token: 'DEFAULT', foreground: 'C586C0' },\r\n        // { token: 'RETURN', foreground: 'C586C0' },\r\n        // { token: 'CONTINUE', foreground: 'C586C0' },\r\n        // { token: 'OBJECT_SELF', foreground: 'C586C0' },\r\n        // { token: 'OBJECT_INVALID', foreground: 'C586C0' },\r\n      ],\r\n      colors: {\r\n        'editor.foreground': '#FFFFFF'\r\n      }\r\n    });\r\n\r\n    log.trace('initNWScriptLanguage building nw_suggestions');\r\n    const nw_suggestions: monacoEditor.languages.CompletionItem[] = [];\r\n    const keywords = ['void', 'int', 'float', 'string', 'object', 'vector', 'struct', 'action'];\r\n    log.trace('initNWScriptLanguage keywords snippet count', keywords.length);\r\n\r\n    for(let i = 0; i < keywords.length; i++){\r\n      log.trace('initNWScriptLanguage push keyword suggestion', keywords[i]);\r\n      nw_suggestions.push({\r\n        label: keywords[i],\r\n        kind: monacoEditor.languages.CompletionItemKind.Keyword,\r\n        insertText: keywords[i],\r\n        insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n        range: undefined\r\n      });\r\n    }\r\n\r\n    const nw_types = ForgeState.nwScriptParser.engine_types.slice(0);\r\n    log.trace('initNWScriptLanguage type suggestions count', nw_types.length);\r\n    for(let i = 0; i < nw_types.length; i++){\r\n      const nw_type = nw_types[i];\r\n      log.trace('initNWScriptLanguage type suggestion', nw_type.name);\r\n      nw_suggestions.push({\r\n        label: nw_type.name,\r\n        kind: monacoEditor.languages.CompletionItemKind.Keyword,\r\n        insertText: `${nw_type.name}`,\r\n        insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n        documentation: `Engine Type #${nw_type.index+1}:\\n\\n${nw_type.name}`,\r\n        range: undefined\r\n      });\r\n    }\r\n\r\n    const nw_constants = ForgeState.nwScriptParser.engine_constants.slice(0);\r\n    log.trace('initNWScriptLanguage constant suggestions count', nw_constants.length);\r\n    for(let i = 0; i < nw_constants.length; i++){\r\n      const nw_constant = nw_constants[i];\r\n      log.trace('initNWScriptLanguage constant suggestion', nw_constant.name);\r\n      nw_suggestions.push({\r\n        label: nw_constant.name,\r\n        kind: monacoEditor.languages.CompletionItemKind.Constant,\r\n        insertText: `${nw_constant.name}`,\r\n        insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n        documentation: `Engine Constant #${nw_constant.index+1}:\\n\\n${nw_constant.datatype.value} ${nw_constant.name} = ${arg_value_parser(nw_constant.value)};`,\r\n        range: undefined\r\n      });\r\n    }\r\n\r\n    //Engine Routines\r\n    // const nw_actions = Object.entries(\r\n    //   KotOR.ApplicationProfile.GameKey == KotOR.GameEngineType.KOTOR ? \r\n    //   KotOR.NWScriptDefK1.Actions : \r\n    //   KotOR.NWScriptDefK2.Actions\r\n    // );\r\n    const nw_actions = ForgeState.nwScriptParser.engine_actions.slice(0);\r\n    log.trace('initNWScriptLanguage engine action suggestions count', nw_actions.length);\r\n    nw_actions.forEach( (action) =>{\r\n      log.trace('initNWScriptLanguage action suggestion', action.name);\r\n      const args: string[] = [];\r\n\r\n      for(let i = 0; i < action.arguments.length; i++){\r\n        const arg = action.arguments[i];\r\n        if(arg.value){\r\n          args.push(`\\${${(i+1)}:${arg.datatype.value} ${arg.name} = ${arg_value_parser(arg.value)}}`);\r\n        }else{\r\n          args.push(`\\${${(i+1)}:${arg.datatype.value} ${arg.name}}`);\r\n        } \r\n      }\r\n      \r\n      nw_suggestions.push({\r\n        label: action.name,\r\n        kind: monacoEditor.languages.CompletionItemKind.Function,\r\n        insertText: `${action.name}(${args.join(', ')})`,\r\n        insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n        documentation: `Engine Routine #${action.index}:\\n\\n${action.returntype.value} ${action.name}(${args.join(', ')})\\n\\n`+action.comment,\r\n        range: undefined\r\n      });\r\n    });\r\n\r\n    log.info('initNWScriptLanguage registering completion item provider');\r\n    monacoEditor.languages.registerCompletionItemProvider('nwscript', {\r\n      provideCompletionItems: () => {\r\n        log.trace('provideCompletionItems entry');\r\n        try{\r\n          log.trace('provideCompletionItems building local_suggestions');\r\n          const local_suggestions: monacoEditor.languages.CompletionItem[] = [\r\n            {\r\n              label: 'void main()',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: ['void main () {', '\\t$0', '}'].join('\\n'),\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'void main() Statement',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'int StartingConditional()',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: ['int StartingConditional () {', '\\t$0', '}'].join('\\n'),\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'int StartingConditional() Statement',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'if',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: 'if (${1:condition}) {\\n\\t$0\\n}',\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'if statement',\r\n              filterText: 'if',\r\n              sortText: '0if',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'ifelse',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: ['if (${1:condition}) {', '\\t$0', '} else {', '\\t', '}'].join('\\n'),\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'If-Else Statement',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'for',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: 'for (${1:int i = 0}; ${2:i < ${3:10}}; ${4:i++}) {\\n\\t$0\\n}',\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'for loop',\r\n              filterText: 'for',\r\n              sortText: '0for',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'while',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: 'while (${1:condition}) {\\n\\t$0\\n}',\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'while loop',\r\n              filterText: 'while',\r\n              sortText: '0while',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'switch',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: ['switch (${1:expression}) {', '\\tcase ${2:value}:', '\\t\\t$0', '\\t\\tbreak;', '\\tdefault:', '\\t\\tbreak;', '}'].join('\\n'),\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'switch statement',\r\n              filterText: 'switch',\r\n              sortText: '0switch',\r\n              range: undefined\r\n            },\r\n            {\r\n              label: 'struct',\r\n              kind: monacoEditor.languages.CompletionItemKind.Snippet,\r\n              insertText: ['struct ${1:StructName} {', '\\t${2:int} ${3:member};', '\\t$0', '};'].join('\\n'),\r\n              insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n              documentation: 'struct declaration',\r\n              filterText: 'struct',\r\n              sortText: '0struct',\r\n              range: undefined\r\n            }\r\n          ];\r\n\r\n          const parser = (ForgeState.tabManager.currentTab as TabTextEditorState | null)?.nwScriptParser;\r\n          log.trace('provideCompletionItems parser', !!parser);\r\n          if(parser){\r\n            try {\r\n              const l_variables = parser.local_variables || (parser.program?.scope?.variables || []);\r\n              log.trace('provideCompletionItems local_variables count', Array.isArray(l_variables) ? l_variables.length : 0);\r\n              if (Array.isArray(l_variables)) {\r\n                for(let i = 0; i < l_variables.length; i++){\r\n                  const l_variable = l_variables[i];\r\n                  if (!l_variable || !l_variable.name) {\r\n                    log.trace('provideCompletionItems skip variable', i);\r\n                    continue;\r\n                  }\r\n                  log.trace('provideCompletionItems local variable', l_variable.name);\r\n                  const kind = l_variable.is_const ? monacoEditor.languages.CompletionItemKind.Constant : monacoEditor.languages.CompletionItemKind.Variable;\r\n                  local_suggestions.push({\r\n                    label: l_variable.name,\r\n                    kind: kind,\r\n                    insertText: `${l_variable.name}`,\r\n                    insertTextRules: monacoEditor.languages.CompletionItemInsertTextRule.InsertAsSnippet,\r\n                    documentation: `Variable:\\n\\n${l_variable.datatype?.value || 'unknown'} ${l_variable.name};`,\r\n                    range: undefined\r\n                  });\r\n                }\r\n              }\r\n            } catch (e) {\r\n              log.warn('Error accessing parser variables:', e);\r\n            }\r\n          }\r\n          const total = local_suggestions.length + nw_suggestions.length;\r\n          log.trace('provideCompletionItems total suggestions', total);\r\n          log.debug('Autocomplete', { local: local_suggestions.length, nw: nw_suggestions.length });\r\n          return {\r\n            incomplete: true,\r\n            suggestions: [...local_suggestions, ...nw_suggestions] as monacoEditor.languages.CompletionItem[],\r\n          };\r\n        }catch(e){\r\n          log.trace('provideCompletionItems catch');\r\n          log.error('Autocomplete error:', e as Error);\r\n          // Always return at least the engine suggestions even on error\r\n          return { \r\n            incomplete: true, \r\n            suggestions: nw_suggestions \r\n          };\r\n        }\r\n      }\r\n    });\r\n\r\n    log.info('initNWScriptLanguage registering document formatter');\r\n    monacoEditor.languages.registerDocumentFormattingEditProvider('nwscript', {\r\n      provideDocumentFormattingEdits: (model: monacoEditor.editor.ITextModel, options: monacoEditor.languages.FormattingOptions, token: monacoEditor.CancellationToken) => {\r\n        log.trace('provideDocumentFormattingEdits entry', { uri: model.uri.toString() });\r\n        const text = model.getValue();\r\n        log.trace('provideDocumentFormattingEdits text length', text.length);\r\n\r\n        const modelOptions = model.getOptions();\r\n        const tabSize = modelOptions.tabSize || 2;\r\n        const insertSpaces = modelOptions.insertSpaces !== false;\r\n        log.trace('provideDocumentFormattingEdits options', { tabSize, insertSpaces });\r\n        const formatOptions = {\r\n          tabSize: tabSize,\r\n          insertSpaces: insertSpaces\r\n        };\r\n\r\n        const formatted = formatNWScript(text, formatOptions);\r\n        log.trace('provideDocumentFormattingEdits formatted length', formatted.length);\r\n\r\n        if (formatted !== text) {\r\n          log.debug('provideDocumentFormattingEdits returning edit');\r\n          return [{\r\n            range: model.getFullModelRange(),\r\n            text: formatted\r\n          }];\r\n        }\r\n        log.trace('provideDocumentFormattingEdits no change');\r\n        return [];\r\n      }\r\n    });\r\n\r\n    log.info('initNWScriptLanguage registering hover provider');\r\n    monacoEditor.languages.registerHoverProvider('nwscript', {\r\n      provideHover: function (model: monacoEditor.editor.ITextModel, position: monacoEditor.Position, token: monacoEditor.CancellationToken) {\r\n        log.trace('provideHover entry', { line: position.lineNumber, column: position.column });\r\n        const wordObject = model.getWordAtPosition(position);\r\n        if(wordObject){\r\n          log.trace('provideHover word', wordObject.word);\r\n\r\n          const nw_constant = ForgeState.nwScriptParser.engine_constants.find( (obj) => obj.name == wordObject.word );\r\n          if(nw_constant){\r\n            log.trace('provideHover match engine constant', nw_constant.name);\r\n            return {\r\n              contents: [\r\n                { value: `**nwscript.nss**` },\r\n                { value: `\\`\\`\\`nwscript\\n${nw_constant.datatype.value} ${nw_constant.name} = ${arg_value_parser(nw_constant.value)}\\n \\n\\`\\`\\`` }\r\n              ]\r\n            };\r\n          }\r\n\r\n          const action = nw_actions.find( (obj: { name: string }) => obj.name == wordObject.word );\r\n          if(action){\r\n            log.trace('provideHover match engine action', action.name);\r\n            let args = '';\r\n            const function_definition = ForgeState.nwScriptParser.engine_actions.find((a) =>\r\n              a.name === wordObject.word || a.name === action.name\r\n            );\r\n            if(!function_definition) {\r\n              log.trace('provideHover action no function_definition, using fallback');\r\n              let args_fallback = '';\r\n              for(let i = 0; i < action.arguments.length; i++){\r\n                const arg = action.arguments[i];\r\n                if(i > 0) args_fallback += ', ';\r\n                args_fallback += arg.name;\r\n              }\r\n              let hoverContent = `\\`\\`\\`nwscript\\n${action.name}(${args_fallback})\\n\\`\\`\\``;\r\n              if (action.comment && action.comment.trim()) {\r\n                hoverContent += `\\n\\n**Documentation:**\\n\\`\\`\\`\\n${action.comment.trim()}\\n\\`\\`\\``;\r\n              }\r\n              return {\r\n                contents: [\r\n                  { value: `**nwscript.nss**` },\r\n                  { value: hoverContent }\r\n                ]\r\n              };\r\n            }\r\n            for(let i = 0; i < action.arguments.length; i++){\r\n              const arg = action.arguments[i];\r\n              const def_arg = function_definition.arguments[i];\r\n              if(i > 0) args += ', ';\r\n              if(def_arg){\r\n                if(def_arg.value){\r\n                  const value = arg_value_parser(def_arg.value);\r\n                  args += `${arg.name} ${def_arg.name} = ${value}`;\r\n                }else{\r\n                  args += `${arg.name} ${def_arg.name}`;\r\n                }\r\n              }else{\r\n                log.warn('invalid argument', i, function_definition);\r\n              }\r\n            }\r\n            let hoverContent = `\\`\\`\\`nwscript\\n${function_definition.returntype.value} ${action.name}(${args})\\n\\`\\`\\``;\r\n            if (function_definition.comment && function_definition.comment.trim()) {\r\n              hoverContent += `\\n\\n**Documentation:**\\n\\`\\`\\`\\n${function_definition.comment.trim()}\\n\\`\\`\\``;\r\n            } else if (action.comment && action.comment.trim()) {\r\n              hoverContent += `\\n\\n**Documentation:**\\n\\`\\`\\`\\n${action.comment.trim()}\\n\\`\\`\\``;\r\n            }\r\n            \r\n            return {\r\n              contents: [\r\n                { value: `**nwscript.nss**` },\r\n                { value: hoverContent }\r\n              ]\r\n            };\r\n          }\r\n\r\n          const parser = (ForgeState.tabManager.currentTab as TabTextEditorState | null)?.nwScriptParser;\r\n          log.trace('provideHover parser', !!parser);\r\n          if(parser){\r\n\r\n            const structPropertyMatches = model.getValue().matchAll(\r\n              new RegExp(\"(?:[A-Za-z_]|[A-Za-z_][A-Za-z0-9_]+)\\\\b[\\\\s|\\\\t+]?\\\\.[\\\\s|\\\\t+]?\"+wordObject.word+\"\\\\b\", 'g')\r\n            );\r\n            const structProperty = structPropertyMatches?.next()?.value;\r\n            if(structProperty){\r\n              log.trace('provideHover structProperty match', structProperty);\r\n              const parts = structProperty[\"0\"].split('.');\r\n              const structName = parts[0];\r\n              const structPropertyName = parts[1];\r\n              log.trace('provideHover struct parts', { structName, structPropertyName });\r\n              if(structName){\r\n                const l_struct = (parser.local_variables || []).find( (obj: { name: string }) => obj.name == structName );\r\n                log.trace('provideHover l_struct', l_struct?.name, l_struct?.datatype?.value);\r\n                if(l_struct?.datatype?.value == 'struct'){\r\n                  const struct_ref = (l_struct.type == 'variable') ? l_struct.struct_reference : l_struct ;\r\n                  for(let i = 0; i < struct_ref.properties.length; i++){\r\n                    const prop = struct_ref.properties[i];\r\n                    if(prop && prop.name == wordObject.word){\r\n                      log.trace('provideHover match struct property', prop.name);\r\n                      return {\r\n                        contents: [\r\n                          { value: '**SOURCE**' },\r\n                          { value: `\\`\\`\\`nwscript\\n${prop.datatype.value} ${prop.name} \\n\\`\\`\\`` }\r\n                        ]\r\n                      };\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            const l_variable = (parser.local_variables || []).find( (obj: { name: string }) => obj.name == wordObject.word );\r\n            if(l_variable){\r\n              log.trace('provideHover match local variable', l_variable.name);\r\n              return {\r\n                contents: [\r\n                  { value: `**nwscript.nss**` },\r\n                  { value: `\\`\\`\\`nwscript\\n${l_variable.datatype.value} ${l_variable.name} \\n\\`\\`\\`` }\r\n                ]\r\n              };\r\n            }\r\n\r\n            //Local Function - check both local_functions (if exists) and program.functions\r\n            let l_function = (parser.local_functions || []).find( (obj: { name: string }) => obj.name == wordObject.word );\r\n            if(!l_function && parser.program && parser.program.functions) {\r\n              l_function = parser.program.functions.find( (obj: { name: string }) => obj.name == wordObject.word );\r\n            }\r\n            \r\n            if(l_function){\r\n              log.trace('provideHover match local function', l_function.name);\r\n              let functionComment = '';\r\n              if (l_function.source && l_function.source.first_line > 1) {\r\n                const scriptText = model.getValue();\r\n                const lines = scriptText.split('\\n');\r\n                const funcLine = l_function.source.first_line - 1; // Convert to 0-based index\r\n                \r\n                // Look backwards for comment blocks (similar to engine actions)\r\n                const commentLines: string[] = [];\r\n                let inBlockComment = false;\r\n                \r\n                for (let i = funcLine - 1; i >= 0; i--) {\r\n                  const line = lines[i];\r\n                  if (!line) continue; // Skip if line doesn't exist\r\n                  const trimmed = line.trim();\r\n                  \r\n                  if (trimmed === '') {\r\n                    if (commentLines.length > 0 && !inBlockComment) {\r\n                      break;\r\n                    }\r\n                    if (inBlockComment) {\r\n                      commentLines.unshift('');\r\n                    }\r\n                    continue;\r\n                  }\r\n                  \r\n                  // Check for block comment end */\r\n                  if (trimmed.includes('*/') && !trimmed.includes('/*')) {\r\n                    inBlockComment = true;\r\n                    const endMatch = trimmed.match(/\\*\\/(.*)/);\r\n                    if (endMatch && endMatch[1].trim()) {\r\n                      break;\r\n                    }\r\n                    continue;\r\n                  }\r\n                  \r\n                  // Check for block comment start /*\r\n                  if (trimmed.includes('/*')) {\r\n                    const startMatch = trimmed.match(/\\/\\*(.*?)(\\*\\/)?/);\r\n                    if (startMatch) {\r\n                      if (startMatch[2]) {\r\n                        commentLines.unshift(startMatch[1].trim());\r\n                        inBlockComment = false;\r\n                      } else {\r\n                        inBlockComment = false;\r\n                        if (startMatch[1].trim()) {\r\n                          commentLines.unshift(startMatch[1].trim());\r\n                        }\r\n                        break;\r\n                      }\r\n                    }\r\n                    continue;\r\n                  }\r\n                  \r\n                  // If we're in a block comment, collect the line\r\n                  if (inBlockComment) {\r\n                    commentLines.unshift(trimmed);\r\n                    continue;\r\n                  }\r\n                  \r\n                  // Handle single-line comments\r\n                  if (trimmed.startsWith('//')) {\r\n                    commentLines.unshift(trimmed.replace(/^\\/\\/\\s*/, ''));\r\n                    continue;\r\n                  }\r\n                  \r\n                  // Stop at non-comment code\r\n                  break;\r\n                }\r\n                \r\n                functionComment = commentLines.join('\\n').trim();\r\n              }\r\n              \r\n              const args: string[] = [];\r\n              for(let i = 0; i < l_function.arguments.length; i++){\r\n                const def_arg = l_function.arguments[i];\r\n                if(def_arg){\r\n                  if(def_arg.value){\r\n                    const value = arg_value_parser(def_arg.value);\r\n                    args.push(`${def_arg.datatype.value} ${def_arg.name} = ${value}`);\r\n                  }else{\r\n                    args.push(`${def_arg.datatype.value} ${def_arg.name}`);\r\n                  }\r\n                }else{\r\n                  log.warn('invalid argument', i, l_function);\r\n                }\r\n              }\r\n              \r\n              // Build hover content with comment\r\n              let hoverContent = `\\`\\`\\`nwscript\\n${l_function.returntype.value} ${l_function.name}(${args.join(', ')})\\n\\`\\`\\``;\r\n              \r\n              if (functionComment) {\r\n                hoverContent += `\\n\\n**Documentation:**\\n\\`\\`\\`\\n${functionComment}\\n\\`\\`\\``;\r\n              }\r\n              \r\n              return {\r\n                contents: [\r\n                  { value: '**SOURCE**' },\r\n                  { value: hoverContent }\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n        }\r\n        log.trace('provideHover no match');\r\n        return {\r\n          range: new monacoEditor.Range(\r\n            1,\r\n            1,\r\n            model.getLineCount(),\r\n            model.getLineMaxColumn(model.getLineCount())\r\n          ),\r\n        };\r\n      }\r\n    });\r\n\r\n    log.info('initNWScriptLanguage registering document symbol provider');\r\n    monacoEditor.languages.registerDocumentSymbolProvider('nwscript', {\r\n      provideDocumentSymbols: function (model: monacoEditor.editor.ITextModel, token: monacoEditor.CancellationToken) {\r\n        log.trace('provideDocumentSymbols entry', { uri: model.uri.toString() });\r\n        const symbols: monacoEditor.languages.DocumentSymbol[] = [];\r\n        try {\r\n          const text = model.getValue();\r\n          log.trace('provideDocumentSymbols text length', text.length);\r\n\r\n          const currentTab = ForgeState.tabManager.currentTab as TabTextEditorState | null;\r\n          let parser = currentTab?.nwScriptParser;\r\n          log.trace('provideDocumentSymbols parser from tab', !!parser);\r\n\r\n          if (!parser) {\r\n            log.trace('provideDocumentSymbols creating temp parser');\r\n            parser = new NWScriptParser(ForgeState.nwScriptParser?.nwscript_source, text);\r\n          } else {\r\n            log.trace('provideDocumentSymbols parseScript');\r\n            parser.parseScript(text);\r\n          }\r\n\r\n          if (!parser.ast || !parser.ast.statements) {\r\n            log.trace('provideDocumentSymbols no ast or statements');\r\n            return [];\r\n          }\r\n          log.trace('provideDocumentSymbols statements count', parser.ast.statements.length);\r\n\r\n          for (const statement of parser.ast.statements) {\r\n            log.trace('provideDocumentSymbols statement', statement.type);\r\n            if (statement.type === 'function') {\r\n              const func = statement as FunctionNode;\r\n              log.trace('provideDocumentSymbols function', func.name);\r\n              const args = func.arguments.map((arg) => `${arg.datatype.value} ${arg.name}`).join(', ');\r\n              const detail = `${func.returntype.value} ${func.name}(${args})`;\r\n              \r\n              symbols.push({\r\n                name: func.name,\r\n                detail: detail,\r\n                kind: monacoEditor.languages.SymbolKind.Function,\r\n                range: {\r\n                  startLineNumber: func.source?.first_line || 1,\r\n                  startColumn: func.source?.first_column || 1,\r\n                  endLineNumber: func.source?.last_line || func.source?.first_line || 1,\r\n                  endColumn: func.source?.last_column || func.source?.first_column || 1,\r\n                },\r\n                selectionRange: {\r\n                  startLineNumber: func.source?.first_line || 1,\r\n                  startColumn: func.source?.first_column || 1,\r\n                  endLineNumber: func.source?.last_line || func.source?.first_line || 1,\r\n                  endColumn: func.source?.last_column || func.source?.first_column || 1,\r\n                },\r\n                children: [], // Could extract local variables here if needed\r\n                tags: []\r\n              });\r\n            } else if (statement.type === 'struct') {\r\n              const struct = statement as StructNode;\r\n              log.trace('provideDocumentSymbols struct', struct.name);\r\n              symbols.push({\r\n                name: struct.name,\r\n                detail: `struct ${struct.name}`,\r\n                kind: monacoEditor.languages.SymbolKind.Struct,\r\n                range: {\r\n                  startLineNumber: struct.source?.first_line || 1,\r\n                  startColumn: struct.source?.first_column || 1,\r\n                  endLineNumber: struct.source?.last_line || struct.source?.first_line || 1,\r\n                  endColumn: struct.source?.last_column || struct.source?.first_column || 1,\r\n                },\r\n                selectionRange: {\r\n                  startLineNumber: struct.source?.first_line || 1,\r\n                  startColumn: struct.source?.first_column || 1,\r\n                  endLineNumber: struct.source?.last_line || struct.source?.first_line || 1,\r\n                  endColumn: struct.source?.last_column || struct.source?.first_column || 1,\r\n                },\r\n                children: struct.properties?.map((prop) => ({\r\n                  name: prop.name,\r\n                  detail: prop.datatype ? `${prop.datatype.value} ${prop.name}` : prop.name,\r\n                  kind: monacoEditor.languages.SymbolKind.Property,\r\n                  range: {\r\n                    startLineNumber: prop.source?.first_line || struct.source?.first_line || 1,\r\n                    startColumn: prop.source?.first_column || struct.source?.first_column || 1,\r\n                    endLineNumber: prop.source?.last_line || struct.source?.first_line || 1,\r\n                    endColumn: prop.source?.last_column || struct.source?.first_column || 1,\r\n                  },\r\n                  selectionRange: {\r\n                    startLineNumber: prop.source?.first_line || struct.source?.first_line || 1,\r\n                    startColumn: prop.source?.first_column || struct.source?.first_column || 1,\r\n                    endLineNumber: prop.source?.last_line || struct.source?.first_line || 1,\r\n                    endColumn: prop.source?.last_column || struct.source?.first_column || 1,\r\n                  },\r\n                  tags: [] as number[]\r\n                })) || [],\r\n                tags: [] as number[]\r\n              });\r\n            } else if (statement.type === 'variableList') {\r\n              const variable = statement as VariableListNode;\r\n              for (const nameInfo of variable.names) {\r\n                symbols.push({\r\n                  name: nameInfo.name,\r\n                  detail: `${variable.datatype.value} ${nameInfo.name}${variable.is_const ? ' (const)' : ''}`,\r\n                  kind: variable.is_const ? monacoEditor.languages.SymbolKind.Constant : monacoEditor.languages.SymbolKind.Variable,\r\n                  range: {\r\n                    startLineNumber: nameInfo.source?.first_line || nameInfo.source?.first_line || 1,\r\n                    startColumn: nameInfo.source?.first_column || nameInfo.source?.first_column || 1,\r\n                    endLineNumber: nameInfo.source?.last_line || nameInfo.source?.last_line || 1,\r\n                    endColumn: nameInfo.source?.last_column || nameInfo.source?.last_column || 1,\r\n                  },\r\n                  selectionRange: {\r\n                    startLineNumber: nameInfo.source?.first_line || nameInfo.source?.first_line || 1,\r\n                    startColumn: nameInfo.source?.first_column || nameInfo.source?.first_column || 1,\r\n                    endLineNumber: nameInfo.source?.last_line || nameInfo.source?.last_line || 1,\r\n                    endColumn: nameInfo.source?.last_column || nameInfo.source?.last_column || 1,\r\n                  },\r\n                  tags: [] as number[]\r\n                });\r\n              }\r\n            } else if (statement.type === 'variable') {\r\n              const variable = statement as VariableNode;\r\n              // const names = statement.type === 'variableList' ? variable.names : [{ name: variable.name, source: variable.source }];\r\n              \r\n              symbols.push({\r\n                name: variable.name,\r\n                detail: `${variable.datatype.value} ${variable.name}${variable.is_const ? ' (const)' : ''}`,\r\n                kind: variable.is_const ? monacoEditor.languages.SymbolKind.Constant : monacoEditor.languages.SymbolKind.Variable,\r\n                range: {\r\n                  startLineNumber: variable.source?.first_line || variable.source?.first_line || 1,\r\n                  startColumn: variable.source?.first_column || variable.source?.first_column || 1,\r\n                  endLineNumber: variable.source?.last_line || variable.source?.last_line || 1,\r\n                  endColumn: variable.source?.last_column || variable.source?.last_column || 1,\r\n                },\r\n                selectionRange: {\r\n                  startLineNumber: variable.source?.first_line || variable.source?.first_line || 1,\r\n                  startColumn: variable.source?.first_column || variable.source?.first_column || 1,\r\n                  endLineNumber: variable.source?.last_line || variable.source?.last_line || 1,\r\n                  endColumn: variable.source?.last_column || variable.source?.last_column || 1,\r\n                },\r\n                tags: []\r\n              });\r\n                \r\n            }\r\n          }\r\n\r\n          log.debug('provideDocumentSymbols returning symbols', symbols.length);\r\n          return symbols;\r\n        } catch (e) {\r\n          log.error('Error providing document symbols:', e as Error);\r\n          return [];\r\n        }\r\n      }\r\n    });\r\n\r\n    log.info('initNWScriptLanguage registering definition provider');\r\n    monacoEditor.languages.registerDefinitionProvider('nwscript', {\r\n      provideDefinition: function (model: monacoEditor.editor.ITextModel, position: monacoEditor.Position, token: monacoEditor.CancellationToken) {\r\n        log.trace('provideDefinition entry', { line: position.lineNumber, column: position.column });\r\n        try {\r\n          const wordObject = model.getWordAtPosition(position);\r\n          if (!wordObject) {\r\n            log.trace('provideDefinition no word at position');\r\n            return [];\r\n          }\r\n          log.trace('provideDefinition word', wordObject.word);\r\n\r\n          const currentTab = ForgeState.tabManager.currentTab as TabTextEditorState | null;\r\n          if (!currentTab || !currentTab.nwScriptParser) {\r\n            log.trace('provideDefinition no currentTab or parser');\r\n            return [];\r\n          }\r\n\r\n          const parser = currentTab.nwScriptParser;\r\n          const word = wordObject.word;\r\n\r\n          // Helper to calculate which file a line number belongs to\r\n          const getFileForLine = (lineNumber: number): { resref: string | null; adjustedLine: number } => {\r\n            if (!currentTab.resolvedIncludes || currentTab.resolvedIncludes.size === 0) {\r\n              return { resref: null, adjustedLine: lineNumber };\r\n            }\r\n\r\n            // Calculate line offsets for each included file\r\n            const includeOrder = Array.from(currentTab.resolvedIncludes.keys()) as string[];\r\n            let currentOffset = 0;\r\n            \r\n            for (const resref of includeOrder) {\r\n              const source = currentTab.resolvedIncludes.get(resref);\r\n              if (source) {\r\n                const lineCount = source.split('\\n').length;\r\n                if (lineNumber <= currentOffset + lineCount) {\r\n                  return { resref: resref as string, adjustedLine: lineNumber - currentOffset };\r\n                }\r\n                currentOffset += lineCount;\r\n              }\r\n            }\r\n\r\n            // If not in includes, it's in the main file\r\n            return { resref: null, adjustedLine: lineNumber - currentOffset };\r\n          };\r\n\r\n          // Helper to open/focus a tab and scroll to a line\r\n          const navigateToDefinition = (resref: string | null, lineNumber: number, column: number) => {\r\n            if (resref) {\r\n              // Definition is in an included file\r\n              // Check if file is already open\r\n              let targetTab: TabState | undefined = undefined;\r\n              \r\n              // Find tab by file resref\r\n              for (const tab of ForgeState.tabManager.tabs) {\r\n                if (tab.file && tab.file.resref === resref && tab.file.ext === KotOR.ResourceTypes.nss) {\r\n                  targetTab = tab;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              if (targetTab && targetTab.constructor.name === 'TabTextEditorState') {\r\n                const editorTab = targetTab as TabTextEditorState;\r\n                // File is already open - focus it and scroll\r\n                editorTab.show();\r\n                if (editorTab.editor && editorTab.monaco) {\r\n                  setTimeout(() => {\r\n                    editorTab.editor.revealLineInCenter(lineNumber);\r\n                    editorTab.editor.setPosition({ lineNumber, column });\r\n                  }, 100);\r\n                }\r\n              } else {\r\n                // File is not open - load from KEY system and open it\r\n                const key = KotOR.KEYManager.Key.getFileKey(resref, KotOR.ResourceTypes.nss);\r\n                if (key) {\r\n                  // Load the file buffer from KEY system first (fire and forget)\r\n                  KotOR.KEYManager.Key.getFileBuffer(key).then((buffer: Uint8Array) => {\r\n                    if (buffer) {\r\n                      // Create EditorFile with the buffer already loaded\r\n                      const editorFile = new EditorFile({ \r\n                        resref, \r\n                        reskey: KotOR.ResourceTypes.nss,\r\n                        buffer: buffer\r\n                      });\r\n                      \r\n                      // Use FileTypeManager to open the file - this will create the tab\r\n                      FileTypeManager.onOpenResource(editorFile);\r\n                  \r\n                      // Find the newly opened tab and wait for file to load, then scroll\r\n                      const findAndScroll = () => {\r\n                        const newTab = ForgeState.tabManager.tabs.find((tab) =>\r\n                          tab.file && tab.file.resref === resref && tab.file.ext === KotOR.ResourceTypes.nss\r\n                        ) as TabTextEditorState | undefined;\r\n                        \r\n                        if (newTab) {\r\n                          // Set up a one-time listener for when the file loads\r\n                          const onFileLoad = () => {\r\n                            newTab.removeEventListener('onEditorFileLoad', onFileLoad);\r\n                            // Wait a bit for the editor to be ready, then scroll\r\n                            setTimeout(() => {\r\n                              if (newTab.editor && newTab.monaco) {\r\n                                newTab.editor.revealLineInCenter(lineNumber);\r\n                                newTab.editor.setPosition({ lineNumber, column });\r\n                              }\r\n                            }, 200);\r\n                          };\r\n                          \r\n                          newTab.addEventListener('onEditorFileLoad', onFileLoad);\r\n                          \r\n                          // If file is already loaded, trigger scroll immediately\r\n                          if (newTab.code && newTab.code.length > 0) {\r\n                            setTimeout(() => {\r\n                              onFileLoad();\r\n                            }, 100);\r\n                          }\r\n                        } else {\r\n                          // Tab not found yet, try again\r\n                          setTimeout(findAndScroll, 50);\r\n                        }\r\n                      };\r\n                      \r\n                      // Start looking for the tab after a short delay\r\n                      setTimeout(findAndScroll, 50);\r\n                    }\r\n                  }).catch((error: Error) => {\r\n                    log.error('Error loading file from KEY system:', error as Error);\r\n                  });\r\n                }\r\n              }\r\n            } else {\r\n              // Definition is in current file - just scroll\r\n              if (currentTab.editor && currentTab.monaco) {\r\n                currentTab.editor.revealLineInCenter(lineNumber);\r\n                currentTab.editor.setPosition({ lineNumber, column });\r\n              }\r\n            }\r\n          };\r\n\r\n          const nw_constant = ForgeState.nwScriptParser.engine_constants.find((obj) => obj.name === word);\r\n          if (nw_constant && nw_constant.source) {\r\n            log.trace('provideDefinition match engine constant', word);\r\n            const lineNumber = nw_constant.source.first_line || 1;\r\n            const column = nw_constant.source.first_column || 1;\r\n            \r\n            // Check if nwscript.nss is already open\r\n            const nwscriptTab = ForgeState.tabManager.tabs.find((tab) => \r\n              tab.file && tab.file.resref === 'nwscript' && tab.file.ext === KotOR.ResourceTypes.nss\r\n            ) as TabTextEditorState | undefined;\r\n            \r\n            if (nwscriptTab) {\r\n              // File is already open - focus it and scroll\r\n              nwscriptTab.show();\r\n              if (nwscriptTab.editor && nwscriptTab.monaco) {\r\n                setTimeout(() => {\r\n                  nwscriptTab.editor.revealLineInCenter(lineNumber);\r\n                  nwscriptTab.editor.setPosition({ lineNumber, column });\r\n                }, 100);\r\n              }\r\n            } else {\r\n              // File is not open - create EditorFile with the buffer and open it\r\n              if (ForgeState.nwscript_nss) {\r\n                const textDecoder = new TextDecoder();\r\n                const nwscriptSource = textDecoder.decode(ForgeState.nwscript_nss);\r\n                const editorFile = new EditorFile({ \r\n                  resref: 'nwscript', \r\n                  reskey: KotOR.ResourceTypes.nss,\r\n                  buffer: ForgeState.nwscript_nss\r\n                });\r\n                \r\n                FileTypeManager.onOpenResource(editorFile);\r\n                \r\n                // Find the newly opened tab and scroll\r\n                const findAndScroll = () => {\r\n                  const newTab = ForgeState.tabManager.tabs.find((tab) => \r\n                    tab.file && tab.file.resref === 'nwscript' && tab.file.ext === KotOR.ResourceTypes.nss\r\n                  ) as TabTextEditorState | undefined;\r\n                  \r\n                  if (newTab) {\r\n                    const onFileLoad = () => {\r\n                      newTab.removeEventListener('onEditorFileLoad', onFileLoad);\r\n                      setTimeout(() => {\r\n                        if (newTab.editor && newTab.monaco) {\r\n                          newTab.editor.revealLineInCenter(lineNumber);\r\n                          newTab.editor.setPosition({ lineNumber, column });\r\n                        }\r\n                      }, 200);\r\n                    };\r\n                    \r\n                    newTab.addEventListener('onEditorFileLoad', onFileLoad);\r\n                    \r\n                    if (newTab.code && newTab.code.length > 0) {\r\n                      setTimeout(() => {\r\n                        onFileLoad();\r\n                      }, 100);\r\n                    }\r\n                  } else {\r\n                    setTimeout(findAndScroll, 50);\r\n                  }\r\n                };\r\n                \r\n                setTimeout(findAndScroll, 50);\r\n              }\r\n            }\r\n            \r\n            // Return definition location\r\n            return [{\r\n              uri: model.uri,\r\n              range: new monacoEditor.Range(\r\n                lineNumber,\r\n                column,\r\n                nw_constant.source.last_line || lineNumber,\r\n                nw_constant.source.last_column || column\r\n              )\r\n            }];\r\n          }\r\n\r\n          const nw_action = ForgeState.nwScriptParser.engine_actions.find((obj) => obj.name === word);\r\n          if (nw_action && nw_action.source) {\r\n            log.trace('provideDefinition match engine action', word);\r\n            const lineNumber = nw_action.source.first_line || 1;\r\n            const column = nw_action.source.first_column || 1;\r\n            \r\n            // Check if nwscript.nss is already open\r\n            const nwscriptTab = ForgeState.tabManager.tabs.find((tab) => \r\n              tab.file && tab.file.resref === 'nwscript' && tab.file.ext === KotOR.ResourceTypes.nss\r\n            ) as TabTextEditorState | undefined;\r\n            \r\n            if (nwscriptTab) {\r\n              // File is already open - focus it and scroll\r\n              nwscriptTab.show();\r\n              if (nwscriptTab.editor && nwscriptTab.monaco) {\r\n                setTimeout(() => {\r\n                  nwscriptTab.editor.revealLineInCenter(lineNumber);\r\n                  nwscriptTab.editor.setPosition({ lineNumber, column });\r\n                }, 100);\r\n              }\r\n            } else {\r\n              // File is not open - create EditorFile with the buffer and open it\r\n              if (ForgeState.nwscript_nss) {\r\n                const editorFile = new EditorFile({ \r\n                  resref: 'nwscript', \r\n                  reskey: KotOR.ResourceTypes.nss,\r\n                  buffer: ForgeState.nwscript_nss\r\n                });\r\n                \r\n                FileTypeManager.onOpenResource(editorFile);\r\n                \r\n                // Find the newly opened tab and scroll\r\n                const findAndScroll = () => {\r\n                  const newTab = ForgeState.tabManager.tabs.find((tab: TabState) =>\r\n                    tab.file && tab.file.resref === 'nwscript' && tab.file.ext === KotOR.ResourceTypes.nss\r\n                  ) as TabTextEditorState | undefined;\r\n                  \r\n                  if (newTab) {\r\n                    const onFileLoad = () => {\r\n                      newTab.removeEventListener('onEditorFileLoad', onFileLoad);\r\n                      setTimeout(() => {\r\n                        if (newTab.editor && newTab.monaco) {\r\n                          newTab.editor.revealLineInCenter(lineNumber);\r\n                          newTab.editor.setPosition({ lineNumber, column });\r\n                        }\r\n                      }, 200);\r\n                    };\r\n                    \r\n                    newTab.addEventListener('onEditorFileLoad', onFileLoad);\r\n                    \r\n                    if (newTab.code && newTab.code.length > 0) {\r\n                      setTimeout(() => {\r\n                        onFileLoad();\r\n                      }, 100);\r\n                    }\r\n                  } else {\r\n                    setTimeout(findAndScroll, 50);\r\n                  }\r\n                };\r\n                \r\n                setTimeout(findAndScroll, 50);\r\n              }\r\n            }\r\n            \r\n            // Return definition location\r\n            return [{\r\n              uri: model.uri,\r\n              range: new monacoEditor.Range(\r\n                lineNumber,\r\n                column,\r\n                nw_action.source.last_line || lineNumber,\r\n                nw_action.source.last_column || column\r\n              )\r\n            }];\r\n          }\r\n\r\n          const l_variable = (parser.local_variables || []).find((obj: { name: string }) => obj.name === word);\r\n          if (l_variable && l_variable.source) {\r\n            log.trace('provideDefinition match local variable', word);\r\n            const fileInfo = getFileForLine(l_variable.source.first_line);\r\n            const lineNumber = fileInfo.adjustedLine;\r\n            const column = l_variable.source.first_column || 1;\r\n\r\n            // Navigate to definition\r\n            navigateToDefinition(fileInfo.resref, lineNumber, column);\r\n\r\n            if (fileInfo.resref) {\r\n              // Return a definition that will trigger navigation\r\n              // We'll handle the actual navigation in navigateToDefinition\r\n              return [{\r\n                uri: model.uri, // This will be updated when the file opens\r\n                range: new monacoEditor.Range(lineNumber, column, lineNumber, column)\r\n              }];\r\n            } else {\r\n              return [{\r\n                uri: model.uri,\r\n                range: new monacoEditor.Range(\r\n                  lineNumber,\r\n                  column,\r\n                  l_variable.source.last_line || lineNumber,\r\n                  l_variable.source.last_column || column\r\n                )\r\n              }];\r\n            }\r\n          }\r\n\r\n          let l_function = (parser.local_functions || []).find((obj: { name: string }) => obj.name === word);\r\n          if (!l_function && parser.program && parser.program.functions) {\r\n            l_function = parser.program.functions.find((obj: { name: string }) => obj.name === word);\r\n          }\r\n          log.trace('provideDefinition l_function', l_function?.name);\r\n\r\n          if (l_function && l_function.source) {\r\n            log.trace('provideDefinition match local function', word);\r\n            const fileInfo = getFileForLine(l_function.source.first_line);\r\n            const lineNumber = fileInfo.adjustedLine;\r\n            const column = l_function.source.first_column || 1;\r\n\r\n            // Navigate to definition\r\n            navigateToDefinition(fileInfo.resref, lineNumber, column);\r\n\r\n            if (fileInfo.resref) {\r\n              return [{\r\n                uri: model.uri,\r\n                range: new monacoEditor.Range(lineNumber, column, lineNumber, column)\r\n              }];\r\n            } else {\r\n              return [{\r\n                uri: model.uri,\r\n                range: new monacoEditor.Range(\r\n                  lineNumber,\r\n                  column,\r\n                  l_function.source.last_line || lineNumber,\r\n                  l_function.source.last_column || column\r\n                )\r\n              }];\r\n            }\r\n          }\r\n\r\n          log.trace('provideDefinition no match');\r\n          return [];\r\n        } catch (e) {\r\n          log.error('Error providing definition:', e as Error);\r\n          return [];\r\n        }\r\n      }\r\n    });\r\n    log.info('initNWScriptLanguage complete');\r\n  }\r\n\r\n  static updateLocalFunctions(localFunctions: string[]) {\r\n    log.trace('updateLocalFunctions entry', { count: localFunctions?.length ?? 0 });\r\n    if (!NWScriptLanguageService.nwScriptTokenConfig) {\r\n      log.trace('updateLocalFunctions no token config, skip');\r\n      return;\r\n    }\r\n    NWScriptLanguageService.nwScriptTokenConfig.localFunctions = localFunctions;\r\n    log.debug('updateLocalFunctions set MonarchTokensProvider', localFunctions.length);\r\n    monacoEditor.languages.setMonarchTokensProvider('nwscript', NWScriptLanguageService.nwScriptTokenConfig);\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\modal\\ModalItemBrowserState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":91,"column":17,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":91,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":91,"column":30,"nodeType":"MemberExpression","messageId":"errorCall","endLine":91,"endColumn":74}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\r\n\r\nimport { ModalItemBrowser } from \"@/apps/forge/components/modal/ModalItemBrowser\";\r\nimport { ModalState } from \"@/apps/forge/states/modal/ModalState\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\nimport * as KotOR from \"@/apps/forge/KotOR\";\r\n\r\nconst log = createScopedLogger(LogScope.Forge);\r\n\r\nexport interface UTIItem {\r\n  resref: string;\r\n  baseItem: number;\r\n  localizedName: string;\r\n  iconResRef: string;\r\n  gff: KotOR.GFFObject;\r\n}\r\n\r\nexport class ModalItemBrowserState extends ModalState {\r\n  static itemsCache: UTIItem[] = [];\r\n  static cacheLoaded: boolean = false;\r\n\r\n  items: UTIItem[] = [];\r\n  filteredItems: UTIItem[] = [];\r\n  searchQuery: string = '';\r\n  onItemSelect?: (item: UTIItem) => void;\r\n\r\n  constructor(onItemSelect?: (item: UTIItem) => void) {\r\n    super();\r\n    this.title = 'Item Browser';\r\n    this.onItemSelect = onItemSelect;\r\n    this.setView(<ModalItemBrowser modal={this} />);\r\n  }\r\n\r\n  async loadItems() {\r\n    if (ModalItemBrowserState.cacheLoaded) {\r\n      this.items = ModalItemBrowserState.itemsCache.slice(0);\r\n      this.filteredItems = this.items.slice(0);\r\n      this.processEventListener('onItemsLoaded', [this]);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const items: UTIItem[] = [];\r\n      \r\n      // Get all UTI files from KEYManager\r\n      const utiKeys = KotOR.KEYManager.Key.keys.filter(\r\n        (key: KotOR.IKEYEntry) => key.resType === KotOR.ResourceTypes['uti']\r\n      );\r\n\r\n      // Load and parse each UTI file\r\n      for (const key of utiKeys) {\r\n        try {\r\n          const buffer = await KotOR.KEYManager.Key.getFileBuffer(key);\r\n          if (!buffer) continue;\r\n\r\n          const gff = new KotOR.GFFObject(buffer);\r\n          gff.parse(buffer);\r\n          const root = gff.RootNode;\r\n          if (!root) continue;\r\n\r\n          // Extract metadata\r\n          let baseItem = 0;\r\n          let localizedName = '';\r\n          let iconResRef = '';\r\n          let modelVariation = 1;\r\n\r\n          if (root.hasField('BaseItem')) {\r\n            baseItem = root.getFieldByLabel('BaseItem').getValue() || 0;\r\n          }\r\n\r\n          if (root.hasField('ModelVariation')) {\r\n            modelVariation = root.getFieldByLabel('ModelVariation').getValue() || 1;\r\n          }\r\n\r\n          if (root.hasField('LocalizedName')) {\r\n            const localizedNameField = root.getFieldByLabel('LocalizedName');\r\n            if (localizedNameField) {\r\n              const locString = localizedNameField.getCExoLocString();\r\n              if (locString) {\r\n                localizedName = locString.getValue() || '';\r\n              }\r\n            }\r\n          }\r\n\r\n          // Get icon from baseitem\r\n          if (baseItem > 0) {\r\n            const baseitems2DA = KotOR.TwoDAManager.datatables.get('baseitems');\r\n            if (baseitems2DA) {\r\n              const baseItemRow = baseitems2DA.getRowByIndex(baseItem);\r\n              if (baseItemRow) {\r\n                iconResRef = (baseItemRow['itemclass'] || '').toLowerCase();\r\n                iconResRef = `i${iconResRef}_${(\"000\" + modelVariation).slice(-3)}`;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Use resref as fallback for localized name\r\n          if (!localizedName) {\r\n            localizedName = key.resRef;\r\n          }\r\n\r\n          items.push({\r\n            resref: key.resRef,\r\n            baseItem,\r\n            localizedName,\r\n            iconResRef,\r\n            gff\r\n          });\r\n        } catch (error) {\r\n          log.error(`Failed to load UTI: ${key.resRef}`, error);\r\n        }\r\n      }\r\n\r\n      this.items = items;\r\n      this.filteredItems = items;\r\n      ModalItemBrowserState.itemsCache = items.slice(0);\r\n      ModalItemBrowserState.cacheLoaded = true;\r\n      this.processEventListener('onItemsLoaded', [this]);\r\n    } catch (error) {\r\n      log.error('Failed to load items', error);\r\n    }\r\n  }\r\n\r\n  setSearchQuery(query: string) {\r\n    this.searchQuery = query.toLowerCase();\r\n    this.filteredItems = this.items.filter(item => \r\n      item.resref.toLowerCase().includes(this.searchQuery) ||\r\n      item.localizedName.toLowerCase().includes(this.searchQuery)\r\n    );\r\n    this.processEventListener('onSearchChanged', [this]);\r\n  }\r\n\r\n  selectItem(item: UTIItem) {\r\n    if (this.onItemSelect) {\r\n      this.onItemSelect(item);\r\n    }\r\n    this.close();\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabGUIEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":48,"column":90,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":48,"endColumn":113}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\n\nimport { TabGUIEditor } from \"@/apps/forge/components/tabs/tab-gui-editor/TabGUIEditor\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { TabState, TabStateEventListenerTypes, TabStateEventListeners } from \"@/apps/forge/states/tabs\";\nimport { UI3DRenderer, UI3DRendererEventListenerTypes } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope, type IScopedLogger } from \"@/utility/Logger\";\nimport type { GameState } from \"@/GameState\";\n\nconst log: IScopedLogger = createScopedLogger(LogScope.Forge);\n\n\n\nexport type TabGUIEditorStateEventListenerTypes =\nTabStateEventListenerTypes &\n  ''|'onEditorFileLoad'|'onNodeSelected'|'onNodeAdded'|'onNodeRemoved'|'onAnimate';\n\nexport interface TabGUIEditorStateEventListeners extends TabStateEventListeners {\n  onEditorFileLoad: (() => void)[];\n  onNodeSelected: (() => void)[];\n  onNodeAdded: (() => void)[];\n  onNodeRemoved: (() => void)[];\n  onAnimate: (() => void)[];\n}\n\nexport class TabGUIEditorState extends TabState {\n\n  tabName: string = `GUI`;\n  gff: KotOR.GFFObject;\n  menu: KotOR.GameMenu;\n\n  background: string = '';\n  backgrounds: string[] = [];\n\n  ui3DRenderer: UI3DRenderer;\n\n  selectedNode: KotOR.GFFField|KotOR.GFFStruct;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabGUIEditorState constructor entry');\n    super(options);\n    this.setContentView(<TabGUIEditor tab={this}></TabGUIEditor>);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.guiMode = true;\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onBeforeRender', this.animate.bind(this));\n\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'GUI File Format (GUI)',\n        accept: {\n          'application/octet-stream': ['.gui']\n        }\n      }\n    ];\n    log.trace('TabGUIEditorState constructor exit');\n  }\n\n  show(): void {\n    log.trace('TabGUIEditorState show');\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    log.trace('TabGUIEditorState hide');\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  animate(delta: number = 0){\n    this.menu?.update(delta);\n    this.processEventListener('onAnimate', [delta]);\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabGUIEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.tabName = this.file.getFilename();\n        log.debug('TabGUIEditorState openFile tabName', this.tabName);\n\n        file.readFile().then( async (response) => {\n          this.gff = new KotOR.GFFObject(response.buffer);\n          this.menu = new KotOR.GameMenu();\n          this.menu.voidFill = true;\n          this.menu.bVisible = true;\n          this.menu.context = this.ui3DRenderer as unknown as typeof GameState;\n          await this.menu.loadBackground();\n          await this.menu.buildMenu(this.gff);\n          this.ui3DRenderer.scene.add(this.menu.tGuiPanel.widget);\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabGUIEditorState openFile loaded');\n          resolve(this.gff);\n        });\n      } else {\n        log.trace('TabGUIEditorState openFile no file');\n      }\n    });\n  }\n\n  async getExportBuffer(_resref?: string, _ext?: string): Promise<Uint8Array> {\n    log.trace('TabGUIEditorState getExportBuffer');\n    return this.gff.getExportBuffer();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabModelViewerState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":104,"column":90,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":104,"endColumn":113},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Texture<unknown>`.","line":432,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":432,"endColumn":92}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { TabModelViewer } from \"@/apps/forge/components/tabs/tab-model-viewer/TabModelViewer\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { SceneGraphNode } from \"@/apps/forge/SceneGraphNode\";\nimport { TabState, TabStateEventListenerTypes, TabStateEventListeners } from \"@/apps/forge/states/tabs\";\nimport { UI3DRenderer, UI3DRendererEventListenerTypes } from \"@/apps/forge/UI3DRenderer\";\nimport { BinaryReader } from \"@/utility/binary/BinaryReader\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport type TabModelViewerStateEventListenerTypes =\nTabStateEventListenerTypes &\n  ''|'onModelLoaded'|'onPlay'|'onPause'|'onStop'|'onAudioLoad'|'onHeadChange'|\n  'onHeadLoad'|'onKeyFrameSelect'|'onKeyFrameTrackZoomIn'|'onKeyFrameTrackZoomOut'|\n  'onAnimate'|'onKeyFramesChange'|'onDurationChange'|'onAnimationChange'|'onLoopChange';\n\nexport interface TabModelViewerStateEventListeners extends TabStateEventListeners {\n  onModelLoaded: (() => void)[];\n  onPlay: (() => void)[];\n  onPause: (() => void)[];\n  onStop: (() => void)[];\n  onAudioLoad: (() => void)[];\n  onHeadChange: (() => void)[];\n  onHeadLoad: (() => void)[];\n  onKeyFrameSelect: (() => void)[];\n  onKeyFrameTrackZoomIn: (() => void)[];\n  onKeyFrameTrackZoomOut: (() => void)[];\n  onAnimate: (() => void)[];\n  onKeyFramesChange: (() => void)[];\n  onDurationChange: (() => void)[];\n  onAnimationChange: (() => void)[];\n  onLoopChange: (() => void)[];\n}\n\nexport class TabModelViewerState extends TabState {\n\n  tabName: string = `Model Viewer`;\n\n  model: KotOR.OdysseyModel3D;\n  odysseyModel: KotOR.OdysseyModel;\n\n  mdl: Uint8Array;\n  mdx: Uint8Array;\n\n  ui3DRenderer: UI3DRenderer;\n\n  selectedAnimationIndex: number = -1;\n  animations: KotOR.OdysseyModelAnimation[] = [];\n  currentAnimation: KotOR.OdysseyModelAnimation;\n\n  timelineOffset: number = 200;\n  timelineZoom: number = 250;\n  seeking: boolean = false;\n  playing: boolean = false;\n  looping: boolean = false;\n  min_timeline_zoom: number = 50;\n  max_timeline_zoom: number = 1000;\n\n  dragging_frame: number | null = null;\n  selected_frame: number | null = null;\n  groundColor: THREE.Color;\n  groundGeometry: THREE.WireframeGeometry<THREE.PlaneGeometry>;\n  groundMaterial: THREE.LineBasicMaterial;\n  groundMesh: THREE.LineSegments<THREE.WireframeGeometry<THREE.PlaneGeometry>, THREE.LineBasicMaterial>;\n\n  //layout\n  layout_group: THREE.Group = new THREE.Group();\n  selectedLayoutIndex: number = -1;\n  layoutSceneGraphNode: SceneGraphNode;\n  layout: KotOR.LYTObject;\n  currentAnimationState: { elapsed: number } = {\n    elapsed: 0\n  };\n  scrubbing: boolean = false;\n  scrubbingTimeout: NodeJS.Timeout;\n  paused: boolean = false;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace(\"TabModelViewerState constructor entry\");\n    super(options);\n    this.isClosable = true;\n    log.trace(\"TabModelViewerState constructor isClosable set\");\n\n    if(this.file){\n      this.tabName = this.file.getFilename();\n      log.debug(\"TabModelViewerState constructor tabName from file\", this.tabName);\n    } else {\n      log.trace(\"TabModelViewerState constructor no file\");\n    }\n\n    log.trace(\"TabModelViewerState constructor ground setup\");\n    this.groundColor = new THREE.Color(0.5, 0.5, 0.5);\n    this.groundGeometry = new THREE.WireframeGeometry(new THREE.PlaneGeometry( 2500, 2500, 100, 100 ));\n    this.groundMaterial = new THREE.LineBasicMaterial( { color: this.groundColor, linewidth: 2 } );\n    this.groundMesh = new THREE.LineSegments( this.groundGeometry, this.groundMaterial );\n\n    log.trace(\"TabModelViewerState constructor UI3DRenderer\");\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onBeforeRender', this.animate.bind(this));\n    this.ui3DRenderer.scene.add(this.groundMesh);\n    this.ui3DRenderer.scene.add(this.layout_group);\n    log.debug(\"TabModelViewerState constructor scene nodes added\");\n\n    this.layoutSceneGraphNode = new SceneGraphNode({\n      name: 'Layout'\n    });\n    this.ui3DRenderer.sceneGraphManager.sceneNode.addChildNode(this.layoutSceneGraphNode);\n    log.trace(\"TabModelViewerState constructor layout node added\");\n\n    this.setContentView(<TabModelViewer tab={this}></TabModelViewer>);\n    log.trace(\"TabModelViewerState constructor setContentView done\");\n    this.openFile();\n    log.trace(\"TabModelViewerState constructor exit\");\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace(\"openFile entry\", \"file=%s\", file?.getFilename?.() ?? String(file));\n    return new Promise<KotOR.OdysseyModel3D>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n        log.trace(\"openFile using this.file\");\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.tabName = this.file.getFilename();\n        log.debug(\"openFile tabName\", this.tabName);\n\n        log.trace(\"openFile readFile\");\n        file.readFile().then( (response) => {\n          log.trace(\"openFile readFile resolved\");\n          this.mdl = response.buffer;\n          this.mdx = response.buffer2 as Buffer;\n          log.debug(\"openFile buffer lengths\", this.mdl?.length, this.mdx?.length);\n          this.odysseyModel = new KotOR.OdysseyModel(new BinaryReader(response.buffer), new BinaryReader(response.buffer2 as Buffer));\n          log.trace(\"openFile OdysseyModel created, FromMDL\");\n          KotOR.OdysseyModel3D.FromMDL(this.odysseyModel, {\n            context: this.ui3DRenderer,\n            editorMode: true,\n            onComplete: (model: KotOR.OdysseyModel3D) => {\n              log.trace(\"openFile onComplete\");\n              this.model = model;\n              this.ui3DRenderer.attachObject(this.model, true);\n              log.trace(\"openFile attachObject done\");\n\n              this.animations = this.model.odysseyAnimations.slice(0).sort( (a, b) => {\n                return a.name.localeCompare(b.name);\n              });\n              log.debug(\"openFile animations count\", this.animations.length);\n\n              this.selectedAnimationIndex = 0;\n              this.currentAnimation = this.animations[this.selectedAnimationIndex];\n              this.paused = true;\n              log.trace(\"openFile animation state set\");\n\n              model.emitters.map( (emitter) => {\n                emitter.referenceNode = this.ui3DRenderer.referenceNode as KotOR.OdysseyObject3D;\n              });\n              log.trace(\"openFile emitters reference set\");\n\n              if(model.camerahook){\n                log.trace(\"openFile adding camera\");\n                const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n                camera.name = model.name;\n                model.camerahook.add(camera);\n                this.ui3DRenderer.attachCamera(camera);\n              } else {\n                log.trace(\"openFile no camerahook\");\n              }\n              this.ui3DRenderer.sceneGraphManager.rebuild();\n              log.trace(\"openFile sceneGraphManager rebuild\");\n\n              this.processEventListener('onEditorFileLoad', [this]);\n              log.info(\"openFile model loaded\", this.model?.name);\n              resolve(this.model);\n            }\n          });\n          log.trace(\"openFile FromMDL called\");\n        });\n      } else {\n        log.trace(\"openFile file not EditorFile\");\n      }\n      log.trace(\"openFile promise body done\");\n    });\n  }\n\n  show(): void {\n    log.trace(\"show entry\");\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.ui3DRenderer.render();\n    log.trace(\"show exit\");\n  }\n\n  hide(): void {\n    log.trace(\"hide entry\");\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n    log.trace(\"hide exit\");\n  }\n\n  animate(delta: number = 0){\n    log.trace(\"animate\", \"delta=%s model=%s\", delta, !!this.model);\n    if(this.model){\n      if(this.currentAnimation != this.model.animationManager.currentAnimation){\n        log.trace(\"animate sync currentAnimation\");\n        this.model.animationManager.currentAnimation = this.currentAnimation;\n        this.model.animationManager.currentAnimationState = this.currentAnimationState;\n      }\n      const cachedAnimationState = this.model.animationManager.currentAnimationState;\n      if(!this.paused){\n        log.trace(\"animate not paused update\");\n        const elapsed = this.currentAnimationState.elapsed;\n        this.model.update(delta);\n        let cElapsed = this.model.animationManager.currentAnimationState.elapsed;\n        if(isNaN(cElapsed)) cElapsed = elapsed;\n        if(cElapsed < elapsed && !this.looping) cElapsed = elapsed;\n      } else {\n        log.trace(\"animate paused update\");\n        const elapsed = this.model.animationManager.currentAnimationState.elapsed;\n        this.model.update(delta);\n        if(!isNaN(elapsed)){\n          this.model.animationManager.currentAnimationState.elapsed = elapsed;\n        }\n      }\n      if(!this.model.animationManager.currentAnimationState){\n        log.trace(\"animate restore cached state\");\n        this.model.animationManager.currentAnimationState = cachedAnimationState;\n      }\n      this.currentAnimationState = this.model.animationManager.currentAnimationState;\n    }\n    this.processEventListener('onAnimate', [delta]);\n    log.trace(\"animate onAnimate fired\");\n  }\n\n\n\n  keyframeTrackZoomIn(){\n    log.trace(\"keyframeTrackZoomIn entry\", this.timelineZoom);\n    this.timelineZoom += 25;\n    if(this.timelineZoom > this.max_timeline_zoom){\n      this.timelineZoom = this.max_timeline_zoom;\n      log.trace(\"keyframeTrackZoomIn clamped to max\");\n    }\n    this.processEventListener<TabModelViewerStateEventListenerTypes>('onKeyFrameTrackZoomIn', [this]);\n    log.trace(\"keyframeTrackZoomIn exit\", this.timelineZoom);\n  }\n\n  keyframeTrackZoomOut(){\n    log.trace(\"keyframeTrackZoomOut entry\", this.timelineZoom);\n    this.timelineZoom -= 25;\n    if(this.timelineZoom < this.min_timeline_zoom){\n      this.timelineZoom = this.min_timeline_zoom;\n      log.trace(\"keyframeTrackZoomOut clamped to min\");\n    }\n    this.processEventListener<TabModelViewerStateEventListenerTypes>('onKeyFrameTrackZoomOut', [this]);\n    log.trace(\"keyframeTrackZoomOut exit\", this.timelineZoom);\n  }\n\n  setAnimationByIndex(index: number = 0){\n    log.trace(\"setAnimationByIndex entry\", index);\n    this.selectedAnimationIndex = index;\n    const animation = this.animations[index];\n    if(animation){\n      log.debug(\"setAnimationByIndex play\", animation.name);\n      this.model.playAnimation(animation, this.looping);\n      this.currentAnimation = animation;\n    } else {\n      log.trace(\"setAnimationByIndex no animation at index, use 0\");\n      this.selectedAnimationIndex = 0;\n      this.currentAnimation = this.animations[0];\n    }\n    this.processEventListener<TabModelViewerStateEventListenerTypes>('onAnimationChange', [this]);\n    log.trace(\"setAnimationByIndex exit\");\n  }\n\n  getCurrentAnimationLength(){\n    log.trace(\"getCurrentAnimationLength\");\n    if(!this.currentAnimation) {\n      log.trace(\"getCurrentAnimationLength no animation return 0\");\n      return 0;\n    }\n    log.trace(\"getCurrentAnimationLength\", this.currentAnimation.length);\n    return this.currentAnimation.length;\n  }\n\n  getCurrentAnimationElapsed(){\n    log.trace(\"getCurrentAnimationElapsed\");\n    if(!this.currentAnimationState) {\n      log.trace(\"getCurrentAnimationElapsed no state return 0\");\n      return 0;\n    }\n    log.trace(\"getCurrentAnimationElapsed\", this.currentAnimationState.elapsed);\n    return this.currentAnimationState.elapsed;\n  }\n\n  playAnimation(){\n    // if(!this.currentAnimation){\n    //   this.pause();\n    //   return;\n    // }\n    // if(this.currentAnimation != this.model.animationManager.currentAnimation){\n    //   this.model.playAnimation(this.currentAnimation, this.looping);\n    // }else{\n    //   this.stopAnimation();\n    // }\n    // this.play();\n  }\n\n  stopAnimation(){\n    log.trace(\"stopAnimation entry\");\n    this.model.stopAnimation();\n    this.pause();\n    log.trace(\"stopAnimation exit\");\n  }\n\n  play(){\n    log.trace(\"play entry\");\n    if(!this.currentAnimation) {\n      log.trace(\"play no currentAnimation return\");\n      return;\n    }\n    this.paused = false;\n    if(this.currentAnimation != this.model.animationManager.currentAnimation){\n      log.debug(\"play playAnimation\", this.currentAnimation.name);\n      this.model.playAnimation(this.currentAnimation, this.looping);\n    }\n    this.processEventListener('onPlay');\n    log.info(\"play started\");\n    log.trace(\"play exit\");\n  }\n\n  pause(){\n    log.trace(\"pause entry\");\n    this.paused = true;\n    this.processEventListener('onPause');\n    log.trace(\"pause exit\");\n  }\n\n  stop(){\n    log.trace(\"stop entry\");\n    this.paused = true;\n    this.stopAnimation();\n    log.trace(\"stop exit\");\n  }\n\n  seek(time: number = 0){\n    log.trace(\"seek entry\", time);\n    if(this.currentAnimation && this.currentAnimationState){\n      if(time < 0) time = 0;\n      if(time > this.currentAnimation.length) time = this.currentAnimation.length;\n      this.currentAnimationState.elapsed = time;\n      log.debug(\"seek set elapsed\", time);\n    } else {\n      log.trace(\"seek no animation/state\");\n    }\n    log.trace(\"seek exit\");\n  }\n\n  setLooping(loop: boolean = false){\n    log.trace(\"setLooping entry\", loop);\n    this.looping = loop;\n    if(this.currentAnimation){\n      this.model.playAnimation(this.currentAnimation, this.looping);\n      log.trace(\"setLooping playAnimation updated\");\n    }\n    this.processEventListener('onLoopChange', [this.looping]);\n    log.trace(\"setLooping exit\");\n  }\n\n  destroy(): void {\n    log.trace(\"destroy entry\");\n    this.ui3DRenderer.destroy();\n    log.trace(\"destroy ui3DRenderer destroyed\");\n    this.disposeLayout();\n    super.destroy();\n    log.trace(\"destroy exit\");\n  }\n\n  loadLayout(key?: KotOR.IKEYEntry){\n    log.trace(\"loadLayout entry\", \"key=%s\", key?.resref ?? String(key));\n    this.disposeLayout();\n    if(key) {\n      return new Promise<void>( async (resolve, reject) => {\n        log.trace(\"loadLayout getFileBuffer\");\n        const data = await KotOR.KEYManager.Key.getFileBuffer(key);\n        log.debug(\"loadLayout buffer length\", data?.length);\n        const lyt = new KotOR.LYTObject(data);\n        this.layout = lyt;\n        log.trace(\"loadLayout LYTObject created rooms=%s\", this.layout.rooms?.length);\n        for(let i = 0, len = this.layout.rooms.length; i < len; i++){\n          const room = this.layout.rooms[i];\n          log.trace(\"loadLayout room\", i, room.name);\n          const mdl = await KotOR.MDLLoader.loader.load(room.name);\n          if(mdl){\n            log.trace(\"loadLayout FromMDL room\", room.name);\n            const model = await KotOR.OdysseyModel3D.FromMDL(mdl, {\n              context: this.ui3DRenderer,\n              mergeStatic: false,\n            });\n            if(model){\n              model.position.copy( room.position );\n              this.layout_group.add(model);\n              log.trace(\"loadLayout added model\", room.name);\n            }\n          }\n          this.layoutSceneGraphNode.addChildNode(\n            new SceneGraphNode({\n              name: room.name,\n            })\n          );\n        }\n        log.trace(\"loadLayout sceneGraphManager.rebuild\");\n        this.ui3DRenderer.sceneGraphManager.rebuild();\n        KotOR.TextureLoader.LoadQueue().then(() => {\n          log.trace(\"loadLayout LoadQueue then\");\n          if(this.ui3DRenderer.renderer)\n            this.ui3DRenderer.renderer.compile(this.ui3DRenderer.scene, this.ui3DRenderer.currentCamera);\n          log.info(\"loadLayout complete\");\n          resolve();\n        }, (texObj: KotOR.ITextureLoaderQueuedRef) => {\n          if(texObj.material){\n            if(texObj.material instanceof THREE.ShaderMaterial){\n              if(texObj.material.uniforms.map.value){\n                log.trace('Initializing texture', texObj.name);\n                if(this.ui3DRenderer.renderer)\n                  this.ui3DRenderer.renderer.initTexture(texObj.material.uniforms.map.value);\n              }\n            }\n          }\n        });\n        log.trace(\"loadLayout LoadQueue registered\");\n      });\n    }\n    log.trace(\"loadLayout no key exit\");\n  }\n\n\n\n  disposeLayout(){\n    log.trace(\"disposeLayout entry\");\n    this.layoutSceneGraphNode.setNodes([]);\n    this.ui3DRenderer.sceneGraphManager.rebuild();\n    log.trace(\"disposeLayout setNodes rebuild done\");\n    try{\n      if(this.layout_group.children.length){\n        log.debug(\"disposeLayout children count\", this.layout_group.children.length);\n        let modelIndex = this.layout_group.children.length - 1;\n        while(modelIndex >= 0){\n          const model = this.layout_group.children[modelIndex] as KotOR.OdysseyModel3D;\n          if(model){\n            model.dispose();\n            this.layout_group.remove(model);\n            log.trace(\"disposeLayout removed model\", modelIndex);\n          }\n          modelIndex--;\n        }\n      } else {\n        log.trace(\"disposeLayout no children\");\n      }\n    }catch(e){\n      log.error('Dispose layout error', e);\n    }\n    log.trace(\"disposeLayout exit\");\n  }\n\n  setRandomReferencePosition(spread: number = 1){\n    log.trace(\"setRandomReferencePosition\", spread);\n    this.ui3DRenderer.referenceNode.position.set(\n      (Math.random()-0.5*2) * spread,\n      (Math.random()-0.5*2) * spread,\n      (Math.random()-0.5*2) * spread\n    );\n    log.trace(\"setRandomReferencePosition done\");\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabModuleEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":103,"column":90,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":103,"endColumn":113},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":104,"column":87,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":104,"endColumn":114},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":105,"column":87,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":105,"endColumn":114},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":106,"column":84,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":106,"endColumn":108},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":109,"column":40,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":109,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListener<{}, \"change\", TransformControls>`.","line":136,"column":70,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":136,"endColumn":111},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListener<{}, \"change\", TransformControls>`.","line":141,"column":74,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":141,"endColumn":115},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":347,"column":42,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":347,"endColumn":66},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":350,"column":42,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":350,"endColumn":66},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":353,"column":42,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":353,"endColumn":66}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { TabModuleEditor } from \"@/apps/forge/components/tabs/tab-module-editor/TabModuleEditor\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from '@/apps/forge/KotOR';\nimport { ForgeArea } from \"@/apps/forge/module-editor/ForgeArea\";\nimport { ForgeCamera } from \"@/apps/forge/module-editor/ForgeCamera\";\nimport { ForgeCreature } from \"@/apps/forge/module-editor/ForgeCreature\";\nimport { ForgeDoor } from \"@/apps/forge/module-editor/ForgeDoor\";\nimport { ForgeEncounter } from \"@/apps/forge/module-editor/ForgeEncounter\";\nimport { ForgeGameObject } from \"@/apps/forge/module-editor/ForgeGameObject\";\nimport { ForgeItem } from \"@/apps/forge/module-editor/ForgeItem\";\nimport { ForgeModule } from \"@/apps/forge/module-editor/ForgeModule\";\nimport { ForgePlaceable } from \"@/apps/forge/module-editor/ForgePlaceable\";\nimport { ForgeRoom } from \"@/apps/forge/module-editor/ForgeRoom\";\nimport { ForgeSound } from \"@/apps/forge/module-editor/ForgeSound\";\nimport { ForgeStore } from \"@/apps/forge/module-editor/ForgeStore\";\nimport { ForgeTrigger } from \"@/apps/forge/module-editor/ForgeTrigger\";\nimport { ForgeWaypoint } from \"@/apps/forge/module-editor/ForgeWaypoint\";\nimport { Project } from \"@/apps/forge/Project\";\nimport { ForgeState } from \"@/apps/forge/states/ForgeState\";\nimport { ModalBlueprintBrowserState, BlueprintType } from \"@/apps/forge/states/modal/ModalBlueprintBrowserState\";\nimport { TabState } from \"@/apps/forge/states/tabs\";\nimport { UI3DRenderer, UI3DRendererEventListenerTypes, GroupType } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport enum TabModuleEditorControlMode {\n  SELECT = 0,\n  TRANSFORM_CONTROL = 2,\n  ROTATE_CONTROL = 3,\n  SCALE_CONTROL = 4,\n  ADD_GAME_OBJECT = 5\n}\n\nexport enum GameObjectType {\n  ROOM = 'room',\n  CREATURE = 'creature',\n  CAMERA = 'camera',\n  DOOR = 'door',\n  ENCOUNTER = 'encounter',\n  ITEM = 'item',\n  PLACEABLE = 'placeable',\n  SOUND = 'sound',\n  STORE = 'store',\n  TRIGGER = 'trigger',\n  WAYPOINT = 'waypoint'\n}\n\nexport class TabModuleEditorState extends TabState {\n\n  tabName: string = `Module Editor`;\n  controlMode: TabModuleEditorControlMode = TabModuleEditorControlMode.SELECT;\n  selectedGameObjectType: GameObjectType | undefined;\n  selectedBlueprintResRef: string = '';\n\n  ui3DRenderer: UI3DRenderer;\n  module: ForgeModule | undefined;\n  groundColor: THREE.Color;\n  groundGeometry: THREE.WireframeGeometry<THREE.PlaneGeometry>;\n  groundMaterial: THREE.LineBasicMaterial;\n  groundMesh: THREE.LineSegments<THREE.WireframeGeometry<THREE.PlaneGeometry>, THREE.LineBasicMaterial>;\n\n  // Ghost preview for object placement\n  ghostPreviewMesh: THREE.Mesh;\n  previewPosition: THREE.Vector3 = new THREE.Vector3();\n  previewValid: boolean = false;\n\n  // Selected game object\n  selectedGameObject: ForgeGameObject | undefined;\n\n  // Mouse vector for raycasting (reused to avoid allocation)\n  private mouseVector: THREE.Vector2 = new THREE.Vector2();\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabModuleEditorState constructor entry');\n    super(options);\n    this.singleInstance = true;\n    this.isClosable = true;\n\n    this.ui3DRenderer = new UI3DRenderer();\n    log.trace('TabModuleEditorState constructor ui3DRenderer created');\n\n    // Geometry\n    this.groundColor = new THREE.Color(0.5, 0.5, 0.5);\n    this.groundGeometry = new THREE.WireframeGeometry(new THREE.PlaneGeometry( 2500, 2500, 100, 100 ));\n    this.groundMaterial = new THREE.LineBasicMaterial( { color: this.groundColor, linewidth: 2 } );\n    this.groundMesh = new THREE.LineSegments( this.groundGeometry, this.groundMaterial );\n\n    // Create ghost preview mesh for object placement\n    const ghostGeometry = new THREE.BoxGeometry(1, 1, 1);\n    const ghostMaterial = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      wireframe: true,\n      transparent: true,\n      opacity: 0.5\n    });\n    this.ghostPreviewMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);\n    this.ghostPreviewMesh.visible = false;\n\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onBeforeRender', this.animate.bind(this));\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onMouseDown', this.onMouseDown.bind(this));\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onMouseMove', this.onMouseMove.bind(this));\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onSelect', this.onSelect.bind(this));\n\n    // Listen for keyboard events (Delete key to remove selected object)\n    this.addEventListener('onKeyDown', this.onKeyDown.bind(this));\n\n    // Add ground mesh and ghost preview to scene when scene is available\n    // The scene is initialized in UI3DRenderer, but buildScene() is called when canvas is attached\n    const addMeshesToScene = () => {\n      if(this.ui3DRenderer?.scene){\n        if(!this.ui3DRenderer.scene.children.includes(this.groundMesh)){\n          this.ui3DRenderer.scene.add(this.groundMesh);\n        }\n        if(!this.ui3DRenderer.scene.children.includes(this.ghostPreviewMesh)){\n          this.ui3DRenderer.scene.add(this.ghostPreviewMesh);\n        }\n      }\n    };\n\n    // Try to add immediately if scene exists (scene is initialized in UI3DRenderer class definition)\n    if(this.ui3DRenderer.scene){\n      addMeshesToScene();\n    }\n\n    // Also listen for when canvas is attached (which calls buildScene and ensures scene is ready)\n    this.ui3DRenderer.addEventListener('onCanvasAttached', addMeshesToScene);\n    this.setContentView(<TabModuleEditor tab={this}></TabModuleEditor>);\n\n    // Listen to transform controls changes to update point positions\n    // Add listener immediately if transform controls exist, otherwise wait for canvas attachment\n    if(this.ui3DRenderer.transformControls){\n      this.ui3DRenderer.transformControls.addEventListener('change', this.onTransformControlsChange.bind(this));\n    } else {\n      // Wait for canvas to be attached so transform controls are built\n      this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onCanvasAttached', () => {\n        if(this.ui3DRenderer.transformControls){\n          this.ui3DRenderer.transformControls.addEventListener('change', this.onTransformControlsChange.bind(this));\n        }\n      });\n    }\n    log.trace('TabModuleEditorState constructor exit');\n  }\n\n  show(): void {\n    log.trace('TabModuleEditorState show');\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    log.trace('TabModuleEditorState hide');\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  destroy(): void {\n    log.trace('TabModuleEditorState destroy entry');\n    if(this.ghostPreviewMesh){\n      this.ui3DRenderer.scene.remove(this.ghostPreviewMesh);\n      this.ghostPreviewMesh.geometry.dispose();\n      (this.ghostPreviewMesh.material as THREE.Material).dispose();\n    }\n\n    this.ui3DRenderer.destroy();\n    super.destroy();\n    log.trace('TabModuleEditorState destroy exit');\n  }\n\n  animate(delta: number = 0){\n    this.processEventListener('onAnimate', [delta]);\n\n    // Update the module area (which updates all game objects)\n    if(this.module?.area){\n      this.module.area.update(delta);\n    }\n\n    // this.ui3DRenderer.transformControls.space = 'local';\n    if(this.selectedGameObject){\n      if(this.selectedGameObject instanceof ForgeCamera){\n        const camera = this.selectedGameObject as ForgeCamera;\n        // Ensure rotation order is maintained\n        // camera.rotation.reorder('YZX');\n        // // Sync quaternion from rotation\n        // camera.quaternion.setFromEuler(camera.rotation);\n        // // Update pitch from rotation.x\n        // camera.pitch = THREE.MathUtils.radToDeg(camera.rotation.x);\n        // Sync to perspective camera\n        if(camera.perspectiveCamera){\n          camera.perspectiveCamera.position.copy(camera.position);\n          camera.perspectiveCamera.rotation.copy(camera.rotation);\n          camera.perspectiveCamera.updateMatrixWorld(true);\n          camera.perspectiveCamera.updateMatrix();\n        }\n      }\n    }\n  }\n\n  private onTransformControlsChange(): void {\n    if(!this.selectedGameObject) return;\n\n    const object3D = this.selectedGameObject.container;\n    if(!object3D) return;\n\n    // For cameras, ensure rotation order is maintained and sync quaternion/pitch\n    if(this.selectedGameObject instanceof ForgeCamera){\n      const camera = this.selectedGameObject as ForgeCamera;\n\n      // Ensure rotation order is set correctly\n      camera.rotation.reorder('YZX');\n\n      // Update quaternion from rotation\n      camera.quaternion.setFromEuler(camera.rotation);\n\n      // Update pitch from rotation.x (pitch is stored separately)\n      camera.pitch = THREE.MathUtils.radToDeg(camera.rotation.x);\n\n      // Sync to perspective camera\n      if(camera.perspectiveCamera){\n        camera.perspectiveCamera.quaternion.copy(camera.quaternion);\n        camera.perspectiveCamera.updateMatrixWorld(true);\n        camera.perspectiveCamera.updateMatrix();\n      }\n    }\n\n    // Mark file as having unsaved changes\n    this.updateFile();\n  }\n\n  onMouseMove(event: MouseEvent){\n    // Update ghost preview only when mouse moves\n    if(this.controlMode === TabModuleEditorControlMode.ADD_GAME_OBJECT){\n      this.updateGhostPreview();\n    }\n  }\n\n  updateGhostPreview(): void {\n    if(this.controlMode !== TabModuleEditorControlMode.ADD_GAME_OBJECT || !this.selectedGameObjectType){\n      if(this.ghostPreviewMesh){\n        this.ghostPreviewMesh.visible = false;\n      }\n      this.previewValid = false;\n      return;\n    }\n\n    if(!this.ui3DRenderer || !this.ui3DRenderer.canvas || !this.module?.area){\n      if(this.ghostPreviewMesh){\n        this.ghostPreviewMesh.visible = false;\n      }\n      this.previewValid = false;\n      return;\n    }\n\n    // Find intersection point using same logic as placement\n    const intersection = this.findPlacementIntersection();\n    if(intersection && intersection.point && this.ghostPreviewMesh){\n      this.previewPosition.copy(intersection.point);\n      this.ghostPreviewMesh.position.copy(this.previewPosition);\n      this.ghostPreviewMesh.visible = true;\n      this.previewValid = true;\n    } else {\n      if(this.ghostPreviewMesh){\n        this.ghostPreviewMesh.visible = false;\n      }\n      this.previewValid = false;\n    }\n  }\n\n  findPlacementIntersection(): THREE.Intersection | null {\n    if(!this.ui3DRenderer || !this.ui3DRenderer.canvas || !this.module?.area){\n      return null;\n    }\n\n    // Get mouse position in normalized device coordinates\n    // Reuse Vector2 to avoid allocation\n    this.mouseVector.x = ((KotOR.Mouse.MouseX) / this.ui3DRenderer.canvas.width) * 2 - 1;\n    this.mouseVector.y = -((KotOR.Mouse.MouseY) / this.ui3DRenderer.canvas.height) * 2 + 1;\n\n    // Perform raycast\n    this.ui3DRenderer.raycaster.setFromCamera(this.mouseVector, this.ui3DRenderer.camera);\n\n    // Try to intersect with walkmesh first, then ground plane\n    let intersection: THREE.Intersection | null = null;\n\n    // Use cached walkmesh objects from ForgeArea\n    const walkmeshObjects = this.module.area.getWalkmeshObjects();\n    if(walkmeshObjects.length > 0){\n      const walkmeshIntersects = this.ui3DRenderer.raycaster.intersectObjects(walkmeshObjects, true);\n      if(walkmeshIntersects.length > 0){\n        intersection = walkmeshIntersects[0];\n      }\n    }\n\n    // Fallback to ground plane if no walkmesh intersection\n    if(!intersection && this.groundMesh){\n      const planeIntersects = this.ui3DRenderer.raycaster.intersectObject(this.groundMesh);\n      if(planeIntersects.length > 0){\n        intersection = planeIntersects[0];\n      }\n    }\n\n    return intersection;\n  }\n\n  onMouseDown(event: MouseEvent){\n    if(event.button !== 0 || !this.ui3DRenderer.canvas){ // Left mouse button only\n      return;\n    }\n\n    // Handle placement when in ADD_GAME_OBJECT mode\n    if(this.controlMode === TabModuleEditorControlMode.ADD_GAME_OBJECT && this.selectedGameObjectType && this.module?.area){\n      const intersection = this.findPlacementIntersection();\n      if(intersection && intersection.point){\n        this.placeGameObject(intersection.point);\n      }\n      return;\n    }\n    // if(this.controlMode === TabModuleEditorControlMode.SELECT){\n    //   this.ui3DRenderer.selectObject(undefined);\n    // }\n  }\n\n  setControlMode(mode: TabModuleEditorControlMode){\n    log.trace('TabModuleEditorState setControlMode', mode);\n    this.controlMode = mode;\n\n    const isTransformTool =\n      mode === TabModuleEditorControlMode.TRANSFORM_CONTROL ||\n      mode === TabModuleEditorControlMode.ROTATE_CONTROL ||\n      mode === TabModuleEditorControlMode.SCALE_CONTROL;\n\n    const isSelectModeTool =\n      mode === TabModuleEditorControlMode.SELECT;\n\n    // Detach transform controls when not in SELECT mode\n    if(!isTransformTool && !isSelectModeTool){\n      this.selectedGameObject = undefined;\n      this.ui3DRenderer.transformControls.detach();\n    }\n\n    if(mode === TabModuleEditorControlMode.TRANSFORM_CONTROL){\n      this.ui3DRenderer.transformControls.mode = 'translate';\n      this.updateTransformControlHelpers(this.selectedGameObject!);\n    } else if(mode === TabModuleEditorControlMode.ROTATE_CONTROL){\n      this.ui3DRenderer.transformControls.mode = 'rotate';\n      this.updateTransformControlHelpers(this.selectedGameObject!);\n    } else if(mode === TabModuleEditorControlMode.SCALE_CONTROL){\n      this.ui3DRenderer.transformControls.mode = 'scale';\n      this.updateTransformControlHelpers(this.selectedGameObject!);\n    }\n\n    this.processEventListener('onControlModeChange', [mode]);\n  }\n\n  onSelect(gameObject: ForgeGameObject | THREE.Object3D | undefined){\n    log.trace('onSelect', gameObject);\n\n    // Check if a vertex helper was selected\n    if(gameObject instanceof THREE.Mesh && gameObject.userData?.vertexIndex !== undefined){\n      const forgeGameObject = gameObject.userData.forgeGameObject as ForgeTrigger | ForgeEncounter;\n      if(forgeGameObject && (forgeGameObject instanceof ForgeTrigger || forgeGameObject instanceof ForgeEncounter)){\n        const vertexIndex = gameObject.userData.vertexIndex as number;\n        forgeGameObject.selectVertex(vertexIndex);\n        // Attach transform controls to the selected vertex helper\n        this.ui3DRenderer.transformControls.detach();\n        this.ui3DRenderer.transformControls.attach(gameObject);\n        this.ui3DRenderer.transformControls.size = 0.25;\n        return;\n      }\n    }\n\n    // Otherwise, select the game object\n    if(gameObject instanceof ForgeGameObject){\n      this.selectGameObject(gameObject);\n    } else if(gameObject instanceof THREE.Object3D){\n      // Try to find ForgeGameObject from userData\n      let current: THREE.Object3D | null = gameObject;\n      while(current){\n        if(current.userData?.forgeGameObject instanceof ForgeGameObject){\n          this.selectGameObject(current.userData.forgeGameObject);\n          return;\n        }\n        current = current.parent;\n      }\n      this.selectGameObject(undefined);\n    } else {\n      this.selectGameObject(undefined);\n    }\n  }\n\n  onKeyDown(event: KeyboardEvent, tab: TabState){\n    // Handle Delete or Backspace key to remove selected object\n    if((event.key === 'Delete') && this.selectedGameObject && this.module?.area){\n      // Prevent default browser behavior (e.g., going back in history)\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Detach the selected object from the area\n      this.module.area.detachObject(this.selectedGameObject);\n\n      // Clear selection and detach transform controls\n      this.selectGameObject(undefined);\n    }\n  }\n\n  updateTransformControlHelpers(gameObject: ForgeGameObject){\n    if(!gameObject) return;\n    if(this.controlMode === TabModuleEditorControlMode.TRANSFORM_CONTROL){\n      this.ui3DRenderer.transformControls.showX = true;\n      this.ui3DRenderer.transformControls.showY = true;\n      this.ui3DRenderer.transformControls.showZ = true;\n    } else if(this.controlMode === TabModuleEditorControlMode.ROTATE_CONTROL){\n      if(gameObject instanceof ForgeCreature || gameObject instanceof ForgeDoor || gameObject instanceof ForgeEncounter || gameObject instanceof ForgeItem || gameObject instanceof ForgePlaceable || gameObject instanceof ForgeStore || gameObject instanceof ForgeTrigger || gameObject instanceof ForgeWaypoint){\n        this.ui3DRenderer.transformControls.showX = false;\n        this.ui3DRenderer.transformControls.showY = false;\n        this.ui3DRenderer.transformControls.showZ = true;\n      } else if(gameObject instanceof ForgeCamera){\n        this.ui3DRenderer.transformControls.showX = false;\n        this.ui3DRenderer.transformControls.showY = false;\n        this.ui3DRenderer.transformControls.showZ = true;\n      } else if(gameObject instanceof ForgeRoom){\n        this.ui3DRenderer.transformControls.showX = false;\n        this.ui3DRenderer.transformControls.showY = false;\n        this.ui3DRenderer.transformControls.showZ = true;\n      }\n    }else if(this.controlMode === TabModuleEditorControlMode.SCALE_CONTROL){\n      this.ui3DRenderer.transformControls.showX = true;\n      this.ui3DRenderer.transformControls.showY = true;\n      this.ui3DRenderer.transformControls.showZ = true;\n    }\n  }\n\n  selectGameObject(gameObject: ForgeGameObject | undefined){\n    log.trace('selectGameObject', gameObject);\n    this.selectedGameObject = gameObject;\n    this.ui3DRenderer.transformControls.detach();\n\n    // Hide vertex helpers for previously selected trigger/encounter\n    if(this.selectedGameObject instanceof ForgeTrigger || this.selectedGameObject instanceof ForgeEncounter){\n      const prevObject = this.selectedGameObject as ForgeTrigger | ForgeEncounter;\n      prevObject.showVertexHelpers(false);\n      prevObject.selectVertex(-1);\n    }\n\n    // Enable/disable camera preview\n    if(gameObject instanceof ForgeCamera){\n      const camera = gameObject as ForgeCamera;\n      // Ensure rotation order is set before attaching transform controls\n      camera.rotation.reorder('YZX');\n      // Sync quaternion from rotation to ensure consistency\n      camera.quaternion.setFromEuler(camera.rotation);\n      // Enable preview with the camera's perspective camera\n      if(camera.perspectiveCamera){\n        this.ui3DRenderer.setPreviewCamera(camera.perspectiveCamera);\n      }\n    } else {\n      // Disable preview when not selecting a camera\n      this.ui3DRenderer.disablePreview();\n    }\n\n    // Show vertex helpers for triggers and encounters\n    if(gameObject instanceof ForgeTrigger || gameObject instanceof ForgeEncounter){\n      gameObject.showVertexHelpers(true);\n    }\n\n    if(gameObject){\n      this.ui3DRenderer.transformControls.attach(gameObject.container);\n      this.ui3DRenderer.transformControls.size = 0.5;\n      this.updateTransformControlHelpers(gameObject);\n    }\n    this.processEventListener('onSelectionChanged', [gameObject]);\n  }\n\n  placeGameObject(position: THREE.Vector3){\n    if(!this.module?.area || !this.selectedGameObjectType){\n      return;\n    }\n\n    const typesThatUseBlueprints = [GameObjectType.CREATURE, GameObjectType.DOOR, GameObjectType.ENCOUNTER, GameObjectType.ITEM, GameObjectType.PLACEABLE, GameObjectType.STORE, GameObjectType.TRIGGER, GameObjectType.WAYPOINT];\n    const useBlueprintLoader = typesThatUseBlueprints.includes(this.selectedGameObjectType);\n\n    if(useBlueprintLoader && !this.selectedBlueprintResRef){\n      return;\n    }\n\n    const gameObject = this.createGameObject(this.selectedGameObjectType);\n    if(!gameObject){\n      log.error(`Failed to create game object of type: ${this.selectedGameObjectType}`);\n      return;\n    }\n\n    // Create async loaders array\n    const asyncLoaders: (() => Promise<void>)[] = [];\n\n    // Set template resref if one was selected\n    if(this.selectedGameObjectType === GameObjectType.ROOM && this.selectedBlueprintResRef){\n      (gameObject as ForgeRoom).roomName = this.selectedBlueprintResRef;\n    }else if(this.selectedBlueprintResRef){\n      const resType = this.getResourceTypeForGameObjectType(this.selectedGameObjectType);\n      gameObject.setTemplateResRef(this.selectedBlueprintResRef, resType);\n    }\n\n    // Add object loader to async loaders array\n    asyncLoaders.push(gameObject.load);\n\n    // Set position\n    gameObject.position.copy(position);\n\n    // Set area\n    this.module.area.attachObject(gameObject);\n\n    // Load all async loaders\n    (async () => {\n      if(useBlueprintLoader){\n        await gameObject.loadBlueprint();\n      }\n      await gameObject.load();\n    })();\n\n    // Notify listeners\n    this.processEventListener('onGameObjectPlaced', [gameObject, this.selectedGameObjectType]);\n    this.selectedBlueprintResRef = '';\n    this.selectedGameObjectType = undefined;\n    this.setControlMode(TabModuleEditorControlMode.TRANSFORM_CONTROL);\n    this.ghostPreviewMesh.visible = false;\n  }\n\n  openBlueprintBrowser(){\n    this.openBlueprintBrowserForType('utc');\n  }\n\n  cloneGameObject(gameObject: ForgeGameObject){\n    if(!gameObject || !this.module?.area){\n      return;\n    }\n    const gameObjectType = this.getGameObjectTypeFromGameObject(gameObject);\n    if(!gameObjectType){\n      return;\n    }\n    const resref = gameObject.templateResRef;\n    const resType = gameObject.templateResType;\n    this.setGameObjectControlOptions(gameObjectType, resref, resType);\n  }\n\n  openBlueprintBrowserForType(blueprintType: BlueprintType){\n    const modal = new ModalBlueprintBrowserState(blueprintType, (blueprint, type) => {\n      // Map blueprint type to GameObjectType\n      const gameObjectType = this.getGameObjectTypeFromBlueprintType(type);\n      if(gameObjectType){\n        this.setGameObjectControlOptions(gameObjectType, blueprint.resref, type);\n      }\n    });\n    modal.attachToModalManager(ForgeState.modalManager);\n    modal.open();\n  }\n\n  setGameObjectControlOptions(gameObjectType: GameObjectType, resref: string, _resType: typeof KotOR.ResourceTypes){\n    this.selectedGameObjectType = gameObjectType;\n    this.selectedBlueprintResRef = resref;\n    this.controlMode = TabModuleEditorControlMode.ADD_GAME_OBJECT;\n  }\n\n  getGameObjectTypeFromBlueprintType(blueprintType: BlueprintType): GameObjectType | undefined {\n    const mapping: Record<BlueprintType, GameObjectType> = {\n      'utc': GameObjectType.CREATURE,\n      'utd': GameObjectType.DOOR,\n      'ute': GameObjectType.ENCOUNTER,\n      'uti': GameObjectType.ITEM,\n      'utp': GameObjectType.PLACEABLE,\n      'utm': GameObjectType.STORE,\n      'uts': GameObjectType.SOUND,\n      'utt': GameObjectType.TRIGGER,\n      'utw': GameObjectType.WAYPOINT,\n    };\n    return mapping[blueprintType];\n  }\n\n  getGameObjectTypeFromGameObject(gameObject: ForgeGameObject): GameObjectType | undefined {\n    if(gameObject instanceof ForgeCreature) return GameObjectType.CREATURE;\n    if(gameObject instanceof ForgeDoor) return GameObjectType.DOOR;\n    if(gameObject instanceof ForgeEncounter) return GameObjectType.ENCOUNTER;\n    if(gameObject instanceof ForgeItem) return GameObjectType.ITEM;\n    if(gameObject instanceof ForgePlaceable) return GameObjectType.PLACEABLE;\n    if(gameObject instanceof ForgeStore) return GameObjectType.STORE;\n    if(gameObject instanceof ForgeTrigger) return GameObjectType.TRIGGER;\n    if(gameObject instanceof ForgeWaypoint) return GameObjectType.WAYPOINT;\n    if(gameObject instanceof ForgeCamera) return GameObjectType.CAMERA;\n    if(gameObject instanceof ForgeRoom) return GameObjectType.ROOM;\n    if(gameObject instanceof ForgeSound) return GameObjectType.SOUND;\n    return undefined;\n  }\n\n  getResourceTypeForGameObjectType(gameObjectType: GameObjectType): typeof KotOR.ResourceTypes {\n    const mapping: Record<GameObjectType, typeof KotOR.ResourceTypes> = {\n      [GameObjectType.ROOM]: KotOR.ResourceTypes.NA,\n      [GameObjectType.CREATURE]: KotOR.ResourceTypes.utc,\n      [GameObjectType.DOOR]: KotOR.ResourceTypes.utd,\n      [GameObjectType.ENCOUNTER]: KotOR.ResourceTypes.ute,\n      [GameObjectType.ITEM]: KotOR.ResourceTypes.uti,\n      [GameObjectType.PLACEABLE]: KotOR.ResourceTypes.utp,\n      [GameObjectType.STORE]: KotOR.ResourceTypes.utm,\n      [GameObjectType.SOUND]: KotOR.ResourceTypes.uts,\n      [GameObjectType.TRIGGER]: KotOR.ResourceTypes.utt,\n      [GameObjectType.WAYPOINT]: KotOR.ResourceTypes.utw,\n      [GameObjectType.CAMERA]: KotOR.ResourceTypes.NA, // Camera doesn't use blueprints\n    };\n    return mapping[gameObjectType] || KotOR.ResourceTypes.NA;\n  }\n\n  createGameObject(type: GameObjectType): ForgeGameObject | null {\n    switch(type){\n      case GameObjectType.CREATURE:\n        return new ForgeCreature();\n      case GameObjectType.CAMERA:\n        return new ForgeCamera();\n      case GameObjectType.DOOR:\n        return new ForgeDoor();\n      case GameObjectType.ENCOUNTER:\n        return new ForgeEncounter();\n      case GameObjectType.ITEM:\n        return new ForgeItem();\n      case GameObjectType.PLACEABLE:\n        return new ForgePlaceable();\n      case GameObjectType.SOUND:\n        return new ForgeSound();\n      case GameObjectType.STORE:\n        return new ForgeStore();\n      case GameObjectType.TRIGGER:\n        return new ForgeTrigger();\n      case GameObjectType.WAYPOINT:\n        return new ForgeWaypoint();\n      default:\n        log.error(`Unknown game object type: ${type}`);\n        return null;\n    }\n  }\n\n  //This should only be used inside KotOR Forge\n  static async FromProject(project: Project): Promise<ForgeModule | undefined> {\n    log.trace('BuildFromExisting', project);\n    if(!project){\n      return undefined;\n    }\n    const module = new ForgeModule(new KotOR.GFFObject());\n    module.transWP = '';\n    // KotOR.ModuleObjectManager.module = module;\n\n    /**\n     * Load the IFO file\n     */\n    const ifoFile = await project.module_ifo?.readFile();\n    if(!ifoFile){\n      log.error('IFO file not found');\n      return undefined;\n    }\n    const ifo = new KotOR.GFFObject(ifoFile.buffer);\n    module.setFromIFO(ifo);\n    KotOR.GameState.time = module.timeManager.pauseTime / 1000;\n\n    /**\n     * Load the ARE file\n     */\n    const areFile = await project.module_are?.readFile();\n    if(!areFile){\n      log.error('ARE file not found');\n      return undefined;\n    }\n    const are = new KotOR.GFFObject(areFile.buffer);\n\n    /**\n     * Load the GIT file\n     */\n    const gitFile = await project.module_git?.readFile();\n    if(!gitFile){\n      log.error('GIT file not found');\n      return undefined;\n    }\n    const git = new KotOR.GFFObject(gitFile.buffer);\n\n    /**\n     * Create the area\n     */\n    module.area = new ForgeArea(git, are);\n    module.area.module = module;\n    module.areas = [module.area];\n    return module;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabPTHEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":60,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":60,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":76,"column":84,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":76,"endColumn":108},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListener<{}, \"change\", TransformControls>`.","line":81,"column":70,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":81,"endColumn":111},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListener<{}, \"change\", TransformControls>`.","line":86,"column":74,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":86,"endColumn":115},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":227,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":227,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":229,"column":28,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":229,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":256,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":256,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Computed name [pointIndex] resolves to an `any` value.","line":258,"column":40,"nodeType":"Identifier","messageId":"unsafeComputedMemberAccess","endLine":258,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":263,"column":26,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":263,"endColumn":36}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\nimport type { Intersection } from 'three';\n\nimport { TabPTHEditor } from \"@/apps/forge/components/tabs/tab-pth-editor/TabPTHEditor\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { CameraFocusMode, GroupType, UI3DRenderer, UI3DRendererEventListenerTypes } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\nconst POINT_OFFSET_HEIGHT = 1;\n\n/** Intersection with optional face that may have walkCheck (walkmesh). */\ninterface IntersectionWithWalkFace extends Intersection {\n  face?: (THREE.Face & { walkCheck?: boolean }) | null;\n}\n\nexport enum TabPTHEditorControlMode {\n  SELECT = 0,\n  ADD_POINT = 1,\n  ADD_CONNECTION = 2,\n}\n\nexport class TabPTHEditorState extends TabState {\n  tabName: string = `PTH`;\n  blueprint: KotOR.GFFObject;\n\n  points: KotOR.PathPoint[] = [];\n  ui3DRenderer: UI3DRenderer;\n  pathHelperGroup: THREE.Group;\n  pointMeshes: THREE.Mesh[] = [];\n  connectionLines: THREE.LineSegments | undefined;\n  layout: KotOR.LYTObject;\n  layoutModels: KotOR.OdysseyModel3D[] = [];\n  walkmeshes: KotOR.OdysseyWalkMesh[] = [];\n\n  controlMode: TabPTHEditorControlMode = TabPTHEditorControlMode.SELECT;\n  selectedPointIndex: number = -1;\n\n  box3: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3();\n\n  selectedPointA: KotOR.PathPoint | undefined;\n  selectedPointB: KotOR.PathPoint | undefined;\n\n  // Ghost preview for point placement\n  ghostPreviewMesh: THREE.Mesh;\n  previewPosition: THREE.Vector3 = new THREE.Vector3();\n  previewValid: boolean = false;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabPTHEditorState constructor entry');\n    super(options);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.setCameraFocusMode(CameraFocusMode.SELECTABLE);\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n\n    // Create a group to hold all path visualization elements\n    this.pathHelperGroup = new THREE.Group();\n    this.ui3DRenderer.scene.add(this.pathHelperGroup);\n\n    this.setContentView(<TabPTHEditor tab={this}></TabPTHEditor>);\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'Odyssey Pathfinding Blueprint',\n        accept: {\n          'application/octet-stream': ['.pth']\n        }\n      }\n    ];\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onSelect', this.onSelect.bind(this));\n\n    // Listen to transform controls changes to update point positions\n    // Add listener immediately if transform controls exist, otherwise wait for canvas attachment\n    if(this.ui3DRenderer.transformControls){\n      this.ui3DRenderer.transformControls.addEventListener('change', this.onTransformControlsChange.bind(this));\n    } else {\n      // Wait for canvas to be attached so transform controls are built\n      this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onCanvasAttached', () => {\n        if(this.ui3DRenderer.transformControls){\n          this.ui3DRenderer.transformControls.addEventListener('change', this.onTransformControlsChange.bind(this));\n        }\n      });\n    }\n\n    // Create ghost preview mesh\n    const ghostGeometry = new THREE.SphereGeometry(0.5, 16, 16);\n    const ghostMaterial = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      wireframe: false,\n      transparent: true,\n      opacity: 0.5\n    });\n    this.ghostPreviewMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);\n    this.ghostPreviewMesh.visible = false;\n    this.pathHelperGroup.add(this.ghostPreviewMesh);\n\n    this.addEventListener('onKeyUp', (e: KeyboardEvent) => {\n      if(e.key === 'Escape'){\n        this.setControlMode(TabPTHEditorControlMode.SELECT);\n        this.selectPoint(-1);\n        this.ui3DRenderer.selectObject(undefined);\n      } else if(e.key === 'Delete'){\n        this.deleteSelectedPoint();\n      }\n    });\n    log.trace('TabPTHEditorState constructor exit');\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabPTHEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, _reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) {\n          // Dispose of previous layout when switching files\n          this.disposeLayout();\n          this.file = file;\n        }\n        this.file.isBlueprint = true;\n        this.tabName = this.file.getFilename();\n\n        file.readFile().then( async (response) => {\n          this.blueprint = new KotOR.GFFObject(response.buffer);\n          this.setPropsFromBlueprint();\n\n          await this.loadLayoutFile();\n\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabPTHEditorState openFile loaded');\n          resolve(this.blueprint);\n        });\n      } else {\n        log.trace('TabPTHEditorState openFile no file');\n      }\n    });\n  }\n\n  public setControlMode(mode: TabPTHEditorControlMode = TabPTHEditorControlMode.SELECT): void {\n    log.trace('TabPTHEditorState setControlMode', mode);\n    this.controlMode = mode;\n\n    this.ui3DRenderer.disableSelection = mode !== TabPTHEditorControlMode.SELECT;\n    if(this.ui3DRenderer.disableSelection){\n      this.ui3DRenderer.selectObject(undefined);\n    }\n    // Show/hide ghost preview based on mode\n    if(mode === TabPTHEditorControlMode.ADD_POINT){\n      this.ghostPreviewMesh.visible = this.previewValid;\n    } else {\n      this.ghostPreviewMesh.visible = false;\n    }\n\n    // Clear selection when switching modes\n    if(mode !== TabPTHEditorControlMode.ADD_CONNECTION){\n      this.selectedPointA = undefined;\n      this.selectedPointB = undefined;\n    }\n\n    // Detach transform controls when not in SELECT mode\n    if(mode !== TabPTHEditorControlMode.SELECT){\n      this.ui3DRenderer.transformControls.detach();\n      this.selectedPointIndex = -1;\n    }\n\n    this.processEventListener('onControlModeChange', [mode]);\n  }\n\n  public setPropsFromBlueprint(): void {\n\n    /**\n     * Parse the Path Points\n     */\n    if(this.blueprint.RootNode.hasField('Path_Points')){\n      const pathPoints = this.blueprint.getFieldByLabel('Path_Points').getChildStructs();\n      for(let i = 0, len = pathPoints.length; i < len; i++){\n        this.points[i] = KotOR.PathPoint.FromGFFStruct(pathPoints[i]);\n        this.points[i].id = i;\n      }\n    }\n\n    /**\n     * Parse the Path Connections\n     */\n    if(this.blueprint.RootNode.hasField('Path_Conections')){\n      const pathConnections = this.blueprint.getFieldByLabel('Path_Conections').getChildStructs();\n      for(let i = 0, len = this.points.length; i < len; i++){\n        const point = this.points[i];\n        if(!point.num_connections) continue;\n\n        const connIdx = point.first_connection;\n        for(let j = 0; j < point.num_connections; j++){\n          const destVal = pathConnections[connIdx + j].getFieldByLabel('Destination').getValue();\n          const pointIdx = typeof destVal === 'number' ? destVal : -1;\n          if (pointIdx >= 0 && pointIdx < this.points.length) {\n            point.addConnection(this.points[pointIdx]);\n          }\n        }\n      }\n    }\n\n    // Update visualization after parsing\n    this.updatePathVisualization();\n  }\n\n  private updateCameraFocus(): void {\n    this.box3 = new THREE.Box3();\n    for(let i = 0; i < this.points.length; i++){\n      this.box3.expandByPoint(this.points[i].vector);\n    }\n    this.box3.getCenter(this.center);\n    this.ui3DRenderer.orbitControls.target.copy(this.center);\n  }\n\n  private onSelect(intersect: THREE.Intersection): void {\n    if(this.controlMode === TabPTHEditorControlMode.SELECT){\n      // SELECT mode: select points for transform controls\n      if(intersect && intersect.object){\n        const pointIndex = (intersect.object as THREE.Mesh).userData.pointIndex;\n        if(pointIndex !== undefined){\n          this.selectPoint(pointIndex);\n          return;\n        }\n      }\n      this.selectPoint(-1);\n    } else if(this.controlMode === TabPTHEditorControlMode.ADD_POINT){\n      // POINT mode: add new point on walkable face\n      this.handlePointPlacement(intersect);\n    } else if(this.controlMode === TabPTHEditorControlMode.ADD_CONNECTION){\n      // CONNECTION mode: connect points\n      this.handleConnection(intersect);\n    }\n  }\n\n  private handlePointPlacement(_intersect: THREE.Intersection | undefined): void {\n    // Find walkable face intersection at current mouse position\n    const walkableIntersect = this.findWalkableFaceIntersection();\n    if(walkableIntersect && walkableIntersect.point){\n      this.addPathPoint(walkableIntersect.point);\n    }\n  }\n\n  private handleConnection(intersect: THREE.Intersection | undefined): void {\n    if(!intersect || !intersect.object){\n      return;\n    }\n\n    const pointIndex = (intersect.object as THREE.Mesh).userData.pointIndex;\n    if(pointIndex !== undefined && pointIndex >= 0 && pointIndex < this.points.length){\n      const clickedPoint = this.points[pointIndex];\n\n      if(!this.selectedPointA){\n        // First point selected\n        this.selectedPointA = clickedPoint;\n        this.selectPoint(pointIndex);\n      } else if(this.selectedPointA !== clickedPoint){\n        // Second point selected - create connection\n        this.selectedPointB = clickedPoint;\n        this.connectPoints(this.selectedPointA, this.selectedPointB);\n        this.selectedPointA = undefined;\n        this.selectedPointB = undefined;\n        this.selectPoint(-1);\n      } else {\n        // Clicked same point - deselect\n        this.selectedPointA = undefined;\n        this.selectPoint(-1);\n      }\n    } else {\n      // Clicked empty space - deselect\n      this.selectedPointA = undefined;\n      this.selectPoint(-1);\n    }\n  }\n\n  private findWalkableFaceIntersection(): THREE.Intersection | null {\n    if(!this.ui3DRenderer.canvas) return null;\n\n    this.ui3DRenderer.raycaster.setFromCamera(KotOR.Mouse.Vector, this.ui3DRenderer.camera);\n\n    let closestIntersection: THREE.Intersection | null = null;\n    let closestDistance = Infinity;\n\n    // Raycast against all walkmeshes\n    for(let i = 0; i < this.layoutModels.length; i++){\n      const model = this.layoutModels[i];\n\n      if(model.wok && model.wok.mesh){\n        // model.updateMatrixWorld(true);\n\n        // Get walkable faces\n        const tempBox = new THREE.Box3();\n        const rayOrigin = this.ui3DRenderer.raycaster.ray.origin.clone();\n        tempBox.setFromCenterAndSize(rayOrigin, new THREE.Vector3(100, 100, 2000));\n        let faces = model.wok.getAABBCollisionFaces(tempBox);\n\n        if(!faces || faces.length === 0){\n          faces = model.wok.walkableFaces;\n        }\n\n        const intersects = model.wok.raycast(this.ui3DRenderer.raycaster, model.wok.walkableFaces);\n\n        if(intersects && intersects.length > 0){\n          for(let j = 0; j < intersects.length; j++){\n            const intersect = intersects[j];\n            // Only consider walkable faces (materialIndex 7 or 2)\n            const face = (intersect as IntersectionWithWalkFace).face;\n            if(face && face.walkCheck){\n              if(intersect.distance < closestDistance){\n                closestDistance = intersect.distance;\n                closestIntersection = intersect;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return closestIntersection;\n  }\n\n  private updateGhostPreview(): void {\n    if(this.controlMode !== TabPTHEditorControlMode.ADD_POINT){\n      this.ghostPreviewMesh.visible = false;\n      return;\n    }\n\n    if(!this.ui3DRenderer.canvas) return;\n\n    const walkableIntersect = this.findWalkableFaceIntersection();\n    if(walkableIntersect && walkableIntersect.point){\n      this.previewPosition.copy(walkableIntersect.point);\n      this.previewPosition.z += POINT_OFFSET_HEIGHT; // Offset above surface\n      this.ghostPreviewMesh.position.copy(this.previewPosition);\n      this.ghostPreviewMesh.visible = true;\n      this.previewValid = true;\n    } else {\n      this.ghostPreviewMesh.visible = false;\n      this.previewValid = false;\n    }\n  }\n\n  private addPathPoint(position: THREE.Vector3): void {\n    const newPoint = new KotOR.PathPoint({\n      id: this.points.length,\n      connections: [],\n      first_connection: 0,\n      num_connections: 0,\n      vector: position.clone()\n    });\n    newPoint.vector.z += POINT_OFFSET_HEIGHT; // Offset above surface\n\n    this.points.push(newPoint);\n    this.updatePathVisualization();\n\n    // Mark file as having unsaved changes\n    if(this.file){\n      this.file.unsaved_changes = true;\n      this.editorFileUpdated();\n    }\n  }\n\n  private connectPoints(pointA: KotOR.PathPoint, pointB: KotOR.PathPoint): void {\n    if(!pointA || !pointB || pointA === pointB) return;\n\n    pointA.addConnection(pointB);\n    this.updatePathVisualization();\n\n    // Mark file as having unsaved changes\n    // if(this.file){\n    //   this.file.unsaved_changes = true;\n    //   this.editorFileUpdated();\n    // }\n  }\n\n  private deleteSelectedPoint(): void {\n    // Only delete in SELECT mode\n    if(this.controlMode !== TabPTHEditorControlMode.SELECT) return;\n\n    const pointToDelete = this.points[this.selectedPointIndex];\n    if(!pointToDelete) return;\n\n    log.debug('selectedPointIndex', this.selectedPointIndex);\n    log.debug('pointToDelete', pointToDelete);\n\n    const connections = pointToDelete.connections.slice();\n    for(let i = 0; i < connections.length; i++){\n      const connection = connections[i];\n      pointToDelete.removeConnection(connection);\n    }\n\n    log.debug('connections', connections, pointToDelete.connections.slice());\n\n    // Remove the point from the array\n    this.points.splice(this.selectedPointIndex, 1);\n\n    // Update IDs for remaining points\n    for(let i = 0; i < this.points.length; i++){\n      this.points[i].id = i;\n    }\n\n    // Clear selection\n    this.selectPoint(-1);\n\n    // Update visualization\n    this.updatePathVisualization();\n\n    // Mark file as having unsaved changes\n    // if(this.file){\n    //   this.file.unsaved_changes = true;\n    //   this.editorFileUpdated();\n    // }\n  }\n  private selectPoint(pointIndex: number = -1): void {\n    this.ui3DRenderer.transformControls.detach();\n    this.selectedPointIndex = pointIndex;\n    const point = this.points[pointIndex];\n    if(point){\n      const mesh = this.pointMeshes[pointIndex] as THREE.Mesh;\n      if(mesh){\n        this.ui3DRenderer.transformControls.attach(mesh);\n        this.ui3DRenderer.transformControls.size = 0.5;\n        this.ui3DRenderer.transformControls.showZ = false;\n      }\n    }\n    // this.updatePathVisualization();\n  }\n\n  private onTransformControlsChange(): void {\n    if(this.selectedPointIndex < 0 || this.selectedPointIndex >= this.points.length) return;\n\n    const mesh = this.pointMeshes[this.selectedPointIndex] as THREE.Mesh;\n    if(!mesh) return;\n\n    const point = this.points[this.selectedPointIndex];\n    if(!point) return;\n\n    // Update point vector from mesh position\n    point.vector.copy(mesh.position);\n\n    // Update connection lines\n    this.updateConnectionLines();\n\n    // Mark file as having unsaved changes\n    if(this.file){\n      this.file.unsaved_changes = true;\n      this.editorFileUpdated();\n    }\n  }\n\n  private updateConnectionLines(): void {\n    if(!this.connectionLines) return;\n\n    const positions: number[] = [];\n    const colors: number[] = [];\n\n    for(let i = 0; i < this.points.length; i++){\n      const point = this.points[i];\n      for(let j = 0; j < point.connections.length; j++){\n        const connectedPoint = point.connections[j];\n\n        // Add line from current point to connected point\n        positions.push(\n          point.vector.x, point.vector.y, point.vector.z || 0,\n          connectedPoint.vector.x, connectedPoint.vector.y, connectedPoint.vector.z || 0\n        );\n\n        // Add colors (cyan for connections)\n        colors.push(\n          0, 1, 1, // cyan\n          0, 1, 1  // cyan\n        );\n      }\n    }\n\n    if(positions.length > 0){\n      const positionArray = new Float32Array(positions);\n      const colorArray = new Float32Array(colors);\n\n      const positionAttribute = this.connectionLines.geometry.getAttribute('position') as THREE.BufferAttribute;\n      if(positionAttribute && positionAttribute.array.length === positionArray.length){\n        // Update existing attribute\n        (positionAttribute.array as Float32Array).set(positionArray);\n        positionAttribute.needsUpdate = true;\n      } else {\n        // Recreate attribute if size changed\n        this.connectionLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionArray, 3));\n      }\n\n      const colorAttribute = this.connectionLines.geometry.getAttribute('color') as THREE.BufferAttribute;\n      if(colorAttribute && colorAttribute.array.length === colorArray.length){\n        // Update existing attribute\n        (colorAttribute.array as Float32Array).set(colorArray);\n        colorAttribute.needsUpdate = true;\n      } else {\n        // Recreate attribute if size changed\n        this.connectionLines.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));\n      }\n    }\n  }\n\n  private updatePathVisualization(): void {\n    // Clear existing meshes\n    this.pointMeshes.forEach(mesh => {\n      this.ui3DRenderer.selectable.remove(mesh);\n      mesh.geometry.dispose();\n      (mesh.material as THREE.Material).dispose();\n    });\n    this.pointMeshes = [];\n\n    // Remove existing connection lines\n    if(this.connectionLines){\n      this.pathHelperGroup.remove(this.connectionLines);\n      this.connectionLines.geometry.dispose();\n      (this.connectionLines.material as THREE.Material).dispose();\n      this.connectionLines = undefined;\n    }\n\n    if(this.points.length === 0) return;\n\n    // Create shared material for points (geometry will be created per mesh)\n    const pointMaterial = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      wireframe: false\n    });\n\n    // Create visual indicators for each point\n    for(let i = 0; i < this.points.length; i++){\n      const point = this.points[i];\n      const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);\n      const sphere = new THREE.Mesh(sphereGeometry, pointMaterial);\n      sphere.position.set(point.vector.x, point.vector.y, point.vector.z || 0);\n      sphere.userData.pointIndex = i;\n      this.ui3DRenderer.selectable.add(sphere);\n      this.pointMeshes.push(sphere);\n    }\n\n    // Create lines for connections\n    const connectionGeometry = new THREE.BufferGeometry();\n    const positions: number[] = [];\n    const colors: number[] = [];\n\n    for(let i = 0; i < this.points.length; i++){\n      const point = this.points[i];\n      for(let j = 0; j < point.connections.length; j++){\n        const connectedPoint = point.connections[j];\n\n        // Add line from current point to connected point\n        positions.push(\n          point.vector.x, point.vector.y, point.vector.z || 0,\n          connectedPoint.vector.x, connectedPoint.vector.y, connectedPoint.vector.z || 0\n        );\n\n        // Add colors (cyan for connections)\n        colors.push(\n          0, 1, 1, // cyan\n          0, 1, 1  // cyan\n        );\n      }\n    }\n\n    if(positions.length > 0){\n      connectionGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n      connectionGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n\n      const connectionMaterial = new THREE.LineBasicMaterial({\n        vertexColors: true,\n        linewidth: 2\n      });\n\n      this.connectionLines = new THREE.LineSegments(connectionGeometry, connectionMaterial);\n      this.pathHelperGroup.add(this.connectionLines);\n    }\n  }\n\n  private async loadLayoutFile(): Promise<void> {\n    if(!this.file) return;\n\n    try {\n      // Get the resref (filename without extension) from the PTH file\n      const pthResref = this.file.resref;\n      if (typeof pthResref !== 'string' || !pthResref) return;\n\n      // Use ResourceLoader to load the LYT file with the same name\n      const lytBuffer = await KotOR.ResourceLoader.loadResource(KotOR.ResourceTypes.lyt, pthResref);\n\n      if(lytBuffer && lytBuffer.length > 0){\n        // Parse the LYT file\n        this.layout = new KotOR.LYTObject(lytBuffer);\n\n        // Load room models\n        await this.loadLayoutRooms();\n      }\n    } catch (error) {\n      // LYT file doesn't exist or couldn't be loaded - that's okay\n      log.debug('Could not load LYT file:', error);\n    }\n  }\n\n  private async loadLayoutRooms(): Promise<void> {\n    // Clear existing layout models\n    this.disposeLayout();\n\n    if(!this.layout || !this.layout.rooms || this.layout.rooms.length === 0) return;\n\n    // Load each room model\n    for(let i = 0; i < this.layout.rooms.length; i++){\n      const room = this.layout.rooms[i];\n      try {\n        const mdl = await KotOR.MDLLoader.loader.load(room.name);\n        if(mdl){\n          const model = await KotOR.OdysseyModel3D.FromMDL(mdl, {\n            context: this.ui3DRenderer,\n            manageLighting: true,\n            mergeStatic: true,\n          });\n          if(model){\n            model.position.copy(room.position);\n\n            // Load walkmesh for the room\n            try {\n              const wokBuffer = await KotOR.ResourceLoader.loadResource(KotOR.ResourceTypes.wok, room.name);\n              if(wokBuffer && wokBuffer.length > 0){\n                const wok = new KotOR.OdysseyWalkMesh(new KotOR.BinaryReader(wokBuffer));\n                model.wok = wok;\n                this.ui3DRenderer.unselectable.add(wok.mesh);\n                this.walkmeshes.push(wok);\n              }\n            } catch {\n              // Walkmesh might not exist for this room - that's okay\n              log.debug('No walkmesh found for room:', room.name);\n            }\n\n            this.ui3DRenderer.addObjectToGroup(model, GroupType.ROOMS);\n            this.layoutModels.push(model);\n          }\n        }\n      } catch (error) {\n        log.warn('Could not load room model:', room.name, error);\n      }\n    }\n\n    // Load textures\n    await KotOR.TextureLoader.LoadQueue();\n\n    // Update point Z positions based on walkmesh raycasting\n    await this.updatePointsFromWalkmesh();\n  }\n\n  private async updatePointsFromWalkmesh(): Promise<void> {\n    if(this.points.length === 0 || this.layoutModels.length === 0) return;\n\n    const raycaster = new THREE.Raycaster();\n    const rayDirection = new THREE.Vector3(0, 0, -1); // Point downward\n    const rayOrigin = new THREE.Vector3();\n    const tempBox = new THREE.Box3();\n\n    // Loop through all points\n    for(let i = 0; i < this.points.length; i++){\n      const point = this.points[i];\n      let closestIntersection: THREE.Intersection | null = null;\n      let closestDistance = Infinity;\n\n      // Set ray origin to point position, high above to ensure we start above any geometry\n      rayOrigin.set(point.vector.x, point.vector.y, (point.vector.z || 0) + 1000);\n\n      raycaster.ray.origin.copy(rayOrigin);\n      raycaster.ray.direction.copy(rayDirection);\n      raycaster.far = 2000; // Large enough to reach the ground\n\n      // Raycast against all room model walkmeshes\n      for(let j = 0; j < this.layoutModels.length; j++){\n        const model = this.layoutModels[j];\n\n        // Check if model has a walkmesh\n        if(model.wok && model.wok.mesh){\n          // Update model's world matrix to ensure walkmesh is in correct position\n          model.updateMatrixWorld(true);\n\n          // Create a small bounding box around the ray origin to get relevant faces\n          tempBox.setFromCenterAndSize(rayOrigin, new THREE.Vector3(20, 20, 2000));\n          let faces = model.wok.getAABBCollisionFaces(tempBox);\n\n          // If AABB doesn't return faces, try using all walkable faces\n          if(!faces || faces.length === 0){\n            faces = model.wok.walkableFaces;\n          }\n\n          // Raycast against the walkmesh\n          const intersects = model.wok.raycast(raycaster, faces);\n\n          // Find the closest intersection\n          if(intersects && intersects.length > 0){\n            for(let k = 0; k < intersects.length; k++){\n              const intersect = intersects[k];\n              // Only consider intersections that are below the ray origin\n              if(intersect.point && intersect.point.z < rayOrigin.z && intersect.distance < closestDistance){\n                closestDistance = intersect.distance;\n                closestIntersection = intersect;\n              }\n            }\n          }\n        }\n      }\n\n      // Update point Z position if we found an intersection\n      if(closestIntersection && closestIntersection.point){\n        point.vector.z = closestIntersection.point.z + POINT_OFFSET_HEIGHT;\n      }\n    }\n\n    // Update visualization to reflect new Z positions\n    this.updatePathVisualization();\n  }\n\n  private disposeLayout(): void {\n    // Remove and dispose of all layout models\n    this.layoutModels.forEach(model => {\n      this.ui3DRenderer.removeObjectFromGroup(model, GroupType.ROOMS);\n      try {\n        model.dispose();\n      } catch (e) {\n        log.warn('Error disposing layout model:', e);\n      }\n    });\n    this.layoutModels = [];\n  }\n\n  public destroy(): void {\n    // Dispose ghost preview\n    if(this.ghostPreviewMesh){\n      this.pathHelperGroup.remove(this.ghostPreviewMesh);\n      this.ghostPreviewMesh.geometry.dispose();\n      (this.ghostPreviewMesh.material as THREE.Material).dispose();\n    }\n\n    super.destroy();\n  }\n\n  animate(_delta: number = 0){\n    // Update ghost preview when in POINT mode\n    if(this.controlMode === TabPTHEditorControlMode.ADD_POINT){\n      this.updateGhostPreview();\n    }\n  }\n\n  public show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.ui3DRenderer.render();\n  }\n\n  public hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(!!resref && ext == 'pth'){\n      this.updateFile();\n      return this.blueprint.getExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  updateFile(){\n    const pth = new KotOR.GFFObject();\n    pth.FileType = 'PTH ';\n    pth.RootNode.type = -1;\n\n    const root = pth.RootNode;\n    if(!root) return;\n\n    const pathConnectionsField = root.addField( new KotOR.GFFField(KotOR.GFFDataType.LIST, 'Path_Conections') );\n    const pathPointsField = root.addField( new KotOR.GFFField(KotOR.GFFDataType.LIST, 'Path_Points') );\n    let connIdx = 0;\n    for(let i = 0, len = this.points.length; i < len; i++){\n      const point = this.points[i];\n      const pathPointStruct = new KotOR.GFFStruct(2);\n      pathPointStruct.addField( new KotOR.GFFField(KotOR.GFFDataType.DWORD, 'First_Conection', connIdx ) );\n      pathPointStruct.addField( new KotOR.GFFField(KotOR.GFFDataType.DWORD, 'Conections', point.connections.length ) );\n      pathPointStruct.addField( new KotOR.GFFField(KotOR.GFFDataType.FLOAT, 'X', point.vector.x ) );\n      pathPointStruct.addField( new KotOR.GFFField(KotOR.GFFDataType.FLOAT, 'Y', point.vector.y ) );\n      pathPointsField?.addChildStruct(pathPointStruct);\n\n      for(let j = 0; j < point.connections.length; j++){\n        const pathConnectionStruct = new KotOR.GFFStruct(3);\n        const destinationPoint = point.connections[j];\n        const destinationIndex = this.points.indexOf(destinationPoint);\n        pathConnectionStruct.addField( new KotOR.GFFField(KotOR.GFFDataType.DWORD, 'Destination', destinationIndex ) );\n        pathConnectionsField?.addChildStruct(pathConnectionStruct);\n        connIdx++;\n      }\n    }\n\n    this.blueprint = pth;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabTLKEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":117,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":117,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe construction of a type that could not be resolved.","line":117,"column":19,"nodeType":"NewExpression","messageId":"errorNew","endLine":117,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `TLKString`.","line":118,"column":30,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":118,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":130,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":130,"endColumn":119},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":130,"column":50,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":130,"endColumn":119},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":131,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":131,"endColumn":97},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":131,"column":39,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":131,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":132,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":132,"endColumn":69},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":132,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":132,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":133,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":133,"endColumn":105},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":133,"column":58,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":133,"endColumn":105},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":135,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":146,"endColumn":7},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe construction of an `any` typed value.","line":135,"column":19,"nodeType":"NewExpression","messageId":"unsafeNew","endLine":146,"endColumn":7},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":137,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":137,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":137,"column":27,"nodeType":"Identifier","messageId":"unsafeCall","endLine":137,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":138,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":138,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":138,"column":31,"nodeType":"Identifier","messageId":"unsafeCall","endLine":138,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":139,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":142,"endColumn":11},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe construction of an `any` typed value.","line":139,"column":30,"nodeType":"NewExpression","messageId":"unsafeNew","endLine":142,"endColumn":11},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":140,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":140,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":143,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":143,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attachToModalManager on an `any` value.","line":143,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":143,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .modalManager on an `any` value.","line":143,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":143,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":144,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":144,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .open on an `any` value.","line":144,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":144,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":147,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":147,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attachToModalManager on an `any` value.","line":147,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .modalManager on an `any` value.","line":147,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":148,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":148,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .open on an `any` value.","line":148,"column":11,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":148,"endColumn":15}],"suppressedMessages":[],"errorCount":30,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\n\nimport { TabTLKEditor } from \"@/apps/forge/components/tabs/tab-tlk-editor/TabTLKEditor\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport class TabTLKEditorState extends TabState {\n  tabName: string = 'TLK Editor';\n  tlk?: KotOR.TLKObject;\n  selectedStringIndex: number = -1;\n  searchQuery: string = '';\n  filterQuery: string = '';\n  searchBoxVisible: boolean = false;\n  jumpBoxVisible: boolean = false;\n  jumpValue: number = 0;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabTLKEditorState constructor entry');\n    super(options);\n\n    if(this.file){\n      this.tabName = this.file.getFilename();\n      log.debug('TabTLKEditorState constructor tabName', this.tabName);\n    }\n\n    this.saveTypes = [\n      {\n        description: 'Talk Table File',\n        accept: {\n          'application/octet-stream': ['.tlk']\n        }\n      }\n    ];\n\n    this.setContentView(<TabTLKEditor tab={this}></TabTLKEditor>);\n    this.openFile();\n    log.trace('TabTLKEditorState constructor exit');\n  }\n\n  async openFile() {\n    log.trace('TabTLKEditorState openFile entry');\n    if(!this.file) {\n      log.trace('TabTLKEditorState openFile no file');\n      return;\n    }\n    const response = await this.file.readFile();\n    log.debug('TabTLKEditorState openFile readFile done', response.buffer?.length ?? 0);\n    await new Promise<void>((resolve, reject) => {\n      this.tlk = new KotOR.TLKObject(response.buffer, () => resolve(), undefined);\n    });\n    this.selectedStringIndex = -1;\n    this.searchQuery = '';\n    this.filterQuery = '';\n    this.searchBoxVisible = false;\n    this.jumpBoxVisible = false;\n    this.jumpValue = 0;\n    this.processEventListener('onEditorFileLoad', [this]);\n    this.processEventListener('onSearchQueryChanged', [this.searchQuery]);\n    this.processEventListener('onFilterChanged', [this.filterQuery]);\n    this.processEventListener('onSearchBoxToggled', [this.searchBoxVisible]);\n    this.processEventListener('onJumpBoxToggled', [this.jumpBoxVisible]);\n    this.processEventListener('onJumpValueChanged', [this.jumpValue]);\n    log.trace('TabTLKEditorState openFile exit');\n  }\n\n  selectString(index: number) {\n    log.trace('TabTLKEditorState selectString', index);\n    this.selectedStringIndex = index;\n    this.processEventListener('onStringSelected', [index]);\n  }\n\n  setSearchQuery(query: string) {\n    log.trace('TabTLKEditorState setSearchQuery');\n    this.searchQuery = query;\n    this.processEventListener('onSearchQueryChanged', [query]);\n  }\n\n  applySearchFilter(query?: string) {\n    log.trace('TabTLKEditorState applySearchFilter');\n    this.filterQuery = typeof query === 'string' ? query : this.searchQuery;\n    this.processEventListener('onFilterChanged', [this.filterQuery]);\n  }\n\n  clearSearchFilter() {\n    log.trace('TabTLKEditorState clearSearchFilter');\n    this.filterQuery = '';\n    this.processEventListener('onFilterChanged', [this.filterQuery]);\n  }\n\n  toggleSearchBox(force?: boolean) {\n    log.trace('TabTLKEditorState toggleSearchBox', force);\n    const next = typeof force === 'boolean' ? force : !this.searchBoxVisible;\n    this.searchBoxVisible = next;\n    this.processEventListener('onSearchBoxToggled', [next]);\n  }\n\n  toggleJumpBox(force?: boolean) {\n    log.trace('TabTLKEditorState toggleJumpBox', force);\n    const next = typeof force === 'boolean' ? force : !this.jumpBoxVisible;\n    this.jumpBoxVisible = next;\n    this.processEventListener('onJumpBoxToggled', [next]);\n  }\n\n  setJumpValue(value: number) {\n    log.trace('TabTLKEditorState setJumpValue', value);\n    this.jumpValue = value;\n    this.processEventListener('onJumpValueChanged', [value]);\n  }\n\n  insertEntry() {\n    log.trace('TabTLKEditorState insertEntry');\n    if (!this.tlk) return;\n    const entry = new KotOR.TLKString(0, '', 0, 0, 0, 0, 0, '');\n    this.tlk.TLKStrings.push(entry);\n    this.tlk.StringCount = this.tlk.TLKStrings.length;\n    const index = this.tlk.TLKStrings.length - 1;\n    this.selectString(index);\n    if (this.file) {\n      this.file.unsaved_changes = true;\n    }\n    this.processEventListener('onEntriesChanged', [this.tlk.TLKStrings.length]);\n  }\n\n  async findReferencesForIndex(index: number): Promise<void> {\n    if (index < 0) return;\n    const { ModalReferenceSearchOptionsState } = require('@/apps/forge/states/modal/ModalReferenceSearchOptionsState');\n    const { ModalFileResultsState } = require('@/apps/forge/states/modal/ModalFileResultsState');\n    const { ForgeState } = require('@/apps/forge/states/ForgeState');\n    const { createKeyResources, findStrRefReferences } = require('@/apps/forge/helpers/ReferenceFinder');\n\n    const modal = new ModalReferenceSearchOptionsState({\n      onApply: async (options: import('../modal/ModalReferenceSearchOptionsState').ReferenceSearchOptionsStateValues) => {\n        const resources = createKeyResources();\n        const results = await findStrRefReferences(resources, index.toString(), options);\n        const resultsModal = new ModalFileResultsState({\n          results,\n          title: `References for ${index}`,\n        });\n        resultsModal.attachToModalManager(ForgeState.modalManager);\n        resultsModal.open();\n      },\n    });\n    modal.attachToModalManager(ForgeState.modalManager);\n    modal.open();\n  }\n\n  async getExportBuffer(_resref?: string, _ext?: string): Promise<Uint8Array> {\n    log.trace('TabTLKEditorState getExportBuffer');\n    if(this.tlk){\n      const buf = this.tlk.toBuffer();\n      log.debug('TabTLKEditorState getExportBuffer tlk length', buf?.length ?? 0);\n      return buf;\n    }\n    if(this.file?.buffer){\n      return this.file.buffer;\n    }\n    return new Uint8Array(0);\n  }\n\n  updateFile() {\n    log.trace('TabTLKEditorState updateFile');\n    // UI edits TLKStrings in place; getExportBuffer uses this.tlk.toBuffer()\n  }\n\n  getResourceID(): string | undefined {\n    return this.file ? `${this.file.resref ?? ''}${this.file.reskey ?? ''}` : undefined;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabTextEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":396,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":396,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on an `any` value.","line":399,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":399,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":400,"column":28,"nodeType":"Property","messageId":"anyAssignment","endLine":400,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on an `any` value.","line":400,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":400,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .description on an `any` value.","line":400,"column":64,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":400,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":472,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":472,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":475,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":475,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":476,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":476,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .content on an `any` value.","line":476,"column":74,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":476,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":582,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":582,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .first_line on a type that cannot be resolved.","line":582,"column":56,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":582,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":583,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":583,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .first_column on a type that cannot be resolved.","line":583,"column":52,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":583,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":584,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":584,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .last_line on a type that cannot be resolved.","line":584,"column":54,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":584,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":585,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":585,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .last_column on a type that cannot be resolved.","line":585,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":585,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .first_line on a type that cannot be resolved.","line":727,"column":71,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":727,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .first_column on a type that cannot be resolved.","line":727,"column":107,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":727,"endColumn":119}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as monacoEditor from \"monaco-editor/esm/vs/editor/editor.api\";\nimport React from \"react\";\n\nimport { TabScriptCompileLogState } from \"./TabScriptCompileLogState\";\nimport { TabScriptErrorLogState } from \"./TabScriptErrorLogState\";\nimport { TabScriptFindReferencesState, type TextReferenceMatch } from \"./TabScriptFindReferencesState\";\nimport { TabScriptInspectorState } from \"./TabScriptInspectorState\";\n\nimport { TabTextEditor } from \"@/apps/forge/components/tabs/tab-text-editor/TabTextEditor\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport { findAllReferencesInText, getWordAtIndex, createKeyResources, findScriptReferences, findStrRefReferences, findConversationReferences } from \"@/apps/forge/helpers/ReferenceFinder\";\nimport type { ReferenceSearchResult } from \"@/apps/forge/helpers/ReferenceFinderCore\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\n\n// import { NWScriptCompiler } from \"@/nwscript/NWScriptCompiler\";\n\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { EditorTabManager } from \"@/apps/forge/managers/EditorTabManager\";\nimport { ForgeState } from \"@/apps/forge/states/ForgeState\";\nimport { LYTLanguageService } from \"@/apps/forge/states/LYTLanguageService\";\nimport { ModalFileResultsState } from \"@/apps/forge/states/modal/ModalFileResultsState\";\nimport { ModalReferenceSearchOptionsState } from \"@/apps/forge/states/modal/ModalReferenceSearchOptionsState\";\nimport { NWScriptLanguageService } from \"@/apps/forge/states/NWScriptLanguageService\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { SemanticFunctionNode } from \"@/nwscript/compiler/ASTSemanticTypes\";\nimport type { CompilerProgramNode } from \"@/nwscript/compiler/CompilerNodeTypes\";\nimport { NWScriptCompiler } from \"@/nwscript/compiler/NWScriptCompiler\";\nimport { NWScriptParser } from \"@/nwscript/compiler/NWScriptParser\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport class TabTextEditorState extends TabState {\n\n  tabName: string = `TEXT`;\n  code: string = ``;\n\n  nwScriptParser: NWScriptParser;\n  ncs: Uint8Array = new Uint8Array(0);\n  nwScript: KotOR.NWScript;\n\n  #southTabManager = new EditorTabManager();\n  #tabErrorLogState: TabScriptErrorLogState;\n  #tabCompileLogState: TabScriptCompileLogState;\n  #tabScriptInspectorState: TabScriptInspectorState;\n  #tabFindReferencesState: TabScriptFindReferencesState;\n  editor: monacoEditor.editor.IStandaloneCodeEditor;\n  diffEditor: monacoEditor.editor.IStandaloneDiffEditor | null = null;\n  monaco: typeof monacoEditor;\n\n  isDiffMode: boolean = false;\n  originalText: string = ``;\n  originalModel: monacoEditor.editor.ITextModel | null = null;\n  modifiedModel: monacoEditor.editor.ITextModel | null = null;\n\n  resolvedIncludes: Map<string, string> = new Map();\n  tabSize: number = 2;\n  manualLanguageId: string | null = null; // Override for manual language selection\n\n  bookmarks: { line: number; description: string }[] = [];\n  snippets: { name: string; content: string }[] = [];\n  bookmarkDecorations: string[] = [];\n\n  getLanguageId(): string {\n    // Use manual override if set\n    if(this.manualLanguageId) {\n      return this.manualLanguageId;\n    }\n\n    // Otherwise, detect from file extension\n    if(!this.file) return 'plaintext';\n    const ext = this.file.ext != null ? KotOR.ResourceTypes.getKeyByValue(this.file.ext).toLowerCase() : '';\n    switch(ext){\n      case 'lyt':\n        return 'lyt';\n      case 'nss':\n      case 'ncs':\n        return 'nwscript';\n      default:\n        return 'plaintext';\n    }\n  }\n\n  setLanguageId(languageId: string | null): void {\n    this.manualLanguageId = languageId;\n\n    const finalLanguageId = this.getLanguageId();\n    const finalTheme = this.getTheme();\n\n    // Update editor model language if editor exists\n    if(this.editor && this.monaco) {\n      const model = this.editor.getModel();\n      if(model) {\n        this.monaco.editor.setModelLanguage(model, finalLanguageId);\n      }\n      // Update theme\n      this.monaco.editor.setTheme(finalTheme);\n    }\n\n    // Update diff editor models if in diff mode\n    if(this.isDiffMode && this.originalModel && this.modifiedModel && this.monaco) {\n      this.monaco.editor.setModelLanguage(this.originalModel, finalLanguageId);\n      this.monaco.editor.setModelLanguage(this.modifiedModel, finalLanguageId);\n      this.monaco.editor.setTheme(finalTheme);\n    }\n\n    // Trigger linter with new language\n    this.triggerLinterTimeout();\n  }\n\n  getTheme(): string {\n    const langId = this.getLanguageId();\n    switch(langId){\n      case 'lyt':\n        return 'lyt-dark';\n      case 'nwscript':\n        return 'nwscript-dark';\n      default:\n        return 'vs-dark';\n    }\n  }\n\n  constructor(options: BaseTabStateOptions = {}){\n    super(options);\n\n    if(this.file){\n      this.tabName = this.file.getFilename();\n    }\n\n\n    this.#tabErrorLogState = new TabScriptErrorLogState( { parentTab: this } );\n    this.#tabCompileLogState = new TabScriptCompileLogState( { parentTab: this } );\n    this.#tabScriptInspectorState = new TabScriptInspectorState( { parentTab: this } );\n    this.#tabFindReferencesState = new TabScriptFindReferencesState( { parentTab: this } );\n    this.#southTabManager.addTab( this.#tabErrorLogState );\n    this.#southTabManager.addTab( this.#tabCompileLogState );\n    this.#southTabManager.addTab( this.#tabScriptInspectorState );\n    this.#southTabManager.addTab( this.#tabFindReferencesState );\n\n    this.setContentView(<TabTextEditor tab={this}></TabTextEditor>);\n    const textDecoder = new TextDecoder();\n    const nwScriptBuffer = ForgeState.nwscript_nss ?? new Uint8Array(0);\n    this.nwScriptParser = new NWScriptParser(textDecoder.decode(nwScriptBuffer));\n    this.openFile();\n\n    this.loadSnippets();\n\n    this.saveTypes = [\n      {\n        description: 'Plain Text File',\n        accept: {\n          'text/plain': ['.txt']\n        }\n      },\n      {\n        description: 'NWScript File',\n        accept: {\n          'text/plain': ['.nss']\n        }\n      }/*,\n      {\n        description: 'NWScript Compiled File',\n        accept: {\n          'application/octet-stream': ['.ncs']\n        }\n      }*/\n    ];\n  }\n\n  openFile(file?: EditorFile){\n      return new Promise<void>( (resolve, _reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n\n        if(file.ext === KotOR.ResourceTypes.ncs){\n          file.readFile().then( (buffer) => {\n            this.ncs = buffer.buffer;\n            this.nwScript = new KotOR.NWScript(this.ncs);\n            this.nwScript.name = file?.getFilename().split('.')[0] || '';\n            this.code = this.nwScript.toAssembly();\n            log.debug('ncs assembly', this.code);\n            this.triggerLinterTimeout();\n            this.loadBookmarks();\n            this.processEventListener('onEditorFileLoad');\n            resolve();\n          });\n        }else{\n          file.readFile().then( (response) => {\n            const decoder = new TextDecoder('utf8');\n            this.code = decoder.decode(response.buffer);\n            this.triggerLinterTimeout();\n\n            this.loadBookmarks();\n\n            this.processEventListener('onEditorFileLoad');\n            resolve();\n          });\n        }\n      }\n    });\n\n  }\n\n  getSouthTabManager(){\n    return this.#southTabManager;\n  }\n\n  setCode(code: string = ``){\n    this.code = code;\n    // Update diff editor modified model if in diff mode\n    if(this.isDiffMode && this.modifiedModel && this.modifiedModel.getValue() !== code) {\n      this.modifiedModel.setValue(code);\n    }\n    this.triggerLinterTimeout();\n  }\n\n  getWordAtCursor(): string {\n    if (this.editor && this.monaco) {\n      const position = this.editor.getPosition();\n      const model = this.editor.getModel();\n      if (position && model) {\n        const word = model.getWordAtPosition(position);\n        return word?.word || \"\";\n      }\n    }\n\n    if (this.code) {\n      return getWordAtIndex(this.code, Math.max(0, (this.code.length || 1) - 1));\n    }\n\n    return \"\";\n  }\n\n  findAllReferencesInFile(searchTerm?: string): TextReferenceMatch[] {\n    const term = (searchTerm ?? this.getWordAtCursor() ?? \"\").trim();\n    if (!term) {\n      this.#tabFindReferencesState.setResults(\"\", []);\n      return [];\n    }\n\n    const matches = findAllReferencesInText(this.code || \"\", term);\n    this.#tabFindReferencesState.setResults(term, matches);\n    this.#tabFindReferencesState.show();\n    return matches;\n  }\n\n  async findReferencesInInstallation(searchTerm?: string): Promise<void> {\n    const term = (searchTerm ?? this.getWordAtCursor() ?? \"\").trim();\n    if (!term) return;\n\n    const modal = new ModalReferenceSearchOptionsState({\n      onApply: async (options) => {\n        const resources = createKeyResources();\n        let results: ReferenceSearchResult[] = [];\n        const extStr = this.file?.ext != null ? KotOR.ResourceTypes.getKeyByValue(this.file.ext).toLowerCase() : \"\";\n        if (extStr === \"dlg\") {\n          results = await findConversationReferences(resources, term, options);\n        } else if (extStr === \"tlk\") {\n          results = await findStrRefReferences(resources, term, options);\n        } else {\n          results = await findScriptReferences(resources, term, options);\n        }\n\n        const resultsModal = new ModalFileResultsState({\n          results,\n          title: `References for ${term}`,\n        });\n        resultsModal.attachToModalManager(ForgeState.modalManager);\n        resultsModal.open();\n      },\n    });\n    modal.attachToModalManager(ForgeState.modalManager);\n    modal.open();\n  }\n\n  setEditor(editor: monacoEditor.editor.IStandaloneCodeEditor){\n    this.editor = editor;\n    this.updateTabSize();\n    this.updateBookmarkDecorations();\n  }\n\n  setTabSize(size: number): void {\n    this.tabSize = size;\n    this.updateTabSize();\n  }\n\n  updateTabSize(): void {\n    // Update regular editor model (tabSize is a model option, not editor option)\n    if(this.editor) {\n      const model = this.editor.getModel();\n      if(model) {\n        model.updateOptions({ tabSize: this.tabSize, insertSpaces: true });\n      }\n    }\n\n    // Update diff editor models\n    if(this.diffEditor) {\n      const originalEditor = this.diffEditor.getOriginalEditor();\n      const modifiedEditor = this.diffEditor.getModifiedEditor();\n      const originalModel = originalEditor.getModel();\n      const modifiedModel = modifiedEditor.getModel();\n\n      if(originalModel) {\n        originalModel.updateOptions({ tabSize: this.tabSize, insertSpaces: true });\n      }\n      if(modifiedModel) {\n        modifiedModel.updateOptions({ tabSize: this.tabSize, insertSpaces: true });\n      }\n    }\n\n    // Update standalone models if they exist\n    if(this.originalModel) {\n      this.originalModel.updateOptions({ tabSize: this.tabSize, insertSpaces: true });\n    }\n    if(this.modifiedModel) {\n      this.modifiedModel.updateOptions({ tabSize: this.tabSize, insertSpaces: true });\n    }\n  }\n\n  setMonaco(monaco: typeof monacoEditor){\n    this.monaco = monaco;\n    this.updateBookmarkDecorations();\n  }\n\n  setDiffEditor(diffEditor: monacoEditor.editor.IStandaloneDiffEditor){\n    this.diffEditor = diffEditor;\n  }\n\n  switchToDiffMode(): void {\n    if(!this.monaco || !this.editor) return;\n\n    // Capture current text as original (left side)\n    this.originalText = this.code;\n\n    // Create models for original and modified text\n    const langId = this.getLanguageId();\n    this.originalModel = this.monaco.editor.createModel(this.originalText, langId);\n    this.modifiedModel = this.monaco.editor.createModel(this.code, langId);\n\n    // Apply tab size to models\n    this.originalModel.updateOptions({ tabSize: this.tabSize });\n    this.modifiedModel.updateOptions({ tabSize: this.tabSize });\n\n    this.isDiffMode = true;\n    this.processEventListener('onDiffModeChanged');\n  }\n\n  switchToRegularMode(): void {\n    if(!this.diffEditor) return;\n\n    // Get the current modified text from the diff editor\n    const modifiedEditor = this.diffEditor.getModifiedEditor();\n    const modifiedText = modifiedEditor.getValue();\n    this.code = modifiedText;\n\n    // Dispose models\n    if(this.originalModel) {\n      this.originalModel.dispose();\n      this.originalModel = null;\n    }\n    if(this.modifiedModel) {\n      this.modifiedModel.dispose();\n      this.modifiedModel = null;\n    }\n\n    // Dispose diff editor\n    this.diffEditor.dispose();\n    this.diffEditor = null;\n\n    this.isDiffMode = false;\n    this.originalText = ``;\n    this.processEventListener('onDiffModeChanged');\n  }\n\n  updateDiffModifiedText(): void {\n    if(this.isDiffMode && this.modifiedModel) {\n      this.modifiedModel.setValue(this.code);\n    }\n  }\n\n  getBookmarkStorageKey(): string {\n    const fileKey = this.file?.getPath?.() || this.file?.getFilename?.() || 'untitled';\n    return `forge.textEditor.bookmarks.${fileKey}`;\n  }\n\n  loadBookmarks(): void {\n    if(typeof window === 'undefined' || !window.localStorage) return;\n    const key = this.getBookmarkStorageKey();\n    const raw = window.localStorage.getItem(key);\n    if(raw){\n      try{\n        const parsed = JSON.parse(raw);\n        if(Array.isArray(parsed)){\n          this.bookmarks = parsed\n            .filter((b) => typeof b?.line === 'number')\n            .map((b) => ({ line: b.line, description: String(b.description || '') }));\n        }\n      }catch{\n        this.bookmarks = [];\n      }\n    }else{\n      this.bookmarks = [];\n    }\n    this.updateBookmarkDecorations();\n    this.processEventListener('onBookmarksChanged');\n  }\n\n  saveBookmarks(): void {\n    if(typeof window === 'undefined' || !window.localStorage) return;\n    const key = this.getBookmarkStorageKey();\n    window.localStorage.setItem(key, JSON.stringify(this.bookmarks));\n  }\n\n  addBookmarkAtCursor(description?: string): void {\n    const line = this.editor?.getPosition()?.lineNumber || 1;\n    const safeDescription = description?.trim() || `Bookmark at line ${line}`;\n    const existing = this.bookmarks.findIndex((b) => b.line === line);\n    if(existing >= 0){\n      this.bookmarks[existing] = { line, description: safeDescription };\n    }else{\n      this.bookmarks = [...this.bookmarks, { line, description: safeDescription }]\n        .sort((a, b) => a.line - b.line);\n    }\n    this.saveBookmarks();\n    this.updateBookmarkDecorations();\n    this.processEventListener('onBookmarksChanged');\n  }\n\n  removeBookmark(line: number): void {\n    this.bookmarks = this.bookmarks.filter((b) => b.line !== line);\n    this.saveBookmarks();\n    this.updateBookmarkDecorations();\n    this.processEventListener('onBookmarksChanged');\n  }\n\n  clearBookmarks(): void {\n    this.bookmarks = [];\n    this.saveBookmarks();\n    this.updateBookmarkDecorations();\n    this.processEventListener('onBookmarksChanged');\n  }\n\n  goToLine(line: number): void {\n    if(!this.editor) return;\n    this.editor.revealLineInCenter(line);\n    this.editor.setPosition({ lineNumber: line, column: 1 });\n    this.editor.focus();\n  }\n\n  updateBookmarkDecorations(): void {\n    if(!this.editor || !this.monaco) return;\n    const decorations = this.bookmarks.map((bookmark) => ({\n      range: new this.monaco.Range(bookmark.line, 1, bookmark.line, 1),\n      options: {\n        isWholeLine: true,\n        glyphMarginClassName: 'forge-text-editor__bookmark',\n        glyphMarginHoverMessage: { value: bookmark.description || `Bookmark at line ${bookmark.line}` },\n      }\n    }));\n    this.bookmarkDecorations = this.editor.deltaDecorations(this.bookmarkDecorations, decorations);\n  }\n\n  loadSnippets(): void {\n    if(typeof window === 'undefined' || !window.localStorage) return;\n    const raw = window.localStorage.getItem('forge.textEditor.snippets');\n    if(raw){\n      try{\n        const parsed = JSON.parse(raw);\n        if(Array.isArray(parsed)){\n          this.snippets = parsed\n            .filter((s) => typeof s?.name === 'string')\n            .map((s) => ({ name: String(s.name || ''), content: String(s.content || '') }));\n        }\n      }catch{\n        this.snippets = [];\n      }\n    }else{\n      this.snippets = [];\n    }\n    this.processEventListener('onSnippetsChanged');\n  }\n\n  saveSnippets(): void {\n    if(typeof window === 'undefined' || !window.localStorage) return;\n    window.localStorage.setItem('forge.textEditor.snippets', JSON.stringify(this.snippets));\n  }\n\n  addSnippet(name: string, content: string): void {\n    const trimmedName = name.trim();\n    if(!trimmedName) return;\n    const existing = this.snippets.findIndex((s) => s.name.toLowerCase() === trimmedName.toLowerCase());\n    if(existing >= 0){\n      this.snippets[existing] = { name: trimmedName, content };\n    }else{\n      this.snippets = [...this.snippets, { name: trimmedName, content }]\n        .sort((a, b) => a.name.localeCompare(b.name));\n    }\n    this.saveSnippets();\n    this.processEventListener('onSnippetsChanged');\n  }\n\n  removeSnippet(name: string): void {\n    this.snippets = this.snippets.filter((s) => s.name !== name);\n    this.saveSnippets();\n    this.processEventListener('onSnippetsChanged');\n  }\n\n  insertSnippet(content: string): void {\n    if(this.editor && this.monaco){\n      const selection = this.editor.getSelection();\n      const range = selection\n        ? new this.monaco.Range(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn)\n        : new this.monaco.Range(1, 1, 1, 1);\n      this.editor.executeEdits('snippet', [{ range, text: content, forceMoveMarkers: true }]);\n      this.editor.focus();\n    }else{\n      this.setCode(`${this.code}${content}`);\n    }\n  }\n\n  _linter_timeout: ReturnType<typeof setTimeout> | undefined;\n\n  triggerLinterTimeout(){\n    clearTimeout(this._linter_timeout);\n    this._linter_timeout = undefined;\n    this._linter_timeout = setTimeout( () => {\n      this.triggerLinter();\n    }, 100);\n  }\n\n  triggerLinter(){\n    if(!this.editor || !this.monaco) return;\n\n    const langId = this.getLanguageId();\n\n    // Handle LYT files\n    if(langId === 'lyt'){\n      try{\n        const markers = LYTLanguageService.validateLYT(this.code);\n        this.#tabErrorLogState.setErrors(markers);\n        if(this.editor) {\n          const model = this.editor.getModel() as monacoEditor.editor.ITextModel;\n          if(model) {\n            this.monaco.editor.setModelMarkers(model, 'lyt', markers);\n          }\n        }\n      }catch(e){\n        log.error('LYT linting error:', e as Error);\n        if(this.editor) {\n          const model = this.editor.getModel() as monacoEditor.editor.ITextModel;\n          if(model) {\n            this.monaco.editor.setModelMarkers(model, 'lyt', []);\n          }\n        }\n        this.#tabErrorLogState.setErrors([]);\n      }\n      return;\n    }\n\n    // Handle NWScript files\n    if(langId === 'nwscript'){\n      this.resolveIncludes(this.code, this.resolvedIncludes).then( (resolvedIncludes) => {\n        this.resolvedIncludes = resolvedIncludes;\n        try{\n          this.nwScriptParser.parseScript( [ [...this.resolvedIncludes.values()].join(\"\\n\"), this.code ].join(\"\\n\") );\n\n          // Update local functions in the tokenizer for syntax highlighting\n          const localFunctions = (this.nwScriptParser.program?.functions || []).map((f: SemanticFunctionNode) => f.name);\n          NWScriptLanguageService.updateLocalFunctions(localFunctions);\n\n          log.debug('nwScriptParser.errors', this.nwScriptParser.errors);\n          const markers: monacoEditor.editor.IMarkerData[] = [ ];\n          for(let i = 0; i < this.nwScriptParser.errors.length; i++){\n            const error = this.nwScriptParser.errors[i];\n            if(error && error.offender && error.offender.source){\n              markers.push({\n                severity: this.monaco.MarkerSeverity.Error,\n                startLineNumber: error.offender.source.first_line,\n                startColumn: error.offender.source.first_column + 1,\n                endLineNumber: error.offender.source.last_line,\n                endColumn: error.offender.source.last_column + 1,\n                message: error.message\n              });\n            }else{\n              markers.push({\n                severity: this.monaco.MarkerSeverity.Warning,\n                startLineNumber: 0,\n                startColumn: 0,\n                endLineNumber: 0,\n                endColumn: 0,\n                message: error.message\n              });\n            }\n          }\n          this.#tabErrorLogState.setErrors(markers);\n          if(this.editor) this.monaco.editor.setModelMarkers(this.editor.getModel() as monacoEditor.editor.ITextModel, 'nwscript', markers);\n        }catch(e: unknown){\n          log.debug('triggerLinter error', e);\n          const err = e as { hash?: { loc: { first_line: number; first_column: number; last_line: number; last_column: number } }; lineNumber?: number; columnNumber?: number; name?: string; message?: string };\n          if(err?.hash){\n            log.debug('err', err.lineNumber, err.columnNumber, err.name, err.message, err.hash);\n            log.debug('err json', JSON.stringify(e));\n            const markers = [{\n              severity: this.monaco.MarkerSeverity.Error,\n              startLineNumber: err.hash.loc.first_line,\n              startColumn: err.hash.loc.first_column + 1,\n              endLineNumber: err.hash.loc.last_line,\n              endColumn: err.hash.loc.last_column + 1,\n              message: err.message ?? 'Unknown error'\n            }];\n            this.#tabErrorLogState.setErrors(markers);\n\n            if(this.editor) this.monaco.editor.setModelMarkers(this.editor.getModel() as monacoEditor.editor.ITextModel, 'nwscript', markers);\n          }else{\n            if(this.editor) this.monaco.editor.setModelMarkers(this.editor.getModel() as monacoEditor.editor.ITextModel, 'nwscript', []);\n            this.#tabErrorLogState.setErrors([]);\n          }\n        }\n      });\n      return;\n    }\n\n    // For other file types, clear markers\n    if(this.editor) {\n      const model = this.editor.getModel() as monacoEditor.editor.ITextModel;\n      if(model) {\n        this.monaco.editor.setModelMarkers(model, 'plaintext', []);\n      }\n    }\n    this.#tabErrorLogState.setErrors([]);\n  }\n\n  resolveIncludes( code: string = ``, includeMap: Map<string, string> = new Map(), includeOrder: string[] = [] ){\n    return new Promise<Map<string, string>>( (resolve, _reject) => {\n      const visited = new Set<string>();\n\n      const loadInclude = async (resref: string) => {\n        if(!resref || visited.has(resref)) return;\n        visited.add(resref);\n\n        const key = KotOR.KEYManager.Key.getFileKey(resref, KotOR.ResourceTypes.nss);\n        if(!key) return;\n        const buffer = await KotOR.KEYManager.Key.getFileBuffer(key);\n        if(!buffer) return;\n\n        const textDecoder = new TextDecoder();\n        const source = textDecoder.decode(buffer);\n\n        // Resolve nested includes first so they appear before this include\n        const nestedIncludes = [...source.matchAll(/#include\\s*\"?([\\w.]+)\"?/g)];\n        log.debug('nestedIncludes', nestedIncludes);\n        for(const m of nestedIncludes){\n          const nestedResref = m[1];\n          if(nestedResref && !includeMap.has(nestedResref)){\n            log.debug('loading include', nestedResref);\n            await loadInclude(nestedResref);\n          }\n        }\n\n        if(!includeMap.has(resref)){\n          includeMap.set(resref, source);\n          includeOrder.push(resref);\n        }\n      };\n\n      void (async () => {\n        // seed includes from the root code\n        const rootIncludes = [...code.matchAll(/#include\\s*\"?([\\w.]+)\"?/g)];\n        log.debug('rootIncludes', rootIncludes);\n        for(const m of rootIncludes){\n          const resref = m[1];\n          if(resref && !includeMap.has(resref)){\n            log.debug('loading include', resref);\n            await loadInclude(resref);\n          }\n        }\n\n        log.debug('includeMap.keys', [...includeMap.keys()]);\n        resolve(includeMap);\n      })();\n    });\n  }\n\n  async getExportBuffer(_resref?: string, _ext?: string): Promise<Uint8Array> {\n    this.updateFile();\n    return this.file.buffer ? this.file.buffer : new Uint8Array(0);\n  }\n\n  updateFile(): void {\n    super.updateFile();\n    if(this.file){\n      this.file.buffer = new TextEncoder().encode(this.code);\n      this.file.unsaved_changes = true;\n    }\n  }\n\n  async compile(): Promise<boolean> {\n    log.debug('compile', 'parsing...');\n\n    // Resolve #include files and prepend them before parsing to mirror NWScript behavior\n    this.resolvedIncludes = await this.resolveIncludes(this.code, this.resolvedIncludes);\n    const mergedCode = [ [...this.resolvedIncludes.values()].join(\"\\n\"), this.code ].join(\"\\n\");\n    log.debug('mergedCode', mergedCode);\n    ForgeState.nwScriptParser.parseScript(mergedCode);\n    if(!ForgeState.nwScriptParser.errors.length){\n      log.debug('AST', ForgeState.nwScriptParser.toJSON());\n      const nwScriptCompiler = new NWScriptCompiler(ForgeState.nwScriptParser.program as CompilerProgramNode);\n      log.debug('compile', 'compiling...');\n      const buffer = nwScriptCompiler.compile();\n      if(buffer){\n        this.ncs = buffer;\n        log.debug('compile', 'success');\n        log.debug('ncs', this.ncs);\n        this.processEventListener('onCompile');\n        return true;\n      }\n      log.warn('compile', 'failed: no buffer returned');\n      return false;\n    }\n    log.error(`compile Failed with (${ForgeState.nwScriptParser.errors.length}) error!`);\n    for(let i = 0; i < ForgeState.nwScriptParser.errors.length; i++){\n      const error = ForgeState.nwScriptParser.errors[i];\n      log.error(`Error ${i}:`, error.message, error.offender?.source?.first_line, error.offender?.source?.first_column);\n    }\n    return false;\n\n    // const nss_path = path.parse(this.file.path);\n      // if(!this.nwScriptParser.errors.length){\n      //   NotificationManager.Notify(NotificationManager.Types.INFO, `Compiling... - ${nss_path.name}.nss`);\n      //   const nwScriptCompiler = new NWScriptCompiler(this.nwScriptParser.ast);\n      //   const compiledBuffer = nwScriptCompiler.compile();\n      //   fs.writeFileSync(path.join(nss_path.dir, `${nss_path.name}.ncs`), compiledBuffer);\n      //   this.ncsTab.setNCSData(compiledBuffer);\n      //   NotificationManager.Notify(NotificationManager.Types.SUCCESS, `Compile: Success! - ${nss_path.name}.ncs`);\n      // }else{\n      //   NotificationManager.Notify(NotificationManager.Types.ALERT, `Parse: Failed! - with errors (${this.nwScriptParser.errors.length})`);\n      // }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabUTCEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":30,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":30,"endColumn":81}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { TabUTCEditor } from \"@/apps/forge/components/tabs/tab-utc-editor/TabUTCEditor\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { ForgeCreature } from \"@/apps/forge/module-editor/ForgeCreature\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { UI3DRenderer } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport class TabUTCEditorState extends TabState {\n  tabName: string = `UTC`;\n  creature: ForgeCreature = new ForgeCreature();\n\n  get blueprint(): KotOR.GFFObject {\n    return this.creature.blueprint;\n  }\n\n  ui3DRenderer: UI3DRenderer;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabUTCEditorState constructor entry');\n    super(options);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n\n    this.setContentView(<TabUTCEditor tab={this}></TabUTCEditor>);\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'Odyssey Creature File',\n        accept: {\n          'application/octet-stream': ['.utc']\n        }\n      }\n    ];\n    log.trace('TabUTCEditorState constructor exit');\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabUTCEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.tabName = this.file.getFilename();\n        log.debug('TabUTCEditorState openFile tabName', this.tabName);\n\n        file.readFile().then( (response) => {\n          this.creature = new ForgeCreature(response.buffer);\n          this.creature.setContext(this.ui3DRenderer);\n          this.creature.load();\n          this.ui3DRenderer.attachObject(this.creature.container, false);\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabUTCEditorState openFile loaded');\n          resolve(this.blueprint);\n        });\n      } else {\n        log.trace('TabUTCEditorState openFile no file');\n      }\n    });\n  }\n\n  box3: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3();\n  size: THREE.Vector3 = new THREE.Vector3();\n  origin: THREE.Vector3 = new THREE.Vector3();\n\n  updateCameraFocus(){\n    const model = this.creature.model;\n    if(!model) return;\n\n    const oldRotationZ = model.rotation.z;\n    model.rotation.z = 0;\n\n    model.position.set(0, 0, 0);\n    this.box3.setFromObject(model);\n    this.box3.getCenter(this.center);\n    this.box3.getSize(this.size);\n\n    //Center the object to 0\n    model.position.set(-this.center.x, -this.center.y, -this.center.z);\n    this.ui3DRenderer.camera.position.z = 0;\n    this.ui3DRenderer.camera.position.y = (this.size.x + this.size.y) * 1.5;\n    this.ui3DRenderer.camera.lookAt(this.origin)\n\n    model.rotation.z = oldRotationZ;\n  }\n\n  show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  animate(delta: number = 0){\n    if(!this.creature) return;\n    const model = this.creature.model;\n    if(model){\n      model.update(delta);\n      //rotate the object in the viewport\n      model.rotation.z += delta;\n      this.updateCameraFocus();\n    }\n\n    // if(this.moduleCreature && this.moduleCreature.model){\n\n    //   let currentAnimation = this.moduleCreature.model.getAnimationName();\n    //   let animation = this.moduleCreature.animationConstantToAnimation(this.moduleCreature.animState);\n    //   if(animation){\n    //     if(currentAnimation != animation.name.toLowerCase()){\n    //       let aLooping = (!parseInt(animation.fireforget) && parseInt(animation.looping) == 1);\n    //       const anim = this.moduleCreature.model.playAnimation(animation.name.toLowerCase(), aLooping);\n    //       if(!aLooping){\n    //         setTimeout( () => {\n    //           this.moduleCreature.animState = ModuleCreatureAnimState.PAUSE;\n    //         }, anim ? anim.length * 1000 : 1500 );\n    //       }\n    //     }\n    //   }\n    // }\n\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(!!resref && ext == 'utc'){\n      this.creature.templateResRef = resref;\n      this.updateFile();\n      return this.creature.blueprint.getExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  updateFile(){\n    this.creature.exportToBlueprint();\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabUTDEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":32,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":32,"endColumn":81}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { TabUTDEditor } from \"@/apps/forge/components/tabs/tab-utd-editor/TabUTDEditor\";\nimport { UI3DRendererView } from \"@/apps/forge/components/UI3DRendererView\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { ForgeDoor } from \"@/apps/forge/module-editor/ForgeDoor\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { UI3DRenderer } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\n\nexport class TabUTDEditorState extends TabState {\n  tabName: string = `UTD`;\n  door: ForgeDoor = new ForgeDoor();\n\n  get blueprint(): KotOR.GFFObject {\n    return this.door.blueprint;\n  }\n\n  ui3DRenderer: UI3DRenderer;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabUTDEditorState constructor entry');\n    super(options);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n\n    this.setContentView(<TabUTDEditor tab={this}></TabUTDEditor>);\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'Odyssey Door File',\n        accept: {\n          'application/octet-stream': ['.utd']\n        }\n      }\n    ];\n    log.trace('TabUTDEditorState constructor exit');\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabUTDEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.file.isBlueprint = true;\n        this.tabName = this.file.getFilename();\n        log.debug('TabUTDEditorState openFile tabName', this.tabName);\n\n        file.readFile().then( async (response) => {\n          this.door = new ForgeDoor(response.buffer);\n          this.door.setContext(this.ui3DRenderer);\n          await this.door.load();\n          this.ui3DRenderer.attachObject(this.door.container, false);\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabUTDEditorState openFile loaded');\n          resolve(this.blueprint);\n        });\n      } else {\n        log.trace('TabUTDEditorState openFile no file');\n      }\n    });\n  }\n\n  box3: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3();\n  size: THREE.Vector3 = new THREE.Vector3();\n  origin: THREE.Vector3 = new THREE.Vector3();\n\n  updateCameraFocus(){\n    if(!this.door.model) return;\n\n    this.door.model.position.set(0, 0, 0);\n    this.box3.setFromObject(this.door.model);\n    this.box3.getCenter(this.center);\n    this.box3.getSize(this.size);\n\n    //Center the object to 0\n    this.door.model.position.set(-this.center.x, -this.center.y, -this.center.z);\n    this.ui3DRenderer.camera.position.z = 0;\n    this.ui3DRenderer.camera.position.y = this.size.x + this.size.y;\n    this.ui3DRenderer.camera.lookAt(this.origin);\n  }\n\n  show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n\n    this.updateCameraFocus();\n\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  animate(delta: number = 0){\n    if(this.door.model){\n      this.door.model.update(delta);\n      //rotate the object in the viewport\n      this.door.model.rotation.z += delta;\n    }\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(!!resref && ext == 'utd'){\n      this.door.templateResRef = resref;\n      this.updateFile();\n      return this.door.blueprint.getExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  updateFile(){\n    this.door.exportToBlueprint();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabUTIEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":48,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":48,"endColumn":81}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from \"three\";\n\nimport { TabUTIEditor } from \"@/apps/forge/components/tabs/tab-uti-editor/TabUTIEditor\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { ForgeItem } from \"@/apps/forge/module-editor/ForgeItem\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { UI3DRenderer } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport interface ItemPropertyEntry {\n  chanceAppear: number;\n  costTable: number;\n  costValue: number;\n  param1: number;\n  param1Value: number;\n  propertyName: number;\n  subtype: number;\n}\n\nexport class TabUTIEditorState extends TabState {\n  tabName: string = `UTI`;\n  item: ForgeItem = new ForgeItem();\n\n  get blueprint(): KotOR.GFFObject {\n    return this.item.blueprint;\n  }\n\n  get properties() {\n    return this.item.properties;\n  }\n\n  set properties(value) {\n    this.item.properties = value;\n  }\n\n  ui3DRenderer: UI3DRenderer;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabUTIEditorState constructor entry');\n    super(options);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n    this.setContentView(<TabUTIEditor tab={this}></TabUTIEditor>);\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'Odyssey Item Blueprint',\n        accept: {\n          'application/octet-stream': ['.uti']\n        }\n      }\n    ];\n\n    this.item.addEventListener('onPropertyChange', (property: string, newValue: string | number | boolean | object | undefined, oldValue: string | number | boolean | object | undefined) => {\n      if(property === 'baseItem' || property === 'modelVariation'){\n        this.processEventListener('onModelChange', [this]);\n      }\n    });\n    log.trace('TabUTIEditorState constructor exit');\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabUTIEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.file.isBlueprint = true;\n        this.tabName = this.file.getFilename();\n        log.debug('TabUTIEditorState openFile tabName', this.tabName);\n\n        file.readFile().then( async (response) => {\n          this.item = new ForgeItem(response.buffer);\n          this.item.setContext(this.ui3DRenderer);\n          await this.item.load();\n          this.ui3DRenderer.attachObject(this.item.container, false);\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabUTIEditorState openFile loaded');\n          resolve(this.blueprint);\n        });\n      } else {\n        log.trace('TabUTIEditorState openFile no file');\n      }\n    });\n  }\n\n  box3: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3();\n  size: THREE.Vector3 = new THREE.Vector3();\n  origin: THREE.Vector3 = new THREE.Vector3();\n\n  updateCameraFocus(){\n    if(!this.item.model) return;\n\n    this.item.model.position.set(0, 0, 0);\n    this.box3.setFromObject(this.item.model);\n\n    this.box3.getCenter(this.center);\n    this.box3.getSize(this.size);\n\n    //Center the object to 0\n    this.item.model.position.set(-this.center.x, -this.center.y, -this.center.z);\n    this.ui3DRenderer.camera.position.z = 0;\n    this.ui3DRenderer.camera.position.y = this.size.x + this.size.y;\n    this.ui3DRenderer.camera.lookAt(this.origin)\n  }\n\n  animate(delta: number){\n    if(this.item.model){\n      this.item.model.update(delta);\n      //rotate the object in the viewport\n      this.item.model.rotation.z += delta;\n    }\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(!!resref && ext == 'uti'){\n      this.item.templateResRef = resref;\n      this.updateFile();\n      return this.item.blueprint.getExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.updateCameraFocus();\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  updateFile(){\n    this.item.exportToBlueprint();\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabUTPEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":32,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":32,"endColumn":81}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { TabUTPEditor } from \"@/apps/forge/components/tabs/tab-utp-editor/TabUTPEditor\";\nimport { UI3DRendererView } from \"@/apps/forge/components/UI3DRendererView\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { ForgePlaceable } from \"@/apps/forge/module-editor/ForgePlaceable\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { UI3DRenderer } from \"@/apps/forge/UI3DRenderer\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\n\nexport class TabUTPEditorState extends TabState {\n  tabName: string = `UTP`;\n  placeable: ForgePlaceable = new ForgePlaceable();\n\n  get blueprint(): KotOR.GFFObject {\n    return this.placeable.blueprint;\n  }\n\n  ui3DRenderer: UI3DRenderer;\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace('TabUTPEditorState constructor entry');\n    super(options);\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n\n    this.setContentView(<TabUTPEditor tab={this}></TabUTPEditor>);\n    this.openFile();\n    this.saveTypes = [\n      {\n        description: 'Odyssey Placeable File',\n        accept: {\n          'application/octet-stream': ['.utp']\n        }\n      }\n    ];\n    log.trace('TabUTPEditorState constructor exit');\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace('TabUTPEditorState openFile entry', !!file);\n    return new Promise<KotOR.GFFObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.tabName = this.file.getFilename();\n        log.debug('TabUTPEditorState openFile tabName', this.tabName);\n\n        file.readFile().then( async (response) => {\n          this.placeable = new ForgePlaceable(response.buffer);\n          this.placeable.setContext(this.ui3DRenderer);\n          await this.placeable.load();\n          this.ui3DRenderer.attachObject(this.placeable.container, false);\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.trace('TabUTPEditorState openFile loaded');\n          resolve(this.blueprint);\n        });\n      } else {\n        log.trace('TabUTPEditorState openFile no file');\n      }\n    });\n  }\n\n\n\n  box: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3();\n  size: THREE.Vector3 = new THREE.Vector3();\n  origin: THREE.Vector3 = new THREE.Vector3();\n\n  updateCameraFocus(){\n    const model = this.placeable.model;\n    if(!model) return;\n\n    const oldRotationZ = model.rotation.z;\n    model.rotation.z = 0;\n\n    model.position.set(0, 0, 0);\n    this.box.setFromObject(model);\n    this.box.getCenter(this.center);\n    this.box.getSize(this.size);\n\n    //Center the object to 0\n    model.position.set(-this.center.x, -this.center.y, -this.center.z);\n    this.ui3DRenderer.camera.position.z = 0;\n    this.ui3DRenderer.camera.position.y = (this.size.x + this.size.y) * 1.5;\n    this.ui3DRenderer.camera.lookAt(this.origin);\n\n    model.rotation.z = oldRotationZ;\n  }\n\n  show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.updateCameraFocus();\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  animate(delta: number = 0){\n    if(!this.placeable) return;\n    const model = this.placeable.model;\n    if(model){\n      model.update(delta);\n      //rotate the object in the viewport\n      model.rotation.z += delta;\n      this.updateCameraFocus();\n    }\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(!!resref && ext == 'utp'){\n      this.placeable.templateResRef = resref;\n      this.updateFile();\n      return this.placeable.blueprint.getExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  updateFile(){\n    this.placeable.exportToBlueprint();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabWAVEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":44,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":44,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe construction of a type that could not be resolved.","line":44,"column":22,"nodeType":"NewExpression","messageId":"errorNew","endLine":44,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":52,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":52,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":52,"column":14,"nodeType":"MemberExpression","messageId":"errorCall","endLine":52,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toBuffer on a type that cannot be resolved.","line":52,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":52,"endColumn":37}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\n\nimport { TabWAVEditor } from \"@/apps/forge/components/tabs/tab-wav-editor/TabWAVEditor\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport class TabWAVEditorState extends TabState {\n  tabName: string = 'WAV Editor';\n  saveTypes: { description: string; accept: Record<string, string[]> }[] = [\n    {\n      description: 'Wave Audio',\n      accept: {\n        'application/octet-stream': ['.wav']\n      }\n    }\n  ];\n  wavObject?: KotOR.WAVObject;\n\n  constructor(options: BaseTabStateOptions = {}) {\n    log.trace('TabWAVEditorState constructor entry');\n    super(options);\n\n    if (this.file) {\n      this.tabName = this.file.getFilename();\n      log.debug('TabWAVEditorState constructor tabName', this.tabName);\n    }\n\n    this.setContentView(<TabWAVEditor tab={this}></TabWAVEditor>);\n    this.openFile();\n    log.trace('TabWAVEditorState constructor exit');\n  }\n\n  async openFile() {\n    log.trace('TabWAVEditorState openFile entry');\n    if (!this.file) {\n      log.trace('TabWAVEditorState openFile no file');\n      return;\n    }\n    const response = await this.file.readFile();\n    this.wavObject = new KotOR.WAVObject(response.buffer);\n    this.processEventListener('onEditorFileLoad', [this]);\n    log.trace('TabWAVEditorState openFile loaded');\n  }\n\n  async getExportBuffer(_resref?: string, _ext?: string): Promise<Uint8Array> {\n    log.trace('TabWAVEditorState getExportBuffer');\n    if (this.wavObject) {\n      return this.wavObject.toBuffer();\n    }\n    if (this.file?.buffer) {\n      return this.file.buffer;\n    }\n    return new Uint8Array(0);\n  }\n\n  updateFile() {\n    log.trace('TabWAVEditorState updateFile');\n  }\n\n  getResourceID(): string | undefined {\n    const id = this.file ? `${this.file.resref ?? ''}${this.file.reskey ?? ''}` : undefined;\n    log.trace('TabWAVEditorState getResourceID', id ?? '(none)');\n    return id;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\TabWOKEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":107,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":107,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":113,"column":84,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":113,"endColumn":108}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { TabWOKEditor } from \"@/apps/forge/components/tabs/tab-wok-editor/TabWOKEditor\";\n\nconst log = createScopedLogger(LogScope.Forge);\n\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { TabState } from \"@/apps/forge/states/tabs/TabState\";\nimport { CameraFocusMode, UI3DRenderer, UI3DRendererEventListenerTypes } from \"@/apps/forge/UI3DRenderer\";\n\nexport enum TabWOKEditorControlMode {\n  FACE = 0,\n  VERTEX = 1,\n  EDGE = 2,\n}\n\n/**\n * Get the complementary color of a given hex color\n * @param hexColor\n * @returns\n */\nconst getComplementaryColor = (hexColor: number) => {\n  // Extract RGB components from packed hex color\n  const r = (hexColor >> 16) & 0xff;\n  const g = (hexColor >> 8) & 0xff;\n  const b = hexColor & 0xff;\n\n  // Invert each channel\n  const invertedR = 255 - r;\n  const invertedG = 255 - g;\n  const invertedB = 255 - b;\n\n  // Combine back into packed RGB number\n  const complementary = (invertedR << 16) | (invertedG << 8) | invertedB;\n\n  return complementary;\n}\n\nexport class TabWOKEditorState extends TabState {\n  tabName: string = `WOK`;\n\n  ui3DRenderer: UI3DRenderer;\n  wok: KotOR.OdysseyWalkMesh;\n  groundColor: THREE.Color;\n  groundGeometry: THREE.WireframeGeometry<THREE.PlaneGeometry>;\n  groundMaterial: THREE.LineBasicMaterial;\n  groundMesh: THREE.LineSegments<THREE.WireframeGeometry<THREE.PlaneGeometry>, THREE.LineBasicMaterial>;\n  faceHelperMesh: THREE.Mesh<THREE.BufferGeometry, THREE.Material | THREE.Material[]>;\n  faceHelperGeometry: THREE.BufferGeometry;\n  faceHelperMaterial: THREE.MeshBasicMaterial;\n  wireMaterial: THREE.MeshBasicMaterial;\n  wireframe: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;\n  selectColor = new THREE.Color(0x607D8B);\n\n  vertexHelperGeometry = new THREE.BoxGeometry(1, 1, 1, 1, 1);\n  vertexHelpersGroup: THREE.Group = new THREE.Group();\n  vertexHelpers: THREE.Mesh[] = [];\n  vertexHelperSize: number = 0.125;\n\n  controlMode: TabWOKEditorControlMode = TabWOKEditorControlMode.FACE;\n\n  selectedFaceIndex: number = -1;\n  selectedVertexIndex: number = -1;\n  selectedEdgeIndex: number = -1;\n\n  box3: THREE.Box3 = new THREE.Box3();\n  center: THREE.Vector3 = new THREE.Vector3(0, 0, 0);\n\n  constructor(options: BaseTabStateOptions = {}){\n    log.trace(\"TabWOKEditorState constructor entry\");\n    super(options);\n\n    log.trace(\"TabWOKEditorState constructor ground\");\n    this.groundColor = new THREE.Color(0.5, 0.5, 0.5);\n    this.groundGeometry = new THREE.WireframeGeometry(new THREE.PlaneGeometry( 2500, 2500, 100, 100 ));\n    this.groundMaterial = new THREE.LineBasicMaterial( { color: this.groundColor, linewidth: 2 } );\n    this.groundMesh = new THREE.LineSegments( this.groundGeometry, this.groundMaterial );\n\n    const grid1 = new THREE.GridHelper( 250, 26, 0x00FF00 );\n    grid1.rotation.x = -Math.PI / 2;\n\n    // center line\n    const grid2 = new THREE.GridHelper( 250, 2, 0xFF0000 );\n    grid2.rotation.x = -Math.PI / 2;\n    // (grid2.material as THREE.Material).depthFunc = THREE.AlwaysDepth;\n\n    (grid2.material as THREE.Material).onBeforeCompile = function ( shader ) {\n      // Emulate GL_POLYGON_OFFSET_LINE\n      shader.vertexShader = shader.vertexShader.replace( '<worldpos_vertex>', '<worldpos_vertex>\\ngl_Position.z -= 0.0001;' );\n    };\n\n\n    this.faceHelperGeometry = new THREE.BufferGeometry();\n    this.faceHelperGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 0, 0, 0, 0], 3));\n\n    this.faceHelperMaterial = new THREE.MeshBasicMaterial();\n    this.faceHelperMaterial.wireframe = true;\n    this.faceHelperMaterial.visible = false;\n    this.faceHelperMesh = new THREE.Mesh(this.faceHelperGeometry, this.faceHelperMaterial)\n\n    log.trace(\"TabWOKEditorState constructor UI3DRenderer\");\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n    this.ui3DRenderer.scene.add(grid1);\n    this.ui3DRenderer.scene.add(grid2);\n    this.ui3DRenderer.scene.add(this.faceHelperMesh);\n    this.ui3DRenderer.group.light_helpers.visible = false;\n    this.ui3DRenderer.setCameraFocusMode(CameraFocusMode.SELECTABLE);\n    this.ui3DRenderer.addEventListener<UI3DRendererEventListenerTypes>('onSelect', this.onSelect.bind(this));\n    log.debug(\"TabWOKEditorState constructor scene configured\");\n\n    this.setContentView(<TabWOKEditor tab={this}></TabWOKEditor>);\n    log.trace(\"TabWOKEditorState constructor setContentView\");\n    this.openFile();\n    log.trace(\"TabWOKEditorState constructor exit\");\n\n    this.saveTypes = [\n      {\n        description: 'Odyssey Walk Mesh File',\n        accept: {\n          'application/octet-stream': ['.wok']\n        }\n      },\n      {\n        description: 'Odyssey Door Walk Mesh File',\n        accept: {\n          'application/octet-stream': ['.dwk']\n        }\n      },\n      {\n        description: 'Odyssey Placeable Walk Mesh File',\n        accept: {\n          'application/octet-stream': ['.pwk']\n        }\n      }\n    ];\n\n    this.addEventListener('onKeyUp', (e: KeyboardEvent) => {\n\n    });\n  }\n\n  public openFile(file?: EditorFile){\n    log.trace(\"TabWOKEditorState openFile entry\", file?.getFilename?.() ?? String(file));\n    return new Promise<KotOR.OdysseyWalkMesh>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n        log.trace(\"TabWOKEditorState openFile using this.file\");\n      }\n\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        this.tabName = this.file.getFilename();\n        log.debug(\"TabWOKEditorState openFile tabName\", this.tabName);\n\n        log.trace(\"TabWOKEditorState openFile readFile\");\n        file.readFile().then( (response) => {\n          log.debug('TabWOKEditorState file.readFile response buffer length', response.buffer?.length ?? 0);\n          this.wok = new KotOR.OdysseyWalkMesh(new KotOR.BinaryReader(response.buffer));\n          log.trace(\"TabWOKEditorState openFile OdysseyWalkMesh created\");\n          this.wok.material.visible = true;\n          this.wok.material.side = THREE.DoubleSide;\n          this.wok.material.opacity = 0.75;\n          this.wok.material.transparent = true;\n          this.ui3DRenderer.selectable.add(this.wok.mesh);\n\n\n\n          this.wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true, wireframeLinewidth: 2 } );\n          this.wireframe = new THREE.Mesh(this.wok.geometry, this.wireMaterial);\n          this.ui3DRenderer.unselectable.add(this.wireframe);\n          this.ui3DRenderer.selectable.add(this.vertexHelpersGroup);\n\n          /**\n           * Center the mesh and wireframe if the walkmesh type is AABB\n           */\n          if(this.wok.header.walkMeshType == KotOR.OdysseyWalkMeshType.AABB){\n            log.trace(\"TabWOKEditorState openFile AABB center\");\n            this.wok.box.getCenter(this.center);\n            this.center.z = this.wok.getMinZ();\n            this.wok.mesh.position.sub(this.center);\n            this.wireframe.position.sub(this.center);\n          } else {\n            log.trace(\"TabWOKEditorState openFile not AABB\");\n          }\n\n          log.trace(\"TabWOKEditorState openFile building edge arrows\");\n          const arrowPosition = new THREE.Vector3();\n          this.wok.edges.forEach( (edge, index) => {\n            arrowPosition.copy(edge.center_point).sub(this.center);\n            const arrowHelper = new THREE.ArrowHelper( edge.normal, arrowPosition, 0.5, getComplementaryColor(edge.face.color.getHex()) );\n            arrowHelper.layers.set(2);\n            this.ui3DRenderer.unselectable.add(arrowHelper);\n          });\n          this.buildVertexHelpers();\n          log.trace(\"TabWOKEditorState openFile vertex helpers built\");\n\n          this.processEventListener('onEditorFileLoad', [this]);\n          log.info(\"TabWOKEditorState openFile loaded\");\n          resolve(this.wok);\n        });\n      } else {\n        log.trace(\"TabWOKEditorState openFile file not EditorFile\");\n      }\n    });\n  }\n\n  onSelect(intersect: THREE.Intersection){\n    log.trace(\"TabWOKEditorState onSelect entry\", \"controlMode=%s\", this.controlMode);\n    this.ui3DRenderer.selectionBox.visible = false;\n\n    switch(this.controlMode){\n      case TabWOKEditorControlMode.FACE:\n        log.trace(\"TabWOKEditorState onSelect FACE mode\");\n        if(intersect && intersect.face){\n          if(intersect.object == this.wok.mesh){\n            const f_idx = Math.floor(intersect.face.a / 3);\n            log.debug(\"TabWOKEditorState onSelect face index\", f_idx);\n            const face: KotOR.OdysseyFace3 = this.wok.faces.find( (f: KotOR.OdysseyFace3, index: number) => index == f_idx ) as KotOR.OdysseyFace3;\n            this.selectFace(face);\n          }else{\n            log.trace(\"TabWOKEditorState onSelect object not wok.mesh\");\n            this.selectFace(undefined);\n          }\n        }else{\n          log.trace(\"TabWOKEditorState onSelect no intersect/face\");\n          this.selectFace(undefined);\n        }\n      break;\n      case TabWOKEditorControlMode.VERTEX:\n        log.trace(\"TabWOKEditorState onSelect VERTEX mode\");\n        if(intersect && intersect.object){\n          if(intersect.object != this.wok.mesh){\n            const helperIndex = this.vertexHelpersGroup.children.indexOf(intersect.object);\n            log.trace(\"TabWOKEditorState onSelect helperIndex\", helperIndex);\n            if(helperIndex >= 0) this.selectVertex(helperIndex);\n          }else{\n            log.trace(\"TabWOKEditorState onSelect wok.mesh selectVertex -1\");\n            this.selectVertex(-1);\n          }\n        }else{\n          log.trace(\"TabWOKEditorState onSelect no intersect selectVertex -1\");\n          this.selectVertex(-1);\n        }\n      break;\n      default:\n        log.trace(\"TabWOKEditorState onSelect default case\");\n    }\n    log.trace(\"TabWOKEditorState onSelect exit\");\n  }\n\n  setControlMode(mode: TabWOKEditorControlMode = 0) {\n    log.trace(\"TabWOKEditorState setControlMode\", mode);\n    this.controlMode = mode;\n    this.processEventListener('onControlModeChange', [mode]);\n    log.trace(\"TabWOKEditorState setControlMode done\");\n  }\n\n  private updateCameraFocus(): void {\n    log.trace(\"TabWOKEditorState updateCameraFocus entry\");\n    this.box3 = new THREE.Box3();\n    if(!this.wok) {\n      log.trace(\"TabWOKEditorState updateCameraFocus no wok\");\n      return;\n    }\n    this.box3.setFromObject(this.wok.mesh);\n    this.box3.getCenter(this.center);\n    this.ui3DRenderer.orbitControls.target.copy(this.center);\n    log.trace(\"TabWOKEditorState updateCameraFocus done\");\n  }\n\n  show(): void {\n    log.trace(\"TabWOKEditorState show entry\");\n    super.show();\n    this.ui3DRenderer.enabled = true;\n    this.updateCameraFocus();\n    this.ui3DRenderer.render();\n    log.trace(\"TabWOKEditorState show exit\");\n  }\n\n  hide(): void {\n    log.trace(\"TabWOKEditorState hide entry\");\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n    log.trace(\"TabWOKEditorState hide exit\");\n  }\n\n  animate(delta: number = 0){\n    log.trace(\"TabWOKEditorState animate\", \"delta=%s controlMode=%s\", delta, this.controlMode);\n\n    this.vertexHelpersGroup.visible = false;\n    (this.ui3DRenderer.transformControls as unknown as THREE.Object3D).visible = false;\n    this.faceHelperMesh.visible = false;\n\n    switch(this.controlMode){\n      case TabWOKEditorControlMode.FACE:\n        log.trace(\"TabWOKEditorState animate FACE\");\n        this.selectVertex(-1);\n      break;\n      case TabWOKEditorControlMode.VERTEX:\n        log.trace(\"TabWOKEditorState animate VERTEX\");\n        this.selectFace(undefined);\n        this.vertexHelpersGroup.visible = true;\n\n        const tc = this.ui3DRenderer.transformControls as unknown as THREE.Object3D;\n        if(!(this.ui3DRenderer.transformControls as { object: unknown }).object)\n          tc.visible = false;\n        else\n          tc.visible = true;\n\n        const selectedVertex = this.wok.vertices[this.selectedVertexIndex];\n        if(selectedVertex){\n          log.trace(\"TabWOKEditorState animate selectedVertex\", this.selectedVertexIndex);\n          const selectedVertexHelper = this.vertexHelpers[this.selectedVertexIndex];\n          const vertexNeedsUpdate = (\n            !selectedVertexHelper.position.equals(selectedVertex)\n          );\n          if(vertexNeedsUpdate){\n            log.trace(\"TabWOKEditorState animate vertexNeedsUpdate\");\n            const position = this.wok.geometry.attributes.position as THREE.BufferAttribute;\n            selectedVertex.copy(selectedVertexHelper.position);\n            for(let i = 0; i < this.wok.faces.length; i++){\n              const face = this.wok.faces[i];\n              if(face.a == this.selectedVertexIndex){\n                position.setX( (i * 3) + 0, selectedVertex.x + this.center.x);\n                position.setY( (i * 3) + 0, selectedVertex.y + this.center.y);\n                position.setZ( (i * 3) + 0, selectedVertex.z + this.center.z);\n              }\n\n              if(face.b == this.selectedVertexIndex){\n                position.setX( (i * 3) + 1, selectedVertex.x + this.center.x);\n                position.setY( (i * 3) + 1, selectedVertex.y + this.center.y);\n                position.setZ( (i * 3) + 1, selectedVertex.z + this.center.z);\n              }\n\n              if(face.c == this.selectedVertexIndex){\n                position.setX( (i * 3) + 2, selectedVertex.x + this.center.x);\n                position.setY( (i * 3) + 2, selectedVertex.y + this.center.y);\n                position.setZ( (i * 3) + 2, selectedVertex.z + this.center.z);\n              }\n            }\n            position.needsUpdate = true;\n          }\n        } else {\n          log.trace(\"TabWOKEditorState animate no selectedVertex\");\n        }\n\n      break;\n      case TabWOKEditorControlMode.EDGE:\n        log.trace(\"TabWOKEditorState animate EDGE (no-op)\");\n      break;\n    }\n    log.trace(\"TabWOKEditorState animate exit\");\n  }\n\n  buildVertexHelpers(){\n    log.trace(\"TabWOKEditorState buildVertexHelpers entry\");\n    while(this.vertexHelpers.length){\n      const helper = this.vertexHelpers.splice(this.vertexHelpers.length - 1, 1)[0];\n      helper.removeFromParent();\n      log.trace(\"TabWOKEditorState buildVertexHelpers removed\");\n    }\n    log.debug(\"TabWOKEditorState buildVertexHelpers vertex count\", this.wok.vertices.length);\n    for(let i = 0; i < this.wok.vertices.length; i++){\n      const helper = new THREE.Mesh(this.vertexHelperGeometry, new THREE.MeshBasicMaterial({color: 0x000000}));\n      this.vertexHelpers.push(helper);\n      this.vertexHelpersGroup.add(helper);\n    }\n    this.alignVertexHelpers();\n    log.trace(\"TabWOKEditorState buildVertexHelpers exit\");\n  }\n\n  alignVertexHelpers(){\n    log.trace(\"TabWOKEditorState alignVertexHelpers entry\");\n    for(let i = 0; i < this.wok.vertices.length; i++){\n      const vertex = this.wok.vertices[i];\n      const helper = this.vertexHelpers[i];\n      helper.position.copy(vertex).sub(this.center);\n      helper.scale.setScalar(this.vertexHelperSize);\n    }\n    log.trace(\"TabWOKEditorState alignVertexHelpers exit\");\n  }\n\n  resetFaceColors(){\n    log.trace(\"TabWOKEditorState resetFaceColors entry\");\n    const color = this.wok.geometry.attributes.color as THREE.BufferAttribute;\n    for(let i = 0; i < this.wok.faces.length; i++){\n      const face = this.wok.faces[i];\n      const index = i * 3;\n      color.setX(index, face.color.r);\n      color.setY(index, face.color.g);\n      color.setZ(index, face.color.b);\n\n      color.setX(index + 1, face.color.r);\n      color.setY(index + 1, face.color.g);\n      color.setZ(index + 1, face.color.b);\n\n      color.setX(index + 2, face.color.r);\n      color.setY(index + 2, face.color.g);\n      color.setZ(index + 2, face.color.b);\n    }\n    color.needsUpdate = true;\n    log.trace(\"TabWOKEditorState resetFaceColors exit\");\n  }\n\n  selectFace(face?: KotOR.OdysseyFace3){\n    log.trace(\"TabWOKEditorState selectFace entry\", !!face);\n    this.resetFaceColors();\n    this.selectedFaceIndex = -1;\n    if(face){\n      log.debug(\"TabWOKEditorState selectFace index\", this.wok.faces.indexOf(face));\n      const position = this.wok.geometry.attributes.position as THREE.BufferAttribute;\n      const h_position = this.faceHelperGeometry.attributes.position as THREE.BufferAttribute;\n      const color = this.wok.geometry.attributes.color as THREE.BufferAttribute;\n      this.selectedFaceIndex = this.wok.faces.indexOf(face);\n      const index = this.selectedFaceIndex * 3;\n      color.setX(index, this.selectColor.r);\n      color.setY(index, this.selectColor.g);\n      color.setZ(index, this.selectColor.b);\n\n      color.setX(index + 1, this.selectColor.r);\n      color.setY(index + 1, this.selectColor.g);\n      color.setZ(index + 1, this.selectColor.b);\n\n      color.setX(index + 2, this.selectColor.r);\n      color.setY(index + 2, this.selectColor.g);\n      color.setZ(index + 2, this.selectColor.b);\n\n      h_position.setX(0, position.getX(index) );\n      h_position.setY(0, position.getY(index) );\n      h_position.setZ(0, position.getZ(index) );\n\n      h_position.setX(1, position.getX(index + 1) );\n      h_position.setY(1, position.getY(index + 1) );\n      h_position.setZ(1, position.getZ(index + 1) );\n\n      h_position.setX(2, position.getX(index + 2) );\n      h_position.setY(2, position.getY(index + 2) );\n      h_position.setZ(2, position.getZ(index + 2) );\n\n      h_position.needsUpdate = true;\n      this.faceHelperGeometry.computeBoundingSphere();\n      this.faceHelperMaterial.visible = false;\n      color.needsUpdate = true;\n      this.ui3DRenderer.transformControls.detach();\n    }\n    this.processEventListener('onFaceSelected', [face]);\n    log.trace(\"TabWOKEditorState selectFace exit\");\n  }\n\n  selectVertex(index: number = -1){\n    log.trace(\"TabWOKEditorState selectVertex\", index);\n    this.selectedVertexIndex = index;\n    this.ui3DRenderer.transformControls.detach();\n    for(let i = 0; i < this.vertexHelpersGroup.children.length; i++){\n      const helper = this.vertexHelpersGroup.children[i] as THREE.Mesh;\n      const material = helper.material as THREE.MeshBasicMaterial;\n      if(i == index){\n        material.color.setHex(0xFFFFFF);\n        this.ui3DRenderer.transformControls.attach(helper);\n        this.ui3DRenderer.transformControls.size = 0.5;\n      }else{\n        material.color.setHex(0x000000);\n      }\n    }\n    log.trace(\"TabWOKEditorState selectVertex exit\");\n  }\n\n  async getExportBuffer(_resref?: string, _ext?: string): Promise<Uint8Array> {\n    log.trace(\"TabWOKEditorState getExportBuffer entry\");\n    const buf = this.wok.toExportBuffer();\n    log.trace(\"TabWOKEditorState getExportBuffer length\", buf?.length);\n    return buf;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\states\\tabs\\tab-lip-editor\\TabLIPEditorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EventListenerCallback`.","line":111,"column":58,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":111,"endColumn":81}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport * as THREE from 'three';\n\n\nimport { TabLIPEditor } from \"@/apps/forge/components/tabs/tab-lip-editor/TabLIPEditor\";\nimport { UI3DRendererView } from \"@/apps/forge/components/UI3DRendererView\";\nimport { LIPShapeLabels } from \"@/apps/forge/data/LIPShapeLabels\";\nimport { EditorFile } from \"@/apps/forge/EditorFile\";\nimport { ForgeFileSystem, ForgeFileSystemResponse } from \"@/apps/forge/ForgeFileSystem\";\nimport BaseTabStateOptions from \"@/apps/forge/interfaces/BaseTabStateOptions\";\nimport * as KotOR from \"@/apps/forge/KotOR\";\nimport { EditorTabManager } from \"@/apps/forge/managers/EditorTabManager\";\nimport { SceneGraphNode } from \"@/apps/forge/SceneGraphNode\";\nimport { TabLIPEditorOptionsState } from \"@/apps/forge/states/tabs/tab-lip-editor/TabLIPEditorOptionsState\";\nimport { TabState, TabStateEventListenerTypes, TabStateEventListeners } from \"@/apps/forge/states/tabs/TabState\";\nimport { UI3DRenderer } from \"@/apps/forge/UI3DRenderer\";\nimport { ILIPKeyFrame } from \"@/interface/resource/ILIPKeyFrame\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\nconst log = createScopedLogger(LogScope.Forge);\nconst DEFAULT_HEAD = 'p_bastilah';\n\nexport type TabLIPEditorStateEventListenerTypes =\nTabStateEventListenerTypes &\n  ''|'onLIPLoaded'|'onPlay'|'onPause'|'onStop'|'onAudioLoad'|'onHeadChange'|\n  'onHeadLoad'|'onKeyFrameSelect'|'onKeyFrameTrackZoomIn'|'onKeyFrameTrackZoomOut'|\n  'onAnimate'|'onKeyFramesChange'|'onDurationChange';\n\nexport interface TabLIPEditorStateEventListeners extends TabStateEventListeners {\n  onLIPLoaded: (() => void)[];\n  onPlay: (() => void)[];\n  onPause: (() => void)[];\n  onStop: (() => void)[];\n  onAudioLoad: (() => void)[];\n  onHeadChange: (() => void)[];\n  onHeadLoad: (() => void)[];\n  onKeyFrameSelect: (() => void)[];\n  onKeyFrameTrackZoomIn: (() => void)[];\n  onKeyFrameTrackZoomOut: (() => void)[];\n  onAnimate: (() => void)[];\n  onKeyFramesChange: (() => void)[];\n  onDurationChange: (() => void)[];\n}\n\nexport class TabLIPEditorState extends TabState {\n\n  tabName: string = `LIP Editor`;\n\n  //Lip\n  lip: KotOR.LIPObject = new KotOR.LIPObject(new Uint8Array(0));\n\n  //Audio\n  gainNode: GainNode;\n  source: AudioBufferSourceNode;\n  preview_gain: number = 0.5;\n  audio_buffer: AudioBuffer;\n  playbackRate: number = 1;\n\n  utilitiesTabManager: EditorTabManager = new EditorTabManager();\n  lipOptionsTab: TabLIPEditorOptionsState;\n\n  animLoop: boolean;\n  playing: boolean = false;\n  seeking: boolean;\n  scrubbing: boolean = false;\n  preScrubbingPlayState: boolean = false;\n  scrubbingTimeout: NodeJS.Timeout|number;\n  current_head: string = DEFAULT_HEAD;\n  audio_name: string;\n  selected_frame: ILIPKeyFrame;\n  dragging_frame: ILIPKeyFrame|undefined;\n  dragging_frame_snapshot: ILIPKeyFrame;\n  poseFrame: boolean;\n  max_timeline_zoom: number = 1000;\n  min_timeline_zoom: number = 50;\n  timeline_zoom: number = 250;\n\n  scrubDuration: number|undefined;\n\n  head: KotOR.OdysseyModel3D;\n  head_hook: THREE.Object3D = new THREE.Object3D();\n  pointLight: THREE.PointLight;\n\n  ui3DRenderer: UI3DRenderer;\n  box3: THREE.Box3 = new THREE.Box3();\n\n  keyframesSceneGraphNode: SceneGraphNode = new SceneGraphNode({\n    name: 'Key Frames',\n    open: true,\n  });\n\n  constructor(options: BaseTabStateOptions = {}){\n    super(options);\n    this.isClosable = true;\n\n    if(this.file){\n      this.tabName = this.file.getFilename();\n    }\n\n    //Audio\n    this.gainNode = KotOR.AudioEngine.GetAudioEngine().audioCtx.createGain();\n    this.gainNode.gain.value = this.preview_gain;\n    this.source = KotOR.AudioEngine.GetAudioEngine().audioCtx.createBufferSource();\n\n    this.current_head = localStorage.getItem('lip_head') !== null ? localStorage.getItem('lip_head') as string : DEFAULT_HEAD;\n\n    this.ui3DRenderer = new UI3DRenderer();\n    this.ui3DRenderer.scene.add(this.head_hook);\n    this.ui3DRenderer.addEventListener('onBeforeRender', this.animate.bind(this));\n\n    this.ui3DRenderer.sceneGraphManager.parentNodes.push(this.keyframesSceneGraphNode);\n\n    this.lipOptionsTab = new TabLIPEditorOptionsState({\n      parentTab: this\n    });\n\n    this.utilitiesTabManager.addTab(this.lipOptionsTab);\n\n    this.setContentView(<TabLIPEditor tab={this}></TabLIPEditor>);\n\n    this.saveTypes = [\n      {\n        description: 'Odyssey Lipsync File',\n        accept: {\n          'application/octet-stream': ['.lip']\n        }\n      }\n    ];\n  }\n\n  show(): void {\n    super.show();\n    this.ui3DRenderer.enabled = true;\n\n    this.ui3DRenderer.camera.position.set(0.0, 0.5, 0.1);\n    this.ui3DRenderer.camera.lookAt(0, 0, 0);\n\n    this.ui3DRenderer.render();\n  }\n\n  hide(): void {\n    super.hide();\n    this.ui3DRenderer.enabled = false;\n  }\n\n  openFile(file?: EditorFile){\n    return new Promise<KotOR.LIPObject>( (resolve, reject) => {\n      if(!file && this.file instanceof EditorFile){\n        file = this.file;\n      }\n      if(file instanceof EditorFile){\n        if(this.file != file) this.file = file;\n        file.readFile().then( (response) => {\n          new KotOR.LIPObject(response.buffer, (lip: KotOR.LIPObject) => {\n            this.lip = lip;\n\n            if(typeof this.lip.file != 'string')\n              this.lip.file = this.file.resref + '.' + KotOR.ResourceTypes.getKeyByValue(this.file.reskey);\n\n            this.setDuration(this.lip.duration);\n\n            if(this.lip.keyframes.length){\n              this.selectKeyFrame(this.lip.keyframes[0]);\n            }\n            this.reloadKeyFrames();\n            this.processEventListener<TabLIPEditorStateEventListenerTypes>('onLIPLoaded', [this.lip]);\n\n            this.loadSound(this.file.resref).then( () => {\n              this.loadHead(this.current_head).then( () => {\n                resolve(this.lip);\n              });\n            });\n          });\n        });\n      }\n    });\n  }\n\n  loadHead(model_name = DEFAULT_HEAD){\n    return new Promise<void>( (resolve, reject) => {\n      KotOR.MDLLoader.loader.load(model_name)\n      .then((mdl: KotOR.OdysseyModel) => {\n        this.current_head = model_name;\n        localStorage.setItem('lip_head', this.current_head);\n        KotOR.OdysseyModel3D.FromMDL(mdl, {\n          context: this.ui3DRenderer,\n          castShadow: true,\n          receiveShadow: true,\n        }).then((model: KotOR.OdysseyModel3D) => {\n\n          if(this.head instanceof THREE.Object3D){\n            this.head.parent?.remove(this.head);\n          }\n\n          this.head = model;\n          this.head_hook.add(this.head);\n          this.box3.setFromObject(this.head);\n\n          this.head.odysseyAnimations.sort((a: KotOR.OdysseyModelAnimation, b: KotOR.OdysseyModelAnimation) => (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : ((b.name.toLowerCase() > a.name.toLowerCase()) ? -1 : 0))\n          this.head.playAnimation('tlknorm', true);\n\n          this.head.userData.moduleObject = {\n            lipObject: this.lip\n          };\n\n          this.processEventListener<TabLIPEditorStateEventListenerTypes>('onHeadLoad', [model]);\n          resolve();\n        }).catch(resolve)\n      }).catch(resolve)\n    });\n  }\n\n  loadSound(sound = 'nm35aabast06217_'){\n    return new Promise<void>( (resolve, reject) => {\n      KotOR.AudioLoader.LoadStreamWave(sound).then((data: Uint8Array | ArrayBuffer) => {\n        this.audio_name = sound;\n        const arrayBuffer = data instanceof ArrayBuffer ? data : (data as Uint8Array).buffer.slice(0) as ArrayBuffer;\n        KotOR.AudioEngine.GetAudioEngine().audioCtx.decodeAudioData(arrayBuffer, (buffer: AudioBuffer) => {\n          this.audio_buffer = buffer;\n          this.processEventListener<TabLIPEditorStateEventListenerTypes>('onAudioLoad', [this, buffer]);\n          resolve();\n        });\n      }, (_e: unknown) => {\n        resolve();\n      });\n    });\n  }\n\n  animate(delta: number = 0){\n    delta *= this.playbackRate;\n    if(this.head){\n      this.head.update(delta);\n\n      if(this.ui3DRenderer){\n        const center: THREE.Vector3 = new THREE.Vector3;\n        this.box3.getCenter(center);\n        const size: THREE.Vector3 = new THREE.Vector3;\n        this.box3.getSize(size);\n        //Center the object to 0\n        this.head.position.set(-center.x, -center.y, -center.z);\n        this.ui3DRenderer.camera.position.z = 0;\n        this.ui3DRenderer.camera.position.y = size.x + size.y + size.z;\n        this.ui3DRenderer.camera.lookAt(new THREE.Vector3)\n      }\n    }\n\n    if(this.lip instanceof KotOR.LIPObject && this.head instanceof KotOR.OdysseyModel3D){\n      const last_time = this.lip.elapsed;\n\n      this.updateLip(0);\n\n      if(this.playing || this.poseFrame){\n        this.updateLip(delta);\n        if(typeof this.scrubDuration === 'number'){\n          this.scrubDuration -= delta;\n          if(this.scrubDuration <= 0){\n            this.scrubDuration = undefined;\n            this.pause();\n          }\n        }\n      }\n\n      if(this.poseFrame){\n        this.poseFrame = false;\n        this.lip.elapsed = last_time;\n      }\n\n      if(this.lip.elapsed > this.lip.duration){\n        this.lip.elapsed = this.lip.duration;\n        this.stop();\n      }\n    }\n\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onAnimate', [delta]);\n  }\n\n  updateLip(delta = 0){\n    if(this.lip instanceof KotOR.LIPObject && this.head instanceof KotOR.OdysseyModel3D){\n      this.lip.update(delta, this.head);\n    }\n  }\n\n  private resetAudio(){\n    try{\n      this.source.disconnect();\n      this.source.stop(0);\n    }catch(e){ }\n  }\n\n  play(duration: number|undefined = undefined){\n\n    this.resetAudio();\n    this.source = KotOR.AudioEngine.GetAudioEngine().audioCtx.createBufferSource();\n\n    try{\n      this.source.buffer = this.audio_buffer;\n      this.source.connect(this.gainNode);\n      this.gainNode.connect(KotOR.AudioEngine.GetAudioEngine().audioCtx.destination);\n      this.source.loop = false;\n      this.source.playbackRate.value = this.playbackRate;\n\n      if(this.lip instanceof KotOR.LIPObject){\n        this.source.start(0, this.lip.elapsed, duration);\n      }else{\n        this.source.start(0, 0, duration);\n      }\n    }catch(e){}\n\n    this.poseFrame = true;\n    this.playing = true;\n    this.scrubDuration = duration;\n    if(this.lip instanceof KotOR.LIPObject){\n      if(this.lip.elapsed >= this.lip.duration){\n        this.lip.elapsed = 0;\n      }\n    }\n\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onPlay');\n  }\n\n  pause(){\n    this.resetAudio();\n    this.playing = false;\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onPause');\n  }\n\n  stop(){\n    this.pause();\n    if(this.lip instanceof KotOR.LIPObject){\n      this.lip.elapsed = 0;\n    }\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onStop');\n  }\n\n  seek(time: number = 0){\n\n    const was_playing = this.playing;\n    this.pause();\n\n    if(this.lip instanceof KotOR.LIPObject){\n      if(time > this.lip.duration) time = this.lip.duration;\n      if(time < 0) time = 0;\n      this.lip.elapsed = time;\n      this.poseFrame = true;\n    }\n\n    if(was_playing) this.play();\n  }\n\n  seekAudio(time: number){\n    if(this.source){\n      try{\n        this.source.start(0, time);\n      }catch(e){\n        log.error(e as Error);\n      }\n    }\n  }\n\n  keyframeTrackZoomIn(){\n    this.timeline_zoom += 25;\n\n    if(this.timeline_zoom > this.max_timeline_zoom){\n      this.timeline_zoom = this.max_timeline_zoom;\n    }\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onKeyFrameTrackZoomIn', [this]);\n  }\n\n  keyframeTrackZoomOut(){\n    this.timeline_zoom -= 25;\n\n    if(this.timeline_zoom < this.min_timeline_zoom){\n      this.timeline_zoom = this.min_timeline_zoom;\n    }\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onKeyFrameTrackZoomOut', [this]);\n  }\n\n  selectKeyFrame(keyframe: ILIPKeyFrame){\n    if(this.lip.keyframes.indexOf(keyframe) == -1) return;\n    this.selected_frame = keyframe;\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onKeyFrameSelect', [keyframe]);\n  }\n\n  setDuration(value: number = 0){\n    this.lip.duration = value;\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onDurationChange', [value]);\n  }\n\n  selectNextKeyFrame(){\n    let index = this.lip.keyframes.indexOf(this.selected_frame);\n    if(index == -1){\n      this.selectKeyFrame(this.lip.keyframes[0]);\n    }else{\n      index++;\n      if(index < 0) index = 0;\n      if(index >= this.lip.keyframes.length){\n        index = this.lip.keyframes.length-1;\n      }\n      this.selectKeyFrame(this.lip.keyframes[index]);\n    }\n  }\n\n  selectPreviousKeyFrame(){\n    let index = this.lip.keyframes.indexOf(this.selected_frame);\n    if(index == -1){\n      this.selectKeyFrame(this.lip.keyframes[0]);\n    }else{\n      index--;\n      if(index < 0) index = 0;\n      if(index >= this.lip.keyframes.length){\n        index = this.lip.keyframes.length-1;\n      }\n      this.selectKeyFrame(this.lip.keyframes[index]);\n    }\n  }\n\n  addKeyFrame(time: number = 0, shape: number = 0){\n    const newFrame = this.lip.addKeyFrame(time, shape);\n    this.reloadKeyFrames();\n    this.file.unsaved_changes = true;\n    return newFrame;\n  }\n\n  reloadKeyFrames(){\n    this.keyframesSceneGraphNode.setNodes(this.getKeyframesAsSceneGraphNodes());\n    this.processEventListener<TabLIPEditorStateEventListenerTypes>('onKeyFramesChange');\n  }\n\n  getKeyframesAsSceneGraphNodes(){\n    return this.lip.keyframes.map( (frame: ILIPKeyFrame, index: number) => {\n      return new SceneGraphNode({\n        name: `${index} - ${LIPShapeLabels[frame.shape]}`,\n        data: frame,\n        onClick: (node: SceneGraphNode) => {\n          this.selectKeyFrame(node.data);\n        }\n      })\n    });\n  }\n\n  fitDurationToKeyFrames(){\n    const duration = this.lip.keyframes.reduce((a: number, b: ILIPKeyFrame) => Math.max(a, b.time), -Infinity);\n    this.setDuration(duration);\n  }\n\n  importPHN(): void {\n    ForgeFileSystem.OpenFileBuffer({ext: ['phn']}).then( (buffer: Uint8Array ) => {\n      const textDecoder = new TextDecoder();\n      let data = textDecoder.decode(buffer);\n      log.debug('phn', data);\n      const eoh = data.indexOf('END OF HEADER');\n      if(eoh > -1){\n        data = data.substr(eoh+14);\n        const keyframes = data.trim().split('\\r\\n');\n\n        log.debug('keyframes', keyframes);\n\n        this.lip.keyframes = [];\n\n        const PHN_INVALID = -1;\n        const PHN_EE = 0;\n        const PHN_EH = 1;\n        const PHN_SCHWA = 2;\n        const PHN_AH = 3;\n        const PHN_OH = 4;\n        const PHN_OOH = 5;\n        const PHN_Y = 6;\n        const PHN_S = 7;\n        const PHN_FV = 8;\n        const PHN_NNG = 9;\n        const PHN_TH = 0xA;\n        const PHN_MPB = 0xB;\n        const PHN_TD = 0xC;\n        const PHN_JSH = 0xD;\n        const PHN_L = 0xE;\n        const PHN_KG = 0xF;\n        const PHN_USE_NEXT = 0x10;\n\n        let last_shape = PHN_INVALID;\n\n        for(let i = 0; i < keyframes.length; i++){\n\n          const keyframe_data = keyframes[i].trim().split(' ');\n\n          if(!keyframe_data.length){\n            continue;\n          }\n\n          const keyframe:  {shape: number, time: number} = {\n            shape: PHN_INVALID,\n            time: parseFloat(keyframe_data[0]) * .001\n          };\n\n          switch(keyframe_data[2]){\n            case \"i:\":\n              keyframe.shape = PHN_EE;\n              break;\n            case \"I\":\n              keyframe.shape = PHN_EH;\n              break;\n            case \"I_x\":\n              keyframe.shape = PHN_EH;\n              break;\n            case \"E\":\n              keyframe.shape = PHN_EH;\n              break;\n            case \"@\":\n              keyframe.shape = PHN_AH;\n              break;\n            case \"A\":\n              keyframe.shape = PHN_AH;\n              break;\n            case \"^\":\n              keyframe.shape = PHN_AH;\n              break;\n            case \">\":\n              keyframe.shape = PHN_SCHWA;\n              break;\n            case \"U\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"u\":\n              keyframe.shape = PHN_OOH;\n              break;\n            case \"u_x\":\n              keyframe.shape = PHN_OOH;\n              break;\n            case \"&\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"&_0\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"3r\":\n              keyframe.shape = PHN_SCHWA;\n              break;\n            case \"&r\":\n              keyframe.shape = PHN_SCHWA;\n              break;\n            case \"5\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"ei\":\n              keyframe.shape = PHN_EH;\n              break;\n            case \">i\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"aI\":\n              keyframe.shape = PHN_AH;\n              break;\n            case \"aU\":\n              keyframe.shape = PHN_AH;\n              break;\n            case \"oU\":\n              keyframe.shape = PHN_OH;\n              break;\n            case \"iU\":\n              keyframe.shape = PHN_EE;\n              break;\n            case \"i&\":\n              keyframe.shape = PHN_EE;\n              break;\n            case \"u&\":\n              keyframe.shape = PHN_OOH;\n              break;\n            case \"e&\":\n              keyframe.shape = PHN_EH;\n              break;\n\n            case \"ph\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"pc\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"b\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"bc\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"th\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"tc\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"d\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"dc\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"kh\":\n              keyframe.shape = PHN_KG;\n              break;\n            case \"kc\":\n              keyframe.shape = PHN_KG;\n              break;\n            case \"g\":\n              keyframe.shape = PHN_KG;\n              break;\n            case \"gc\":\n              keyframe.shape = PHN_KG;\n              break;\n            case \"f\":\n              keyframe.shape = PHN_FV;\n              break;\n            case \"v\":\n              keyframe.shape = PHN_FV;\n              break;\n            case \"T\":\n              keyframe.shape = PHN_TH;\n              break;\n            case \"D\":\n              keyframe.shape = PHN_TH;\n              break;\n            case \"s\":\n              keyframe.shape = PHN_S;\n              break;\n            case \"z\":\n              keyframe.shape = PHN_S;\n              break;\n            case \"S\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"Z\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"h\":\n              keyframe.shape = PHN_USE_NEXT;\n              break;\n            case \"h_v\":\n              keyframe.shape = PHN_USE_NEXT;\n              break;\n            case \"tS\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"tSc\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"dZ\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"dZc\":\n              keyframe.shape = PHN_JSH;\n              break;\n            case \"m\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"n\":\n              keyframe.shape = PHN_NNG;\n              break;\n            case \"N\":\n              keyframe.shape = PHN_NNG;\n              break;\n            case \"d_(\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"th_(\":\n              keyframe.shape = PHN_TD;\n              break;\n            case \"n_(\":\n              keyframe.shape = PHN_NNG;\n              break;\n            case \"l=\":\n              keyframe.shape = PHN_L;\n              break;\n            case \"m=\":\n              keyframe.shape = PHN_MPB;\n              break;\n            case \"n=\":\n              keyframe.shape = PHN_NNG;\n              break;\n            case \"l\":\n              keyframe.shape = PHN_L;\n              break;\n            case \"9r\":\n              keyframe.shape = PHN_L;\n              break;\n            case \"j\":\n              keyframe.shape = PHN_Y;\n              break;\n            case \"w\":\n              keyframe.shape = PHN_OOH;\n              break;\n            case \"+\":\n              keyframe.shape = PHN_MPB;\n              break;\n            default:\n              keyframe.shape = PHN_INVALID;\n            break;\n          }\n\n          if(keyframe.shape == last_shape || keyframe.shape == PHN_INVALID){\n            log.debug('skipping');\n            continue;\n          }\n\n          this.lip.addKeyFrame(keyframe.time, keyframe.shape);\n          this.lip.duration = parseFloat(keyframe_data[1]) * .001;\n\n          last_shape = keyframe.shape;\n        }\n\n        this.lip.reIndexKeyframes();\n        this.selectKeyFrame(this.lip.keyframes[0]);\n        this.lip.elapsed = 0;\n\n      }\n    });\n  }\n\n  async getExportBuffer(resref?: string, ext?: string): Promise<Uint8Array> {\n    if(this.lip){\n      return this.lip.toExportBuffer();\n    }\n    return super.getExportBuffer(resref, ext);\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.ui3DRenderer.removeEventListener('onBeforeRender', this.animate);\n    this.ui3DRenderer.destroy();\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\utils\\DLGClipboardManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":220,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":220,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .type on an `any` value.","line":222,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":222,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `DLGNodeSerialized`.","line":226,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":226,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .node on an `any` value.","line":226,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":226,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":229,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":229,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .nodeType on an `any` value.","line":229,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":229,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":230,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":230,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .listIndex on an `any` value.","line":230,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":230,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":232,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":232,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isCut on an `any` value.","line":232,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":232,"endColumn":26}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DLGClipboardManager class.\n *\n * Manages copy/paste operations for DLG nodes.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file DLGClipboardManager.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\n\n\nimport { DLGNodeType } from '@/enums/dialog/DLGNodeType';\nimport { DLGNode } from '@/resource/DLGNode';\nimport { createScopedLogger, LogScope } from '@/utility/Logger';\n\nconst log = createScopedLogger(LogScope.Forge);\n\nexport interface DLGNodeSerialized {\n  nodeType: number;\n  text?: string;\n  comment?: string;\n  speakerTag?: string;\n  listenerTag?: string;\n  vo_resref?: string;\n  sound?: string;\n  delay?: number;\n  cameraAngle?: number;\n  cameraID?: number;\n}\n\nexport interface ClipboardData {\n  node: DLGNode;\n  nodeType: DLGNodeType;\n  listIndex: number;\n  timestamp: number;\n  isCut: boolean;\n}\n\nexport class DLGClipboardManager {\n  private clipboard: ClipboardData | null = null;\n  private changeListeners: (() => void)[] = [];\n\n  /**\n   * Copy a node to clipboard\n   */\n  public copy(node: DLGNode, nodeType: DLGNodeType, listIndex: number): void {\n    this.clipboard = {\n      node: this.cloneNode(node),\n      nodeType,\n      listIndex,\n      timestamp: Date.now(),\n      isCut: false\n    };\n\n    this.notifyChange();\n  }\n\n  /**\n   * Cut a node to clipboard\n   */\n  public cut(node: DLGNode, nodeType: DLGNodeType, listIndex: number): void {\n    this.clipboard = {\n      node: this.cloneNode(node),\n      nodeType,\n      listIndex,\n      timestamp: Date.now(),\n      isCut: true\n    };\n\n    this.notifyChange();\n  }\n\n  /**\n   * Get clipboard data\n   */\n  public getClipboard(): ClipboardData | null {\n    return this.clipboard;\n  }\n\n  /**\n   * Check if clipboard has data\n   */\n  public hasClipboard(): boolean {\n    return this.clipboard !== null;\n  }\n\n  /**\n   * Check if clipboard is cut operation\n   */\n  public isCut(): boolean {\n    return this.clipboard?.isCut || false;\n  }\n\n  /**\n   * Clear clipboard\n   */\n  public clear(): void {\n    this.clipboard = null;\n    this.notifyChange();\n  }\n\n  /**\n   * Clone a DLG node (deep copy)\n   */\n  private cloneNode(node: DLGNode): DLGNode {\n    // Create a new node with the same dialog parent\n    const cloned = new DLGNode(node.dialog);\n\n    // Copy basic properties\n    cloned.nodeType = node.nodeType;\n    cloned.nodeEngineType = node.nodeEngineType;\n    cloned.cameraAngle = node.cameraAngle;\n    cloned.cameraID = node.cameraID;\n    cloned.cameraAnimation = node.cameraAnimation;\n    cloned.camFieldOfView = node.camFieldOfView;\n    cloned.camVidEffect = node.camVidEffect;\n    cloned.comment = node.comment;\n    cloned.delay = node.delay;\n    cloned.fadeType = node.fadeType;\n    cloned.listenerTag = node.listenerTag;\n    cloned.plotIndex = node.plotIndex;\n    cloned.plotXPPercentage = node.plotXPPercentage;\n    cloned.quest = node.quest;\n    cloned.questEntry = node.questEntry;\n    cloned.sound = node.sound;\n    cloned.soundExists = node.soundExists;\n    cloned.speakerTag = node.speakerTag;\n    cloned.text = node.text;\n    cloned.vo_resref = node.vo_resref;\n    cloned.waitFlags = node.waitFlags;\n    cloned.Logic = node.Logic;\n    cloned.isChild = node.isChild;\n    cloned.alienRaceNode = node.alienRaceNode;\n    cloned.emotion = node.emotion;\n    cloned.facialAnimation = node.facialAnimation;\n    cloned.postProcessNode = node.postProcessNode;\n    cloned.recordNoVOOverride = node.recordNoVOOverride;\n    cloned.recordVO = node.recordVO;\n    cloned.voTextChanged = node.voTextChanged;\n\n    // Copy animations (shallow copy of array)\n    cloned.animations = [...node.animations];\n\n    // Don't copy references (replies/entries), as these will need to be re-linked\n    // in the paste operation\n    cloned.replies = [];\n    cloned.entries = [];\n\n    // Copy scripts (references, not deep clones)\n    cloned.script = node.script;\n    cloned.scriptParams = { ...node.scriptParams };\n    cloned.script2 = node.script2;\n    cloned.script2Params = { ...node.script2Params };\n    cloned.isActive = node.isActive;\n    cloned.isActiveParams = { ...node.isActiveParams };\n    cloned.isActive2 = node.isActive2;\n    cloned.isActive2Params = { ...node.isActive2Params };\n\n    // Copy fade settings\n    cloned.fade = {\n      type: node.fade.type,\n      length: node.fade.length,\n      delay: node.fade.delay,\n      color: { ...node.fade.color },\n      started: false\n    };\n\n    return cloned;\n  }\n\n  /**\n   * Register a change listener\n   */\n  public onChange(listener: () => void): () => void {\n    this.changeListeners.push(listener);\n    return () => {\n      const index = this.changeListeners.indexOf(listener);\n      if (index > -1) {\n        this.changeListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Notify all listeners\n   */\n  private notifyChange(): void {\n    this.changeListeners.forEach(listener => listener());\n  }\n\n  /**\n   * Export clipboard to system clipboard\n   */\n  public async exportToSystemClipboard(): Promise<void> {\n    if (!this.clipboard) return;\n\n    const data = {\n      type: 'kotor-dlg-node',\n      node: this.serializeNode(this.clipboard.node),\n      nodeType: this.clipboard.nodeType,\n      listIndex: this.clipboard.listIndex,\n      isCut: this.clipboard.isCut\n    };\n\n    try {\n      await navigator.clipboard.writeText(JSON.stringify(data));\n    } catch (error) {\n      log.error('Failed to write to system clipboard:', error);\n    }\n  }\n\n  /**\n   * Import clipboard from system clipboard\n   */\n  public async importFromSystemClipboard(): Promise<boolean> {\n    try {\n      const text = await navigator.clipboard.readText();\n      const data = JSON.parse(text);\n\n      if (data.type !== 'kotor-dlg-node') {\n        return false;\n      }\n\n      const node = this.deserializeNode(data.node);\n      this.clipboard = {\n        node,\n        nodeType: data.nodeType,\n        listIndex: data.listIndex,\n        timestamp: Date.now(),\n        isCut: data.isCut || false\n      };\n\n      this.notifyChange();\n      return true;\n    } catch (error) {\n      log.error('Failed to read from system clipboard:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Serialize a node for clipboard export\n   */\n  private serializeNode(node: DLGNode): DLGNodeSerialized {\n    return {\n      nodeType: node.nodeType,\n      text: node.text,\n      comment: node.comment,\n      speakerTag: node.speakerTag,\n      listenerTag: node.listenerTag,\n      vo_resref: node.vo_resref,\n      sound: node.sound,\n      delay: node.delay,\n      cameraAngle: node.cameraAngle,\n      cameraID: node.cameraID,\n      // ... include other serializable properties\n    };\n  }\n\n  /**\n   * Deserialize a node from clipboard import\n   */\n  private deserializeNode(data: DLGNodeSerialized): DLGNode {\n    const node = new DLGNode();\n    node.nodeType = data.nodeType as DLGNodeType;\n    node.text = data.text ?? '';\n    node.comment = data.comment ?? '';\n    node.speakerTag = data.speakerTag ?? '';\n    node.listenerTag = data.listenerTag ?? '';\n    node.vo_resref = data.vo_resref ?? '';\n    node.sound = data.sound ?? '';\n    node.delay = data.delay ?? 0;\n    node.cameraAngle = data.cameraAngle ?? 0;\n    node.cameraID = data.cameraID ?? 0;\n    // ... restore other properties\n    return node;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\utils\\DLGTreeModel.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":205,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":205,"endColumn":54},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":223,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":223,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DLGTreeModel class.\n *\n * Manages the tree structure and hierarchy for DLG nodes in the editor.\n * Based on PyKotor's DLGStandardItemModel implementation.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file DLGTreeModel.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\n\nimport { DLGTreeNode, DLGNodePath, DLGNodeReference } from \"@/apps/forge/interfaces/DLGTreeNode\";\nimport { DLGNodeType } from \"@/enums/dialog/DLGNodeType\";\nimport { DLGNode } from \"@/resource/DLGNode\";\nimport { DLGObject } from \"@/resource/DLGObject\";\n\nexport class DLGTreeModel {\n  private rootNodes: DLGTreeNode[] = [];\n  private nodeMap: Map<string, DLGTreeNode> = new Map();\n  private dlg: DLGObject;\n  private nextId: number = 0;\n  private changeListeners: ((nodes: DLGTreeNode[]) => void)[] = [];\n  private selectionListeners: ((node: DLGTreeNode | null) => void)[] = [];\n  private selectedNode: DLGTreeNode | null = null;\n\n  constructor(dlg: DLGObject) {\n    this.dlg = dlg;\n    this.buildTree();\n  }\n\n  /**\n   * Build the complete tree structure from the DLG object\n   */\n  private buildTree(): void {\n    this.rootNodes = [];\n    this.nodeMap.clear();\n    this.nextId = 0;\n\n    // Create starting nodes (root level)\n    this.dlg.startingList.forEach((startNode, index) => {\n      const treeNode = this.createTreeNode(startNode, index, DLGNodeType.STARTING, null, [index]);\n      this.rootNodes.push(treeNode);\n    });\n\n    this.notifyChange();\n  }\n\n  /**\n   * Create a tree node from a DLG node\n   */\n  private createTreeNode(\n    dlgNode: DLGNode,\n    listIndex: number,\n    nodeType: DLGNodeType,\n    parent: DLGTreeNode | null,\n    path: number[]\n  ): DLGTreeNode {\n    const id = this.generateId();\n    const treeNode: DLGTreeNode = {\n      id,\n      dlgNode,\n      parent: parent || undefined,\n      children: [],\n      listIndex,\n      nodeType,\n      expanded: false,\n      selected: false,\n      isCopy: false,\n      childrenLoaded: false,\n      path,\n      visible: true,\n      hasConditions: this.nodeHasConditions(dlgNode),\n      hasActions: this.nodeHasActions(dlgNode),\n      isOrphan: false,\n      depth: parent ? parent.depth + 1 : 0\n    };\n\n    this.nodeMap.set(id, treeNode);\n    return treeNode;\n  }\n\n  /**\n   * Check if a node has conditional scripts\n   */\n  private nodeHasConditions(node: DLGNode): boolean {\n    return !!(node.isActive || node.isActive2);\n  }\n\n  /**\n   * Check if a node has action scripts\n   */\n  private nodeHasActions(node: DLGNode): boolean {\n    return !!(node.script || node.script2);\n  }\n\n  /**\n   * Generate a unique ID for a tree node\n   */\n  private generateId(): string {\n    return `dlg-node-${this.nextId++}`;\n  }\n\n  /**\n   * Load children for a tree node (lazy loading)\n   */\n  public loadChildren(treeNode: DLGTreeNode): void {\n    if (treeNode.childrenLoaded) return;\n\n    const dlgNode = treeNode.dlgNode;\n\n    // For starting nodes, load the linked entry\n    if (treeNode.nodeType === DLGNodeType.STARTING) {\n      dlgNode.entries.forEach((entryNode, idx) => {\n        const childPath = [...treeNode.path, idx];\n        const entryTreeNode = this.createTreeNode(\n          entryNode,\n          entryNode.index,\n          DLGNodeType.ENTRY,\n          treeNode,\n          childPath\n        );\n        treeNode.children.push(entryTreeNode);\n      });\n    }\n    // For entry nodes, load reply links\n    else if (treeNode.nodeType === DLGNodeType.ENTRY) {\n      dlgNode.replies.forEach((replyNode, idx) => {\n        const childPath = [...treeNode.path, idx];\n        const replyTreeNode = this.createTreeNode(\n          replyNode,\n          replyNode.index,\n          DLGNodeType.REPLY,\n          treeNode,\n          childPath\n        );\n        treeNode.children.push(replyTreeNode);\n      });\n    }\n    // For reply nodes, load entry links\n    else if (treeNode.nodeType === DLGNodeType.REPLY) {\n      dlgNode.entries.forEach((entryNode, idx) => {\n        const childPath = [...treeNode.path, idx];\n        const entryTreeNode = this.createTreeNode(\n          entryNode,\n          entryNode.index,\n          DLGNodeType.ENTRY,\n          treeNode,\n          childPath\n        );\n        treeNode.children.push(entryTreeNode);\n      });\n    }\n\n    treeNode.childrenLoaded = true;\n    this.notifyChange();\n  }\n\n  /**\n   * Toggle node expansion\n   */\n  public toggleExpanded(nodeId: string): void {\n    const node = this.nodeMap.get(nodeId);\n    if (!node) return;\n\n    if (!node.expanded && !node.childrenLoaded) {\n      this.loadChildren(node);\n    }\n\n    node.expanded = !node.expanded;\n    this.notifyChange();\n  }\n\n  /**\n   * Expand a node\n   */\n  public expandNode(nodeId: string): void {\n    const node = this.nodeMap.get(nodeId);\n    if (!node) return;\n\n    if (!node.childrenLoaded) {\n      this.loadChildren(node);\n    }\n\n    node.expanded = true;\n    this.notifyChange();\n  }\n\n  /**\n   * Collapse a node\n   */\n  public collapseNode(nodeId: string): void {\n    const node = this.nodeMap.get(nodeId);\n    if (!node) return;\n\n    node.expanded = false;\n    this.notifyChange();\n  }\n\n  /**\n   * Expand all nodes in a subtree\n   */\n  public expandAll(nodeId?: string): void {\n    const nodes = nodeId ? [this.nodeMap.get(nodeId)!] : this.rootNodes;\n\n    const expandRecursive = (node: DLGTreeNode) => {\n      if (!node.childrenLoaded) {\n        this.loadChildren(node);\n      }\n      node.expanded = true;\n      node.children.forEach(expandRecursive);\n    };\n\n    nodes.forEach(expandRecursive);\n    this.notifyChange();\n  }\n\n  /**\n   * Collapse all nodes in a subtree\n   */\n  public collapseAll(nodeId?: string): void {\n    const nodes = nodeId ? [this.nodeMap.get(nodeId)!] : this.rootNodes;\n\n    const collapseRecursive = (node: DLGTreeNode) => {\n      node.expanded = false;\n      node.children.forEach(collapseRecursive);\n    };\n\n    nodes.forEach(collapseRecursive);\n    this.notifyChange();\n  }\n\n  /**\n   * Select a node\n   */\n  public selectNode(nodeId: string | null): void {\n    // Deselect previous\n    if (this.selectedNode) {\n      this.selectedNode.selected = false;\n    }\n\n    // Select new\n    if (nodeId) {\n      const node = this.nodeMap.get(nodeId);\n      if (node) {\n        node.selected = true;\n        this.selectedNode = node;\n        this.notifySelection(node);\n      }\n    } else {\n      this.selectedNode = null;\n      this.notifySelection(null);\n    }\n\n    this.notifyChange();\n  }\n\n  /**\n   * Get the currently selected node\n   */\n  public getSelectedNode(): DLGTreeNode | null {\n    return this.selectedNode;\n  }\n\n  /**\n   * Get a node by ID\n   */\n  public getNode(nodeId: string): DLGTreeNode | undefined {\n    return this.nodeMap.get(nodeId);\n  }\n\n  /**\n   * Get all root nodes\n   */\n  public getRootNodes(): DLGTreeNode[] {\n    return this.rootNodes;\n  }\n\n  /**\n   * Get a flattened list of all visible nodes (respecting expansion state)\n   */\n  public getVisibleNodes(): DLGTreeNode[] {\n    const visible: DLGTreeNode[] = [];\n\n    const traverse = (node: DLGTreeNode) => {\n      if (node.visible) {\n        visible.push(node);\n        if (node.expanded && node.childrenLoaded) {\n          node.children.forEach(traverse);\n        }\n      }\n    };\n\n    this.rootNodes.forEach(traverse);\n    return visible;\n  }\n\n  /**\n   * Get all nodes (including non-visible)\n   */\n  public getAllNodes(): DLGTreeNode[] {\n    return Array.from(this.nodeMap.values());\n  }\n\n  /**\n   * Find nodes matching a filter\n   */\n  public filterNodes(predicate: (node: DLGTreeNode) => boolean): DLGTreeNode[] {\n    return Array.from(this.nodeMap.values()).filter(predicate);\n  }\n\n  /**\n   * Search for nodes by text\n   */\n  public searchByText(query: string, caseSensitive: boolean = false): DLGTreeNode[] {\n    const searchTerm = caseSensitive ? query : query.toLowerCase();\n\n    return this.filterNodes(node => {\n      const text = caseSensitive ? node.dlgNode.text : node.dlgNode.text.toLowerCase();\n      const comment = caseSensitive ? node.dlgNode.comment : node.dlgNode.comment.toLowerCase();\n      const speaker = caseSensitive ? node.dlgNode.speakerTag : node.dlgNode.speakerTag.toLowerCase();\n\n      return text.includes(searchTerm) ||\n             comment.includes(searchTerm) ||\n             speaker.includes(searchTerm);\n    });\n  }\n\n  /**\n   * Get the path to a node (list of indices from root)\n   */\n  public getNodePath(nodeId: string): number[] | null {\n    const node = this.nodeMap.get(nodeId);\n    return node ? node.path : null;\n  }\n\n  /**\n   * Get a node by path\n   */\n  public getNodeByPath(path: number[]): DLGTreeNode | null {\n    let current: DLGTreeNode[] = this.rootNodes;\n    let node: DLGTreeNode | null = null;\n\n    for (const index of path) {\n      if (index >= current.length) return null;\n      node = current[index];\n\n      // Load children if not loaded\n      if (!node.childrenLoaded && path[path.indexOf(index) + 1] !== undefined) {\n        this.loadChildren(node);\n      }\n\n      current = node.children;\n    }\n\n    return node;\n  }\n\n  /**\n   * Get all references to a specific entry/reply node\n   */\n  public getNodeReferences(listIndex: number, nodeType: DLGNodeType): DLGNodeReference[] {\n    const references: DLGNodeReference[] = [];\n\n    this.getAllNodes().forEach(treeNode => {\n      treeNode.children.forEach((child, idx) => {\n        if (child.listIndex === listIndex && child.nodeType === nodeType) {\n          references.push({\n            sourceNode: treeNode,\n            targetNode: child,\n            linkIndex: idx\n          });\n        }\n      });\n    });\n\n    return references;\n  }\n\n  /**\n   * Check if a node is an orphan (has no references)\n   */\n  public isNodeOrphan(listIndex: number, nodeType: DLGNodeType): boolean {\n    const references = this.getNodeReferences(listIndex, nodeType);\n    return references.length === 0;\n  }\n\n  /**\n   * Mark orphan nodes\n   */\n  public markOrphans(): void {\n    // Reset all orphan flags\n    this.getAllNodes().forEach(node => {\n      node.isOrphan = false;\n    });\n\n    // Check entries\n    this.dlg.entryList.forEach((entry, index) => {\n      const isOrphan = this.isNodeOrphan(index, DLGNodeType.ENTRY);\n      // Mark all tree nodes representing this entry\n      this.filterNodes(node =>\n        node.listIndex === index && node.nodeType === DLGNodeType.ENTRY\n      ).forEach(node => {\n        node.isOrphan = isOrphan;\n      });\n    });\n\n    // Check replies\n    this.dlg.replyList.forEach((reply, index) => {\n      const isOrphan = this.isNodeOrphan(index, DLGNodeType.REPLY);\n      // Mark all tree nodes representing this reply\n      this.filterNodes(node =>\n        node.listIndex === index && node.nodeType === DLGNodeType.REPLY\n      ).forEach(node => {\n        node.isOrphan = isOrphan;\n      });\n    });\n\n    this.notifyChange();\n  }\n\n  /**\n   * Add a new starting node\n   */\n  public addStartingNode(entryIndex: number): void {\n    // Create a minimal starting node structure\n    const startNode = new DLGNode(this.dlg);\n    startNode.nodeType = DLGNodeType.STARTING;\n\n    // Link to the entry\n    const entry = this.dlg.entryList[entryIndex];\n    if (entry) {\n      startNode.entries = [entry];\n    }\n\n    this.dlg.startingList.push(startNode);\n\n    // Rebuild tree\n    this.buildTree();\n  }\n\n  /**\n   * Remove a starting node\n   */\n  public removeStartingNode(index: number): void {\n    if (index >= 0 && index < this.dlg.startingList.length) {\n      this.dlg.startingList.splice(index, 1);\n      this.buildTree();\n    }\n  }\n\n  /**\n   * Add a link from source to target\n   */\n  public addLink(sourceNodeId: string, targetListIndex: number, targetType: DLGNodeType): void {\n    const sourceNode = this.nodeMap.get(sourceNodeId);\n    if (!sourceNode) return;\n\n    const sourceDlgNode = sourceNode.dlgNode;\n\n    // Get the target node from the appropriate list\n    let targetDlgNode: DLGNode | undefined;\n    if (targetType === DLGNodeType.ENTRY) {\n      targetDlgNode = this.dlg.entryList[targetListIndex];\n    } else if (targetType === DLGNodeType.REPLY) {\n      targetDlgNode = this.dlg.replyList[targetListIndex];\n    }\n\n    if (!targetDlgNode) return;\n\n    // Add the link\n    if (sourceNode.nodeType === DLGNodeType.ENTRY || sourceNode.nodeType === DLGNodeType.STARTING) {\n      // Add to replies\n      if (!sourceDlgNode.replies.includes(targetDlgNode)) {\n        sourceDlgNode.replies.push(targetDlgNode);\n      }\n    } else if (sourceNode.nodeType === DLGNodeType.REPLY) {\n      // Add to entries\n      if (!sourceDlgNode.entries.includes(targetDlgNode)) {\n        sourceDlgNode.entries.push(targetDlgNode);\n      }\n    }\n\n    // Reload children\n    sourceNode.childrenLoaded = false;\n    this.loadChildren(sourceNode);\n    this.notifyChange();\n  }\n\n  /**\n   * Remove a link\n   */\n  public removeLink(sourceNodeId: string, linkIndex: number): void {\n    const sourceNode = this.nodeMap.get(sourceNodeId);\n    if (!sourceNode) return;\n\n    const sourceDlgNode = sourceNode.dlgNode;\n\n    // Remove from appropriate list\n    if (sourceNode.nodeType === DLGNodeType.ENTRY || sourceNode.nodeType === DLGNodeType.STARTING) {\n      sourceDlgNode.replies.splice(linkIndex, 1);\n    } else if (sourceNode.nodeType === DLGNodeType.REPLY) {\n      sourceDlgNode.entries.splice(linkIndex, 1);\n    }\n\n    // Reload children\n    sourceNode.children.splice(linkIndex, 1);\n    this.notifyChange();\n  }\n\n  /**\n   * Move a link within a node's children\n   */\n  public moveLink(sourceNodeId: string, fromIndex: number, toIndex: number): void {\n    const sourceNode = this.nodeMap.get(sourceNodeId);\n    if (!sourceNode) return;\n\n    const sourceDlgNode = sourceNode.dlgNode;\n\n    // Move in appropriate list\n    let list: DLGNode[];\n    if (sourceNode.nodeType === DLGNodeType.ENTRY || sourceNode.nodeType === DLGNodeType.STARTING) {\n      list = sourceDlgNode.replies;\n    } else if (sourceNode.nodeType === DLGNodeType.REPLY) {\n      list = sourceDlgNode.entries;\n    } else {\n      return;\n    }\n\n    const [moved] = list.splice(fromIndex, 1);\n    list.splice(toIndex, 0, moved);\n\n    // Reload children\n    sourceNode.childrenLoaded = false;\n    this.loadChildren(sourceNode);\n    this.notifyChange();\n  }\n\n  /**\n   * Copy a node (creates a copy flag, not a deep clone)\n   */\n  public copyNode(nodeId: string): DLGTreeNode | null {\n    const node = this.nodeMap.get(nodeId);\n    if (!node) return null;\n\n    // Create a shallow copy with copy flag\n    const copy: DLGTreeNode = {\n      ...node,\n      id: this.generateId(),\n      isCopy: true,\n      selected: false,\n      children: []\n    };\n\n    return copy;\n  }\n\n  /**\n   * Register a change listener\n   */\n  public onChange(listener: (nodes: DLGTreeNode[]) => void): () => void {\n    this.changeListeners.push(listener);\n    return () => {\n      const index = this.changeListeners.indexOf(listener);\n      if (index > -1) {\n        this.changeListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Register a selection listener\n   */\n  public onSelectionChange(listener: (node: DLGTreeNode | null) => void): () => void {\n    this.selectionListeners.push(listener);\n    return () => {\n      const index = this.selectionListeners.indexOf(listener);\n      if (index > -1) {\n        this.selectionListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Notify all listeners of changes\n   */\n  private notifyChange(): void {\n    this.changeListeners.forEach(listener => {\n      listener(this.rootNodes);\n    });\n  }\n\n  /**\n   * Notify all listeners of selection changes\n   */\n  private notifySelection(node: DLGTreeNode | null): void {\n    this.selectionListeners.forEach(listener => {\n      listener(node);\n    });\n  }\n\n  /**\n   * Refresh the entire tree\n   */\n  public refresh(): void {\n    this.buildTree();\n  }\n\n  /**\n   * Get statistics about the dialog\n   */\n  public getStatistics() {\n    return {\n      startingNodes: this.dlg.startingList.length,\n      entryNodes: this.dlg.entryList.length,\n      replyNodes: this.dlg.replyList.length,\n      totalTreeNodes: this.nodeMap.size\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\forge\\utils\\DLGUndoManager.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":64,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":64,"endColumn":41},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":81,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":81,"endColumn":41}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DLGUndoManager class.\n *\n * Manages undo/redo operations for the DLG editor.\n * Based on PyKotor's QUndoStack implementation.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file DLGUndoManager.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\n\nimport { DLGNode } from '@/resource/DLGNode';\nimport { DLGObject } from '@/resource/DLGObject';\nimport { GFFObject } from '@/resource/GFFObject';\n\nexport interface UndoAction {\n  type: string;\n  undo: () => void;\n  redo: () => void;\n  description: string;\n}\n\nexport class DLGUndoManager {\n  private undoStack: UndoAction[] = [];\n  private redoStack: UndoAction[] = [];\n  private maxStackSize: number = 100;\n  private changeListeners: (() => void)[] = [];\n\n  constructor(maxStackSize: number = 100) {\n    this.maxStackSize = maxStackSize;\n  }\n\n  /**\n   * Execute an action and add it to the undo stack\n   */\n  public execute(action: UndoAction): void {\n    // Execute the redo (initial action)\n    action.redo();\n\n    // Add to undo stack\n    this.undoStack.push(action);\n\n    // Limit stack size\n    if (this.undoStack.length > this.maxStackSize) {\n      this.undoStack.shift();\n    }\n\n    // Clear redo stack\n    this.redoStack = [];\n\n    this.notifyChange();\n  }\n\n  /**\n   * Undo the last action\n   */\n  public undo(): boolean {\n    if (this.undoStack.length === 0) {\n      return false;\n    }\n\n    const action = this.undoStack.pop()!;\n    action.undo();\n\n    this.redoStack.push(action);\n\n    this.notifyChange();\n    return true;\n  }\n\n  /**\n   * Redo the last undone action\n   */\n  public redo(): boolean {\n    if (this.redoStack.length === 0) {\n      return false;\n    }\n\n    const action = this.redoStack.pop()!;\n    action.redo();\n\n    this.undoStack.push(action);\n\n    this.notifyChange();\n    return true;\n  }\n\n  /**\n   * Check if undo is available\n   */\n  public canUndo(): boolean {\n    return this.undoStack.length > 0;\n  }\n\n  /**\n   * Check if redo is available\n   */\n  public canRedo(): boolean {\n    return this.redoStack.length > 0;\n  }\n\n  /**\n   * Get the description of the next undo action\n   */\n  public getUndoDescription(): string | null {\n    if (this.undoStack.length === 0) {\n      return null;\n    }\n    return this.undoStack[this.undoStack.length - 1].description;\n  }\n\n  /**\n   * Get the description of the next redo action\n   */\n  public getRedoDescription(): string | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n    return this.redoStack[this.redoStack.length - 1].description;\n  }\n\n  /**\n   * Clear all undo/redo history\n   */\n  public clear(): void {\n    this.undoStack = [];\n    this.redoStack = [];\n    this.notifyChange();\n  }\n\n  /**\n   * Register a change listener\n   */\n  public onChange(listener: () => void): () => void {\n    this.changeListeners.push(listener);\n    return () => {\n      const index = this.changeListeners.indexOf(listener);\n      if (index > -1) {\n        this.changeListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Notify all listeners of changes\n   */\n  private notifyChange(): void {\n    this.changeListeners.forEach(listener => listener());\n  }\n\n  /**\n   * Get undo stack size\n   */\n  public getUndoStackSize(): number {\n    return this.undoStack.length;\n  }\n\n  /**\n   * Get redo stack size\n   */\n  public getRedoStackSize(): number {\n    return this.redoStack.length;\n  }\n}\n\n/**\n * Factory functions for creating common undo actions\n */\nexport class DLGUndoActions {\n  /**\n   * Create an action for editing node text\n   */\n  static editNodeText(\n    node: DLGNode,\n    oldText: string,\n    newText: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-text',\n      description: `Edit node text`,\n      undo: () => {\n        node.text = oldText;\n      },\n      redo: () => {\n        node.text = newText;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node comment\n   */\n  static editNodeComment(\n    node: DLGNode,\n    oldComment: string,\n    newComment: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-comment',\n      description: `Edit node comment`,\n      undo: () => {\n        node.comment = oldComment;\n      },\n      redo: () => {\n        node.comment = newComment;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node speaker\n   */\n  static editNodeSpeaker(\n    node: DLGNode,\n    oldSpeaker: string,\n    newSpeaker: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-speaker',\n      description: `Edit node speaker`,\n      undo: () => {\n        node.speakerTag = oldSpeaker;\n      },\n      redo: () => {\n        node.speakerTag = newSpeaker;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node listener\n   */\n  static editNodeListener(\n    node: DLGNode,\n    oldListener: string,\n    newListener: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-listener',\n      description: `Edit node listener`,\n      undo: () => {\n        node.listenerTag = oldListener;\n      },\n      redo: () => {\n        node.listenerTag = newListener;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node VO\n   */\n  static editNodeVO(\n    node: DLGNode,\n    oldVO: string,\n    newVO: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-vo',\n      description: `Edit node voice-over`,\n      undo: () => {\n        node.vo_resref = oldVO;\n      },\n      redo: () => {\n        node.vo_resref = newVO;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node sound\n   */\n  static editNodeSound(\n    node: DLGNode,\n    oldSound: string,\n    newSound: string\n  ): UndoAction {\n    return {\n      type: 'edit-node-sound',\n      description: `Edit node sound`,\n      undo: () => {\n        node.sound = oldSound;\n      },\n      redo: () => {\n        node.sound = newSound;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node delay\n   */\n  static editNodeDelay(\n    node: DLGNode,\n    oldDelay: number,\n    newDelay: number\n  ): UndoAction {\n    return {\n      type: 'edit-node-delay',\n      description: `Edit node delay`,\n      undo: () => {\n        node.delay = oldDelay;\n      },\n      redo: () => {\n        node.delay = newDelay;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node camera angle\n   */\n  static editNodeCameraAngle(\n    node: DLGNode,\n    oldAngle: number,\n    newAngle: number\n  ): UndoAction {\n    return {\n      type: 'edit-node-camera-angle',\n      description: `Edit node camera angle`,\n      undo: () => {\n        node.cameraAngle = oldAngle;\n      },\n      redo: () => {\n        node.cameraAngle = newAngle;\n      }\n    };\n  }\n\n  /**\n   * Create an action for editing node camera ID\n   */\n  static editNodeCameraID(\n    node: DLGNode,\n    oldID: number,\n    newID: number\n  ): UndoAction {\n    return {\n      type: 'edit-node-camera-id',\n      description: `Edit node camera ID`,\n      undo: () => {\n        node.cameraID = oldID;\n      },\n      redo: () => {\n        node.cameraID = newID;\n      }\n    };\n  }\n\n  /**\n   * Create an action for adding a link\n   */\n  static addLink(\n    sourceNode: DLGNode,\n    targetNode: DLGNode,\n    isReply: boolean\n  ): UndoAction {\n    return {\n      type: 'add-link',\n      description: `Add link`,\n      undo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        const index = list.indexOf(targetNode);\n        if (index > -1) {\n          list.splice(index, 1);\n        }\n      },\n      redo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        if (!list.includes(targetNode)) {\n          list.push(targetNode);\n        }\n      }\n    };\n  }\n\n  /**\n   * Create an action for removing a link\n   */\n  static removeLink(\n    sourceNode: DLGNode,\n    targetNode: DLGNode,\n    index: number,\n    isReply: boolean\n  ): UndoAction {\n    return {\n      type: 'remove-link',\n      description: `Remove link`,\n      undo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        list.splice(index, 0, targetNode);\n      },\n      redo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        list.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Create an action for moving a link\n   */\n  static moveLink(\n    sourceNode: DLGNode,\n    fromIndex: number,\n    toIndex: number,\n    isReply: boolean\n  ): UndoAction {\n    return {\n      type: 'move-link',\n      description: `Move link`,\n      undo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        const [moved] = list.splice(toIndex, 1);\n        list.splice(fromIndex, 0, moved);\n      },\n      redo: () => {\n        const list = isReply ? sourceNode.replies : sourceNode.entries;\n        const [moved] = list.splice(fromIndex, 1);\n        list.splice(toIndex, 0, moved);\n      }\n    };\n  }\n\n  /**\n   * Create an action for adding a starting node\n   */\n  static addStartingNode(\n    dlg: DLGObject,\n    node: DLGNode,\n    index: number\n  ): UndoAction {\n    return {\n      type: 'add-starting-node',\n      description: `Add starting node`,\n      undo: () => {\n        dlg.startingList.splice(index, 1);\n      },\n      redo: () => {\n        dlg.startingList.splice(index, 0, node);\n      }\n    };\n  }\n\n  /**\n   * Create an action for removing a starting node\n   */\n  static removeStartingNode(\n    dlg: DLGObject,\n    node: DLGNode,\n    index: number\n  ): UndoAction {\n    return {\n      type: 'remove-starting-node',\n      description: `Remove starting node`,\n      undo: () => {\n        dlg.startingList.splice(index, 0, node);\n      },\n      redo: () => {\n        dlg.startingList.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Create a batch action\n   */\n  static batch(actions: UndoAction[], description: string): UndoAction {\n    return {\n      type: 'batch',\n      description,\n      undo: () => {\n        // Undo in reverse order\n        for (let i = actions.length - 1; i >= 0; i--) {\n          actions[i].undo();\n        }\n      },\n      redo: () => {\n        // Redo in forward order\n        for (const action of actions) {\n          action.redo();\n        }\n      }\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\game\\states\\AppState.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | Node`.","line":224,"column":26,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":224,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":337,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":337,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":338,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":338,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":339,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":339,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [i] on a type that cannot be resolved.","line":339,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":339,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":341,"column":11,"nodeType":"Identifier","messageId":"errorCall","endLine":341,"endColumn":19}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as KotOR from \"@/apps/game/KotOR\";\r\nimport { ApplicationEnvironment } from \"@/enums/ApplicationEnvironment\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/** Profile shape from ConfigClient.get - used by game app. */\r\nexport interface GameAppProfile {\r\n  key?: string;\r\n  full_name?: string;\r\n  directory?: string;\r\n  directory_handle?: FileSystemDirectoryHandle;\r\n  background?: string;\r\n  logo?: string;\r\n  launch?: { args?: { gameChoice?: number } };\r\n}\r\n\r\n/** EULA config stored in localStorage. */\r\ninterface EULAConfig {\r\n  key: KotOR.GameEngineType;\r\n  version: string | null;\r\n  date: string | null;\r\n  accepted: boolean;\r\n}\r\n\r\nexport class AppState {\r\n  static eulaAccepted: boolean = false;\r\n  static directoryLocated: boolean = false;\r\n  static gameKey: KotOR.GameEngineType = KotOR.GameEngineType.KOTOR;\r\n  static appProfile: GameAppProfile | undefined;\r\n  static env: ApplicationEnvironment;\r\n  static statsMode: number|undefined = undefined;\r\n\r\n  /**\r\n   * getProfile\r\n   */\r\n  static async getProfile(){\r\n    const query = new URLSearchParams(window.location.search);\r\n    await KotOR.ConfigClient.Init();\r\n    return KotOR.ConfigClient.get(`Profiles.${query.get('key')}`);\r\n  }\r\n\r\n  /**\r\n   * initApp\r\n   */\r\n  static async initApp(){\r\n    if(window.location.origin === 'file://'){\r\n      AppState.env = ApplicationEnvironment.ELECTRON;\r\n    }else{\r\n      AppState.env = ApplicationEnvironment.BROWSER;\r\n    }\r\n\r\n    AppState.appProfile = (await AppState.getProfile()) as GameAppProfile | undefined;\r\n    KotOR.ApplicationProfile.InitEnvironment(AppState.appProfile as Record<string, unknown>);\r\n\r\n    document.title = `${AppState.appProfile?.full_name ? AppState.appProfile?.full_name : 'N/A' }`;\r\n    \r\n    switch(AppState.appProfile?.launch?.args?.gameChoice){\r\n      case 2:\r\n        AppState.gameKey = KotOR.GameEngineType.TSL;\r\n      break;\r\n      default:\r\n        AppState.gameKey = KotOR.GameEngineType.KOTOR;\r\n      break;\r\n    }\r\n\r\n    const raw = window.localStorage.getItem('acceptEULA');\r\n    const eulaState: Record<string, EULAConfig> = Object.assign({}, raw ? (JSON.parse(raw) as Record<string, EULAConfig>) : {});\r\n    const gameEULAConfig = Object.assign({\r\n      key: AppState.gameKey,\r\n      version: null,\r\n      date: null,\r\n      accepted: false\r\n    }, eulaState[AppState.gameKey]);\r\n    eulaState[AppState.gameKey] = gameEULAConfig;\r\n    AppState.eulaAccepted = !!gameEULAConfig.accepted;\r\n    window.localStorage.setItem('acceptEULA', JSON.stringify(eulaState));\r\n\r\n    AppState.loaderShow();\r\n\r\n    log.debug('gameEULAConfig', gameEULAConfig);\r\n    log.debug('eulaState', eulaState);\r\n    AppState.directoryLocated = await AppState.checkGameDirectory();\r\n    if(AppState.eulaAccepted){\r\n      await AppState.loadGameDirectory();\r\n    }\r\n    AppState.processEventListener('on-ready', [AppState.eulaAccepted]);\r\n  }\r\n\r\n  /**\r\n   * acceptEULA\r\n   */\r\n  static async acceptEULA(){\r\n    AppState.eulaAccepted = true;\r\n    await AppState.loadGameDirectory();\r\n    AppState.processEventListener('on-preload', []);\r\n  }\r\n\r\n  /**\r\n   * loadGameDirectory\r\n   * - Used for Electron and Browser\r\n   */\r\n  static async loadGameDirectory(){\r\n    AppState.loaderShow();\r\n    KotOR.GameInitializer.SetLoadingMessage('Locating Game Directory...');\r\n  \r\n    if(AppState.env == ApplicationEnvironment.ELECTRON){\r\n      if(await KotOR.GameFileSystem.exists('chitin.key')){\r\n        AppState.directoryLocated = true;\r\n        AppState.processEventListener('on-preload', []);\r\n        AppState.beginGame();\r\n        return;\r\n      }\r\n      alert('Unable to locate chitin.key in the selected directory. Please try again.');\r\n    }else{\r\n      if(KotOR.ApplicationProfile.directoryHandle){\r\n        const validated = await AppState.validateDirectoryHandle(KotOR.ApplicationProfile.directoryHandle);\r\n        if(validated && await KotOR.GameFileSystem.exists('chitin.key')){\r\n          AppState.directoryLocated = true;\r\n          AppState.processEventListener('on-preload', []);\r\n          AppState.beginGame();\r\n          return;\r\n        }\r\n        alert('Unable to locate chitin.key in the selected directory. Please try again.');\r\n      }\r\n    }\r\n    AppState.directoryLocated = false;\r\n    AppState.processEventListener('on-preload', []);\r\n  }\r\n\r\n  /**\r\n   * checkGameDirectory\r\n   * - Used for Electron and Browser\r\n   */\r\n  static async checkGameDirectory(){\r\n    if(AppState.env == ApplicationEnvironment.ELECTRON){\r\n      if(await KotOR.GameFileSystem.exists('chitin.key')){\r\n        return true;\r\n      }\r\n    }else{\r\n      if(KotOR.ApplicationProfile.directoryHandle){\r\n        const validated = await AppState.validateDirectoryHandle(KotOR.ApplicationProfile.directoryHandle);\r\n        if(validated && await KotOR.GameFileSystem.exists('chitin.key')){\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Initializes the loading screen\r\n   */\r\n  static loaderInit(backgroundURL: string, logoURL: string): void {\r\n    AppState.processEventListener('on-loader-init', [backgroundURL, logoURL]);\r\n  }\r\n\r\n  /**\r\n   * Shows the loading screen\r\n   */\r\n  static loaderShow(){\r\n    AppState.processEventListener('on-loader-show', []);\r\n  }\r\n\r\n  /**\r\n   * Hides the loading screen\r\n   */\r\n  static loaderHide(){\r\n    AppState.processEventListener('on-loader-hide', []);\r\n  }\r\n\r\n  /**\r\n   * Sets the loading screen message\r\n   */\r\n  static loaderMessage(message: string): void {\r\n    AppState.processEventListener('on-loader-message', [message]);\r\n  }\r\n\r\n  /**\r\n   * beginGame\r\n   */\r\n  static async beginGame(){\r\n    KotOR.ApplicationProfile.ENV = AppState.env;\r\n    if(AppState.env == ApplicationEnvironment.ELECTRON){\r\n      KotOR.ApplicationProfile.directory = AppState.appProfile.directory;\r\n    }else{\r\n      KotOR.ApplicationProfile.directoryHandle = AppState.appProfile.directory_handle;\r\n    }\r\n    log.info('loading game...');\r\n    AppState.loaderInit(AppState.appProfile.background, AppState.appProfile.logo);\r\n    AppState.loaderShow();\r\n    KotOR.GameState.GameKey = AppState.gameKey;\r\n    KotOR.TextureLoader.GameKey = KotOR.GameState.GameKey;\r\n    KotOR.GameInitializer.AddEventListener('on-loader-message', (message: string) => {\r\n      AppState.loaderMessage(message);\r\n    });\r\n    KotOR.GameInitializer.AddEventListener('on-loader-show', () => {\r\n      AppState.loaderShow();\r\n    });\r\n    KotOR.GameInitializer.AddEventListener('on-loader-hide', () => {\r\n      AppState.loaderHide();\r\n    });\r\n\r\n    await KotOR.GameInitializer.Init(AppState.gameKey);\r\n\r\n    log.info('loaded');\r\n    KotOR.GameState.OpeningMoviesComplete = true;\r\n    KotOR.GUIListBox.InitTextures();\r\n    KotOR.OdysseyWalkMesh.Init();\r\n    KotOR.GameState.setDOMElement(document.getElementById('renderer-container') as HTMLElement);\r\n\r\n    window.addEventListener('blur', (e) => {\r\n      KotOR.AudioEngine.OnWindowFocusChange(false);\r\n    });\r\n\r\n    window.addEventListener('focus', (e) => {\r\n      KotOR.AudioEngine.OnWindowFocusChange(true);\r\n    });\r\n\r\n    AppState.processEventListener('on-game-loaded', []);\r\n    \r\n    AppState.loaderMessage('GameState: Initializing...');\r\n    await KotOR.GameState.Init();\r\n    document.body.append(KotOR.GameState.stats.domElement);\r\n    log.info('init complete');\r\n    AppState.loaderHide();\r\n  }\r\n\r\n  /**\r\n   * attachDirectoryPath\r\n   * - Used for Electron\r\n   */\r\n  static attachDirectoryPath(path: string){\r\n    KotOR.ConfigClient.set(`Profiles.${AppState.appProfile.key}.directory`, path);\r\n    AppState.appProfile.directory = path;\r\n    AppState.directoryLocated = true;\r\n    AppState.loadGameDirectory();\r\n  }\r\n\r\n  /**\r\n   * attachDirectoryHandle\r\n   * - Used for Browser\r\n   */\r\n  static async attachDirectoryHandle(handle: FileSystemDirectoryHandle){\r\n    KotOR.ApplicationProfile.directoryHandle = handle;\r\n    KotOR.ConfigClient.set(`Profiles.${AppState.appProfile.key}.directory_handle`, handle);\r\n    AppState.directoryLocated = true;\r\n    AppState.loadGameDirectory();\r\n  }\r\n\r\n  /**\r\n   * validateDirectoryHandle\r\n   * - Used for Browser\r\n   */\r\n  static async validateDirectoryHandle(handle: FileSystemDirectoryHandle){\r\n    try{\r\n      if ((await handle.requestPermission({ mode: 'readwrite' })) === 'granted') {\r\n        return true;\r\n      }\r\n      return false;\r\n    }catch(e){\r\n      log.error('validateDirectoryHandle failed', e);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  static consoleCommand(command: string){\r\n    log.debug('consoleCommand', command);\r\n    KotOR.GameState.CheatConsoleManager.processCommand(command);\r\n  }\r\n\r\n  static togglePerformanceMonitor(){\r\n    let mode: number|undefined = AppState.statsMode;\r\n    if(mode == undefined){\r\n      mode = 0;\r\n    }else{\r\n      mode++;\r\n    }\r\n    if(mode > 2){\r\n      mode = undefined;\r\n    }\r\n    AppState.statsMode = mode;\r\n    KotOR.GameState.stats.showPanel(mode ?? undefined);\r\n  }\r\n\r\n  static toggleDebugger(){\r\n    KotOR.GameState.Debugger.open();\r\n  }\r\n\r\n  static reloadLastSave(){\r\n    const gameKey = KotOR.GameState.GameKey;\r\n    const lastSaveId = parseInt(localStorage.getItem(`${gameKey}_last_save_id`) || '-1');\r\n    const saveGame = KotOR.SaveGame.saves[lastSaveId];\r\n    if(!saveGame){ return; }\r\n    saveGame.load();\r\n  }\r\n\r\n  /**\r\n   * Event Listeners\r\n   */\r\n\r\n  static #eventListeners: Record<string, ((...args: unknown[]) => void)[]> = {};\r\n\r\n  static addEventListener<T extends string>(type: T, cb: (...args: unknown[]) => void): void {\r\n    if(!Array.isArray(this.#eventListeners[type])){\r\n      this.#eventListeners[type] = [];\r\n    }\r\n    if(Array.isArray(this.#eventListeners[type])){\r\n      const ev = this.#eventListeners[type];\r\n      const index = ev.indexOf(cb);\r\n      if(index == -1){\r\n        ev.push(cb);\r\n      }else{\r\n        log.warn('Event Listener: Already added', type);\r\n      }\r\n    }else{\r\n      log.warn('Event Listener: Unsupported', type);\r\n    }\r\n  }\r\n\r\n  static removeEventListener<T extends string>(type: T, cb: (...args: unknown[]) => void): void {\r\n    if(Array.isArray(this.#eventListeners[type])){\r\n      const ev = this.#eventListeners[type];\r\n      const index = ev.indexOf(cb);\r\n      if(index >= 0){\r\n        ev.splice(index, 1);\r\n      }else{\r\n        log.warn('Event Listener: Already removed', type);\r\n      }\r\n    }else{\r\n      log.warn('Event Listener: Unsupported', type);\r\n    }\r\n  }\r\n\r\n  static processEventListener<T>(type: T, args: (string | number | boolean | object | null)[] = []): void {\r\n    if(Array.isArray(this.#eventListeners[type])){\r\n      const ev = this.#eventListeners[type];\r\n      for(let i = 0; i < ev.length; i++){\r\n        const callback = ev[i];\r\n        if(typeof callback === 'function'){\r\n          callback(...args);\r\n        }\r\n      }\r\n    }else{\r\n      log.warn('Event Listener: Unsupported', type);\r\n    }\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\CommunityTabContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":14,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":14,"endColumn":42,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[726,763],"text":"type CommunityTabContentProps = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[726,763],"text":"type CommunityTabContentProps = unknown"},"desc":"Replace empty interface with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SetStateAction<string>`.","line":62,"column":22,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":62,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from \"react\";\n\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { useApp } from \"@/apps/launcher/context/AppContext\";\n\nconst log = createScopedLogger(LogScope.Launcher);\n\nimport { LightboxComponent } from \"@/apps/launcher/components/LightboxComponenet\";\nimport { ProfilePromoItems, ProfilePromoItemsRef } from \"@/apps/launcher/components/ProfilePromoItems\";\nimport { CommunityProvider, useCommunity } from \"@/apps/launcher/context/CommunityContext\";\nimport type { CommunityVideoItem } from \"@/apps/launcher/context/CommunityContext\";\nimport type { LauncherProfileElement } from \"@/apps/launcher/types\";\n\nexport interface CommunityTabContentProps {}\n\nexport interface CommunityTabContentRef {\n  showTab: () => void;\n}\n\nexport const CommunityTabContent = forwardRef<CommunityTabContentRef, CommunityTabContentProps>(function(props, ref){\n  const appContext = useApp();\n  const communityContext = useCommunity();\n  const tabRef = useRef<HTMLDivElement>(null);\n  const promoRef = useRef<ProfilePromoItemsRef | null>(null);\n\n  const [lightboxActiveValue, setLightboxActive] = useState<boolean>(false);\n  const [lightboxType, setLightboxType] = useState<'image'|'ytvideo'>('ytvideo');\n  const [lightboxSrc, setLightboxSrc] = useState<string>(\"\");\n\n  const [communityProfile, setCommunityProfile] = useState<{ name: string; elements: LauncherProfileElement[] }>({\n    name: 'Community',\n    elements: [],\n  });\n  const [videos, setVideos] = appContext.videos;\n\n  useImperativeHandle(ref, () => ({\n    showTab() {\n      log.trace('CommunityTabContent showTab', 'Community');\n      if(promoRef.current) promoRef.current.recalculate();\n    }\n  }));\n  \n  useEffect(() => {\n    setCommunityProfile({\n      name: 'Community',\n      elements: videos.map( (video: CommunityVideoItem) => {\n        const link = video.link as { '@attributes'?: { href?: string } } | undefined;\n        return {\n          type: 'ytvideo',\n          title: video.title,\n          url: link?.['@attributes']?.href ?? '',\n          thumbnail: video.thumbnail,\n          id: video.id,\n        } as LauncherProfileElement;\n      }),\n    });\n  }, [videos]);\n\n  const onPromoItemClick = useCallback((element: LauncherProfileElement) => {\n    if(element.type === 'ytvideo'){\n      setLightboxType('ytvideo');\n      setLightboxSrc(element.id);\n    } else if (element.type === 'image') {\n      setLightboxType('image');\n      setLightboxSrc(element.url);\n    }\n    setLightboxActive(true);\n  }, []);\n\n  const onLightboxClose = useCallback(() => {\n    setLightboxActive(false);\n    setLightboxSrc(\"\");\n  }, []);\n\n  return (\n    <CommunityProvider>\n      <div ref={tabRef} id=\"community\" className={`launcher-content active`}>\n        <div className=\"panel\">\n          <h3 className=\"title\">Helpful Links</h3><br />\n          <ul className=\"link-list\" style={{marginTop: '10px'}}>\n            <li><i className=\"fa-brands fa-github\" />&nbsp;<a href=\"https://github.com/KobaltBlu/KotOR.js\" target=\"_new\">KotOR.js GitHub</a></li>\n            <li>|</li>\n            <li><i className=\"fa-solid fa-globe\" />&nbsp;<a href=\"https://swkotor.net\" target=\"_new\">SWKotOR.net</a></li>\n            <li>|</li>\n            <li><i className=\"fa-brands fa-youtube\" />&nbsp;<a href=\"https://www.youtube.com/@KotORjs\" target=\"_new\">YouTube Channel</a></li>\n            <li>|</li>\n            <li><i className=\"fa-solid fa-globe\" />&nbsp;<a href=\"https://deadlystream.com\" target=\"_new\">Deadly Stream Forum</a></li>\n            <li>|</li>\n            <li><i className=\"fa-brands fa-discord\" />&nbsp;<a href=\"https://discord.com/invite/QxjqVAuN8T\" target=\"_new\">Discord</a></li>\n          </ul>\n          <div style={{marginTop: '10px'}}>\n            <h3 className=\"title\">Latest Videos</h3><br />\n            <ProfilePromoItems ref={promoRef} profile={communityProfile} tabRef={tabRef} promoElementWidth={456.5} onClick={onPromoItemClick}></ProfilePromoItems>\n          </div>\n        </div>\n        <LightboxComponent \n          active={lightboxActiveValue}\n          onClose={onLightboxClose}\n          type={lightboxType}\n          src={lightboxSrc}\n        />\n      </div>\n    </CommunityProvider>\n  );\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\DiscordWidget.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":65,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":65,"endColumn":58}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\n\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Default);\nimport \"@/apps/launcher/styles/DiscordWidget.scss\";\n\ninterface DiscordMember {\n  id: string;\n  username: string;\n  discriminator: string;\n  avatar: string | null;\n  status: 'online' | 'idle' | 'dnd' | 'offline';\n  avatar_url: string;\n  game?: {\n    name: string;\n  };\n}\n\ninterface DiscordServer {\n  id: string;\n  name: string;\n  instant_invite: string | null;\n  channels: Array<{\n    id: string;\n    name: string;\n    position: number;\n  }>;\n  members: DiscordMember[];\n  presence_count: number;\n}\n\ninterface DiscordWidgetProps {\n  serverId?: string;\n  className?: string;\n}\n\nconst imageBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAIAAAABc2X6AAAgAElEQVR4nGW8abBl13Uets883fm+++ahX7/3GugBaHRjHoiBAzSRIEVKKkuWyyWXU4ocRqrKUIn/SGapUqnEldgV/1AcJbFky4okirIlkwZFioAoggSJoYFGo+fpzcN9dzzzvPOtfQFGFV90N7rvO/ecvfda61vft/baV/qZz3yJccYVjeeJVOaK6URRJDOmSoqsKZIkhWHEGC+LXFYkXnCZfmZEsadIKmMsTqMsL/CXokhVRY/jIM+SJInLMiuLUpIYk2RN1SVZLsqy4CX+naVJWWS4c0aXZooiZVlRqVaLorQtO02SvMArTbOUSczQ9TAMOWOyJJk6/mWqioIr0yzGDRVFsQxLV42RN+YSd8yKU63IiqKqep6mnPM4jSXOdN1I03jsjYs8VeZmVpIUMyxwGVNUSVYweM4LXdcVScmKPC8zVdNowpqB0cuKjHthjTCaIsskRdV1tSx5kZeyLOUFHoP3VFXTJVUvOX3C52WkSrlTtZpzpaaysjRNJ0iiFEvFGcZn4KWptqFLXNLwF9Oo2BXHsU3VwLQxBiwoHogFipI4zRI8yLIs267LeEmwCtM1AzPH2mEkeCjnLIqDOIlwFVYqigLMA2PCT9V6o+77QbXRHo+GnjeuVOuWYcI4RZElWchkFfei+5pWyRTOYRBZsXSMg15ZAlvgh4qmq5qSZxhdpmJJJKWQVbnVNF98sXPmrLa8FPbc3LL7vd3CDcz52erurnL9Bn/7fe4PVQyPw2ZlnueajuVmaRKF7hDWMw1zqjnlBQEWHdPCsxLhP14Y+FGIn2oqbK4XOUalYto5/CqOkzTOi7zi1PAjLBRW3zLsBHcvMsM0YZzStm0dCy9hdbV6rTYYDuA8KTkW47jIwNgxgbJIY023S55LDE4FLygNy+G0ovg7h8NitTXNKFWFn1jNnnxaXlwsLTP8/T9qL6/PJ6khyRu1Sr970F1ccI8O6hcfZbPLkVRqb12O7l81NKNu2XEUBkFQapLVcOA4C7Nzj5w/+6df/SNdlXVFwYgSr0CUYKh4xUkcxxEcxDItqVDx2ZwiRYaFanYNI4Ezwy5wDZjXMm1LsWFF6ee/8CtwO9wLoQsXtx0LSy2rquf5lmUeHB7Uq9U8y2G1tCiwnpqmwO+iyMuzEvPEwkkKxbgsyXHkJysn+OkzfGEJBlG/9hdylkx35iuW6QdRtV5Pk0AqJTfysJThuYczz3XLeGlhLqzW+3/4RyYv4zKr6LZsWLJleL1j3bRjt89gsTyN/SHmaeimIst46NgfASnY33phhrAqOaAk40oMrswz+DZcWlVlTTc1Tc/LXHriwguYnoSIt+1qrYPlYICEHFEqcZn3uoe27WBFENxhHE6QBiBU4JNMykuyLcO9Gc/hDM+/IE8v8LWT/Hd/V/ciw7ID32u1pmxLQ0hU6nXPHcmKGqcJbh4nQWIY8fqD5tbd4ImHS64UoZ9v7xoIa9tGtEmOIw2Gua7FAMSdrXL/IB8eAirwXIAfnuv7Y7gu5oV3mLA74kqWVYwNDqsCGeDSBCIYICKUwyT4i3LixCkAQBzgw6U7Gh7s78ZpADjJ8kSR1WqtwbmCKJOEw5uWNRgeW6aJAEsRcooaxVGSJhIi4otfYpZl3NtUf/Cm7vkALvzKeS5LrGKbmuGE/ohQPQpWlmb39nZyTZXXTnoyk1dPVvb2rd296sWLVpZLt2+XW/elw311PGgWqb+7j2HKYVKcP1fWHN8dx6NRGocqltC0GpW6Y1cAX0BJhDHmnxB6FxmgFpNEuMKr4R1xpFDCQSSmyoPr51y36/ujOPayzMcP4BQANMTGzs6mbZnDYY/BRxQZ1sQd4SFiFQsNKcKyAYCGrWevfF4ah2prpvju93Q8oyiQQRT4WK0F4Pz7v/xLTqV+fDxAkMu23UfSevGT2f4+D6Ny875q2XohSbt74Vs/io6PjV/4YvrhdVNWQ8/t93vAh6R7BBTVj7vZ4ZH59HPAc5NxZDk4KkccJQkGg8yEVAK4ROgZmg6XJkjNAEQZ3oHlMd2KVdF0Q6k5VpaEJTkGIhFTCosy84MhgBLJA0AXBsjDiH7AYzQa94HIcB7TsLCAYejD8fnnPuc0O+q1W87tu6qiFQzzkoClWFokVUBIvzfa2t2WrZq/MK9Va3mcmm4Q7W4m/X4ReKx7kFHqKsrxUEOQHOxXPvOTvJDs9QeYU9fW1phu5guLUrWmVurx1fd0xPDDD5fH3dj18AiJ54wQnvIXnotETMBJtiUgxbzgrAgijCmM/ZE7UqY7UyXj8AF4rSxxRdFkCk6sn2JZQHYLM4XD4Ge25cA3EBnDQS+MAixeEPnap17SrI6NwN/bU9KsRGYtM8AF8jamalfMIAyx2PyRR6Q0s06uJ5feDo4O037PNmt5lmrILExp16vFqTNNw4rBBaZmrGbd0438R9/XXTfb3JS8sRkEVpwWTtVeWg8MU94/KBcWzTQxwUZMG1QADotHUnjDBxm9aTsVrD5mi/QhoAe4zG1A9UxnGgtDrIiwDZgOQCLsLXhRrTYbzeksB08w4cfAdyQA4gBFgeysqzpfOiGdvxh/89vheCwdd71xX1fVElSCMA7uq/b7R8bqWvPCY+XtO6rvs53tMiPGhQ+DosEJcf2v/dqvYi0OdvcHJzfSy2/z/kjbOfCP95Wzp/nWtlNr6KZjqLqMLJikfNiz8lKdn7dPbMRFkuGGmA8nGgTGIhMjBOJmERw9xv11C0Bv2vBkPIoyfJZgwjPwhwQ8DoHxEcLLhOYyHKUArmZpZBpAP5ow4hbRgsQLiCgtx3rqqcq588WNO+YYrA2uJadF6roj8D5VMxOVWc+9KA+GcpbxPggGvKxAYsRiAnWw9n7o+kFw6dL7l/b2Y9Ac0KIwlpMAwasg5Swva1VTcSPCYYlFQZQmfpmlFdPhfsgHPfPpT1iBp0QR/A4RBP9VNE0CdmnInaoBlFaRwsBbEwCnYVhILkQfO+0pTA+oixQDXgmqTHSyANOkQLd1m0nEg8DG4C3ueAxSiqsoJZ443Xr8OfnPX00cx4pDBLzgAwA4PFeTTp9OJTm7cSU76tWYDJLcbLVBOgN/3OrMIh8GoacwqVSkdG6x6B0iA0n9rrpyQhsODNNBOmW7u/qjT4yuXc18r1Jv47lkBgUEiIPj25Jswc0efUrd3kTaUmFeWckyeC7WHcAigbXHOakAzBZekKSgEQVcD1x6RlHh1DRawWFAiWF/jeUZro4LwHoOBxHcmcG3R+Mhsr/R6LDf+u/9b303GR3zvR3cEXTYRCJvtoM0Ms6dg50U8JsoybKo3Wpi1ZIkNOy6P+5HkY8MAUwDIVDnV9PdLaPMVd2U0lDSrSyNo1EviSJkUG7o1om1apbqigGHmOrMwXYS4yDOGFXSOx5Nt0NJ4d2jMscIyWB4YaCkhmSmwtga6Q3kU6wgfBS+qXQ6U/BhYop0GafwA5BzqCIw59ILADkJboFLM/LHtFKxuawVL77A7m7ng365vJSEYePUaZhTb7dASv1GPQn8GcuuFTwLfVAry6nCmQX11QHyBJ+8RIzltdr8VNPK4qzgDqJMVcfTc6U7zr0hU+RqpVbPsoVHzmVJ2d++C5vFYQg+77sjJFl/jDwSl3EEhpjCXiBeMVyAX7h4oXt8DIvJig4wBn3E+OGb5MyKSgJwZmoaplUm9IUJRlaUWEjwFeAtHKEUVIoUW15sbKz9l7/+63998278kz+VXH6vTHL1xi027gW7W1G/1z8+ZKsbVs7Zhx+Eo+HjF84++txT13f3GXADMcWY67qBO2q1mr3h0Gy3tHZn95238ECkt/nZuXGYYu2l9fVaHIMLwiBYiKPRyG04SrdH3ierve4++AzRRVkjWtBqV6HJTqypvlcEY7jpeOyKjAjihDyMJKxQgmIsIdFVkOUXF5ZVcvNCSC3iaABgTFoVGs8PQ6gPig2abw7h8qGsjf7uL0svP5e8+i39H/796M//AtoUzlHCz594Jn/zDURjgSAI3IO9g1vXbmSe32nOQJLK07NEv8oUiR1S5NEXn8+2N+NCcqp1SAbEHZa02Z4f9g5hkzj02rPLrjsGQvqykoRe6nmAJXgfnB8zSKIAZqI0i4W4fSObmy+ODqC04YO4jMQkI2BSSBurXLxgYCyEMt1u4WOgpHgKJimTO5cMbyAkGPIFyBrdkwk/ZM+8MICtPvNp/qdfT95/33rq6WLkp61WDvOdPcfe+F4cYraQxKzRmnE9F3PQVCWG0ogC/2AX+rFbZlZ76iAMo+FodDzw3QHEIPIg0kScxUCY5Ny5dDzECscFKC5Ya8nbTevU6eJgF1pVNgwIXZD/NAJBKspmE2hvZIW0spIO+6Xvgj7A+pgbgbZCQh3cEaREOCisVlIepn8g24oZwsyYLiNgQzJAQi4QxmKBSjbV0f/Rl7U7m4YfsT/+Gu6kvn+Ff+Yl3u6kly4b/b57sKvZFTgDoSKUehSVaYpE6o1GMvjW4Cj03cLzcibnrcboaL/Ag8qsOd2Oc0AlcYgA7r2/q545l2zfx3ic2Xk4TzbsR626Aoofelat5Y8HxNKzWMbSN9sQegakyO0PlVOnw3s3OQ0dMgmDyGFnsCO8ZJqWPNG/FMM0QLj0BKUZElc+wWxKV7I69gIyL+PqK19gP/iR2Zpjv/RzwZ98FWuQ7u1iNaPr17XHHpPev0wOBtpoVePQhTXsWhVqcjDqYWV9rw8sABkyLDM19XR3R4cWq9cKx0pKKeN5JuWFoq2srWDxidIFY6SEhJV2tYHEbT7wgF6pZBHpGRDGNHAlUj8lq9Wk0TD2XRnPaE1lkc/DACSVajy6YVoVRtxRdRwHb0Dt4k1Qyw7cGI5Oml5i9CfiCXyVcJsYWRiR7OTAsX/yFfnVvwIfTN/4kdY94o6JQWenHlBW17Pzj/NX//3G+nqYxN7o2CRY5kDvwHcNs4pAgZwAzyTOizVttvjoGALcAtGHVplpa+2qtraoVvSXn33iU89cvNupFdu3q41axamAwSP+peOB/sBGtHfALB3T4ym0lg73AY0re33YDlfKaVTUqq2SGbohUfqFBjbItiAUjAGPSPCAhM5OT3OekaxlglAwwmRiiMAtFcGiB1EE32fNpqo78vsfaD/3S/zqBxpStOdKjz5W/OU3896h/sGlhqz/d//tl9995904zX3fL0ip5IUkw7EWVk8BCFRDq7Xa9bU1edSzdNaaqbc69ssvPOUd36xsLC996tHqyVnw+a0b78aKpFnq1IOnsEx8ZVatmVKzOVpeSHt9dXnFqLUkE4xfLaK4trreZIpNqVbPxq7casvjPiwik+DTIcjhLFTtMpERNTAWUpHTSEsUonB3wAdgDuqcHB5XFFTNUBLCPa7+Z/8Fu31L/4nPZV/6Se3kqfD6daM9nXz4HgRuORrwRit76cXX/7d/4UKSeCPiawgDw5iaWylkHgTjeqvRbLeXVzpR3TRVae7Rh+oLjcXHz33i8QvRxoJ+/tHT3L+oDrSHH6rnhycb5WpLHoRZOhzzMJeMmm3oar2hXHg4B72p1SWzMjU1o5x7OJluKnZNm1sY9LsVWc2XlvXxGMqRmJNhIvUAJkF4cgItmMFFnMKTSV6BOmM1gzi2dA1QFcdFpaJjlfAjG7GEfNsfKH/nF9W+K//Ft2VwiX/4D6Sv/YemWWd6LfSHxud+NrUgFfqAu+b0HCwDLAXD7LlHdqdd2VivIN5WF5TFmdkyso9356eUFUefbfu18tbPzErdptqOZebFU3e+3T4zM5Ya5eDoKWfrMsu/fl87OnM2u3untnHK8cNmNtA++Vz3X/5+vLBo3N8ub97QnFqslrXzF0KAEDKNbWXd/aLIJsyRIitJQNKJayiUvuHbGqIcFJRElpIgL5WyEgQeBBYAHpgOesJMg//oLf0zL6df/7r6yU8V//r3zP/jd/yjvfj40HGqCIH4T/6QjYcAZACAG0XOM08tK2ZpcNUxKnMrMwdbVTlYM44021idtU88fPIE/LRqBoVat2aIP5Q9TTt/89ZVuZbfi1hLOribFixlG6c6n2g57zxydvv7b6df/0vzoYeynb3oX21CDJe/8Z8P/8d/ruTZ+HhPg9AbuqWqxxfP6J/96eyf/a8lkp/tgH0A4QAapVDMpuVATamE31kmkfhn4HfAJ8xwqt6gMiRlKdXQNT69pP/m/5Ac7NuvfAkBxp5+Kv76N+UnHrUPjnD9VH2enOaFFyg0huPlXF5dO5vt3J0FOKnyjMWf/MLLhnQ81eSrqw81TUa8jlkYhs4D4CLssDcK0/Cdnu+U437hXotNxZm+eFUuZlYfD/Qh/+N/o0hJGrEwSaQsAcFghwf8n/zT4rMvs9l5+7t/nUZBVoRIF9L168Xpn6XJkL7Ff5kgyIXAShYGHgYoW4ZVqdaosqzroFSQaX7gFRnVA0Br4A8E1nvb5dUrbHuP37zGXn4OoJ5/59tFtRlpsra2njzzBBWc/vFXijtbxc0bcTyMD7YrMzV7tja76Dy4UVmv3zpzMn9oo9MywekwVZuxDKkg5qab56PMbVRPDYPI9/yAyjJICtrRzas9o3PvztWDa1fisvj8T3xqYeOkfO6BRNES32Wm7Reh9M571uXLUUbCC4EKxOGmkWxtImkhcqMAHDEGl8aKinp5BipFeXi2M4MFKcGlcypDwzsgLuDuVAaD1pOpGpxVGsXVW1qlms5Oya++Vnz4vvHAmeTxh/TtA//Ke8m1D7OjQ23Q0w4Pdcc0atVCLup1o91iz62Wjy2ky4txvT3PmVlIoJB6zCJNanBWzaHEsLThFovT+UqLj+/WingYxoVt3w2rt7VO4rpbu34im5f2BwdPPZF0ZuJGLXv8USQNdumSevt29iu/EtUq8q1rZMnlZWntdNY9Ku7cQLDCfjIRaShHkD2q6euGQSXbokhKUVVHOhq5XrPu4E03ToCzlkpCESTI+fXf4LkibW9JDz0cP6loT1wMvvWqen8v/fA9gDmTLafRTt78gdVuRyx16sZPPX/h6bNLLW237aStzpxmDTJulZIZjTftWpOxaWQ5TUL42Ew23GwkdT+I3C1zsH987CvjIBj0+nOfGW5uJ6N9P5vmM63k0SeLH74n7X9b3tkFdZe//I+UGzerBwej73/Pubepzy6wk+vKeMTefMNstZz2DKOKPJPFC7EK783JvWWQMGA4hzrIKbbldrOJnJRlRdWxNVEvQCRLFx4zoyD+xjclMMDlWblay775l+zqTSQIBDgoIVelQZEU//Nvx7Nto1WbW6otr9pPrikn2/7ykmU5RlAYatk/CMJbSSfms5LUUGm2kiqpttqwE1nuH8neMNo/isaxyvM7+1k/N8zFudtDY1yU/tRcuXNQ6Q3tpZPt51/qPP0J+3//l51HzqtcaiVp67/6sjE92z44Vnf3VElqTs+DYVFeFRwzI29OkZDiMIAU8UC2qQ6gqqK8riFoDc2WCb8ZKFAhCcHw7lu8e9x8+fPgav6/e1Upc8f1uO0wy7EandJUoRXUqana/ExzbaMSbW08sJR7m93hcLY9DXENAnpraxzGmVKX/TH37WKhqk0K56LeoLWaTjndSPaPAoB41TgeZgcbjxtrZ2pX7jUWN4I05ktL2v/1b9jqA+mV93ilUUZBtdK2Nnfi+bmy0oziOLx5MxbRl0nca1TD0YBl4YRKiZlLJYkjEk+IYTVKEogkkOkopxCn4odQibC8DQqqG0hU4Rc/X7o87w6U+VkwuKxWs2cWoD9L6DPTMCoOknX+z39HWpmfmV84sz7/oMOXZh2FY57mrTu7B24xyPRq0POGkpNfrmycbdTmqRZElBW6oSu5B+PeEJpxK5TfzduNav2tRBseD0vXK7ojaa1XdI8QOcoLz0ZIpN/8zujhh0df/WrmjqaXTng3rmiKEQYj3bBhuejyexIlOj4xMsxJ5USJqBDeybJS1VTVMCysged7WK2ZVgO0ASkqCH1Vp3DnYNa7B2asFZqWa1Vm1jr1zvjiefXWLe7UIYOwzPyxh1JVUpKBxgqTDWdqhlQMShnGiBPV2QV8dm+7kmlAh2SjUbpfeeR51VpkSLXFW3x4udePQqfxvbBzLVOHcnnbrx72gnI4jnf2ZpzWUNIlp1FECXvnSr1RU+Mye+ddJUtluxY8cMb5r7/c/+nPOoaekizNpQzGS0GSMYnJhgnoFkkOkrdU0lGRgCdFHOj+TruF5XEsG1dSXRIjynP68N+8Jv3j3zb2R5W9/eLzL/n/4U/Vh39R++7fQH9ptXoMHrt2ojLfUX74A2u+EepZocMeUMFjZqz5qZtt3rowr0GZ2lKq+Nc185DvxUV7WtLz5Gi3f2tnT9be5ufulntDh92151y9XjEkd+A1dBPhp/MU2KuZpjU9512/pp5+UPqP34Dsk5WCv/Wm+w8u1ytVMCSDy4mhyEuL7O7Vic6VhE+LUomobNAvrtTrNYgmTtNOka/x23U9ZAuq8TIJgkMqMzi3tP6wMt2O4Pr7++zCheLufe7UinCs2A63tOzgSCmLhp5XKxIeb6tJ22hUKrOFnJb+2FIq7tinvO5nM03JrpiKknpBVLDOuCyuOGuvdu1eKR+lxmbSKnvewAvyD29rM9P8eFRClvkxf2DDunErXVs1O4vJ979nVBvZ6JhphvaV32RHPfAQ2gCEDgjHRR6yQR+q8KM508aQTFtqQvxS3aNRq5Mept3g0jBUCdkD+AsTSQptsYJ7QjTFsXT7BuvM8Scflz7xWL67L71zmSDozBmqiy4uaquLzI+SkkcMcSTx8XC7O4xVuTuKR24yTrP20sNjWRuVuSsZXaV+I5/dz5W3u/Ef3QDD4gM33rw/un33cLy543W75fRsAYUEoXfpSry3WcQJO302meucnGqOrl0tP/V8ef8+DzwFnDDJ8s07ZpKFCEBVzhv1/GhXStMJIgrcIqye2FkmvVAoC3NzhgH6qPpRGIYRNDJkk6TobhBgHUhKYFUkqfjiF5Wc6f/PnxVtCJm+euse398v+8f6uXPS/GzxxHnr6r1MMQxGG44397r49O1R4UbyzsHADZIH15+51R29uzvY8sv7mXNtpP9woF49CsfjMPXibi892D0AYscFS1RL9mPzzXczqwKZxyD6hsPq5nZu2aMnHy9rjvzGO85gGDUa0m/8N8blK9ntG1mcmBWHBOlUuxwcQ0J8nALoBYNNZjv5p7I0PwdHxru4Hla3TQsMS9FUkFGkJ6wFRHExoaNGRdrdVUeRM3BpTLpOfRG2kbqBdgyCOKbGlrI88rJIq2NxVhqLH+wc78sdz5j/3v2je6EZTy31s/o9V+0Ng9ILy0zpD7x2dQZcNbErRZyuNmaibk9Jc3Z/U51fziMfmMP7QzLQ9la9ZPEf/4naO4YFlKUVRVPiy29XFAMog3QrszKr22xn82/vkmOGk6ow9XDgDxivXqupQFrYMCtod190mcgUvSoX0U7Bjw8M+tkv/z2j7wMe82efVLu98e6WblfVL/wEa9T5ve2IFyxOUs4K2ZBV/fbQf//IOyrtYajf3xnc64733LBfyL3D4zQp3JwD8B98+Nwnzl/8s9ffGO0epLfuLCjOvde/g8Hk25tWreX19uxnny0g4hFbtA+ZaRsnpe3drNUsWu32V37L/z9/1xx5UPGYrW1Xk85UHnhscMwmlSrxmkAV7d2DKosdRWVhdo5LwOsyCPwYah7zBi+DtqANm9S0YHKbdtjyQl5eY25gzi2AcScQlXu7+Wd/kr1/RfMDeRzI8wvF/XtKlrMipQKwqlbNqmJUqPopQWRqMleLSi0fh3h8MvaKIMq6x+lu//jNS+1MCrd2Rnt7mmbK7anMD7mmMijwezvxzk71t7+SXvlAfnC92Dgd7W6rv/lb9g9/OPj3f67oBkvBHgJVQVLgceTnx/s8TSZF2UkMT160cSgqtyAnSqfdnFTeozAdeS4wlpWSbhpj0CnGCL4UOQV95SwLYmXtQYmV6U+/RBWNNFJf+Wz8e38g7R2pYeQMx/LpU+nmppaV5XhYDAbZeJj1umOEuh9Kw352fJQfH6X7+9HVD4q796rHfa17lB90+0f73e3NNIsN08mrTrKxXh51YagiCfM4xErHb7xRLixUf+Hn08N9A0LttdfZ3r6VxMWor88tKmFAhUfOUkspj4/Aqia25SIJT6Yu/oC3ip2YZr3OqWYNcssrNoQbTR6+ULUcXdeyLDd0hWp6ZSED6m1bu3lbeuFF/dSqtrmlfe9te9CH5tPKrHCH+a1blQsXIbqt3f2apPDjY20wrMQxos7sDypjr+YGjuIo+3vTtQ4+0js8OO72J9zW0M00z5SVk61ez0wTS9ecStUwtEqlqqZ5IypKd8z/4utWv8+6B47l0A4ZUGZp4YkTa1tbm5Gt50gxh4fS/wdX8kcxLICa5oywzXMq4mG2eCNwvVI4NMhplqaKTA1veF9VNUQ96CfQT6k37SRVXv8uPxgq7Zby3deVIleZ6vcPLVKSKdvZKQ725RMr0t37hh/x8YgPx+XgKDnq5d5IKSWj0cpHQ0fXfu1XfwXP3T88FoImU5YWFYgzx0oPD8rQk4jGI2PX0hDJIpNb7ahTNw6OLLsShX6tVldUvcySytrG6bnOHmTcwpx68xowCAkHWZXSjqabFvyTNrJN6nyjji78UGk26rTrQjHNMUmSwqpkG5Ykuj0EkCu0iU1hzpOhm54+rex307MP+HkWX3oXjx+7A0mUxHzPiz1PlzR/ezNYWuznUbF/GIxHSRwwRQ6jwK42tZJVO9MHO/e//8YbVz+8FiShp8lao1VNw15eqLOL6uFAlnUvGMuqFoauaItSiqmG2u2yMNJNx3EqrtuH3MPQEl5s3r7TuPC4f/8288ZiZxR0SeAyyXleFDkXjHpCt2BRZabTAo8HpU7S1At9QmUq6ipBkow836RNPWJ1pbhHFsbeaJyurAE5xvcAABZjSURBVESvfUf59Kf5flfxA+pYS+IECEncjMXgxUihezvM99n6WgUeQf2BkCF6HPrhqD82dDkYg6tPPXQxLXIjz8qRi2WzOnNKf6QUSJDeYHCA4QZxDP4zhOZ47oXRX3+H2tYiYKuHXxg+bfm228Vo8Hd/4ZUf/NlXkyik6YldUMGrPupgm2w7iJ0HsqgyNz1NvR3ErCnEYX0SyrIkdjcVS9MZBbtKXKzkM9MLYfcAE5NW14u9Q/7Cs8nbPyoTQcUNiwLeMCE8k9BlcPWSUSJdXsrmFszBQKLlB78vDIlVHntSLcvBvbtTlaamqEkY8kYzs+wFqxMEY3e0q2p6szVLPai80KY6DCHWPSYcYpT7MZEk9gHO+fxcsbD03X/9e97hXkIv6jvEukTxx//Ri3oEkjRKU+qNVPOs2Ds6ghqvOHXbrlUs3aDylgnXR0KhbcccqWRMvZQyCeSl+ZV7O7fl0Ug5d846eypd25A37+IjnErtZq3e0hmzqlWF8aWVk0eHh1F/6MqD7NRacf++Vm0b7Zm6qnpHR4gZrd1Mg76iigay5QWrlAY7Bzz3VFUxrUqJNUvihaVF65Mv7b76OuR3msSGbsPIPE9Ns1LC1aFm790pe12EqPQxlxS/KQbFBiDVcgBbouM3oQhdW1nZ3tsrqakDDgDQnp6e6gDhFFXQE6gJwUU59f/khlmdmloII/+oe6BbTvn0c+rnflr62jdawIbBABhThTfoOnIYnpLEYek4LM99w8iTkFdrxcaa8e3XqqTaw3xpUbp3E4MCQqcs5yfXgveve0Eaegeqks105sBeijyrr63rnanjty5lcQgXJsQlV5XdUS9ZXinPni7++N+WSYTnFTyboDHhM2la4dbk04qgIbLY8WfS+sry8WDgh9Fk94x+wJGZTKdSq9eaukJbcNS2RL1MqcTUqc6ibTuYM3SFWanzl16SH70o/87/bbZbVnMWyTnXzDx0kVQzdxhHgZ5hLBlxNahvuA5GmSW8VtX39rWlE/Ht64qqZRcf1z64dOnd62XmR+7+g6cfajRacN9M1uRPPp//5bcl4L8AzoI2gEDGjFe+9MofDMaDP/3D4uBAdLoyUZfNU9HLAUOxScdlkWHutJPIJkKCko4xNzt33OuPPVc4RSnae+J0GI9Gx7ruVJ2qZVuaxlTkMZ7bos9vbmZRU03aLrx13290lFYj2Nly795pd+a9cR8pdOx7BSsRiimtNxI9LbSGYd29BX9J1ldzmaVuD/JVTbP80lveOMF1SeZhnaFJgzDUVJ2dO528+ZaGlQbPhyWKSSNC6WbpnzE1/Ovv6GBHpj1pQaOMKwnclKTJLFzXHY6opQyftUGhTJMIR7s9jQFVazXgDRBwgmzsY+kMhIhi3/PdJOGaZq+eWFdkapcDkCEh4V7BcRfYF589J011kju3kzxXwcxELxuXZcD3J1549trNm1BitFOlgheFMITUG+ReAKeXzp/PFpbi8Xh373BhpvmzP/WiqVu4iaGayhOPYX3V+/fzjDbHDMtB+oQ/5088mZ5a97/1H9XtXVUW29/0kugP8c8g9Hq94/39vfH4eNL7g3XQVczX6nSmqcQD3VPw0rasRrV6d/NeQrtv8oSXTYAA0BqEwyAaHhxtV6utpYUTjUZdUVgYxEEYKK9/S69ZSm1Kq1YBXXGSIQsBXrMcjD/uHnYNVfehaTVtut2477oYPQg/BJnKlOzqbbl/FNZqwcL03fHR0dWrjlPXo6QADNoO/973mQrXcso4kBen83qlWF4uL7/N/+oK5EQhU+++KNxQvywk8Wg8GI2GQFnRVCbqO6WQt9RxTK5OCv/R8xeQh8MkKkVfB2TJ/uEB5kxtIxAueSyAgP+YmgoXoG3UarVhW05nqoNMTQrhZ7/AWgvK1lb5/TdVKhUCrSCn9UkLH8zrONUzpx94+51LMrXil8ZU86mf/zuv/f7vaVHcHw4CWUnUTF9ebpaKPTuvvPR8+p3X9JLnJddWVlfnpu8O3eTKpezaFRbRBj0iHNNAjkIGH44GQeiK7lkuvJNNWpJkYpfk3qoqN2vtmdkVrLV06uQasEBs8RA/EMmY9Xo91/dwtY30wIuElqP8T3UmZm6aTqs1vbK0gn/xz7+iVpvGOx9G+/ekDDY0EXNpljngg0moa4ZmWIGLPGRmi4v1mU744XVCI84Oj7qIjjQ8sCrtxV/8e9qJE9q1Tcntc/BBJHdo8eNecryfUJ+OqHRmydgdj92h6w9FvzQsTag06YjGNAuxUyQGCmdW5mdPVCtteAOppUatjhkS45RBIYmLwZsqFQdLGEVRlicq8oxuFQR3H9/l4zgX+S4DNNjguLYt3bzGDZU/+7R88bx2Z0+mQgIix0QAm3YlTXza3ujMlO0ps1ILrnxoqrQtgDUOaXV0xVSVF1+Yn1vS3/iRPew5Zam5Y8UdSaMeC12ECAzXGxzv7m/uHWyFwTBOI9FRNelYkKogcOD7GfUpygoT4kECmz6x/GCt0hLHMlQK1VOra3RsROLUDoA5g6OyHB8BGQzj+PDoCLbFhKGcwFkm02b/yQtM/fyZRzTdokwwPSM//TxbWTXgBP/uGySGA1dqt6jrbW4B3l4edvmoB5APfVdBECXBMOThydnMMWaq9eb1WypUhW6ksVtmKTRRQE47POoeBsEQ6ZGO3ADNyo86njE9Q1M0TVZpwPBD0aYPiculeq1xYnGD0fYYrGgiO5JK3FhdwapQd+SkAs+YbdFpEep/NyCB1Hc/eAfklXBSd7IcQiqbiOn/n4cD7ddOnibCyhnGW8wvyE89Ka8sc8tU//zV0q5aUaQmiRxFiji3Qh0WlgVpETz1hDvyX3ny9Nf+p39ql3xuZoHYPDUWEWMF/b569W0xR6AgSXnRhcUnEUiVWIk3HDq+gMwFbc0FvcKP5qaX5ueW6ZAPXJ26mCYddqX0iSeeAU2DnKo6DnQL3DcIghygFwd+4EIVjDx372A/ThIRsTYMniTh37bzR8EiyetrZ6fbMyUlfj6pnhXVivr0M7/87JPfyPn4zXe0IpV0Awihbqwp+4fxo4/sfngDMih860fB0T3MsNmcNTWLsahWaVSdSl6y27cv9waHdHhKHF76SL/JfOLJQJJGvTEzPd/t9Y97XZGN8VxldfmBer0Fh6X9FephL8C2QIBoB+nzn/4skkuSpSGSTALBQUQSDoOr8RSJziqVAB7QEs/z8CNds0iXpdGEqAodAuWcT6K6UZ9aWlwzVLq/ImpjGKOJFDqzsJu503aTSsGAES7zobf5wQfRqKtJapb7SdDFuq+uPjoY7sbRaG7uRNVuxLF/7dpbGeQYSCVcVyHkFZxiounZ4tK847S3tu77oT95HwB5au2Moegk7sSGEdZITIfcgRYDODXyRilxKzo8kFIMUxmoLCg+cip+5uBCFcdBcofqyAuSe4hqLo4r0QqKXDjJe1Hi9frdkslOlQoptOOcFxArjRdf3Pybv4pvXHP8UDrYZweH4+17R7t3izQokPlqZqPRtNQaFqc/uG8B+eszWMTtnZusiMUJKq5rMrWCCrKcC3q/euJEzandun03SqjKgzFMd2bXV89QvqCTf2B6dMyDUTAa1EQt02kVZWpqSqEzUNRrSMZi1NIJ2DPFbg1iwKnUW40WPgN/m55eGA57OfXVl5pqCY0gfVRAIa/m4gxX7vuj/uAY8UIgrGqtZ55a/LVfvfknf3B87zZ8FcIF+L+zvy0SZxlFLmRTe33DjnXP2y+LZKq9mGXJ/v7twfAYYwMUYa0nSVWEDsiIcmJpNUmK2/fuigNFxAuXF08uzq5IIohF/2Qp+qbFIR4GUkDNpjC4Sr0AH5f5YDrHrjqQ/ApVQ+olbk3yGM4Whh4X3P2B9fN3718PIxf4CfpREi9nH1f6qXoA8Mez0jTc3b8L6YREvf7JF6QfvCUOOJV3t261W0sYVaU6pWnW/v5VSqSGbq6eSze/rqlJa3YVnry1cxd+37ANL6Uzg8QUCKiIUEC6TrXnEWLHvWNBBPFpY+3Eachbgc4wKX5LlErzhAmvlmmTjNCdNqU7nXloQer51k34jtBWhaFSGJPJcAs6FYZba1TWQKxneXtqpTi6m+VxTgdAf5yZ5QsXHoG/vPba68K9BeTzLI29q//if7kJHtvs6NOYqkbFUqpZFWP3gKoRHFOT9BOrA81C6tvZuYXFkkW5oucl4oCroPbEJhidHq20+oOjgBpwCauRY1eWT4quMirITRZeA2ERR8ngz6RrS7BdDoYHO6vt+lzJydZpAXlgpnEAep1Row3syQFUyElEg6gNhHrMhRAr6815aiBNgjTzEQogvoqsdqZnZqdndF2hvlTyLVkhakHHEBbml5HJMdMoIkxABC0szVcq6/c3twELUbe/889+K/DGID8pFAJtddI+kNj0mBx9UzD8drMDItM9PoDDC4ovz82uzE4vpVkK9ITfIsWACBV0SC4FkFO9p8hEA6JCWydFhgukn/nMz4Ox4sOIOJkRyQ6iyAvGfuBFUSgOANHy5vSKcgFpAn2pWmAaFUgo2DKHZoihClR6njjxqFAn8kd9BzPTc9TOVfI4icSSSaqmTU01EUGun0ZY4jLqj3qFOAQCTSeR8JhwV3HgmPic3G63kX/7/S7CiuSmrK+dPFOrNPE4zAfBIovudpkCCoqNXqk4Qky935ql0hkuBcmdWqRjL4F3QjoiAyP9cnECV9RF0qLMPvZZmqNGDQLSpIwikWz24X6MWjeNWnVKQeItMy6Ku6S9qeIbYHXixDdMA7rSptOojMwnDg6pVDtUsjJ1LDhbJQHfKxOZ2mhK4EuM31SIEs2/qkKlqsCnwhqXsHxrJx9Ukc+op1C0vXM6zAGPmnRogY6lPAMRgDwEDEniPChsST3/P/PyFy9/+G4Q+SKV55PiiGAyfDKvCSn98bR/rBxEYEkf8+qPyimMPJma/KgVXdGJI4IkJm6SgbfQkQuV9r4UkDksAQRiiAUG8aRCKkFGs9UJfNfzqVsT0a4juPJyODykU9OYhizhj057fm7uJGaF8KZKMuCGcJcINeMfjRkJiUgoSIQgKlAbnA42iba7Xn809vr845qW6IgQZzLFuS1RlhacW1R/6FyiOJpMbSHITLqlKXTKkU6XEwGi+qYKlaQbOUWgLsIP0ZOM/T60MVw6KcDSWBiOhMfQ4KgVmxW4cdWx4I7T00um1fC9AR2hpU7XksruspZRKpR1AzKk3h8PTN0KSrViSoY0Kf5wnQYmiVRAB+Mwf5WIAPw0p8NcdFyRWJj08ic/73rjLC9UqgmYyiRiADa0wQg1SudyBbugXWIAuG5W+GTjQv6olaAQr5L9uB6mQxSCcGAZmGAwonZGq59miSDD1OM6KZEL7JFMywKBixOPZxF14ZOnGZyreeYVopJIJ0TpuwGgF5uG2YaykkkkgGzTLo1JRy3h9WacBMJPKRxloe1gNyyAOikIiEPo1FcEvsKJLZYpbXeWlmGCVEO2VTQKdYQBJSM6hFBWaw1azjyTVdF5SiMuZC5GWPIgScBgJ733GAod9yNukcFtStF6YOo2cIg4EKvmAj8+2uwiOoQlqRSKkWZRHI4QzMgN8KuE+gNpe5poMuNp0s/SkWHWTKsF8Qepzljg5Wqk6JaK2+aCdSgC2BCJ5aTPgbpdILxlpeI0lPUTZ+hIjCRD5QP0q5UGdGNO9sECJwVVRjIkchhZNyzIhiSlk/RZElNVhU6h8+yjLkUJoC2Jk/qQvYJ+mtRogREQc6AkJ07pUtMQ3jdV6t5VRUlCmXRfAHg4mUJXLHEemKqNVIEEduel/HHVmU5QpXjyCJGi6LYkGZyqDGAoSK7UDg9DIlEh3PC4ydF13MQyLSoe4yMbJ8/BMV1vVKt1wLw1qVRFf7cCtkX1UBs6WYQ+jQrxCZwmR4DWngQ8Ra3hOBVxEL1I0nhygFF8NUWBVZYF4YQHOVYVCA3JSaU28nSyv2g2MCQ6fp2UtG6cbkqHreFdpqE6VHUS31dQTrqO2MeskB4RxtEQHoErZdUuChAjL0oyMKuKU+G0vUg9E4JRUN5EHAEuSEnBjJblHHX3a7UGKxJRtc+RG8SBpYTTGV1yf3EQBk/nCHYshUbH8VWEqym+ZwE+Ik5CMSh7IufkGingGvBK/cIC7+WJ0pjwdiLhlA3kifBg5N40POqpwjUirzJYzHZM6N0ap138TMCTYAGUocXuAu1sjcAeJDopXSuKIAWTSIgmUbGNvgkjnBzRoUIqnPzTL/4cXBchWq21SVAUKfiTOEtKSl5SodgjYjqKiRigQ6m0LxuBljh2XRyCKuSJvKIRwGl1nseT5jcuTt1JH2UtnmQx3FwEDlEuSlwccRSmaUT9+KlgqVT6JtpPrb2ESPBrRtBJqZHm6ftj3x+M/aEotZcf8wNiqtSaoiCMmoCwNKXaqKqZjWpThz+RYMhBPxi59OoZeCkYgOf28X88EYwRT02ImrI4zRTVRi6lJ4KdlgWVgDm36NiE7Hse1EEhkj0SLLUekMimb0YRRfMSPFGoRkV8kURJlRnqr5AIrvMMb0JXC4ARwU5lcPF1LgU3reqkng4nw0cwYJXOlaV0GFjV2u05qC6Mlk5nZ4WoUk5INBIAVjDE3OhbVJIojLysoHKVZVeAnORsG6un4Ge0KaqovjcM00xSDKRSCB2LSjyEjVg3CtA8p4O50kc7L/ARB8wpi+AdOmDTMJmoJAHoCD0kjc4UgNMLURaGAZItNYoQm2c0WxgoA56p8HbYRGRx4aTSpP7ISJwy8f0gdOyckg3iGQa3LRtIb2BJnGarOdOotQzNzEWcf1xIhwVCBKOk6PCSPHPTPEozDqzFWkJYrlGLbcnEt35IcUbHKyFKLLMCRgdkhorKRM5UiKZOvkCBAwHAtKnRA2RSnDrFlXkaIkiEKxBjI6JXZHEaUpyK/Cz2rpAIc5EgjSSLCmqO0nLxzTuqaqXiewNkIuBgCUzsqxSmVXMs2t9h4gtGBPej4+cf0QlJtaxKxanVqy0sMQWF+K4LYW34EaZtADrTZAzLVytTytz8SdF6CHfLEKJ0AISzIPAIRlSSHHmR0D5VmSBKAFlYM3FQTQyKM8hdSXxLDqevDSDaCIYA76KvUaHeKSom0rfcxAnt66i0z1zS9bm4njgcnQ2MY1E2SuAbhmXmIh6FbGG64VAJrSwFUaFWb0V8Ko3DQjQ3Y+5EkaiORh3+FYv2AC2ziotFY1ZBh6XpxLpB5BRecnbtLCwpSBMVKHJRE8FSYb6k00iL0OSovqfRDmqckr8Cn03LrlYbVNoljC2DJJLpDCx96QufgEhZIuWCRRP3hG8TvOmiVKI5Vk0RpUnxNTykVOEvyIaqwJfJlkUS+yUVoajfBWNI4hD3JwRhJZCP02kFRfAiOqepip53ZXJwknPwNiTkVmPWNh1F9Kg4Th1QT7srEe25JMg0wPyCOvFqpmmHoQclpHFVDF2enIWBjaFXLVOmjI8FzMqoTBngRJzCrqoaknCaFpZZQ8AHPDJMJ6HcGJJTMLlSaUIjIVIzIcIoIJFpihzTzNJIgxSgtKnI0FtZ5uZpo9bG9LIkKjJfheA2TcgMVhqFkC4ASJDGBLBY5grJ4GLS1yC0giS+jgqUJ6/X2vVaR3CCHCgD2fv/AnhhAKaznwzsAAAAAElFTkSuQmCC';\n\nconst base64ToImage = (base64: string) => {\n  return `data:image/png;base64,${base64}`;\n}\n\nconst DiscordWidget: React.FC<DiscordWidgetProps> = ({\n  serverId = \"\",\n  className = \"\"\n}) => {\n  const [serverData, setServerData] = useState<DiscordServer | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchDiscordData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // For now, we'll use the local discord.json file\n        // In a real implementation, you'd fetch from Discord's widget API\n        const response = await fetch(`https://discord.com/api/guilds/${serverId}/widget.json`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch Discord data');\n        }\n\n        const data: DiscordServer = await response.json();\n        setServerData(data);\n      } catch (err) {\n        log.error('Error fetching Discord data:', err);\n        setError(err instanceof Error ? err.message : 'Unknown error');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchDiscordData();\n  }, [serverId]);\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'online':\n        return '#43b581';\n      case 'idle':\n        return '#faa61a';\n      case 'dnd':\n        return '#f04747';\n      default:\n        return '#747f8d';\n    }\n  };\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'online':\n        return '';\n      case 'idle':\n        return '';\n      case 'dnd':\n        return '';\n      default:\n        return '';\n    }\n  };\n\n  const handleOpenDiscord = () => {\n    if (serverData?.instant_invite) {\n      window.open(serverData.instant_invite, '_blank');\n    } else {\n      // Fallback to Discord invite or server page\n      // window.open(`https://discord.gg/${serverId}`, '_blank');\n      window.open(`https://discord.gg/QxjqVAuN8T`, '_blank');\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className={`discord-widget ${className}`}>\n        <div className=\"discord-widget-header\">\n          <div className=\"discord-widget-server-info\">\n            <img\n              src={base64ToImage(imageBase64)}\n              alt=\"Discord server icon\"\n              className=\"discord-widget-server-icon\"\n              onError={(e) => {\n                const target = e.target as HTMLImageElement;\n                target.style.display = 'none';\n              }}\n            />\n            <div className=\"discord-widget-server-details\">\n              <div className=\"discord-widget-title\">Discord</div>\n            </div>\n          </div>\n        </div>\n        <div className=\"discord-widget-content\">\n          <div className=\"discord-loading\">Loading...</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (error || !serverData) {\n    return (\n      <div className={`discord-widget ${className}`}>\n        <div className=\"discord-widget-header\">\n          <div className=\"discord-widget-server-info\">\n            <img\n              src={base64ToImage(imageBase64)}\n              alt=\"Discord server icon\"\n              className=\"discord-widget-server-icon\"\n              onError={(e) => {\n                const target = e.target as HTMLImageElement;\n                target.style.display = 'none';\n              }}\n            />\n            <div className=\"discord-widget-server-details\">\n              <div className=\"discord-widget-title\">Discord</div>\n            </div>\n          </div>\n        </div>\n        <div className=\"discord-widget-content\">\n          <div className=\"discord-error\">\n            Failed to load Discord data\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`discord-widget ${className}`}>\n      <div className=\"discord-widget-header\">\n        <div className=\"discord-widget-server-info\">\n          <img\n            src={base64ToImage(imageBase64)}\n            alt={`${serverData.name} server icon`}\n            className=\"discord-widget-server-icon\"\n            onError={(e) => {\n              const target = e.target as HTMLImageElement;\n              target.style.display = 'none';\n            }}\n          />\n          <div className=\"discord-widget-server-details\">\n            <div className=\"discord-widget-title\">{serverData.name}</div>\n            <div className=\"discord-widget-subtitle\">\n              {serverData.presence_count} members online\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"discord-widget-content\">\n        <div className=\"discord-members-list\">\n          {serverData.members.map((member) => (\n            <div key={member.id} className=\"discord-member\">\n              <div className=\"discord-member-avatar\">\n                <img\n                  src={member.avatar_url}\n                  alt={member.username}\n                  onError={(e) => {\n                    const target = e.target as HTMLImageElement;\n                    target.src = `https://cdn.discordapp.com/embed/avatars/${parseInt(member.discriminator) % 5}.png`;\n                  }}\n                />\n                <div\n                  className=\"discord-member-status\"\n                  style={{ backgroundColor: getStatusColor(member.status) }}\n                >\n                  {getStatusIcon(member.status)}\n                </div>\n              </div>\n              <div className=\"discord-member-info\">\n                <div className=\"discord-member-name\">\n                  {member.username}\n                  {member.game && (\n                    <div className=\"discord-member-game\">\n                      Playing {member.game.name}\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"discord-widget-footer\">\n        <button\n          className=\"discord-open-button\"\n          onClick={handleOpenDiscord}\n        >\n          <i className=\"fab fa-discord\"></i>\n          Open in Discord\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default DiscordWidget;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\ProfilePromoItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":51,"column":3,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":53,"endColumn":5}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createRef, useEffect, useRef, useState } from \"react\";\r\n\r\n\r\nimport { GalleryPromoItem } from \"@/apps/launcher/components/PromoItems/GalleryPromoItem\";\r\nimport { VideoPromoItem } from \"@/apps/launcher/components/PromoItems/VideoPromoItem\";\r\nimport { WebviewPromoItem } from \"@/apps/launcher/components/PromoItems/WebviewPromoItem\";\r\nimport { YTVideoPromoItem } from \"@/apps/launcher/components/PromoItems/YTVideoPromoItem\";\r\nimport { AppProvider, AppProviderValues, useApp } from \"@/apps/launcher/context/AppContext\";\r\nimport type { LauncherProfileElement } from \"@/apps/launcher/types\";\n\r\n\r\nexport interface ProfilePromoItemProps {\r\n  element: LauncherProfileElement;\r\n  onClick?: (element: LauncherProfileElement) => void;\r\n  onDoubleClick?: (element: LauncherProfileElement) => void;\r\n}\r\n\r\nexport const ProfilePromoItem = function(props: ProfilePromoItemProps){\r\n  const element = props.element;\r\n  const appContext = useApp();\r\n\r\n  let jsxElement: JSX.Element = (\r\n    <div className=\"promo-element\">\r\n      <p>[Invalid Promo Element]</p>\r\n    </div>\r\n  );\r\n\r\n  switch(element.type){\r\n    case 'gallery':\r\n      jsxElement = (\r\n        <GalleryPromoItem element={element} onClick={props.onClick} onDoubleClick={props.onDoubleClick}></GalleryPromoItem>\r\n      );\r\n    break;\r\n    case 'video':\r\n      jsxElement = (\r\n        <VideoPromoItem element={element} onClick={props.onClick} onDoubleClick={props.onDoubleClick}></VideoPromoItem>\r\n      )\r\n    break;\r\n    case 'webview':\r\n      jsxElement = (\r\n        <WebviewPromoItem element={element} onClick={props.onClick} onDoubleClick={props.onDoubleClick}></WebviewPromoItem>\r\n      )\r\n    break;\r\n    case 'ytvideo':\r\n      jsxElement = (\r\n        <YTVideoPromoItem element={element} onClick={props.onClick} onDoubleClick={props.onDoubleClick}></YTVideoPromoItem>\r\n      )\r\n    break;\r\n  }\r\n\r\n  return (\r\n    jsxElement\r\n  );\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\PromoItems\\GalleryPromoItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":14,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":14,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":27,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":27,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .images on a type that cannot be resolved.","line":27,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":27,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":36,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":36,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .images on a type that cannot be resolved.","line":36,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":36,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":56,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":56,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .images on a type that cannot be resolved.","line":56,"column":20,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":56,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on a type that cannot be resolved.","line":56,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":56,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":58,"column":116,"nodeType":"MemberExpression","messageId":"anyAssignment","endLine":58,"endColumn":131},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .path_full on an `any` value.","line":58,"column":122,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":58,"endColumn":131},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .path_thumbnail on an `any` value.","line":58,"column":171,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":58,"endColumn":185},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":62,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":62,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .path_full on an `any` value.","line":62,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":62,"endColumn":41}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createRef, useEffect, useState } from \"react\";\r\n\r\nimport { useApp } from \"@/apps/launcher/context/AppContext\";\r\nimport { useProfile } from \"@/apps/launcher/context/ProfileContext\";\nimport type { LauncherProfileElement } from \"@/apps/types\";\r\n\r\nexport interface GalleryPromoItemProps {\r\n  element: LauncherProfileElement;\r\n  onClick?: (element: LauncherProfileElement) => void;\r\n  onDoubleClick?: (element: LauncherProfileElement) => void;\r\n}\r\n\r\nexport const GalleryPromoItem = function(props: GalleryPromoItemProps) {\r\n  const element = props.element;\r\n\r\n  const [index, setIndex] = useState(0);\r\n\r\n  const onBtnLeftClick: React.MouseEventHandler<HTMLDivElement> = (e: React.MouseEvent<HTMLDivElement>) => {\r\n    galleryPreviousImage();\r\n  };\r\n\r\n  const onBtnRightClick: React.MouseEventHandler<HTMLDivElement> = (e: React.MouseEvent<HTMLDivElement>) => {\r\n    galleryNextImage();\r\n  };\r\n\r\n  const galleryPreviousImage = () => {\r\n    const count = element.images.length;\r\n    const newIndex = index - 1;\r\n    setIndex(index - 1);\r\n    if(newIndex < 0){\r\n      setIndex(count - 1);\r\n    }\r\n  }\r\n\r\n  const galleryNextImage = () => {\r\n    const count = element.images.length;\r\n    const newIndex = index + 1;\r\n    setIndex(index + 1);\r\n    if(newIndex >= count){\r\n      setIndex(0);\r\n    }\r\n  }\r\n\r\n  useEffect(() => {\r\n    const interval = setInterval(() => {\r\n      galleryNextImage();\r\n    }, 2500)\r\n    return () => clearInterval(interval);\r\n  }, [index]);\r\n\r\n  return (\r\n    <div className=\"promo-element gallery\">\r\n      <div className=\"gallery-left\" onClick={onBtnLeftClick}><i className=\"fas fa-chevron-left\"></i></div>\r\n      <div className=\"gallery-images\">\r\n        {\r\n          (element.images ?? []).map((image, i: number) => {\r\n            return (\r\n              <div key={`gallery-image-${i}`} className={`gallery-image ${i == index ? 'active' : ''}`} data-full={image.path_full} style={{backgroundImage: `url(${image.path_thumbnail})`}} onClick={() => {\r\n                if(typeof props.onClick === 'function'){\r\n                  props.onClick({\r\n                    type: 'image',\r\n                    url: image.path_full,\r\n                  });\r\n                }\r\n              }}></div>\r\n            )\r\n          }\r\n        )}\r\n      </div>\r\n      <div className=\"gallery-right\" onClick={onBtnRightClick}><i className=\"fas fa-chevron-right\"></i></div>\r\n    </div>\r\n  );\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\PromoItems\\VideoPromoItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":16,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":16,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":55,"column":38,"nodeType":"MemberExpression","messageId":"anyAssignment","endLine":55,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .url on a type that cannot be resolved.","line":55,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":55,"endColumn":49}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef } from \"react\";\n\nimport { useApp } from \"@/apps/launcher/context/AppContext\";\nimport type { LauncherProfileElement } from \"@/apps/types\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Launcher);\n\nexport interface VideoPromoItemProps {\n  element: LauncherProfileElement;\n  onClick?: (element: LauncherProfileElement) => void;\n  onDoubleClick?: (element: LauncherProfileElement) => void;\n}\n\nexport const VideoPromoItem = function(props: VideoPromoItemProps){\n  const element = props.element;\n\n  const appContext = useApp();\n\n  const videoElement = useRef(null) as React.RefObject<HTMLVideoElement>;\n  const onVideoClick: React.MouseEventHandler<HTMLDivElement> = (e: React.MouseEvent<HTMLDivElement>) => {\n    log.debug('onVideoClick', videoElement.current, e);\n    if(videoElement.current){\n      const elem: HTMLVideoElement = videoElement.current;\n      if(elem === document.fullscreenElement){\n        if (elem.paused == false) {\n          elem.pause();\n        } else {\n          elem.play();\n        }\n      }else{\n        if (elem.requestFullscreen) {\n          elem.requestFullscreen();\n        }\n\n        //elem.currentTime = 0;\n        elem.volume = 0.25;\n        elem.loop = false;\n      }\n    }\n  };\n\n  const onVideoDoubleClick: React.MouseEventHandler<HTMLVideoElement> = (e: React.MouseEvent<HTMLVideoElement>) => {\n    log.trace('onVideoDoubleClick', videoElement.current, e);\n    if(videoElement.current){\n      const elem: HTMLVideoElement = videoElement.current;\n      if(elem === document.fullscreenElement){\n        document.exitFullscreen()\n      }\n    }\n  };\n\n  return (\n    <div className=\"promo-element video\" onClick={onVideoClick}>\n      <video ref={videoElement} src={element.url} loop autoPlay style={{height: '250px'}} onLoadStart={() => { if(videoElement?.current){ videoElement.current.volume=0 } }} onDoubleClick={onVideoDoubleClick}></video>\n    </div>\n  );\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\PromoItems\\WebviewPromoItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":13,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":13,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":18,"column":20,"nodeType":"MemberExpression","messageId":"anyAssignment","endLine":18,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .url on a type that cannot be resolved.","line":18,"column":28,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":18,"endColumn":31}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\r\n\r\nimport { useApp } from \"@/apps/launcher/context/AppContext\";\nimport type { LauncherProfileElement } from \"@/apps/types\";\r\n\r\nexport interface WebviewPromoItemProps {\r\n  element: LauncherProfileElement;\r\n  onClick?: (element: LauncherProfileElement) => void;\r\n  onDoubleClick?: (element: LauncherProfileElement) => void;\r\n}\r\n\r\nexport const WebviewPromoItem = function(props: WebviewPromoItemProps) {\r\n  const element = props.element;\r\n  const appContext = useApp();\r\n\r\n  return (\r\n    <div className=\"promo-element webview\">\r\n      <iframe src={element.url} width=\"646\" height=\"190\" />\r\n    </div>\r\n  );\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\components\\PromoItems\\YTVideoPromoItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":13,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":13,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":30,"column":36,"nodeType":"MemberExpression","messageId":"anyAssignment","endLine":30,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .thumbnail on a type that cannot be resolved.","line":30,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":30,"endColumn":53}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef } from \"react\";\r\n\r\nimport { useApp } from \"@/apps/launcher/context/AppContext\";\nimport type { LauncherProfileElement } from \"@/apps/types\";\r\n\r\nexport interface YTVideoPromoItemProps {\r\n  element: LauncherProfileElement;\r\n  onClick?: (element: LauncherProfileElement) => void;\r\n  onDoubleClick?: (element: LauncherProfileElement) => void;\r\n}\r\n\r\nexport const YTVideoPromoItem = function(props: YTVideoPromoItemProps) {\r\n  const element = props.element;\r\n\r\n  const imageElement = useRef(null) as React.RefObject<HTMLImageElement>;\r\n  const onYTVideoClick: React.MouseEventHandler<HTMLDivElement> = (e: React.MouseEvent<HTMLDivElement>) => {\r\n    if(typeof props.onClick === 'function'){\r\n      props.onClick(element);\r\n    }\r\n  };\r\n\r\n  const onImageDoubleClick: React.MouseEventHandler<HTMLImageElement> = (e: React.MouseEvent<HTMLImageElement>) => {\r\n    if(typeof props.onDoubleClick === 'function'){\r\n      props.onDoubleClick(element);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"promo-element ytvideo\" onClick={onYTVideoClick}>\r\n      <img ref={imageElement} src={element.thumbnail} style={{height: '250px'}} onDoubleClick={onImageDoubleClick} />\r\n    </div>\r\n  );\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\apps\\launcher\\index.tsx","messages":[{"ruleId":"@typescript-eslint/no-invalid-void-type","severity":2,"message":"void is only valid as a return type or generic type argument.","line":270,"column":18,"nodeType":"TSVoidKeyword","messageId":"invalidVoidNotReturnOrGeneric","endLine":270,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useMemo, useState } from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\nimport \"@/apps/launcher/app.scss\";\n\n\nimport { CategoryMenuItem } from \"@/apps/launcher/components/CategoryMenuItem\";\nimport { CommunityTabContent } from \"@/apps/launcher/components/CommunityTabContent\";\nimport DiscordWidget from \"@/apps/launcher/components/DiscordWidget\";\nimport { GOGWidget } from \"@/apps/launcher/components/GOGWidget\";\nimport type { ProfileTabContentHandle } from \"@/apps/launcher/components/ProfileTabContent\";\nimport { ProfileTabContent } from \"@/apps/launcher/components/ProfileTabContent\";\nimport { AppProvider, useApp } from \"@/apps/launcher/context/AppContext\";\nimport { Launcher } from \"@/apps/launcher/context/Launcher\";\nimport type { LauncherProfile, ProfileCategory } from \"@/apps/launcher/types\";\nimport { ApplicationEnvironment } from \"@/enums/ApplicationEnvironment\";\nimport { ApplicationProfile } from \"@/utility/ApplicationProfile\";\nimport { ConfigClient } from \"@/utility/ConfigClient\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Launcher);\n\ndeclare global {\n  interface Window {\n    Launcher?: typeof Launcher;\n    ConfigClient?: typeof ConfigClient;\n    launcherView?: Promise<void>;\n  }\n}\nwindow.Launcher = Launcher;\nwindow.ConfigClient = ConfigClient;\n\nif(window.location.origin === 'file://'){\n  ApplicationProfile.ENV = ApplicationEnvironment.ELECTRON;\n  ApplicationProfile.isMac = window.electron.isMac();\n}else{\n  ApplicationProfile.ENV = ApplicationEnvironment.BROWSER;\n  const menuTopRight = document.getElementById('launcher-menu-top-right');\n  if(menuTopRight) menuTopRight.style.display = 'none';\n}\n\nconst App = function() {\n  const appContext = useApp();\n  const [appReady, setAppReady] = useState<boolean>(false);\n\n  const [selectedProfileValue, setSelectedProfile] = appContext.selectedProfile;\n  const [profileCategoriesValue, setProfilesCategories] = appContext.profileCategories;\n  const [backgroundImageValue, setBackgroundImage] = appContext.backgroundImage;\n  const [discordWidgetOpen, setDiscordWidgetOpen] = appContext.discordWidgetOpen;\n\n  const [selectedTab, setSelectedTab] = useState('apps');\n\n  const [showMenuTopRight, setShowMenuTopRight] = useState(false);\n\n  let tabRefs: React.RefObject<ProfileTabContentHandle | null>[] = Array(Object.values(profileCategoriesValue).reduce((acc: number, cat: ProfileCategory) => {\n    return acc + cat.profiles.length;\n  }, 0)).fill(0).map(() => React.createRef<ProfileTabContentHandle | null>());\n\n  let resizeEndTimeout: ReturnType<typeof setTimeout>;\n  const onResizeEnd = () => {\n    log.trace('resize end');\n    ConfigClient.set(['Launcher', 'width'], window.outerWidth);\n    ConfigClient.set(['Launcher', 'height'], window.outerHeight);\n    log.debug('tabRefs count', tabRefs.length);\n  };\n\n  const onResize = () => {\n    clearTimeout(resizeEndTimeout);\n    resizeEndTimeout = setTimeout(onResizeEnd, 100);\n  };\n\n  const onFocus = () => {\n    Launcher.InitProfiles().then( () => {\n      setProfilesCategories(Launcher.AppCategories);\n      setSelectedProfile(\n        Launcher.GetProfileByKey(\n          ConfigClient.get(['Launcher', 'selected_profile'], 'kotor')\n        )\n      );\n      document.body.style.display = '';\n      // getProfileByKey();\n    })\n  };\n\n  const onFullscreenChange = (event: Event) => {\n    log.debug('fullscreenchange', document.fullscreenElement, event)\n    if(document.fullscreenElement == null){\n      if(event.target instanceof HTMLVideoElement){\n        event.target.volume = 0;\n        event.target.loop = true;\n        if(event.target.currentTime == event.target.duration){\n          event.target.currentTime = 0;\n        }\n        event.target.play();\n      }\n    }\n  };\n\n  useEffect(() => {\n    log.trace('selectedProfile', selectedProfileValue?.key, 'tabRefs', tabRefs.length);\n\n    if(!selectedProfileValue) return;\n    if(!tabRefs[selectedProfileValue.id]?.current) return;\n\n    tabRefs[selectedProfileValue.id].current.showTab();\n  }, [selectedProfileValue])\n\n  //on-mount\n  useEffect(() => {\n    log.trace('mount: tabRefs initial', tabRefs.length);\n    window.addEventListener('resize', onResize);\n    setShowMenuTopRight(!(ApplicationProfile.ENV == ApplicationEnvironment.BROWSER));\n    Launcher.InitProfiles().then( () => {\n      setProfilesCategories(Launcher.AppCategories);\n      setSelectedProfile(\n        Launcher.GetProfileByKey(\n          ConfigClient.get(['Launcher', 'selected_profile'], 'kotor')\n        )\n      );\n      document.body.style.display = '';\n      tabRefs = Array(Object.values(Launcher.AppCategories).reduce((acc: number, cat: ProfileCategory) => {\n        return acc + cat.profiles.length;\n      }, 0)).fill(0).map(() => React.createRef<ProfileTabContentHandle | null>());\n      log.debug('mount: tabRefs after InitProfiles', tabRefs.length);\n      setAppReady(true);\n    })\n\n    window.addEventListener('focus', onFocus);\n    document.addEventListener('fullscreenchange', onFullscreenChange);\n    //on-unmount\n    return () => {\n      log.trace('launcher unmount: removing resize/focus/fullscreen listeners');\n      window.removeEventListener('resize', onResize);\n      window.removeEventListener('resize', onFocus);\n      document.removeEventListener('fullscreenchange', onFullscreenChange);\n      clearTimeout(resizeEndTimeout);\n    }\n  }, []);\n\n  useEffect(() => {\n    log.trace('profileCategories changed', Object.keys(appContext.profileCategories).length);\n  }, [appContext.profileCategories]);\n\n  const onBtnMinimize = (e: React.MouseEvent<HTMLDivElement>) => {\n    // e.preventDefault();\n    if(ApplicationProfile.ENV == ApplicationEnvironment.ELECTRON){\n      window.electron.minimize();\n    }\n  }\n  const onBtnMaximize = (e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    if(ApplicationProfile.ENV == ApplicationEnvironment.ELECTRON){\n      window.electron.maximize();\n    }\n  }\n  const onBtnClose = (e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    if(ApplicationProfile.ENV == ApplicationEnvironment.ELECTRON){\n      window.close();\n    }\n  }\n\n  const onTabClicked = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    e.preventDefault();\n    const tabId = e.currentTarget.href.split('#').pop();\n    if(!tabId){ return; }\n    setSelectedTab(tabId);\n  }\n\n  const onDiscordToggle = (e: React.MouseEvent<HTMLLIElement>) => {\n    e.preventDefault();\n    setDiscordWidgetOpen(!discordWidgetOpen);\n  }\n\n  return (\n    <>\n      <div id=\"container\" className={`${appReady ? 'ready': ''} ${discordWidgetOpen ? 'discord_widget_open' : ''}`} style={{'backgroundImage': `url(\"${backgroundImageValue}\")`}}>\n        <div className=\"launcher-menu\">\n          <div className=\"launcher-menu-background\"></div>\n          <div className=\"menu-accent\"><div className=\"inner\"></div></div>\n          <ul className=\"top-nav\">\n            <li className=\"tab-btn nav-logo\"><img src=\"images/kotor-js-logo.png\" /></li>\n            <li className=\"tab-btn\"><a href=\"#apps\" onClick={onTabClicked}>Apps</a></li>\n            <li className=\"tab-btn\"><a href=\"#community\" onClick={onTabClicked}>Community</a></li>\n            <li className=\"tab-btn\"><a href=\"#buy\" onClick={onTabClicked}>Need KotOR?</a></li>\n            <li className=\"tab-btn discord-toggle\" onClick={onDiscordToggle} title={discordWidgetOpen ? \"Hide Discord\" : \"Show Discord\"}>\n              <i className={`fab fa-discord ${discordWidgetOpen ? 'active' : ''}`}></i>\n            </li>\n          </ul>\n          {showMenuTopRight && (\n            <div id=\"launcher-menu-top-right\" className=\"launcher-menu-top-right\">\n              <div className=\"launcher-min\" title=\"Minimize Window\" onClick={onBtnMinimize}><i className=\"fas fa-window-minimize\"></i></div>\n              <div className=\"launcher-max\" title=\"Maximize Window\" onClick={onBtnMaximize}><i className=\"far fa-clone\"></i></div>\n              <div className=\"launcher-close\" title=\"Close Window\" onClick={onBtnClose}><i className=\"fas fa-times\"></i></div>\n            </div>\n          )}\n        </div>\n        <div className=\"tab-host\">\n          {(selectedTab == 'apps' && <div className=\"tab selected\">\n            <div className=\"launcher-options\">\n              {Object.values(profileCategoriesValue).map((category: ProfileCategory, i: number) => {\n                return (\n                  <CategoryMenuItem category={category} key={`cat-menu-item-${i}`}></CategoryMenuItem>\n                )\n              })}\n            </div>\n            <div className=\"launcher-contents\">\n              {Object.values(profileCategoriesValue).map((category: ProfileCategory, index: number) => {\n                return (\n                  category.profiles.map((profile, index: number) => {\n                    return (\n                      <ProfileTabContent ref={tabRefs[profile.id]} profile={profile} active={selectedProfileValue == profile ? true : false} key={`profile-content-item-${profile.id}`}></ProfileTabContent>\n                    )\n                  })\n                )\n              })}\n            </div>\n          </div>)}\n          {(selectedTab == 'community' && <div className=\"tab selected\">\n            <div className=\"launcher-contents full-width\">\n              <CommunityTabContent />\n            </div>\n          </div>)}\n          {(selectedTab == 'buy' && <div className=\"tab selected\">\n            <div className=\"launcher-contents full-width d-flex\">\n              <div className=\"panel scroll-y\">\n                <p>This project does not support piracy. To use this app, you will need to have obtained a legal copy of the supported games that you wish to play.</p>\n                <br />\n\n                <h3 className=\"title\">GOG Store</h3>\n                <div className=\"buy-widgets\" style={{display: 'flex', gap: '20px', flexWrap: 'wrap', marginTop: '20px'}}>\n                  <GOGWidget\n                    productId=\"1207666283\" // KotOR 1 GOG ID\n                    onError={(error) => log.error('GOG Widget Error', error)}\n                    onProductLoaded={(product) => log.info('GOG Widget product loaded', product)}\n                    showPrice={true}\n                    showDiscount={true}\n                  />\n                  <GOGWidget\n                    productId=\"1421404581\" // KotOR 2 GOG ID\n                    onError={(error) => log.error('GOG Widget Error', error)}\n                    onProductLoaded={(product) => log.info('GOG Widget product loaded', product)}\n                    showPrice={true}\n                    showDiscount={true}\n                  />\n                </div>\n\n                <br />\n                <h3 className=\"title\">Steam Store</h3>\n                <div className=\"buy\">\n                  <br />\n                  <iframe src=\"https://store.steampowered.com/widget/32370/\" frameBorder=\"0\" width=\"646\" height=\"190\"></iframe>\n                  <br />\n                  <iframe src=\"https://store.steampowered.com/widget/208580/\" frameBorder=\"0\" width=\"646\" height=\"190\"></iframe>\n                </div>\n              </div>\n            </div>\n          </div>)}\n          <div className=\"version\">{process.env.VERSION}</div>\n        </div>\n        <DiscordWidget serverId=\"739590575359262792\" />\n      </div>\n    </>\n  );\n\n}\n\n/** Launcher exposes root render on window for tooling. */\ninterface WindowWithLauncherView extends Window {\n  launcherView?: void;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement);\n(async () => {\n  (window as WindowWithLauncherView).launcherView = root.render(\n    <React.StrictMode>\n      <AppProvider>\n        <App />\n      </AppProvider>\n    </React.StrictMode>\n  );\n})();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\audio\\AudioEmitter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":419,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":419,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AudioEngine } from \"@/audio/AudioEngine\";\nimport { AudioLoader } from \"@/audio/AudioLoader\";\nimport { AudioEmitterType } from \"@/enums/audio/AudioEmitterType\";\nimport { AudioEngineChannel } from \"@/enums/audio/AudioEngineChannel\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/** AudioBufferSourceNode with optional custom .name (resRef) for tracking. */\ntype AudioBufferSourceWithName = AudioBufferSourceNode & { name?: string };\n\nconst GAIN_RAMP_TIME = 0.25;\nconst PRIORITY_GROUP_DEFAULT = 23;\n\nenum AudioEmitterState {\n  STOPPED = 0,\n  PLAYING = 1,\n  FADING_OUT = 2,\n  FADING_IN = 3,\n}\n\n/**\n * AudioEmitter class.\n * \n * The AudioEmitter class is used in conjunction with AudioEngine class manage global and positional audio emitters in the game.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file AudioEmitter.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class AudioEmitter {\n  isDestroyed: boolean;\n  position: { x: number; y: number; z: number; } = {x: 0, y: 0, z: 0};\n  engine: AudioEngine;\n  gainNode: GainNode;\n  pannerNode: PannerNode;\n  mainNode: AudioNode;\n  state: AudioEmitterState = AudioEmitterState.STOPPED;\n\n  name: string = '';\n  sounds: string[] = [];\n  isActive: boolean = true;\n  isLooping: boolean = false;\n  isRandom: boolean = false;\n  isRandomPosition: boolean = false;\n  randomX: number = 0;\n  randomY: number = 0;\n  randomZ: number = 0;\n  interval: number = 0;\n  intervalVariation: number = 0;\n  minDistance: number = 0;\n  maxDistance: number = 1;\n  volume: number = 127;\n  volumeVariation: number = 0;\n  soundIndex: number = 0;\n  playbackRate: number = 1;\n  playbackRateVariation: number = 0;\n  elevation: number = 0;\n\n  priority: number = PRIORITY_GROUP_DEFAULT;\n\n  currentSound: AudioBufferSourceNode = undefined;\n  buffers: Map<string, AudioBuffer> = new Map<string, AudioBuffer>();\n  channel: AudioEngineChannel = AudioEngineChannel.SFX;\n  type: AudioEmitterType = AudioEmitterType.GLOBAL;\n  interationCount: number = 0;\n\n  disabled: boolean = false;\n\n  constructor (audioEngine: AudioEngine, channel: AudioEngineChannel = AudioEngineChannel.SFX) {\n    this.isDestroyed = false;\n\n    this.engine = audioEngine;\n    this.channel = channel;\n\n    this.position = {x: 0, y: 0, z: 0};\n    this.gainNode = this.engine.audioCtx.createGain();\n    this.pannerNode = this.engine.audioCtx.createPanner();\n  }\n\n  setVolume(volume: number = 127): AudioEmitter {\n    this.volume = Math.max(0, Math.min(127, volume));\n    if(this.gainNode){\n      this.gainNode.gain.value = this.volume;\n    }\n    return this;\n  }\n\n  setPosition(x = 0, y = 0, z = 0): void {\n    x = isNaN(x) ? this.position.x : x;\n    y = isNaN(y) ? this.position.y : y;\n    z = isNaN(z) ? this.position.z : z;\n\n    // We need to cache the values below because setPosition stores the floats in a higher precision than THREE.Vector3\n    // which could keep them from matching when compared\n    if(this.position.x != x || this.position.y != y || this.position.z != z){\n      this.position.x = x;\n      this.position.y = y;\n      this.position.z = z + this.elevation;\n    }\n\n    if(this.mainNode instanceof PannerNode && (\n      this.mainNode.positionX.value != this.position.x ||\n      this.mainNode.positionY.value != this.position.y ||\n      this.mainNode.positionZ.value != this.position.z + this.elevation\n    )){\n      this.mainNode.positionX.value = this.position.x;\n      this.mainNode.positionY.value = this.position.y;\n      this.mainNode.positionZ.value = this.position.z + this.elevation;\n    }\n  }\n\n  setDisabled(disabled: boolean): void {\n    if(disabled == this.disabled){\n      return;\n    }\n    return;\n    this.disabled = disabled;\n    this.gainNode.gain.linearRampToValueAtTime(disabled ? 0 : 1, this.engine.audioCtx.currentTime + GAIN_RAMP_TIME);\n  }\n\n  async load(): Promise<void> {\n    this.gainNode.gain.value = this.getVolume();\n\n    switch(this.type){\n      case AudioEmitterType.POSITIONAL:\n        this.mainNode = this.engine.audioCtx.createPanner();\n        this.setPosition( this.position.x, this.position.y, this.position.z + this.elevation );\n        (this.mainNode as PannerNode).maxDistance = this.maxDistance;\n        this.mainNode.connect(this.gainNode);\n      break;\n      case AudioEmitterType.GLOBAL:\n        this.mainNode = this.gainNode;\n      break;\n    }\n\n    this.setChannel(this.channel);\n\n    if(this.engine){\n      this.engine.addEmitter(this);\n    }\n\n    for(let i = 0; i < this.sounds.length; i++){\n      await this.loadSounds(i);\n    }\n    if(this.isActive){\n      this.start();\n    }\n  }\n\n  setChannel(channel: AudioEngineChannel): void {\n    this.channel = channel;\n\n    if(!this.gainNode){ return; }\n\n    try{\n      this.gainNode.disconnect();\n    }catch(e){\n      log.error(e as Error);\n    }\n\n    switch(this.channel){\n      case AudioEngineChannel.VO:\n        this.gainNode.connect(AudioEngine.voChannel.getGainNode());\n      break;\n      case AudioEngineChannel.MUSIC:\n        this.gainNode.connect(AudioEngine.musicChannel.getGainNode());\n      break;\n      case AudioEngineChannel.MOVIE:\n        this.gainNode.connect(AudioEngine.movieChannel.getGainNode());\n      break;\n      case AudioEngineChannel.GUI:\n        this.gainNode.connect(AudioEngine.guiChannel.getGainNode());\n      break;\n      default:\n        this.gainNode.connect(AudioEngine.sfxChannel.getGainNode());\n      break;\n    }\n  }\n\n  async loadSounds(soundIndex = 0): Promise<void> {\n    if(soundIndex >= this.sounds.length){\n      return;\n    }\n\n    const resRef = this.sounds[soundIndex];\n    try{\n      const data = await AudioLoader.LoadSound(resRef);\n      try{\n        await this.addSound(resRef, data);\n      }catch(e){\n        log.error('AudioEmitter', 'Sound not added to emitter', resRef);\n      }\n    }catch(e){\n      log.error('AudioEmitter', 'Sound not found', resRef);\n    }\n  }\n\n  ffsounds: AudioBufferSourceNode[] = [];\n\n  async playSoundFireAndForget(resRef = ''): Promise<AudioBufferSourceNode>{\n    if(resRef == '****' || !resRef?.length){ return; }\n    try{\n      const sound: AudioBufferSourceNode = this.engine.audioCtx.createBufferSource();\n      (sound as AudioBufferSourceWithName).name = resRef;\n      let buffer: AudioBuffer = (this.buffers.has(resRef)) ? this.buffers.get(resRef) : undefined;\n      if(!buffer){\n        const data = await AudioLoader.LoadSound(resRef);\n        buffer = await this.addSound(resRef, data);\n      }\n\n      if(!buffer){\n        log.error('AudioEmitter', 'Sound not found', resRef);\n        return;\n      }\n\n      this.ffsounds.push(sound);\n\n      sound.buffer = buffer;\n      sound.connect(this.mainNode);\n      sound.start(this.engine.audioCtx.currentTime);\n\n      sound.onended = () => {\n        sound.disconnect();\n        sound.stop(0);\n        this.ffsounds.splice(this.ffsounds.indexOf(sound), 1);\n      }\n      return sound;\n    }catch(e){\n      log.error('AudioEmitter', 'Failed to play sound', resRef);\n      log.error(e as Error);\n    }\n    return;\n  }\n\n  async playSound(resRef = ''): Promise<AudioBufferSourceNode>{\n    if(resRef == '****' || !resRef?.length){ return; }\n    this.disposeCurrentSound();\n\n    //attempt to load from the buffer cache\n    if(this.buffers.has(resRef)){\n      this.currentSound = this.engine.audioCtx.createBufferSource();\n      this.currentSound.buffer = this.buffers.get(resRef);\n      (this.currentSound as AudioBufferSourceWithName).name = resRef;\n      this.currentSound.loop = this.isLooping;\n      this.currentSound.connect(this.mainNode);\n      this.currentSound.start(this.engine.audioCtx.currentTime);\n      return this.currentSound;\n    }\n    \n    //load from disk\n    try{\n      const data = await AudioLoader.LoadSound(resRef);\n      try{\n        const buffer = await this.addSound(resRef, data);\n        this.currentSound = this.engine.audioCtx.createBufferSource();\n        this.currentSound.buffer = buffer;\n        (this.currentSound as AudioBufferSourceWithName).name = resRef;\n        this.currentSound.loop = this.isLooping;\n        this.currentSound.connect(this.mainNode);\n        this.currentSound.start(this.engine.audioCtx.currentTime);\n        return this.currentSound;\n      }catch(e){\n        log.info('AudioEmitter', 'Sound not added to emitter', resRef);\n        log.error(e as Error);\n      }\n    }catch(e){\n      log.info('AudioEmitter', 'Sound not found', resRef);\n    }\n  }\n\n  async playStreamWave(resRef =''): Promise<AudioBufferSourceNode> {\n    this.disposeCurrentSound();\n\n    //attempt to load from the buffer cache\n    if(this.buffers.has(resRef)){\n      this.stop();\n      this.currentSound = this.engine.audioCtx.createBufferSource();\n      this.currentSound.buffer = this.buffers.get(resRef);\n      // this.currentSound.buffer.onEnd = onEnd;\n      (this.currentSound as AudioBufferSourceWithName).name = resRef;\n      this.currentSound.start(this.engine.audioCtx.currentTime);\n      this.currentSound.connect(this.mainNode);\n      return this.currentSound;\n    }\n    \n    //load from disk\n    try{\n      const data = await AudioLoader.LoadStreamWave(resRef);\n      try{\n        const buffer = await this.addSound(resRef, data);\n        this.stop();\n        this.currentSound = this.engine.audioCtx.createBufferSource();\n        this.currentSound.buffer = buffer;\n        // this.currentSound.buffer.onEnd = onEnd;\n        (this.currentSound as AudioBufferSourceWithName).name = resRef;\n        this.currentSound.start(this.engine.audioCtx.currentTime);\n        this.currentSound.connect(this.mainNode);\n\n        return this.currentSound;\n      }catch(e){\n        log.info('AudioEmitter', 'Sound not added to emitter', resRef);\n        throw e;\n      }\n    }catch(e){\n      log.info('AudioEmitter', 'Failed to locate StreamWave', resRef);\n      throw e;\n    }\n  }\n\n  start(): void {\n    if(!this.sounds.length){\n      return;\n    }\n    this.state = AudioEmitterState.PLAYING;\n    this.disposeCurrentSound();\n    this.interationCount = 0;\n    this.gainNode.gain.setValueAtTime(this.getVolume(), this.getCurrentTime());\n    this.playNextSound();\n  }\n\n  getRandomVariation(value: number): number {\n    return ( Math.random() * (value * 2) ) - value;\n  }\n\n  getNextSoundIndex(): number {\n    if(this.isRandom){\n      return Math.floor(Math.random() * this.sounds.length);\n    }else{\n      this.soundIndex++;\n      if(this.soundIndex >= this.sounds.length)\n        this.soundIndex = 0;\n    }\n    return this.soundIndex;\n  }\n\n  getDelayInSeconds(): number {\n    return this.interationCount == 0 ? 0 : (this.interval + this.getRandomVariation(this.intervalVariation))/1000;\n  }\n\n  getPlaybackRate(): number {\n    return this.playbackRate + this.getRandomVariation(this.playbackRateVariation);\n  }\n\n  getVolume(): number {\n    return (this.volume + this.getRandomVariation(this.volumeVariation)) / 127;\n  }\n\n  getCurrentSoundName(): string {\n    return this.currentSound ? (this.currentSound as AudioBufferSourceWithName).name || '' : '';\n  }\n\n  isPlayingSound(resRef: string): boolean {\n    return this.getCurrentSoundName() == resRef;\n  }\n\n  playNextSound(): void {\n    if(this.isDestroyed || this.state == AudioEmitterState.FADING_OUT)\n      return;\n    \n    this.disposeCurrentSound();\n\n    if(!this.sounds.length){\n      return;\n    }\n\n    const resRef = this.sounds[this.soundIndex];\n    const delay = this.getDelayInSeconds();\n    this.interationCount++;\n    this.currentSound = this.engine.audioCtx.createBufferSource();\n    this.currentSound.buffer = this.buffers.get(resRef);\n    this.currentSound.loop = (this.sounds.length == 1 && this.isLooping);\n    (this.currentSound as AudioBufferSourceWithName).name = resRef;\n    this.currentSound.playbackRate.value = this.getPlaybackRate();\n    this.gainNode.gain.value = this.getVolume();\n\n    if(this.type == AudioEmitterType.POSITIONAL && (this.mainNode instanceof PannerNode)){\n      this.mainNode.positionX.value = this.position.x;\n      this.mainNode.positionY.value = this.position.y;\n      this.mainNode.positionZ.value = this.position.z + this.elevation;\n      if(this.isRandomPosition){\n        this.mainNode.positionX.value += this.getRandomVariation(this.randomX);\n        this.mainNode.positionY.value += this.getRandomVariation(this.randomY);\n      }\n    }\n\n    const canExecuteCallback = !this.currentSound?.loop;\n    this.currentSound.onended = canExecuteCallback ? () => {\n      if(!!this.currentSound?.loop || !this.isActive || this.isDestroyed){\n        return;\n      }\n      this.getNextSoundIndex();\n      this.playNextSound();\n    } : undefined;\n    this.currentSound.start(this.engine.audioCtx.currentTime + delay);\n    this.currentSound.connect(this.mainNode);\n  }\n\n  async addSound(resRef: string, data: Uint8Array | ArrayBuffer): Promise<AudioBuffer> {\n    if(!data){\n      log.error('AudioEmitter.addSound: No audio data present');\n      throw new Error('No audio data present');\n    }\n    const rawBuffer = data instanceof Uint8Array\n      ? data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)\n      : data.slice(0);\n    const arrayBuffer: ArrayBuffer = rawBuffer instanceof SharedArrayBuffer\n      ? new Uint8Array(rawBuffer).slice(0).buffer\n      : rawBuffer;\n    try{\n      const buffer: AudioBuffer = await this.engine.audioCtx.decodeAudioData(arrayBuffer);\n      this.buffers.set(resRef, buffer);\n      return buffer;\n    }catch(e){\n      log.error('AudioEmitter.addSound: Failed to decodeAudioData');\n      if (e.name === 'DataCloneError') {\n        log.error('AudioEmitter.addSound: ArrayBuffer is detached. This usually happens when the buffer was transferred to another context.');\n      }\n      log.error(e as Error);\n      throw e;\n    }\n  }\n\n  disposeCurrentSound(): void {\n    if(!this.currentSound){\n      return;\n    }\n    try{\n      this.currentSound.onended = undefined;\n      this.currentSound.disconnect();\n      this.currentSound.stop(0);\n    }catch(e) {\n      log.error('Failed to disconnect sound', e instanceof Error ? e : new Error(String(e)));\n    }\n    this.currentSound = null;\n  }\n\n  getCurrentTime(): number {\n    return this.engine.audioCtx.currentTime;\n  }\n\n  stop(fadeTime: number = 0): void {\n    fadeTime = Math.max(0, fadeTime);\n    const isInstant = fadeTime <= 0;\n\n    if(this.isDestroyed)\n      return;\n    \n    if(!this.currentSound){\n      return;\n    }\n\n    if(isInstant){\n      this.state = AudioEmitterState.STOPPED;\n      this.interationCount = 0;\n      this.disposeCurrentSound();\n      return;\n    }\n    this.state = AudioEmitterState.FADING_OUT;\n    const now = this.getCurrentTime();\n    const fadeEndTime = now + fadeTime;\n    this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);\n    this.gainNode.gain.linearRampToValueAtTime(0, fadeEndTime);\n      \n    if(this.currentSound){\n      this.currentSound.onended = () => {\n        this.state = AudioEmitterState.STOPPED;\n        this.interationCount = 0;\n        this.disposeCurrentSound();\n      };\n      this.currentSound.stop(fadeEndTime);\n    }\n  }\n\n  destroy(): void {\n    this.buffers.clear();\n    this.interationCount = 0;\n    this.isDestroyed = true;\n    if(!this.engine){ return; }\n    this.engine.removeEmitter(this);\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\audio\\AudioLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":26,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":26,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\n\r\nimport { AudioFile } from \"@/audio/AudioFile\";\r\nimport { ResourceLoader } from \"@/loaders\";\r\nimport { KEYManager } from \"@/managers/KEYManager\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { GameFileSystem } from \"@/utility/GameFileSystem\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\r\n\r\nconst log = createScopedLogger(LogScope.Loader);\r\n\r\n/**\r\n * AudioLoader class.\r\n * \r\n * The AudioLoader class is used for finding and loading audio files by name and filetype.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file AudioLoader.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class AudioLoader {\r\n\r\n  constructor () { }\r\n\r\n  static toArrayBuffer(buffer: Uint8Array) {\r\n    const ab = new ArrayBuffer(buffer.length);\r\n    const view = new Uint8Array(ab);\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n        view[i] = buffer[i];\r\n    }\r\n    return ab;\r\n}\r\n\r\n  static async LoadSound (resRef: string){\r\n\r\n    if(AudioLoader.cache.hasOwnProperty(resRef)){\r\n      return AudioLoader.cache[resRef];\r\n    }else{\r\n      const visKey = KEYManager.Key.getFileKey(resRef, ResourceTypes['wav']);\r\n      if(visKey){\r\n        try{\r\n          const buffer = await KEYManager.Key.getFileBuffer(visKey);\r\n          if(!buffer){ return; }\r\n        \r\n          const af = new AudioFile(buffer);\r\n          const data = await af.getPlayableByteStream();\r\n\r\n          if(data.byteLength){\r\n            return data;\r\n          }else{\r\n            return buffer;\r\n          }\r\n        }catch(e){\r\n          log.error('AudioLoader.LoadSound', e as Error);\r\n          throw e;\r\n        }\r\n      }else{\r\n        return await this.LoadStreamSound( resRef);\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  static async LoadStreamSound (resRef: string) {\r\n    try{\r\n      const file = path.join('streamsounds', resRef+'.wav');\r\n      log.debug('AudioLoader.LoadStreamSound : file', file);\r\n      const buffer = await GameFileSystem.readFile(file);\r\n      const af = new AudioFile(buffer);\r\n      const data = await af.getPlayableByteStream();\r\n      return data;\r\n    }catch(e){\r\n      log.debug('AudioLoader.LoadStreamSound : read');\r\n      log.error('AudioLoader.LoadStreamSound', e as Error);\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  static async LoadStreamWave (ResRef: string) {\r\n    const snd = ResourceLoader.getResource(ResourceTypes['wav'], ResRef) as { file: string } | null | undefined;\r\n    if(!!snd && typeof snd.file === 'string'){\r\n      try{\r\n        const buffer = await GameFileSystem.readFile(snd.file);\r\n        const af = new AudioFile(buffer);\r\n        const data = await af.getPlayableByteStream();\r\n        return data;\r\n      }catch(e){\r\n        log.debug('AudioLoader.LoadStreamWave : read');\r\n        log.error('AudioLoader.LoadStreamWave', e as Error);\r\n        throw e;\r\n      }\r\n    }else{\r\n      throw new Error(`LoadSteamWave: failed to locate playable resource`);\r\n    }\r\n  }\r\n\r\n  static async LoadMusic (resRef?: string){\r\n    return await AudioLoader.LoadAmbientSound(resRef);\r\n  }\r\n\r\n  static async LoadAmbientSound (resRef: string): Promise<Uint8Array> {\r\n    try{\r\n      const file = path.join('streammusic', resRef+'.wav');\r\n      const buffer = await GameFileSystem.readFile(file);\r\n      const af = new AudioFile(buffer);\r\n      return await af.getPlayableByteStream();\r\n    }catch(e){\r\n      log.debug('AudioLoader.LoadAmbientSound : read');\r\n      log.error(e instanceof Error ? e : new Error(String(e)));\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  static cache: Record<string, ArrayBuffer | Uint8Array> = {};\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\controls\\GamePad.ts","messages":[{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":2,"message":"Do not delete dynamically computed property keys.","line":158,"column":33,"nodeType":"MemberExpression","messageId":"dynamicDelete","endLine":158,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { AnalogInput } from \"@/controls/AnalogInput\";\nimport { KeyInput } from \"@/controls/KeyInput\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * GamePad class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file GamePad.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GamePad {\n\n  button_a = new KeyInput('A');\n  button_b = new KeyInput('B');\n  button_x = new KeyInput('X');\n  button_y = new KeyInput('Y');\n\n  button_back = new KeyInput('BACK');\n  button_start = new KeyInput('START');\n\n  button_d_up = new KeyInput('D_UP');\n  button_d_down = new KeyInput('D_DOWN');\n  button_d_left = new KeyInput('D_LEFT');\n  button_d_right = new KeyInput('D_RIGHT');\n\n  button_bumper_l = new KeyInput('BUMPER_LEFT');\n  button_bumper_r = new KeyInput('BUMPER_RIGHT');\n\n  trigger_l = new AnalogInput('TRIGGER_LEFT', 0.0);\n  trigger_r = new AnalogInput('TRIGGER_RIGHT', 0.0);\n\n  stick_l_x = new AnalogInput('L_STICK_X', 0.1, true);\n  stick_l_y = new AnalogInput('L_STICK_Y', 0.1, true);\n  stick_l = new KeyInput('L_STICK');\n\n  stick_r_x = new AnalogInput('R_STICK_X', 0.1, true);\n  stick_r_y = new AnalogInput('R_STICK_Y', 0.1, true);\n  stick_r = new KeyInput('R_STICK');\n  gamePad: Gamepad;\n  controlsMapped: boolean;\n\n  constructor(){\n    this.gamePad = undefined;\n    this.controlsMapped = false;\n    this.mapKeys();\n  }\n\n  setGamePad( gamePad: Gamepad ){\n    this.gamePad = gamePad;\n  }\n\n  updateState(delta = 0){\n    if(this.gamePad instanceof Gamepad){\n      this.button_a.update(this.gamePad, delta);\n      this.button_b.update(this.gamePad, delta);\n      this.button_x.update(this.gamePad, delta);\n      this.button_y.update(this.gamePad, delta);\n\n      this.button_bumper_l.update(this.gamePad, delta);\n      this.button_bumper_r.update(this.gamePad, delta);\n\n      this.trigger_l.update(this.gamePad, delta);\n      this.trigger_r.update(this.gamePad, delta);\n\n      this.button_back.update(this.gamePad, delta);\n      this.button_start.update(this.gamePad, delta);\n\n      this.button_d_up.update(this.gamePad, delta);\n      this.button_d_down.update(this.gamePad, delta);\n      this.button_d_left.update(this.gamePad, delta);\n      this.button_d_right.update(this.gamePad, delta);\n\n      this.stick_l.update(this.gamePad, delta);\n      this.stick_l_x.update(this.gamePad, delta);\n      this.stick_l_y.update(this.gamePad, delta);\n\n      this.stick_r.update(this.gamePad, delta);\n      this.stick_r_x.update(this.gamePad, delta);\n      this.stick_r_y.update(this.gamePad, delta);\n    }\n  }\n\n  mapKeys(){\n    //A B X Y | X O  \n    this.button_a.buttonIndex = 0; //A | X == 0\n    this.button_b.buttonIndex = 1; //B | O == 1\n    this.button_x.buttonIndex = 2; //X |  == 2\n    this.button_y.buttonIndex = 3; //Y |  == 3\n\n    //Bumpers\n    this.button_bumper_l.buttonIndex = 4; //bumper_l == 4\n    this.button_bumper_r.buttonIndex = 5; //bumper_r == 5\n\n    //Triggers\n    this.trigger_l.buttonIndex = 6; //trigger_l == 6\n    this.trigger_r.buttonIndex = 7; //trigger_r == 7\n\n    //Start / Select\n    this.button_back.buttonIndex = 8; //back == 8\n    this.button_start.buttonIndex = 9; //start == 9\n\n    //Left Stick\n    this.stick_l.buttonIndex = 10; //stick_l == 10\n    this.stick_l_x.axesIndex = 0;\n    this.stick_l_y.axesIndex = 1;\n\n    //Right Stick\n    this.stick_r.buttonIndex = 11; //stick_r == 11\n    this.stick_r_x.axesIndex = 2;\n    this.stick_r_y.axesIndex = 3;\n\n    //D Pad\n    this.button_d_up.buttonIndex = 12; //d_up == 12\n    this.button_d_down.buttonIndex = 13; //d_down == 13\n    this.button_d_left.buttonIndex = 14; //d_left == 14\n    this.button_d_right.buttonIndex = 15; //d_right == 15\n\n\n    //16 //home_button\n    //17 //dualshock4 trackpad button\n\n    this.controlsMapped = true;\n  }\n\n  onDisconnected(){\n\n  }\n\n  onConnected(){\n\n  }\n\n  static Init(){\n    GamePad.GamePads = {};\n\n    function gamepadHandler(e: GamepadEvent, connecting: boolean = false): void {\n      const gamepad = e.gamepad;\n      // Note:\n      // gamepad === navigator.getGamepads()[gamepad.index]\n      log.trace('gamepadHandler connecting=%s index=%s', String(connecting), String(e.gamepad?.index));\n      if (connecting) {\n        GamePad.GamePads[gamepad.index] = gamepad;\n        if(GamePad.CurrentGamePadIndex == -1){\n          GamePad.CurrentGamePad = gamepad;\n        }\n      } else {\n        if(GamePad.CurrentGamePadIndex == gamepad.index){\n          GamePad.CurrentGamePadIndex = -1;\n          GamePad.CurrentGamePad = undefined;\n        }\n\n        delete GamePad.GamePads[gamepad.index];\n      }\n    }\n\n    global.addEventListener(\"gamepadconnected\", function(e) { gamepadHandler(e, true); }, false);\n    global.addEventListener(\"gamepaddisconnected\", function(e) { gamepadHandler(e, false); }, false);\n  }\n\n\n  static CurrentGamePad: GamePad;\n  static CurrentGamePadIndex: number = -1;\n  static GamePads: Record<number, GamePad> = {};\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\controls\\KeyMapper.ts","messages":[{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":753,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":753,"endColumn":12},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":754,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":754,"endColumn":10},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":755,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":755,"endColumn":11},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":756,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":756,"endColumn":10},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":757,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":757,"endColumn":11},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":758,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":758,"endColumn":14},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":759,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":759,"endColumn":8},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":760,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":760,"endColumn":8}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { AnalogInput } from \"@/controls/AnalogInput\";\r\nimport { GamePad } from \"@/controls/GamePad\";\r\nimport { Keyboard } from \"@/controls/Keyboard\";\r\nimport { KeyInput } from \"@/controls/KeyInput\";\r\nimport type { INIConfig } from \"@/engine/INIConfig\";\r\nimport { KeyMapAction } from \"@/enums/controls/KeyMapAction\";\r\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { TwoDAManager } from \"@/managers/TwoDAManager\";\nimport type { ITwoDARowData } from \"@/resource/TwoDAObject\";\n\r\n\r\ntype KeymapProcessorCallback = (map: Keymap, delta: number) => void;\r\n\r\n/**\r\n * Keymap class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file Keymap.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class Keymap {\r\n\r\n  disabled:     boolean = false;\r\n  actionstrref: number  = -1;\r\n  descstrref:   number  = -1;\r\n  language0:    number  =  0; //keycode?\r\n  character:    string  = '';\r\n  page:         number  =  0;\r\n  sortpos:      number  = -1;\r\n  name:         string  = '';\r\n  remappable:   boolean = false;\r\n  forcedisplay: boolean = false;\r\n\r\n  icpc:       boolean = false;\r\n  icminigame: boolean = false;\r\n  icpcgui:    boolean = false;\r\n  icdialog:   boolean = false;\r\n  icfreelook: boolean = false;\r\n  icmovie:    boolean = false;\r\n\r\n  repeatwait: number = -1;\r\n  repeatrate: number = -1;\r\n  scale:      number =  0;\r\n  scalemag:   number =  0;\r\n  scaleexp:   number =  0;\r\n\r\n  keyboardInput: KeyInput;\r\n  gamepadInput: KeyInput|AnalogInput;\r\n  label: string;\r\n\r\n  tokenRegEx: RegExp;\r\n\r\n  processCallback?: KeymapProcessorCallback;\r\n\r\n  setProcessor(callback: KeymapProcessorCallback){\r\n    this.processCallback = callback;\r\n  }\r\n\r\n  static From2DA(row: ITwoDARowData | Record<string, string | number> = {}){\r\n    const keymap = new Keymap();\r\n\r\n    if(typeof row.disabled !== 'undefined')     keymap.disabled     = row.disabled      == '****' ? false : parseInt(row.disabled) ? true : false;\r\n    if(typeof row.actionstrref !== 'undefined') keymap.actionstrref = row.actionstrref  == '****' ? -1    : parseInt(row.actionstrref);\r\n    if(typeof row.descstrref !== 'undefined')   keymap.descstrref   = row.descstrref    == '****' ? -1    : parseInt(row.descstrref);\r\n    if(typeof row.language0 !== 'undefined')    keymap.language0    = row.language0     == '****' ? -1    : parseInt(row.language0);\r\n    if(typeof row.character !== 'undefined')    keymap.character    = row.label         == '****' ? ''    : row.character;\r\n    if(typeof row.page !== 'undefined')         keymap.page         = row.label         == '****' ? 0     : parseInt(row.page);\r\n    if(typeof row.sortpos !== 'undefined')      keymap.sortpos      = row.label         == '****' ? -1    : parseInt(row.sortpos);\r\n    if(typeof row.name !== 'undefined')         keymap.name         = row.label         == '****' ? ''    : row.name;\r\n    if(typeof row.remappable !== 'undefined')   keymap.remappable   = row.remappable    == '****' ? false : parseInt(row.remappable) ? true : false;\r\n    if(typeof row.forcedisplay !== 'undefined') keymap.forcedisplay = row.forcedisplay  == '****' ? false : parseInt(row.forcedisplay) ? true : false;\r\n\r\n    if(typeof row.icpc !== 'undefined')         keymap.icpc         = row.icpc          == '****' ? false : parseInt(row.icpc) ? true : false;\r\n    if(typeof row.icminigame !== 'undefined')   keymap.icminigame   = row.icminigame    == '****' ? false : parseInt(row.icminigame) ? true : false;\r\n    if(typeof row.icpcgui !== 'undefined')      keymap.icpcgui      = row.icpcgui       == '****' ? false : parseInt(row.icpcgui) ? true : false;\r\n    if(typeof row.icdialog !== 'undefined')     keymap.icdialog     = row.icdialog      == '****' ? false : parseInt(row.icdialog) ? true : false;\r\n    if(typeof row.icfreelook !== 'undefined')   keymap.icfreelook   = row.icfreelook    == '****' ? false : parseInt(row.icfreelook) ? true : false;\r\n    if(typeof row.icmovie !== 'undefined')      keymap.icmovie      = row.icmovie       == '****' ? false : parseInt(row.icmovie) ? true : false;\r\n\r\n    if(typeof row.repeatwait !== 'undefined')   keymap.repeatwait   = row.repeatwait    == '****' ? -1    : parseInt(row.repeatwait);\r\n    if(typeof row.repeatrate !== 'undefined')   keymap.repeatrate   = row.repeatrate    == '****' ? -1    : parseInt(row.repeatrate);\r\n    if(typeof row.scale !== 'undefined')        keymap.scale        = row.scale         == '****' ?  0    : parseInt(row.scale);\r\n    if(typeof row.scalemag !== 'undefined')     keymap.scalemag     = row.scalemag      == '****' ? -1    : parseInt(row.scalemag);\r\n    if(typeof row.scaleexp !== 'undefined')     keymap.scaleexp     = row.scaleexp      == '****' ? -1    : parseInt(row.scaleexp);\r\n    if(typeof row.__rowlabel !== 'undefined')   keymap.label        = row.__rowlabel;\r\n\r\n    keymap.tokenRegEx = new RegExp(`<${keymap.name}>`, 'gm');\r\n\r\n    return keymap;\r\n  }\r\n}\r\n\r\ninterface KeyMapperActions {\r\n  action200: Keymap;\r\n  action201: Keymap;\r\n  action202: Keymap;\r\n  action203: Keymap;\r\n  action204: Keymap;\r\n  action205: Keymap;\r\n  action206: Keymap;\r\n  action207: Keymap;\r\n  action208: Keymap;\r\n  action209: Keymap;\r\n  action210: Keymap;\r\n  action211: Keymap;\r\n  action212: Keymap;\r\n  action213: Keymap;\r\n  action214: Keymap;\r\n  action215: Keymap;\r\n  action216: Keymap;\r\n  action217: Keymap;\r\n  action218: Keymap;\r\n  action219: Keymap;\r\n  action220: Keymap;\r\n  action221: Keymap;\r\n  action222: Keymap;\r\n  action223: Keymap;\r\n  action224: Keymap;\r\n  action225: Keymap;\r\n  action226: Keymap;\r\n  action227: Keymap;\r\n  action228: Keymap;\r\n  action229: Keymap;\r\n  action230: Keymap;\r\n  action231: Keymap;\r\n  action232: Keymap;\r\n  action233: Keymap;\r\n  action234: Keymap;\r\n  action235: Keymap;\r\n  action236: Keymap;\r\n  action237: Keymap;\r\n  action238: Keymap;\r\n  action239: Keymap;\r\n  action240: Keymap;\r\n  action241: Keymap;\r\n  action242: Keymap;\r\n  action243: Keymap;\r\n  action244: Keymap;\r\n  action245: Keymap;\r\n  action246: Keymap;\r\n  action247: Keymap;\r\n  action248: Keymap;\r\n  action249: Keymap;\r\n  action250: Keymap;\r\n  action251: Keymap;\r\n  action252: Keymap;\r\n  action253: Keymap;\r\n  action254: Keymap;\r\n  action255: Keymap;\r\n  action256: Keymap;\r\n  action257: Keymap;\r\n  action258: Keymap;\r\n  action259: Keymap;\r\n  action260: Keymap;\r\n  action261: Keymap;\r\n  action262: Keymap;\r\n  action263: Keymap;\r\n  action264: Keymap;\r\n  action265: Keymap;\r\n  action268: Keymap;\r\n\r\n  action280a: Keymap;\r\n  action280b: Keymap;\r\n  action281a: Keymap;\r\n  action281b: Keymap;\r\n  action282a: Keymap;\r\n  action282b: Keymap;\r\n  action283a: Keymap;\r\n  action283b: Keymap;\r\n  action284a: Keymap;\r\n  action284b: Keymap;\r\n  action285a: Keymap;\r\n  action285b: Keymap;\r\n  action286a: Keymap;\r\n  action286b: Keymap;\r\n\r\n  action900: Keymap;\r\n  action901: Keymap;\r\n\r\n  action1001: Keymap;\r\n  action1002: Keymap;\r\n  action1003: Keymap;\r\n  action1004: Keymap;\r\n  action1005: Keymap;\r\n}\r\n\r\nexport class KeyMapper {\r\n\r\n  static Actions: KeyMapperActions = {\r\n    action200: undefined,\r\n    action201: undefined,\r\n    action202: undefined,\r\n    action203: undefined,\r\n    action204: undefined,\r\n    action205: undefined,\r\n    action206: undefined,\r\n    action207: undefined,\r\n    action208: undefined,\r\n    action209: undefined,\r\n    action210: undefined,\r\n    action211: undefined,\r\n    action212: undefined,\r\n    action213: undefined,\r\n    action214: undefined,\r\n    action215: undefined,\r\n    action216: undefined,\r\n    action217: undefined,\r\n    action218: undefined,\r\n    action219: undefined,\r\n    action220: undefined,\r\n    action221: undefined,\r\n    action222: undefined,\r\n    action223: undefined,\r\n    action224: undefined,\r\n    action225: undefined,\r\n    action226: undefined,\r\n    action227: undefined,\r\n    action228: undefined,\r\n    action229: undefined,\r\n    action230: undefined,\r\n    action231: undefined,\r\n    action232: undefined,\r\n    action233: undefined,\r\n    action234: undefined,\r\n    action235: undefined,\r\n    action236: undefined,\r\n    action237: undefined,\r\n    action238: undefined,\r\n    action239: undefined,\r\n    action240: undefined,\r\n    action241: undefined,\r\n    action242: undefined,\r\n    action243: undefined,\r\n    action244: undefined,\r\n    action245: undefined,\r\n    action246: undefined,\r\n    action247: undefined,\r\n    action248: undefined,\r\n    action249: undefined,\r\n    action250: undefined,\r\n    action251: undefined,\r\n    action252: undefined,\r\n    action253: undefined,\r\n    action254: undefined,\r\n    action255: undefined,\r\n    action256: undefined,\r\n    action257: undefined,\r\n    action258: undefined,\r\n    action259: undefined,\r\n    action260: undefined,\r\n    action261: undefined,\r\n    action262: undefined,\r\n    action263: undefined,\r\n    action264: undefined,\r\n    action265: undefined,\r\n    action268: undefined,\r\n\r\n    action280a: undefined,\r\n    action280b: undefined,\r\n    action281a: undefined,\r\n    action281b: undefined,\r\n    action282a: undefined,\r\n    action282b: undefined,\r\n    action283a: undefined,\r\n    action283b: undefined,\r\n    action284a: undefined,\r\n    action284b: undefined,\r\n    action285a: undefined,\r\n    action285b: undefined,\r\n    action286a: undefined,\r\n    action286b: undefined,\r\n\r\n    action900: undefined,\r\n    action901: undefined,\r\n\r\n    action1001: undefined,\r\n    action1002: undefined,\r\n    action1003: undefined,\r\n    action1004: undefined,\r\n    action1005: undefined,\r\n  };\r\n\r\n  static ACTIONS_ALL: Keymap[] = [];\r\n  static ACTIONS_INGAME: Keymap[] = [];\r\n  static ACTIONS_MINIGAME: Keymap[] = [];\r\n  static ACTIONS_GUI: Keymap[] = [];\r\n  static ACTIONS_DIALOG: Keymap[] = [];\r\n  static ACTIONS_FREELOOK: Keymap[] = [];\r\n  static ACTIONS_MOVIE: Keymap[] = [];\r\n\r\n  static Init(){\r\n    const keymap_table = TwoDAManager.datatables.get('keymap');\r\n    if(keymap_table){\r\n      KeyMapper.ACTIONS_INGAME = [];\r\n      KeyMapper.ACTIONS_MINIGAME = [];\r\n      KeyMapper.ACTIONS_GUI = [];\r\n      KeyMapper.ACTIONS_DIALOG = [];\r\n      KeyMapper.ACTIONS_FREELOOK = [];\r\n      KeyMapper.ACTIONS_MOVIE = [];\r\n      const rows = Object.values(keymap_table.rows);\r\n      for (let i = 0; i < rows.length; i++) {\r\n        const row = rows[i] as ITwoDARowData;\r\n        const map = Keymap.From2DA(row);\r\n        (KeyMapper.Actions as Record<string, Keymap>)[row.__rowlabel.toLowerCase()] = map;\r\n                            KeyMapper.ACTIONS_ALL.push(map);\r\n        if(map.icpc)        KeyMapper.ACTIONS_INGAME.push(map);\r\n        if(map.icminigame)  KeyMapper.ACTIONS_MINIGAME.push(map);\r\n        if(map.icpcgui)     KeyMapper.ACTIONS_GUI.push(map);\r\n        if(map.icdialog)    KeyMapper.ACTIONS_DIALOG.push(map);\r\n        if(map.icfreelook)  KeyMapper.ACTIONS_FREELOOK.push(map);\r\n        if(map.icmovie)     KeyMapper.ACTIONS_MOVIE.push(map);\r\n      }\r\n\r\n      if(typeof KeyMapper.Actions[KeyMapAction.WALKMODIFY] === 'undefined'){\r\n        this.CreateCustomAction(KeyMapAction.WALKMODIFY, {\r\n          name: 'WALKMODIFY',\r\n          remappable: 0,\r\n          icpc: 1,\r\n        });\r\n      }\r\n\r\n      //Custom KeyMappings\r\n      this.CreateCustomAction(KeyMapAction.DialogAbort, {\r\n        name: 'DialogAbort',\r\n        remappable: 0,\r\n        icdialog: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.DialogSkip, {\r\n        name: 'DialogSkip',\r\n        remappable: 0,\r\n        icdialog: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.FlyUp, {\r\n        name: 'FlyUp',\r\n        remappable: 0,\r\n        icpc: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.FlyDown, {\r\n        name: 'FlyDown',\r\n        remappable: 0,\r\n        icpc: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.ResolutionScaleUp, {\r\n        name: 'ResolutionScaleUp',\r\n        remappable: 0,\r\n        icpc: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.ResolutionScaleDown, {\r\n        name: 'ResolutionScaleDown',\r\n        remappable: 0,\r\n        icpc: 1,\r\n      });\r\n\r\n      this.CreateCustomAction(KeyMapAction.ResolutionScaleReset, {\r\n        name: 'ResolutionScaleReset',\r\n        remappable: 0,\r\n        icpc: 1,\r\n      });\r\n    }\r\n  }\r\n\r\n  static CreateCustomAction(action: KeyMapAction, props: Record<string, string | number | boolean> = {}){\r\n    KeyMapper.Actions[action] = Keymap.From2DA(props);\r\n    if(KeyMapper.Actions[action].icpc)        KeyMapper.ACTIONS_INGAME.push(KeyMapper.Actions[action]);\r\n    if(KeyMapper.Actions[action].icminigame)  KeyMapper.ACTIONS_MINIGAME.push(KeyMapper.Actions[action]);\r\n    if(KeyMapper.Actions[action].icpcgui)     KeyMapper.ACTIONS_GUI.push(KeyMapper.Actions[action]);\r\n    if(KeyMapper.Actions[action].icdialog)    KeyMapper.ACTIONS_DIALOG.push(KeyMapper.Actions[action]);\r\n    if(KeyMapper.Actions[action].icfreelook)  KeyMapper.ACTIONS_FREELOOK.push(KeyMapper.Actions[action]);\r\n    if(KeyMapper.Actions[action].icmovie)     KeyMapper.ACTIONS_MOVIE.push(KeyMapper.Actions[action]);\r\n  }\r\n\r\n  static ProcessMappings(mode: EngineMode, delta: number = 0){\r\n    switch(mode){\r\n      case EngineMode.INGAME:\r\n        KeyMapper.ACTIONS_INGAME.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n      case EngineMode.MINIGAME:\r\n        KeyMapper.ACTIONS_MINIGAME.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n      case EngineMode.GUI:\r\n        KeyMapper.ACTIONS_GUI.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n      case EngineMode.DIALOG:\r\n        KeyMapper.ACTIONS_DIALOG.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n      case EngineMode.FREELOOK:\r\n        KeyMapper.ACTIONS_FREELOOK.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n      case EngineMode.MOVIE:\r\n        KeyMapper.ACTIONS_MOVIE.map( keymap => {\r\n          if(typeof keymap.processCallback === 'function'){\r\n            keymap.processCallback(keymap, delta);\r\n          }\r\n        });\r\n      break;\r\n    }\r\n  }\r\n\r\n  static BindKeyboard(keyboard: Keyboard, iniConfig: INIConfig){\r\n    const remappedKeys = Object.fromEntries(\r\n      Object.entries( (iniConfig.getProperty('Keymapping') || {})).map(([k, v]) => [k.toLowerCase(), v])\r\n    );\r\n    for(let i = 0; i < KeyMapper.ACTIONS_ALL.length; i++){\r\n      const keyMap = KeyMapper.ACTIONS_ALL[i];\r\n\r\n      if(typeof remappedKeys[keyMap.label] === 'number'){\r\n        keyMap.language0 = remappedKeys[keyMap.label] as number;\r\n      }\r\n\r\n      const action: KeyInput = (keyboard.action as Record<string, KeyInput>)[language0ToKeyCode(keyMap.language0)];\r\n      if(action){\r\n        keyMap.keyboardInput = action;\r\n      }\r\n    }\r\n\r\n    //Movement\r\n    /*KeyMapper.Actions[KeyMapAction.ActionUp].keyboardInput = keyboard.action.KeyW;\r\n    KeyMapper.Actions[KeyMapAction.ActionDown].keyboardInput = keyboard.action.KeyS;\r\n    KeyMapper.Actions[KeyMapAction.ActionLeft].keyboardInput = keyboard.action.KeyZ;\r\n    KeyMapper.Actions[KeyMapAction.ActionRight].keyboardInput = keyboard.action.KeyC;\r\n    KeyMapper.Actions[KeyMapAction.CameraRotateLeft].keyboardInput = keyboard.action.KeyA;\r\n    KeyMapper.Actions[KeyMapAction.CameraRotateRight].keyboardInput = keyboard.action.KeyD;\r\n    KeyMapper.Actions[KeyMapAction.Freelook].keyboardInput = keyboard.action.CapsLock;\r\n    KeyMapper.Actions[KeyMapAction.LeftLookabout].keyboardInput = keyboard.action.ControlLeft;\r\n    KeyMapper.Actions[KeyMapAction.GUI].keyboardInput = keyboard.action.Escape;\r\n    KeyMapper.Actions[KeyMapAction.SelectPrev].keyboardInput = keyboard.action.KeyQ;\r\n    KeyMapper.Actions[KeyMapAction.SelectNext].keyboardInput = keyboard.action.KeyE;\r\n    KeyMapper.Actions[KeyMapAction.WALKMODIFY].keyboardInput = keyboard.action.KeyB;*/\r\n\r\n    //Game\r\n    /*KeyMapper.Actions[KeyMapAction.Pause].keyboardInput = keyboard.action.Pause;\r\n    KeyMapper.Actions[KeyMapAction.Pause1].keyboardInput = keyboard.action.Space;\r\n    KeyMapper.Actions[KeyMapAction.DefaultAction].keyboardInput = keyboard.action.KeyR;\r\n\r\n    KeyMapper.Actions[KeyMapAction.TargetLeftAct].keyboardInput = keyboard.action.Digit1;\r\n    KeyMapper.Actions[KeyMapAction.TargetMiddleAct].keyboardInput = keyboard.action.Digit2;\r\n    KeyMapper.Actions[KeyMapAction.TargetRightAct].keyboardInput = keyboard.action.Digit3;\r\n\r\n    KeyMapper.Actions[KeyMapAction.PersonalPowerAct].keyboardInput = keyboard.action.Digit4;\r\n    KeyMapper.Actions[KeyMapAction.PersonalMedicalAct].keyboardInput = keyboard.action.Digit5;\r\n    KeyMapper.Actions[KeyMapAction.PersonalOtherAct].keyboardInput = keyboard.action.Digit6;\r\n    KeyMapper.Actions[KeyMapAction.PersonalMinesAct].keyboardInput = keyboard.action.Digit7;\r\n\r\n    KeyMapper.Actions[KeyMapAction.Messages].keyboardInput = keyboard.action.KeyJ;\r\n    KeyMapper.Actions[KeyMapAction.Map].keyboardInput = keyboard.action.KeyM;\r\n    KeyMapper.Actions[KeyMapAction.Quests].keyboardInput = keyboard.action.KeyL;\r\n    KeyMapper.Actions[KeyMapAction.SkillsAndFeats].keyboardInput = keyboard.action.KeyK;\r\n    KeyMapper.Actions[KeyMapAction.Options].keyboardInput = keyboard.action.KeyO;\r\n    KeyMapper.Actions[KeyMapAction.Character].keyboardInput = keyboard.action.KeyP;\r\n    KeyMapper.Actions[KeyMapAction.Inventory].keyboardInput = keyboard.action.KeyI;\r\n    KeyMapper.Actions[KeyMapAction.Equip].keyboardInput = keyboard.action.KeyU;\r\n\r\n    KeyMapper.Actions[KeyMapAction.CancleCombat].keyboardInput = keyboard.action.KeyF;\r\n    KeyMapper.Actions[KeyMapAction.ChangeChar].keyboardInput = keyboard.action.Tab;\r\n    KeyMapper.Actions[KeyMapAction.PartyActive].keyboardInput = keyboard.action.KeyV;\r\n    KeyMapper.Actions[KeyMapAction.STEALTH].keyboardInput = keyboard.action.KeyG;\r\n    KeyMapper.Actions[KeyMapAction.Flourish].keyboardInput = keyboard.action.KeyX;\r\n    KeyMapper.Actions[KeyMapAction.ToolTips].keyboardInput = keyboard.action.KeyT;\r\n\r\n    KeyMapper.Actions[KeyMapAction.Quicksave].keyboardInput = keyboard.action.F4;\r\n    KeyMapper.Actions[KeyMapAction.QUICKLOAD].keyboardInput = keyboard.action.F5;\r\n\r\n    KeyMapper.Actions[KeyMapAction.PrevMenu].keyboardInput = keyboard.action.KeyQ;\r\n    KeyMapper.Actions[KeyMapAction.NextMenu].keyboardInput = keyboard.action.KeyE;\r\n    KeyMapper.Actions[KeyMapAction.ClearOneAction].keyboardInput = keyboard.action.KeyY;*/\r\n\r\n    //MiniGame\r\n    /*KeyMapper.Actions[KeyMapAction.MGActionUp].keyboardInput = keyboard.action.KeyW;\r\n    KeyMapper.Actions[KeyMapAction.MGActionDown].keyboardInput = keyboard.action.KeyS;\r\n    KeyMapper.Actions[KeyMapAction.MGActionLeft].keyboardInput = keyboard.action.KeyA;\r\n    KeyMapper.Actions[KeyMapAction.MGActionRight].keyboardInput = keyboard.action.KeyD;\r\n    KeyMapper.Actions[KeyMapAction.MGshoot].keyboardInput = keyboard.action.Space;\r\n    KeyMapper.Actions[KeyMapAction.PauseMinigame].keyboardInput = keyboard.action.Escape;*/\r\n\r\n    //Dialog\r\n    /*KeyMapper.Actions[KeyMapAction.Dialog1].keyboardInput = keyboard.action.Digit1;\r\n    KeyMapper.Actions[KeyMapAction.Dialog2].keyboardInput = keyboard.action.Digit2;\r\n    KeyMapper.Actions[KeyMapAction.Dialog3].keyboardInput = keyboard.action.Digit3;\r\n    KeyMapper.Actions[KeyMapAction.Dialog4].keyboardInput = keyboard.action.Digit4;\r\n    KeyMapper.Actions[KeyMapAction.Dialog5].keyboardInput = keyboard.action.Digit5;\r\n    KeyMapper.Actions[KeyMapAction.Dialog6].keyboardInput = keyboard.action.Digit6;\r\n    KeyMapper.Actions[KeyMapAction.Dialog7].keyboardInput = keyboard.action.Digit7;\r\n    KeyMapper.Actions[KeyMapAction.Dialog8].keyboardInput = keyboard.action.Digit8;\r\n    KeyMapper.Actions[KeyMapAction.Dialog9].keyboardInput = keyboard.action.Digit9;\r\n    KeyMapper.Actions[KeyMapAction.DialogSkip].keyboardInput = keyboard.action.Space;*/\r\n\r\n    //Custom Mappings\r\n    KeyMapper.Actions[KeyMapAction.FlyUp].keyboardInput = keyboard.action.NumpadAdd;\r\n    KeyMapper.Actions[KeyMapAction.FlyDown].keyboardInput = keyboard.action.NumpadSubtract;\r\n    KeyMapper.Actions[KeyMapAction.ResolutionScaleUp].keyboardInput = keyboard.action.NumpadAdd;\r\n    KeyMapper.Actions[KeyMapAction.ResolutionScaleDown].keyboardInput = keyboard.action.NumpadSubtract;\r\n    KeyMapper.Actions[KeyMapAction.ResolutionScaleReset].keyboardInput = keyboard.action.Numpad0;\r\n\r\n  }\r\n\r\n  static BindGamepad(gamepad: GamePad){\r\n\r\n    //Movement\r\n    this.Actions[KeyMapAction.ActionUp].gamepadInput = gamepad.stick_l_y;\r\n    this.Actions[KeyMapAction.ActionDown].gamepadInput = gamepad.stick_l_y;\r\n    this.Actions[KeyMapAction.CameraRotateLeft].gamepadInput = gamepad.stick_l_x;\r\n    this.Actions[KeyMapAction.CameraRotateRight].gamepadInput = gamepad.stick_l_x;\r\n    this.Actions[KeyMapAction.Freelook].gamepadInput = gamepad.stick_l;\r\n    this.Actions[KeyMapAction.SelectPrev].gamepadInput = gamepad.trigger_l;\r\n    this.Actions[KeyMapAction.SelectNext].gamepadInput = gamepad.trigger_r;\r\n\r\n    //Game\r\n    this.Actions[KeyMapAction.Options].gamepadInput = gamepad.button_start;\r\n    this.Actions[KeyMapAction.Pause].gamepadInput = gamepad.button_bumper_l;\r\n    this.Actions[KeyMapAction.ChangeChar].gamepadInput = gamepad.button_bumper_r;\r\n    this.Actions[KeyMapAction.STEALTH].gamepadInput = gamepad.button_back;\r\n    this.Actions[KeyMapAction.Flourish].gamepadInput = gamepad.button_y;\r\n    this.Actions[KeyMapAction.ClearOneAction].gamepadInput = gamepad.button_y;\r\n    this.Actions[KeyMapAction.ActionUp].gamepadInput = gamepad.button_d_up;\r\n    this.Actions[KeyMapAction.ActionDown].gamepadInput = gamepad.button_d_down;\r\n    this.Actions[KeyMapAction.ActionLeft].gamepadInput = gamepad.button_d_left;\r\n    this.Actions[KeyMapAction.ActionRight].gamepadInput = gamepad.button_d_right;\r\n    this.Actions[KeyMapAction.CancleCombat].gamepadInput = gamepad.button_b;\r\n    this.Actions[KeyMapAction.AlternateActions].gamepadInput = gamepad.button_x;\r\n    \r\n    //GUI\r\n    this.Actions[KeyMapAction.PrevMenu].gamepadInput = gamepad.button_bumper_l;\r\n    this.Actions[KeyMapAction.NextMenu].gamepadInput = gamepad.button_bumper_r;\r\n    this.Actions[KeyMapAction.MoveForward].gamepadInput = gamepad.button_d_up;\r\n    this.Actions[KeyMapAction.MoveBack].gamepadInput = gamepad.button_d_down;\r\n    this.Actions[KeyMapAction.StrafeLeft].gamepadInput = gamepad.button_d_left;\r\n    this.Actions[KeyMapAction.StrafeRight].gamepadInput = gamepad.button_d_right;\r\n    this.Actions[KeyMapAction.PrevMenu].gamepadInput = gamepad.button_bumper_l;\r\n    this.Actions[KeyMapAction.PrevMenu].gamepadInput = gamepad.button_bumper_l;\r\n    this.Actions[KeyMapAction.PrevMenu].gamepadInput = gamepad.button_bumper_l;\r\n    \r\n  }\r\n\r\n}\r\n\r\nexport function language0ToKeyCode(language0: number): string {\r\n  switch(language0){\r\n    case 9:\r\n      return 'UpArrow'; \r\n    case 7:\r\n      return 'LeftArrow'; \r\n    case 8:\r\n      return 'RightArrow'; \r\n    case 10:\r\n      return 'DownArrow'; \r\n    case 11:\r\n      return 'Numpad1'; \r\n    case 12:\r\n      return 'Numpad2'; \r\n    case 13:\r\n      return 'Numpad3'; \r\n    case 14:\r\n      return 'Numpad4'; \r\n    case 15:\r\n      return 'Numpad5'; \r\n    case 16:\r\n      return 'Numpad6'; \r\n    case 17:\r\n      return 'Numpad7'; \r\n    case 18:\r\n      return 'Numpad8'; \r\n    case 19:\r\n      return 'Numpad9'; \r\n    case 20:\r\n      return 'Numpad0'; \r\n    case 21:\r\n      return 'NumpadDecimal'; \r\n    case 22:\r\n      return 'NumpadSubtract'; \r\n    case 23:\r\n      return 'NumpadAdd'; \r\n    case 24:\r\n      return 'ShiftLeft'; \r\n    case 25:\r\n      return 'ShiftRight'; \r\n    case 28:\r\n      return 'ControlLeft'; \r\n    case 29:\r\n      return 'ControlRight'; \r\n    case 30:\r\n      return 'Tab'; \r\n    case 31:\r\n      return 'Escape'; \r\n    case 32:\r\n      return 'Home'; \r\n    case 33:\r\n      return 'End';  \r\n    case 34:\r\n      return 'PageUp'; \r\n    case 35:\r\n      return 'PageDown'; \r\n    case 36:\r\n      return 'Insert'; \r\n    case 37:\r\n      return 'Delete'; \r\n    case 39:\r\n      return 'F1'; \r\n    case 40:\r\n      return 'F2'; \r\n    case 41:\r\n      return 'F3'; \r\n    case 42:\r\n      return 'F4'; \r\n    case 43:\r\n      return 'F5'; \r\n    case 44:\r\n      return 'F6'; \r\n    case 45:\r\n      return 'F7'; \r\n    case 46:\r\n      return 'F8'; \r\n    case 47:\r\n      return 'F9'; \r\n    case 48:\r\n      return 'F10'; \r\n    case 49:\r\n      return 'F11'; \r\n    case 50:\r\n      return 'F12'; \r\n    case 51:\r\n      return 'KeyA'; \r\n    case 52:\r\n      return 'KeyB'; \r\n    case 53:\r\n      return 'KeyC'; \r\n    case 54:\r\n      return 'KeyD'; \r\n    case 55:\r\n      return 'KeyE'; \r\n    case 56:\r\n      return 'KeyF'; \r\n    case 57:\r\n      return 'KeyG'; \r\n    case 58:\r\n      return 'KeyH'; \r\n    case 59:\r\n      return 'KeyI'; \r\n    case 60:\r\n      return 'KeyJ'; \r\n    case 61:\r\n      return 'KeyK'; \r\n    case 62:\r\n      return 'KeyL'; \r\n    case 63:\r\n      return 'KeyM'; \r\n    case 64:\r\n      return 'KeyN'; \r\n    case 65:\r\n      return 'KeyO'; \r\n    case 66:\r\n      return 'KeyP'; \r\n    case 67:\r\n      return 'KeyQ'; \r\n    case 68:\r\n      return 'KeyR'; \r\n    case 69:\r\n      return 'KeyS'; \r\n    case 70:\r\n      return 'KeyT'; \r\n    case 71:\r\n      return 'KeyU'; \r\n    case 72:\r\n      return 'KeyV'; \r\n    case 73:\r\n      return 'KeyW'; \r\n    case 74:\r\n      return 'KeyX'; \r\n    case 75:\r\n      return 'KeyY'; \r\n    case 76:\r\n      return 'KeyZ'; \r\n    case 77:\r\n      return 'Digit1'; \r\n    case 78:\r\n      return 'Digit2'; \r\n    case 79:\r\n      return 'Digit3'; \r\n    case 80:\r\n      return 'Digit4'; \r\n    case 81:\r\n      return 'Digit5'; \r\n    case 82:\r\n      return 'Digit6'; \r\n    case 83:\r\n      return 'Digit7'; \r\n    case 84:\r\n      return 'Digit8'; \r\n    case 85:\r\n      return 'Digit9'; \r\n    case 86:\r\n      return 'Digit0'; \r\n    case 87:\r\n      return 'Space'; \r\n    case 88:\r\n      return 'NumpadEnter';\r\n    case 89:\r\n      return 'CapsLock'; \r\n    case 90:\r\n      return 'Pause';\r\n    case 94:\r\n      return 'Minus'; \r\n    case 96:\r\n      return 'Backspace'; \r\n    case 97:\r\n      return 'BracketRight'; \r\n    case 98:\r\n      return 'Backslash';\r\n    case 99:\r\n      return 'Semicolon'; \r\n    case 103:\r\n      return 'Comma'; \r\n    case 104:\r\n      return 'Period'; \r\n    case 105:\r\n      return 'Slash';\r\n    case 106:\r\n      return 'NumpadMultiply';\r\n    case 108:\r\n      return 'NumpadDivide';\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport enum KeyCodeToLanguage0 {\r\n  Backquote =       undefined, //UNUSED\r\n  AltLeft =         undefined, //UNUSED\r\n  AltRight =        undefined, //UNUSED\r\n  NumLock =         undefined, //UNUSED\r\n  MetaLeft =        undefined, //UNUSED\r\n  BracketLeft =     undefined, \r\n  Quote =           undefined, \r\n  Equal =           undefined,\r\n  UpArrow =         9,  //Up\r\n  LeftArrow =       7, //Left\r\n  RightArrow =      8, //Right\r\n  DownArrow =       10,  //Down\r\n  Numpad1 =         11, //NUM 1\r\n  Numpad2 =         12, //NUM 2\r\n  Numpad3 =         13, //NUM 3\r\n  Numpad4 =         14, //NUM 4\r\n  Numpad5 =         15, //NUM 5\r\n  Numpad6 =         16, //NUM 6\r\n  Numpad7 =         17, //NUM 7\r\n  Numpad8 =         18, //NUM 8\r\n  Numpad9 =         19, //NUM 9 \r\n  Numpad0 =         20, //NUM 0\r\n  NumpadDecimal =   21, //Num Del\r\n  NumpadSubtract =  22, //- \r\n  NumpadAdd =       23, //+\r\n  ShiftLeft =       24, \r\n  ShiftRight =      25, \r\n  ControlLeft =     28, \r\n  ControlRight =    29, \r\n  Tab =             30, \r\n  Escape =          31, \r\n  Home =            32, \r\n  End =             33,  \r\n  PageUp =          34, \r\n  PageDown =        35, \r\n  Insert =          36, \r\n  Delete =          37, \r\n  F1 =              39, \r\n  F2 =              40, \r\n  F3 =              41, \r\n  F4 =              42, \r\n  F5 =              43, \r\n  F6 =              44, \r\n  F7 =              45, \r\n  F8 =              46, \r\n  F9 =              47, \r\n  F10 =             48, \r\n  F11 =             49, \r\n  F12 =             50, \r\n  KeyA =            51, \r\n  KeyB =            52, \r\n  KeyC =            53, \r\n  KeyD =            54, \r\n  KeyE =            55, \r\n  KeyF =            56, \r\n  KeyG =            57, \r\n  KeyH =            58, \r\n  KeyI =            59, \r\n  KeyJ =            60, \r\n  KeyK =            61, \r\n  KeyL =            62, \r\n  KeyM =            63, \r\n  KeyN =            64, \r\n  KeyO =            65, \r\n  KeyP =            66, \r\n  KeyQ =            67, \r\n  KeyR =            68, \r\n  KeyS =            69, \r\n  KeyT =            70, \r\n  KeyU =            71, \r\n  KeyV =            72, \r\n  KeyW =            73, \r\n  KeyX =            74, \r\n  KeyY =            75, \r\n  KeyZ =            76, \r\n  Digit1 =          77, \r\n  Digit2 =          78, \r\n  Digit3 =          79, \r\n  Digit4 =          80, \r\n  Digit5 =          81, \r\n  Digit6 =          82, \r\n  Digit7 =          83, \r\n  Digit8 =          84, \r\n  Digit9 =          85, \r\n  Digit0 =          86, \r\n  Space =           87, \r\n  NumpadEnter =     88, //NUM Enter \r\n  // Enter =        88, \r\n  CapsLock =        89, \r\n  Pause =           90,\r\n  Minus =           94, \r\n  Backspace =       96, \r\n  BracketRight =    97, \r\n  Backslash =       98, // \\ \r\n  Semicolon =       99, \r\n  Comma =           103, \r\n  Period =          104, \r\n  Slash =           105, // /\r\n  NumpadMultiply =  106,  //*\r\n  NumpadDivide =    108,  //Num /\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\controls\\Mouse.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":59,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":61,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { MouseAxis } from \"@/enums/controls/MouseAxis\";\r\nimport { MouseState } from \"@/enums/controls/MouseState\";\r\nimport type { GUIControl } from \"@/gui\";\r\nimport { ResolutionManager } from \"@/managers/ResolutionManager\";\r\n\r\n/**\r\n * Mouse class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file Mouse.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class Mouse {\r\n  static editor: HTMLElement | null = null;\r\n  static camera: THREE.Camera | null = null;\r\n  static MouseX: number = 0;\r\n  static MouseY: number = 0;\r\n  static OldMouseX: number = 0;\r\n  static OldMouseY: number = 0;\r\n  static OffsetX: number = 0;\r\n  static OffsetY: number = 0;\r\n  static MouseDownX: number = 0;\r\n  static MouseDownY: number = 0;\r\n  static MouseDown: boolean = false;\r\n  static ButtonState: MouseState;\r\n  static MiddleMouseDown: boolean = false;\r\n  static Dragging: boolean = false;\r\n  static target: EventTarget | null = null;\r\n  static CollisionPosition: THREE.Vector3 = new THREE.Vector3();\r\n  static Vector: THREE.Vector2 = new THREE.Vector2();\r\n  static Client: THREE.Vector2 = new THREE.Vector2();\r\n\r\n  //button states\r\n  static leftDown: boolean = false;\r\n  static leftClick: boolean = false;\r\n  static rightDown: boolean = false;\r\n  static rightClick: boolean = false;\r\n\r\n  //positions\r\n  static position: THREE.Vector2 = new THREE.Vector2();\r\n\r\n  //MouseEvent client x/y\r\n  static positionWindow: THREE.Vector2 = new THREE.Vector2();\r\n\r\n  //MouseEvent client x/y\r\n  static positionViewport: THREE.Vector2 = new THREE.Vector2();\r\n\r\n  //Game UI mouse position\r\n  static positionUI: THREE.Vector2 = new THREE.Vector2();\r\n\r\n  //UI Control State\r\n  static downItem: GUIControl;\r\n  static clickItem: GUIControl;\r\n\r\n  constructor(){\r\n\r\n  }\r\n\r\n  static Update(x: number, y: number){\r\n    Mouse.positionWindow.x = x;\r\n    Mouse.positionWindow.y = y;\r\n\r\n    const res = ResolutionManager.screenResolution;\r\n\r\n    if(res.isDynamicRes){\r\n      Mouse.positionViewport.x = x;\r\n      Mouse.positionViewport.y = y;\r\n\r\n      Mouse.position.x = Mouse.Vector.x = ( x / window.innerWidth ) * 2 - 1;\r\n      Mouse.position.y = Mouse.Vector.y = - ( y / window.innerHeight ) * 2 + 1; \r\n      Mouse.positionUI.x = Mouse.Vector.x = ( x - (window.innerWidth/2) );\r\n      Mouse.positionUI.y = Mouse.Vector.y = - ( y -(window.innerHeight/2) ); \r\n    }else{\r\n      Mouse.positionViewport.x = x - ((ResolutionManager.windowResolution.width/2) - ((res.width)/2));\r\n      Mouse.positionViewport.y = y - ((ResolutionManager.windowResolution.height/2) - ((res.height)/2));\r\n\r\n      Mouse.position.x = Mouse.Vector.x = ( Mouse.positionViewport.x / res.width ) * 2 - 1;\r\n      Mouse.position.y = Mouse.Vector.y = - ( Mouse.positionViewport.y / res.height ) * 2 + 1; \r\n      Mouse.positionUI.x = Mouse.Vector.x = ( Mouse.positionViewport.x - (res.width/2) );\r\n      Mouse.positionUI.y = Mouse.Vector.y = - ( Mouse.positionViewport.y -(res.height/2) ); \r\n    }\r\n  }\r\n\r\n  static getMouseAxis(axis: MouseAxis){\r\n    if (axis == MouseAxis.X){\r\n      if (Mouse.MouseX == Mouse.OldMouseX)\r\n        return 0;\r\n      else if (Mouse.MouseX > Mouse.OldMouseX)\r\n        return 1;\r\n\r\n      return -1;\r\n    }else{\r\n      if (Mouse.MouseY == Mouse.OldMouseY)\r\n        return 0;\r\n      else if (Mouse.MouseY < Mouse.OldMouseY)\r\n        return 1;\r\n\r\n      return -1;\r\n    }\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\electron\\LauncherWindow.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":91,"column":7,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":92,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\r\n\r\nimport { BrowserWindow, shell } from \"electron\";\r\n\r\nimport Main from \"@/electron/Main\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\n\r\n\r\nconst log = createScopedLogger(LogScope.Debug);\r\n\r\nexport class LauncherWindow {\r\n\r\n  browserWindow?: BrowserWindow;\r\n\r\n  constructor(){\r\n    if(this.browserWindow instanceof BrowserWindow){\r\n      this.browserWindow.show();\r\n      this.browserWindow.focus();\r\n      return;\r\n    }\r\n    \r\n    // Create the browser window.\r\n    this.browserWindow = new BrowserWindow({\r\n      width: 1200, \r\n      height: 600, \r\n      minHeight: 600,\r\n      minWidth: 1000,\r\n      frame: false,\r\n      title: 'KotOR Launcher',\r\n      transparent: true,\r\n      backgroundColor: '#00FFFFFF',\r\n      webPreferences: {\r\n        preload: path.join(Main.ApplicationPath, 'dist/electron/preload.js'),\r\n        webviewTag: false,\r\n        nodeIntegration: true,\r\n        // enableRemoteModule: false,\r\n        //worldSafeExecuteJavaScript: true,\r\n        contextIsolation: true,\r\n        sandbox: false,\r\n      }\r\n    });\r\n    // and load the index.html of the app.\r\n    this.browserWindow.loadURL(`file://${Main.ApplicationPath}/dist/launcher/index.html`);\r\n    //this.browserWindow.openDevTools();\r\n    this.browserWindow.on('ready-to-show', () => {\r\n      // this.browserWindow.webcontents.openDevTools();\r\n      if(!this.browserWindow) { return; }\r\n      this.browserWindow.webContents.setWindowOpenHandler((details) => {\r\n        log.info('setWindowOpenHandler', details);\r\n        if(details.frameName == '_new' || details.url.indexOf('https://') >= 0){\r\n          shell.openExternal(details.url);\r\n          return { action: 'deny' };\r\n        }\r\n        return { action: 'allow' };\r\n      })\r\n    })\r\n  \r\n    // Emitted when the window is closed.\r\n    this.browserWindow.on('closed', () => {\r\n      // Dereference the window object, usually you would store windows\r\n      // in an array if your app supports multi windows, this is the time\r\n      // when you should delete the corresponding element.\r\n      // this.browserWindow = undefined;\r\n    });\r\n  \r\n    this.browserWindow.on('minimize', () => {\r\n      if(this.browserWindow) this.browserWindow.hide();\r\n    });\r\n  \r\n    this.browserWindow.on('close', (event) => {\r\n      /*if(!app.isQuiting){\r\n        event.preventDefault();\r\n        winLauncher.hide();\r\n      }\r\n  \r\n      return false;*/\r\n    });\r\n    \r\n    this.browserWindow.on('show', () => {\r\n      //tray.setHighlightMode('always');\r\n    });\r\n  \r\n    this.browserWindow.on('hide', () => {\r\n      //tray.setHighlightMode('never');\r\n    });\r\n  }\r\n\r\n  toggleWindow(){\r\n    if(this.browserWindow)\r\n      this.browserWindow.isVisible() ? \r\n        this.browserWindow.hide() : this.browserWindow.show();\r\n  }\r\n\r\n  hide(){\r\n    if(this.browserWindow) this.browserWindow.hide();\r\n  }\r\n\r\n  show(){\r\n    if(this.browserWindow) this.browserWindow.show();\r\n  }\r\n\r\n  send(event: string, data: string | number | boolean | object) {\r\n    if(this.browserWindow)\r\n      this.browserWindow.webContents.send(event, data);\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\electron\\WindowManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | number | boolean | object`.","line":66,"column":57,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":66,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | number | boolean | object`.","line":69,"column":61,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":69,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SaveDialogOptions`.","line":122,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":122,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ApplicationWindowProfile`.","line":131,"column":44,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":131,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":153,"column":30,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":153,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":177,"column":18,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":177,"endColumn":26}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\n\nimport { BrowserWindow, dialog } from \"electron\";\n\nimport { ApplicationWindow } from \"@/electron/ApplicationWindow\";\nimport { LauncherWindow } from \"@/electron/LauncherWindow\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n//exec & execFile are used for launching the original games from the launcher\n\n\nconst log = createScopedLogger(LogScope.Extension);\nimport { execFile, exec } from \"child_process\";\n\nexport class WindowManager {\n\n  static launcherWindow: LauncherWindow;\n  static windows: ApplicationWindow[] = [];\n\n  static createLauncherWindow() {\n    if (!WindowManager.launcherWindow) {\n      WindowManager.launcherWindow = new LauncherWindow();\n    }\n    WindowManager.launcherWindow.show();\n  }\n\n  static toggleLauncherWindow() {\n    if (!WindowManager.launcherWindow) {\n      this.createLauncherWindow();\n    } else {\n      WindowManager.launcherWindow.toggleWindow();\n    }\n  }\n\n  static addWindow(window: ApplicationWindow) {\n    const index = WindowManager.windows.indexOf(window);\n    if (index < 0) {\n      WindowManager.windows.push(window);\n    }\n  }\n\n  static removeWindow(window: ApplicationWindow) {\n    const index = WindowManager.windows.indexOf(window);\n    if (index >= 0) {\n      WindowManager.windows.splice(index, 1);\n    }\n  }\n\n  static hideLauncher() {\n    if (WindowManager.launcherWindow) {\n      WindowManager.launcherWindow.hide();\n    }\n  }\n\n  static showLauncher() {\n    if (!WindowManager.launcherWindow) {\n      WindowManager.createLauncherWindow();\n    } else {\n      WindowManager.launcherWindow.show();\n    }\n  }\n\n  static initIPC(ipcMain: Electron.IpcMain) {\n    ipcMain.on('config-changed', (event, data) => {\n      for (let i = 0, len = WindowManager.windows.length; i < len; i++) {\n        WindowManager.windows[i].send('config-changed', data);\n      }\n      if (WindowManager.launcherWindow instanceof LauncherWindow) {\n        WindowManager.launcherWindow.send('config-changed', data);\n      }\n    });\n\n    ipcMain.handle('win-minimize', (event, data) => {\n      const win = BrowserWindow.getFocusedWindow();\n      if (win) {\n        win.minimize();\n        return true;\n      }\n      return false;\n    });\n\n    ipcMain.handle('win-maximize', (event, data) => {\n      const win = BrowserWindow.getFocusedWindow();\n      if (win) {\n        log.debug('win-maximize isMaximized=%s', String(win.isMaximized()));\n        if (win.isMaximized()) {\n          win.unmaximize();\n          return true;\n        } else {\n          win.maximize();\n          return true;\n        }\n      }\n      return false;\n    });\n\n    ipcMain.handle('locate-game-directory', (event, data) => {\n      return new Promise((resolve, reject) => {\n        dialog.showOpenDialog({ title: 'KotOR Game Install Folder', properties: ['openDirectory', 'createDirectory'] }).then(result => {\n          if (result.filePaths.length && !result.canceled) {\n            resolve(result.filePaths[0]);\n          }\n        }).catch(err => {\n          reject(err)\n        });\n      });\n    });\n\n    ipcMain.handle('open-file-dialog', (event, data: Electron.OpenDialogOptions) => {\n      return new Promise((resolve, reject) => {\n        dialog.showOpenDialog(data).then(result => {\n          resolve(result);\n        }).catch(err => {\n          reject(err)\n        });\n      });\n    });\n\n    ipcMain.handle('save-file-dialog', (event, data: Electron.SaveDialogOptions) => {\n      return new Promise((resolve, reject) => {\n        log.info('save-file-dialog2', event, data[0]);\n        dialog.showSaveDialog(data[0]).then(result => {\n          resolve(result);\n        }).catch(err => {\n          reject(err)\n        });\n      });\n    });\n\n    ipcMain.on('launch_profile', (event, profile) => {\n      const window = new ApplicationWindow(profile);\n      WindowManager.addWindow(window);\n      WindowManager.hideLauncher();\n    });\n\n    ipcMain.handle('show-loading-error', async (_event, message: string) => {\n      const win = BrowserWindow.fromWebContents(_event.sender);\n      if (!win || win.isDestroyed()) return;\n      const title = 'Error';\n      const detail = typeof message === 'string' && message.length > 0 ? message : 'An error occurred while loading.';\n      await dialog.showMessageBox(win, {\n        type: 'error',\n        title,\n        message: detail,\n        buttons: ['OK'],\n        noLink: true,\n      });\n      win.close();\n    });\n\n    ipcMain.on('launch_executable', (event, exe_path) => {\n      WindowManager.hideLauncher();\n      const cwd = path.parse(exe_path);\n      if (process.platform == 'linux') {\n        //Attempt to find wine so we can run the exe\n        exec(`which wine`, (error) => {\n          if (error) {\n            dialog.showMessageBoxSync({\n              type: 'error',\n              title: 'Error',\n              message: 'Wine not found!',\n              buttons: ['Ok']\n            });\n            WindowManager.showLauncher();\n          } else {\n            //Attempt to launch with wine\n            exec(`cd ${cwd.dir} && wine ./${cwd.base}`, (error, stdout, stderr) => {\n              log.error(error);\n              log.error(stdout);\n              log.error(stderr);\n              WindowManager.showLauncher();\n            });\n          }\n        });\n      } else {\n        log.info('Launching', exe_path, 'in', cwd.dir);\n        execFile(exe_path, [], { cwd: cwd.dir }, (error, stdout, stderr) => {\n          log.error(error);\n          log.error(stdout);\n          log.error(stderr);\n          WindowManager.showLauncher();\n        });\n      }\n    });\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\electron\\preload.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":114,"column":28,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":114,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `OpenExternalOptions`.","line":114,"column":33,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":114,"endColumn":40}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from \"fs\";\n\nimport { contextBridge, ipcRenderer, shell } from \"electron\";\n\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n/** Profile shape for launch (matches ElectronProfile from src/index.d.ts). */\ninterface LaunchProfile {\n  key?: string;\n  name?: string;\n}\n\nconst log = createScopedLogger(LogScope.Default);\n\nconst query = new URLSearchParams(window.location.search);\n\ncontextBridge.exposeInMainWorld(\n  'dialog', {\n  locateDirectoryDialog: (profile) => {\n    return new Promise((resolve, reject) => {\n      ipcRenderer.invoke('locate-game-directory', profile).then((response) => {\n        resolve(response);\n      }).catch((e) => {\n        reject(e);\n      });\n    })\n  },\n  showOpenDialog: (...args) => {\n    return new Promise((resolve, reject) => {\n      ipcRenderer.invoke('open-file-dialog', args).then((response) => {\n        resolve(response);\n      }).catch((e) => {\n        reject(e);\n      })\n    });\n  },\n  showSaveDialog: (...args) => {\n    return new Promise((resolve, reject) => {\n      log.debug('save-file-dialog', args);\n      ipcRenderer.invoke('save-file-dialog', args).then((response) => {\n        resolve(response);\n      }).catch((e) => {\n        reject(e);\n      })\n    });\n  }\n}\n)\n\ncontextBridge.exposeInMainWorld(\n  'fs', {\n  open: (...args: Parameters<typeof fs.open>) => fs.open(...args),\n  close: (...args: Parameters<typeof fs.close>) => fs.close(...args),\n  read: (...args: Parameters<typeof fs.read>) => fs.read(...args),\n  readFile: (...args: Parameters<typeof fs.readFile>) => fs.readFile(...args),\n  writeFile: (...args: Parameters<typeof fs.writeFile>) => fs.writeFile(...args),\n  createReadStream: (...args: Parameters<typeof fs.createReadStream>) => fs.createReadStream(...args),\n  createWriteStream: (...args: Parameters<typeof fs.createWriteStream>) => fs.createWriteStream(...args),\n  readdir: (...args: Parameters<typeof fs.readdir>) => fs.readdir(...args),\n  mkdir: (...args: Parameters<typeof fs.mkdir>) => fs.mkdir(...args),\n  mkdirSync: (...args: Parameters<typeof fs.mkdirSync>) => fs.mkdirSync(...args),\n  rmdir: (...args: Parameters<typeof fs.rmdir>) => fs.rmdir(...args),\n  rmdirSync: (...args: Parameters<typeof fs.rmdirSync>) => fs.rmdirSync(...args),\n  stat: (...args: Parameters<typeof fs.stat>) => fs.stat(...args),\n  statSync: (...args: Parameters<typeof fs.statSync>) => fs.statSync(...args),\n  exists: (...args: Parameters<typeof fs.exists>) => fs.exists(...args),\n  constants: fs.constants\n}\n);\ncontextBridge.exposeInMainWorld(\n  'electron',\n  {\n    isMac: () => {\n      return process.platform === 'darwin';\n    },\n    minimize: (profile) => {\n      return new Promise((resolve, reject) => {\n        ipcRenderer.invoke('win-minimize', profile).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      })\n    },\n    maximize: (profile) => {\n      return new Promise((resolve, reject) => {\n        ipcRenderer.invoke('win-maximize', profile).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      })\n    },\n    locate_game_directory: (profile) => {\n      return new Promise((resolve, reject) => {\n        ipcRenderer.invoke('locate-game-directory', profile).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      })\n    },\n    launchProfile: (profile: LaunchProfile) => {\n      return new Promise((resolve, reject) => {\n        ipcRenderer.invoke('launch_profile', profile).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n    },\n    openExternal: (src, options) => {\n      return new Promise((resolve, reject) => {\n        shell.openExternal(src, options).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n    },\n    showLoadingErrorAndExit: (message: string) => {\n      return new Promise((resolve, reject) => {\n        ipcRenderer.invoke('show-loading-error', message).then((response) => {\n          resolve(response);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n    },\n  }\n);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\Debugger.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .constructor on an `any` value.","line":99,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DebuggerState } from \"@/enums/server/DebuggerState\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\r\nimport { IPCMessage } from \"@/server/ipc/IPCMessage\";\r\nimport { IPCMessageParam } from \"@/server/ipc/IPCMessageParam\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\nimport { NWScriptStack } from \"@/nwscript/NWScriptStack\";\r\n\r\n/**\r\n * Debugger class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file Debugger.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class Debugger {\r\n  /**\r\n   * The IPCMessage class.\r\n   */\r\n  static IPCMessage: typeof IPCMessage = IPCMessage;\r\n  /**\r\n   * The IPCMessageParam class.\r\n   */\r\n  static IPCMessageParam: typeof IPCMessageParam = IPCMessageParam;\r\n  /**\r\n   * The broadcast channel.\r\n   */\r\n  static broadcastChannel: BroadcastChannel | null;\r\n  /**\r\n   * The UUID of the debugger.\r\n   */\r\n  static uuid: string = crypto.randomUUID();\r\n  /**\r\n   * The window of the debugger.\r\n   */\r\n  static window: WindowProxy | null;\r\n\r\n  static #eventListener: Record<string, ((...args: unknown[]) => void)[]> = {};\r\n\r\n  static state: DebuggerState = DebuggerState.Idle;\r\n\r\n  static currentScript: NWScriptInstance;\r\n  static currentStack: NWScriptStack;\r\n  static currentInstruction: NWScriptInstruction;\r\n  static mainLoopPaused: boolean = false;\r\n\r\n  static showFPS: boolean = false;\r\n  static statsMode: number = 0;\r\n\r\n  /**\r\n   * Sends a message to the debugger.\r\n   * @param message The message to send.\r\n   */\r\n  static send(message: IPCMessage|string) {\r\n    if(!this.window || !this.broadcastChannel) {\r\n      return;\r\n    }\r\n    /**\r\n     * Debug string messages are sent as-is.\r\n     */\r\n    if(typeof message == 'string')\r\n    {\r\n      this.broadcastChannel.postMessage(message);\r\n    }\r\n    /**\r\n     * Complex messages are sent as binary data.\r\n     */\r\n    else\r\n    {\r\n      this.broadcastChannel.postMessage(message.toBuffer());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Opens the debugger window.\r\n   */\r\n  static open() {\r\n    if(this.window) { \r\n      this.window.focus();\r\n      return;\r\n    }\r\n\r\n    this.window = window.open(`../debugger/index.html?uuid=${this.uuid}`, '_blank', 'width=1600,height=1200');\r\n    if(this.window) {\r\n      log.info(`Debugger window opened: ${this.uuid}`);\r\n      this.broadcastChannel = new BroadcastChannel(`debugger-${this.uuid}`);\r\n      this.broadcastChannel.onmessage = (event: MessageEvent) => {\r\n        if(typeof event.data == 'string') {\r\n          if(event.data == 'close') {\r\n            Debugger.close();\r\n          }\r\n          return;\r\n        }\r\n        \r\n        if(event.data?.constructor == Uint8Array){\r\n          const msg = IPCMessage.fromBuffer(event.data);\r\n          this.dispatchEvent('message', msg);\r\n        }\r\n      };\r\n      this.window.addEventListener('close', () => {\r\n        log.info(`Debugger window closed: ${this.uuid}`);\r\n      });\r\n      this.dispatchEvent('open');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Closes the debugger window.\r\n   */\r\n  static close() {\r\n    if (this.window) {\r\n      this.window.close();\r\n    }\r\n    this.window = null;\r\n    if(this.broadcastChannel) {\r\n      this.broadcastChannel.close();\r\n    }\r\n    this.broadcastChannel = null;\r\n    this.dispatchEvent('close');\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener to the debugger.\r\n   * @param event The event to listen for.\r\n   * @param listener The listener to add.\r\n   */\r\n  static addEventListener(event: string, listener: (...args: unknown[]) => void) {\r\n    if(!Array.isArray(this.#eventListener[event])) {\r\n      this.#eventListener[event] = [];\r\n    }\r\n    const index = this.#eventListener[event].indexOf(listener);\r\n    if(index == -1) {\r\n      this.#eventListener[event].push(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an event listener from the debugger.\r\n   * @param event The event to remove the listener from.\r\n   * @param listener The listener to remove.\r\n   */\r\n  static removeEventListener(event: string, listener: (...args: unknown[]) => void) {\r\n    if(!Array.isArray(this.#eventListener[event])) {\r\n      this.#eventListener[event] = [];\r\n    }\r\n    const index = this.#eventListener[event].indexOf(listener);\r\n    if(index >= 0) {\r\n      this.#eventListener[event].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches an event to the debugger.\r\n   * @param event The event to dispatch.\r\n   * @param args The arguments to pass to the event.\r\n   */\r\n  static dispatchEvent(event: string, ...args: unknown[]) {\r\n    if(!Array.isArray(this.#eventListener[event])) {\r\n      return;\r\n    }\r\n    this.#eventListener[event].forEach((listener: (...args: unknown[]) => void) => listener(...args));\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\Faction.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":301,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":301,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":302,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":302,"endColumn":25}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// import { FactionManager } from \"@/managers\";\r\nimport { Reputation } from \"@/engine/Reputation\";\r\nimport { ReputationConstant } from \"@/enums/engine/ReputationConstant\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { ModuleCreature, ModuleObject, ModulePlayer } from \"@/module\";\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport type { ITwoDARowData } from \"@/resource/TwoDAObject\";\n\r\n\r\n/**\r\n * Faction class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file Faction.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class Faction {\r\n\r\n  id = 0;\r\n  label = '';\r\n  global = 0;\r\n  parentId = 4294967295;\r\n  creatures: ModuleCreature[] = [];\r\n\r\n  reputations: Reputation[] = [];\r\n\r\n  addMember( creature: ModuleCreature ){\r\n    if(creature instanceof ModuleCreature){\r\n      if(this.creatures.indexOf(creature) == -1){\r\n        this.creatures.push(creature);\r\n      }\r\n    }\r\n  }\r\n\r\n  removeMember( creature: ModuleCreature ){\r\n    if(creature instanceof ModuleCreature){\r\n      const index = this.creatures.indexOf(creature);\r\n      if(index >= 0){\r\n        this.creatures.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  initReputations( value = ReputationConstant.FRIENDLY ){\r\n    this.reputations = [];\r\n    for(let i = 0; i < GameState.FactionManager.FACTION_COUNT; i++){\r\n      this.reputations[i] = new Reputation(this.id, i, value);\r\n    }\r\n  }\r\n\r\n  setReputation(id = -1, value = 100){\r\n    const reputation = this.reputations[id];\r\n    if(reputation instanceof Reputation){\r\n      reputation.reputation = value;\r\n    }\r\n  }\r\n\r\n  adjustReputation(id = -1, value = 100){\r\n    const reputation = this.reputations[id];\r\n    if(reputation instanceof Reputation){\r\n      reputation.reputation = reputation.reputation + value;\r\n      reputation.reputation = Math.max(0, Math.min(reputation.reputation, 100));\r\n    }\r\n  }\r\n\r\n  getReputation(id = -1){\r\n    const reputation = this.reputations[id];\r\n    if(reputation instanceof Reputation){\r\n      return reputation.reputation;\r\n    }\r\n    return ReputationConstant.NEUTRAL;\r\n  }\r\n\r\n  getCreatureReputation(oTarget: ModuleObject){\r\n    if(oTarget instanceof ModuleCreature){\r\n      const reputation = this.reputations[oTarget.faction.id];\r\n      if(reputation instanceof Reputation){\r\n        return reputation.reputation;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  getWeakestMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let lowerCR = Infinity;\r\n      let cLowestCR = 0;\r\n      let currentCreature = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cLowestCR = creature.challengeRating;\r\n          if(cLowestCR < lowerCR){\r\n            lowerCR = cLowestCR;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getStrongestMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let highestCR = -Infinity;\r\n      let cHighestCR = 0;\r\n      let currentCreature = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cHighestCR = creature.challengeRating;\r\n          if(cHighestCR > highestCR){\r\n            highestCR = cHighestCR;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getMostDamagedMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let lowestHP = Infinity;\r\n      let cLowestHP = 0;\r\n      let currentCreature: ModuleObject = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cLowestHP = creature.maxHitPoints - creature.currentHitPoints;\r\n          if(cLowestHP < lowestHP){\r\n            lowestHP = cLowestHP;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getLeastDamagedMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let highestHP = -Infinity;\r\n      let cHighestHP = 0;\r\n      let currentCreature = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cHighestHP = creature.maxHitPoints + creature.currentHitPoints;\r\n          if(cHighestHP > highestHP){\r\n            highestHP = cHighestHP;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getWorstACMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let ac = Infinity;\r\n      let cAC = 0;\r\n      let currentCreature = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cAC = creature.getAC();\r\n          if(cAC < ac){\r\n            ac = cAC;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getBestACMember(bMustBeVisible = false){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let ac = -Infinity;\r\n      let cAC = 0;\r\n      let currentCreature = undefined;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          cAC = creature.getAC();\r\n          if(cAC > ac){\r\n            ac = cAC;\r\n            currentCreature = creature;\r\n          }\r\n        }\r\n      }\r\n      return currentCreature; \r\n    // }\r\n    return undefined;\r\n  }\r\n\r\n  getMemberGold(){\r\n    let gold = 0;\r\n    let creature;\r\n    for(let i = 0, len = this.creatures.length; i < len; i++){\r\n      creature = this.creatures[i];\r\n      if(creature.faction == this){\r\n        gold += creature.getGold();\r\n      }\r\n    }\r\n    return gold;\r\n  }\r\n\r\n  getAverageReputation(oTarget: ModuleObject){\r\n    if(oTarget instanceof ModuleCreature){\r\n      let totalRep = 0;\r\n      let totalCreatures = 0;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          totalRep += this.getCreatureReputation(oTarget);\r\n          totalCreatures++;\r\n        }\r\n      }\r\n      return Math.floor(totalRep / totalCreatures); \r\n    }\r\n    return -1;\r\n  }\r\n\r\n  getAverageGoodEvilAlignment(){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let totalGoodEvil = 0;\r\n      let totalCreatures = 0;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          totalGoodEvil += creature.getGoodEvil();\r\n          totalCreatures++;\r\n        }\r\n      }\r\n      return Math.floor(totalGoodEvil / totalCreatures); \r\n    // }\r\n    return -1;\r\n  }\r\n\r\n  getAverageLevel(){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let totalLevel = 0;\r\n      let totalCreatures = 0;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          totalLevel += creature.getTotalClassLevel();\r\n          totalCreatures++;\r\n        }\r\n      }\r\n      return Math.floor(totalLevel / totalCreatures); \r\n    // }\r\n    return -1;\r\n  }\r\n\r\n  getAverageExperience(){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      let totalExp = 0;\r\n      let totalCreatures = 0;\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          totalExp += creature.getXP();\r\n          totalCreatures++;\r\n        }\r\n      }\r\n      return Math.floor(totalExp / totalCreatures); \r\n    // }\r\n    return -1;\r\n  }\r\n\r\n  getMostFrequestClass(){\r\n    // if(oTarget instanceof ModuleCreature){\r\n      const classCount = new Map();\r\n      for(let i = 0, len = this.creatures.length; i < len; i++){\r\n        const creature = this.creatures[i];\r\n        if(creature.faction == this){\r\n          const creatureClass = creature.getMainClass();\r\n          if(creatureClass){\r\n            classCount.set(creatureClass, (typeof classCount.get(creatureClass) == 'number') ? classCount.get(creatureClass) + 1 : 1);\r\n          }\r\n        }\r\n      }\r\n      if(classCount.size){\r\n        let bestClass = undefined;\r\n        let count = -Infinity;\r\n        for(const c of classCount.entries()){\r\n          if(c[1] > count){\r\n            bestClass = c[0];\r\n            count = c[1];\r\n          }\r\n        }\r\n        return typeof bestClass == 'number' ? bestClass : -1; \r\n      }else{\r\n        return -1;\r\n      }\r\n    // }\r\n    return -1;\r\n  }\r\n\r\n  getFactionMemberByIndex(index = 0, isPCOnly = false){\r\n    let cIdx = 0;\r\n    for(let i = 0, len = this.creatures.length; i < len; i++){\r\n      const creature = this.creatures[i];\r\n      if(creature.faction == this){\r\n        if(cIdx == index){\r\n          if(!isPCOnly || creature instanceof ModulePlayer)\r\n            return creature;\r\n        }\r\n        cIdx++;\r\n      }\r\n    }\r\n  }\r\n\r\n  toStruct(structIdx: number){\r\n    const struct = new GFFStruct(structIdx);\r\n\r\n    struct.addField( new GFFField(GFFDataType.WORD, 'FactionGlobal') ).setValue(this.global);\r\n    struct.addField( new GFFField(GFFDataType.CEXOSTRING, 'FactionName') ).setValue(this.label);\r\n    struct.addField( new GFFField(GFFDataType.DWORD, 'FactionParentID') ).setValue(this.parentId);\r\n\r\n    return struct;\r\n  }\r\n\r\n  static From2DARow( row: ITwoDARowData | undefined = undefined ){\r\n    if(typeof row === 'object' && row != null){\r\n      const faction = new Faction();\r\n      faction.id = row.__index;\r\n      faction.label = String(row.label ?? '');\r\n      faction.global = 1;\r\n\r\n\r\n\r\n      return faction;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  static FromStruct( struct: GFFStruct ){\r\n    if( struct instanceof GFFStruct ){\r\n      const faction = new Faction();\r\n\r\n      faction.id = struct.getType();\r\n\r\n      if(struct.hasField('FactionGlobal'))\r\n        faction.global = struct.getNumberByLabel('FactionGlobal');\r\n\r\n      if(struct.hasField('FactionName'))\r\n        faction.label = struct.getStringByLabel('FactionName');\r\n\r\n      if(struct.hasField('FactionParentID'))\r\n        faction.parentId = struct.getNumberByLabel('FactionParentID');\r\n\r\n      return faction;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\FeedbackMessageEntry.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":20,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":22,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FeebackMessageColor } from \"@/enums/engine/FeedbackMessageColor\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\n\r\n/**\r\n * FeedbackMessageEntry class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file FeedbackMessageEntry.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class FeedbackMessageEntry {\r\n  color: FeebackMessageColor = FeebackMessageColor.INFO;\r\n  message: string = '';\r\n  type: number = 0;\r\n\r\n  constructor(){\r\n    \r\n  }\r\n\r\n  toStruct(){\r\n    const struct = new GFFStruct(0);\r\n    struct.addField(new GFFField(GFFDataType.BYTE, 'PT_FB_MSG_COLOR', this.color));\r\n    struct.addField(new GFFField(GFFDataType.CEXOSTRING, 'PT_FB_MSG_MSG', this.message));\r\n    struct.addField(new GFFField(GFFDataType.DWORD, 'PT_FB_MSG_TYPE', this.type));\r\n    return struct;\r\n  }\r\n\r\n  static FromStruct(struct: GFFStruct): FeedbackMessageEntry {\r\n    const entry = new FeedbackMessageEntry();\r\n    if(struct instanceof GFFStruct){\r\n      if(struct.hasField('PT_FB_MSG_COLOR')) entry.color = struct.getNumberByLabel('PT_FB_MSG_COLOR') as FeebackMessageColor;\r\n      if(struct.hasField('PT_FB_MSG_MSG')) entry.message = struct.getStringByLabel('PT_FB_MSG_MSG');\r\n      if(struct.hasField('PT_FB_MSG_TYPE')) entry.type = struct.getNumberByLabel('PT_FB_MSG_TYPE');\r\n    }\r\n    return entry;\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\INIConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":66,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":66,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as swKotOR from \"@/game/kotor/swkotor-config\";\nimport * as swKotOR2 from \"@/game/tsl/swkotor2-config\";\nimport { DeepObject } from \"@/utility/DeepObject\";\nimport { GameFileSystem } from \"@/utility/GameFileSystem\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Default);\n\n/** INI value: primitive or nested section. */\nexport type IniValue = string | number | boolean | Record<string, string | number | boolean | Record<string, string | number | boolean>>;\n\n/**\n * INIConfig class.\n * Loads/saves swKotor.ini (K1) or swKotor2.ini (K2). Section and key names match the\n * original game INI layout (Sound Options, Graphics Options, Game Options, Keymapping,\n * Autopause Options; K2: Display Options, config; both: Movies Shown).\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file INIConfig.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class INIConfig {\n  ini_path: string;\n  defaults: Record<string, IniValue>;\n  options: Record<string, IniValue> = {};\n  current_section: string | null = null;\n\n  static defaultConfigs: Record<string, Record<string, IniValue>> = {\n    swKotOR: swKotOR.default,\n    swKotOR2: swKotOR2.default\n  };\n\n  constructor(ini_path: string, defaults: Record<string, IniValue> = {}) {\n    this.ini_path = ini_path;\n    this.defaults = defaults;\n    this.options = {};\n  }\n\n  async load(): Promise<void> {\n    try {\n      const buffer = await GameFileSystem.readFile(this.ini_path);\n      const decoder = new TextDecoder('utf-8');\n      const ini_text = decoder.decode(buffer);\n      const lines = ini_text.split(/\\r?\\n/);\n\n      this.current_section = null;\n\n      for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i].trim();\n        if (!line.length) {\n          continue;\n        }\n\n        const section = line.match(/^\\[(.*)\\]$/);\n        const property = line.split('=');\n        if (section != null && section.length) {\n          this.current_section = section[1];\n          this.options[section[1]] = {};\n        } else if (property.length) {\n          const name = property.shift();\n          let value = property.join('=');\n\n          try {\n            value = JSON.parse(value.toString());\n          } catch (e) {\n            value = value.toString();\n          }\n\n          if (this.current_section) {\n            const section = this.options[this.current_section];\n            if (typeof section === 'object' && section !== null && !Array.isArray(section)) {\n              (section as Record<string, IniValue>)[name] = value;\n            }\n          } else {\n            this.options[name] = value;\n          }\n        }\n      }\n      this.options = DeepObject.Merge(this.defaults, this.options);\n      return;\n    } catch (e) {\n      log.error('INIConfig.load', e as Error);\n      this.options = DeepObject.Merge(this.defaults, this.options);\n      return;\n    }\n  }\n\n  // Code copied from linked Stack Overflow question\n  // https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge\n  // Answer by Salakar:\n  // https://stackoverflow.com/users/2938161/salakar\n  getProperty(key: string): IniValue | undefined {\n    //https://stackoverflow.com/a/20424385\n    const parts = key.split('.');\n    let o: Record<string, IniValue> = this.options;\n    if (parts.length > 1) {\n      for (let i = 0; i < parts.length - 1; i++) {\n        if (!o[parts[i]])\n          o[parts[i]] = {};\n        o = o[parts[i]] as Record<string, IniValue>;\n      }\n    }\n\n    return o[parts[parts.length - 1]];\n  }\n\n  setProperty(key: string, value: IniValue) {\n    //https://stackoverflow.com/a/20424385\n    const parts = key.split('.');\n    let o: Record<string, IniValue> = this.options;\n    if (parts.length > 1) {\n      for (let i = 0; i < parts.length - 1; i++) {\n        if (!o[parts[i]])\n          o[parts[i]] = {};\n        o = o[parts[i]] as Record<string, IniValue>;\n      }\n    }\n\n    o[parts[parts.length - 1]] = value;\n  }\n\n  toString(): string {\n    let string = '';\n    const keys = Object.keys(this.options);\n    for (let i = 0, len = keys.length; i < len; i++) {\n      string += this.toStringNodeWalker(keys[i], this.options[keys[i]]);\n    }\n    return '\\r\\n' + string;\n  }\n\n  toStringNodeWalker(key: string, value: IniValue): string {\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      let string = '[' + key + ']\\r\\n';\n      const keys = Object.keys(value);\n      for (let i = 0, len = keys.length; i < len; i++) {\n        string += this.toStringNodeWalker(keys[i], value[keys[i]]);\n      }\n      return string + '\\r\\n';\n    } else {\n      return key + '=' + value + '\\r\\n';\n    }\n  }\n\n  async save() {\n    try {\n      log.debug(`INIConfig saving: ${this.ini_path}`);\n      const encoder = new TextEncoder();\n      await GameFileSystem.writeFile(this.ini_path, encoder.encode(this.toString()));\n      log.debug(`INIConfig saved: ${this.ini_path}`);\n    } catch (e) {\n      log.error('INIConfig.save', e as Error);\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\JournalEntry.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":32,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":34,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { JournalCategory } from \"@/engine/JournalCategory\";\nimport { JournalCategoryEntry } from \"@/engine/JournalCategoryEntry\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport { GameState } from \"@/GameState\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport type { ITwoDARowData } from \"@/resource/TwoDAObject\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * JournalEntry class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file JournalEntry.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class JournalEntry {\n  date: number = 0;\n  plot_id: string = '';\n  state: number = 0;\n  time: number = 0;\n\n  category: JournalCategory;\n  entry: JournalCategoryEntry;\n  plot: ITwoDARowData | undefined;\n\n  constructor(){\n\n  }\n\n  getName(): string {\n    return this.category.name.getTLKValue();\n  }\n\n  getEntryText(): string {\n    return this.entry.text.getTLKValue();\n  }\n\n  load(): void {\n    this.category = GameState.JournalManager.GetCategoryByTag(this.plot_id);\n    if(this.category){\n      this.entry = this.category.getEntryById(this.state);\n      if(!this.entry){\n        log.warn(`JournalEntry.load: Invalid State \"${this.state}\"`);\n      }\n    }else{\n      log.warn(`JournalEntry.load: Invalid Category \"${this.plot_id}\"`);\n    }\n    const plotTable = GameState.TwoDAManager.datatables.get('plot');\n    if(!plotTable){ return; }\n\n    const plot = plotTable.getRowByColumnAndValue('label', this.plot_id.toLocaleLowerCase());\n    if(!plot){ return; }\n\n    this.plot = plot;\n  }\n\n  getExperience(): number {\n    if(this.plot){\n      return parseInt(String(this.plot.xp ?? 0), 10);\n    }\n    return 0;\n  }\n\n  toStruct(id: number = 0){\n    const struct = new GFFStruct(id);\n    struct.addField(new GFFField(GFFDataType.DWORD, 'JNL_Date', this.date));\n    struct.addField(new GFFField(GFFDataType.DWORD, 'JNL_Time', this.time));\n    struct.addField(new GFFField(GFFDataType.CEXOSTRING, 'JNL_PlotID', this.category.tag));\n    struct.addField(new GFFField(GFFDataType.INT, 'JNL_State', this.entry.id));\n    return struct;\n  }\n\n  static FromStruct(struct: GFFStruct): JournalEntry {\n    const entry = new JournalEntry();\n    if(struct instanceof GFFStruct){\n      if(struct.hasField('JNL_Date'))   entry.date    = struct.getNumberByLabel('JNL_Date');\n      if(struct.hasField('JNL_PlotID')) entry.plot_id = struct.getStringByLabel('JNL_PlotID');\n      if(struct.hasField('JNL_State'))  entry.state   = struct.getNumberByLabel('JNL_State');\n      if(struct.hasField('JNL_Time'))   entry.time    = struct.getNumberByLabel('JNL_Time');\n\n      entry.load();\n\n    }\n    return entry;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\VideoPlayer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":114,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":114,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\n\nimport { ApplicationEnvironment } from \"@/enums/ApplicationEnvironment\";\nimport { ResourceLoader } from \"@/loaders/ResourceLoader\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { ApplicationProfile } from \"@/utility/ApplicationProfile\";\nimport { GameFileSystem } from \"@/utility/GameFileSystem\";\n\n/** BIK (Bink Video) resource type id for cache lookups */\nconst BIK_RES_TYPE = ResourceTypes[\"bik\"] as number;\n\n/** Queue entry: resref + skippable (ExecuteCommandQueueMovie / AddMovieToMovieQueue parity). */\nexport interface VideoPlayerQueueEntry {\n  resref: string;\n  skippable: boolean;\n}\n\n/**\n * VideoPlayer class.\n *\n * Plays Bink (.bik) movies by resref. Matches CClientExoApp::PlayMovie, AddMovieToMovieQueue,\n * PlayMovieQueue, IsMoviePlaying, and CancelMovie: single PlayMovie(resref), queue with\n * QueueMovie(resref, skippable) then PlayMovieQueue(allowSeparateSkips), and cancel/skip behavior.\n *\n * KotOR stores movies under a \"Movies\" folder or in module RIMs; resref is case-insensitive.\n * A full BIK decoder is not implemented yet, so Load() resolves after resolving the resource.\n *\n * @file VideoPlayer.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class VideoPlayer {\n  private static _isPlaying = false;\n  private static _playCompleteResolve: (() => void) | null = null;\n  /** Current skippable flag (for CancelMovie: only cancel if skippable unless force). */\n  private static _currentSkippable = false;\n  /** Request to cancel current playback (set by CancelMovie). */\n  private static _cancelled = false;\n\n  /** Queue: (resref, skippable) per AddMovieToMovieQueue. */\n  private static _queue: VideoPlayerQueueEntry[] = [];\n  private static _queuePlaying = false;\n  /** PlayMovieQueue(bAllowSeparateSkips): true = skip only current; false = cancel whole queue. */\n  private static _allowSeparateSkips = false;\n\n  /**\n   * Load and play a single movie by resref. Resolves when playback ends or is skipped.\n   * Empty resref returns immediately. Mirrors CClientExoApp::PlayMovie(client, resref, ?, 0, 0).\n   *\n   * @param resref - Movie resref (e.g. \"legal\", \"intro\"), case-insensitive\n   * @returns Promise that resolves when the movie has finished or been skipped\n   */\n  static async Load(resref: string = \"\"): Promise<void> {\n    const normalized = (resref || \"\").trim().toLowerCase().replace(/\\.bik$/i, \"\");\n    if (!normalized) {\n      return;\n    }\n\n    VideoPlayer._cancelled = false;\n    let buffer: Uint8Array | null = null;\n    try {\n      buffer = await VideoPlayer.getMovieBuffer(normalized);\n    } catch {\n      return;\n    }\n    if (!buffer) {\n      return;\n    }\n\n    VideoPlayer._isPlaying = true;\n    VideoPlayer._currentSkippable = true;\n    VideoPlayer._playCompleteResolve = null;\n\n    return new Promise<void>((resolve) => {\n      VideoPlayer._playCompleteResolve = resolve;\n      // No BIK decoder yet: resolve immediately. When BIK is implemented, call OnPlaybackComplete from onComplete/skip.\n      VideoPlayer._isPlaying = false;\n      VideoPlayer._currentSkippable = false;\n      if (VideoPlayer._playCompleteResolve) {\n        VideoPlayer._playCompleteResolve();\n        VideoPlayer._playCompleteResolve = null;\n      }\n    });\n  }\n\n  /**\n   * Queue a movie to be played by PlayMovieQueue. Mirrors AddMovieToMovieQueue(client, resref, skippable).\n   *\n   * @param resref - Movie resref\n   * @param skippable - If true, player can cancel this movie (escape); if false, must wait for it to finish\n   */\n  static QueueMovie(resref: string, skippable: boolean): void {\n    const normalized = (resref || \"\").trim().toLowerCase().replace(/\\.bik$/i, \"\");\n    if (!normalized) return;\n    VideoPlayer._queue.push({ resref: normalized, skippable });\n  }\n\n  /**\n   * Play the movies added via QueueMovie. Mirrors PlayMovieQueue(client, bAllowSeparateSkips).\n   * If bAllowSeparateSkips is true, escape cancels only the current movie (if skippable); otherwise cancels the entire queue.\n   *\n   * @param allowSeparateSkips - True = skip only current movie; false = cancel whole queue on skip\n   */\n  static PlayMovieQueue(allowSeparateSkips: boolean): void {\n    VideoPlayer._allowSeparateSkips = !!allowSeparateSkips;\n    if (VideoPlayer._queuePlaying) return;\n    VideoPlayer._playQueueLoop();\n  }\n\n  private static async _playQueueLoop(): Promise<void> {\n    VideoPlayer._queuePlaying = true;\n    while (VideoPlayer._queue.length > 0) {\n      VideoPlayer._cancelled = false;\n      const entry = VideoPlayer._queue.shift()!;\n      VideoPlayer._currentSkippable = entry.skippable;\n      VideoPlayer._isPlaying = true;\n      VideoPlayer._playCompleteResolve = null;\n\n      const resolvePromise = new Promise<void>((resolve) => {\n        VideoPlayer._playCompleteResolve = resolve;\n      });\n\n      try {\n        const buffer = await VideoPlayer.getMovieBuffer(entry.resref);\n        if (!buffer) {\n          VideoPlayer._isPlaying = false;\n          continue;\n        }\n        // No BIK decoder: resolve immediately so queue advances. When BIK exists, resolve from onComplete/skip.\n        VideoPlayer._isPlaying = false;\n        if (VideoPlayer._playCompleteResolve) {\n          VideoPlayer._playCompleteResolve();\n          VideoPlayer._playCompleteResolve = null;\n        }\n      } catch {\n        VideoPlayer._isPlaying = false;\n        if (VideoPlayer._playCompleteResolve) {\n          VideoPlayer._playCompleteResolve();\n          VideoPlayer._playCompleteResolve = null;\n        }\n      }\n\n      await resolvePromise;\n      if (VideoPlayer._cancelled) {\n        if (!VideoPlayer._allowSeparateSkips) {\n          VideoPlayer._queue.length = 0;\n          break;\n        }\n      }\n    }\n    VideoPlayer._queuePlaying = false;\n    VideoPlayer._isPlaying = false;\n  }\n\n  /**\n   * Cancel current movie. If force is true, cancel regardless of skippable. Mirrors CExoMoviePlayerInternal::CancelMovie.\n   *\n   * @param force - If true, cancel even when current movie is not skippable (param_2 in binary)\n   */\n  static CancelMovie(force = false): void {\n    if (!force && VideoPlayer._isPlaying && !VideoPlayer._currentSkippable) return;\n    VideoPlayer._cancelled = true;\n    VideoPlayer.OnPlaybackComplete();\n  }\n\n  /**\n   * Resolve BIK buffer by resref: cache first, then Movies/{resref}.bik from game directory.\n   */\n  private static async getMovieBuffer(resref: string): Promise<Uint8Array | null> {\n    const cached = ResourceLoader.getCache(BIK_RES_TYPE, resref);\n    if (cached) return cached;\n\n    try {\n      if (ApplicationProfile.ENV === ApplicationEnvironment.ELECTRON && ApplicationProfile.directory) {\n        const moviePath = path.join(\"Movies\", `${resref}.bik`);\n        const buffer = await GameFileSystem.readFile(moviePath);\n        return buffer ?? null;\n      }\n    } catch {\n      // Ignore\n    }\n    return null;\n  }\n\n  /**\n   * Whether a movie is currently playing. Mirrors CClientExoApp::IsMoviePlaying (returns 0/1 in script).\n   */\n  static IsMoviePlaying(): boolean {\n    return VideoPlayer._isPlaying;\n  }\n\n  /**\n   * Called when playback finishes or is skipped (for use by a future BIK playback layer or CancelMovie).\n   */\n  static OnPlaybackComplete(): void {\n    VideoPlayer._isPlaying = false;\n    VideoPlayer._currentSkippable = false;\n    if (VideoPlayer._playCompleteResolve) {\n      VideoPlayer._playCompleteResolve();\n      VideoPlayer._playCompleteResolve = null;\n    }\n  }\n\n  /** Clear the movie queue without playing. */\n  static ClearQueue(): void {\n    VideoPlayer._queue.length = 0;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\rules\\SWCreatureAppearance.ts","messages":[{"ruleId":"@typescript-eslint/prefer-as-const","severity":2,"message":"Expected a `const` assertion instead of a literal type annotation.","line":96,"column":17,"nodeType":"TSLiteralType","messageId":"variableConstAssertion","endLine":96,"endColumn":20,"suggestions":[{"messageId":"variableSuggest","fix":{"range":[2394,2405],"text":" = 'l' as const"},"desc":"You should use `as const` instead of type annotation."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TwoDAObject, type ITwoDARowData } from \"@/resource/TwoDAObject\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { Utility } from \"@/utility/Utility\";\r\n\r\n/**\r\n * SWCreatureAppearance class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file SWCreatureAppearance.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class SWCreatureAppearance {\r\n  id: number = -1;\r\n  label: string = '';\r\n  string_ref: number = -1;\r\n  race: string = '';\r\n  walkdist: number = 1.7;\r\n  rundist: number = 5.4;\r\n  driveanimwalk: number = 1.7;\r\n  driveanimrun: number = 5.4;\r\n  driveanimrun_pc: number = 5.4; //TSL\r\n  driveanimrun_xbox: number = 5.4; //TSL\r\n  racetex: string = '';\r\n  modeltype: 'B'|'F'|'S'|'L' = 'B';\r\n  normalhead: number = -1;\r\n  backuphead: number = -1;\r\n\r\n  modela: string = '';\r\n  texa: string = '';\r\n  texaevil: string = '';\r\n\r\n  modelb: string = '';\r\n  texb: string = '';\r\n  texbevil: string = ''; //TSL\r\n\r\n  modelc: string = '';\r\n  texc: string = '';\r\n\r\n  modeld: string = '';\r\n  texd: string = '';\r\n\r\n  modele: string = '';\r\n  texe: string = '';\r\n\r\n  modelf: string = '';\r\n  texf: string = '';\r\n\r\n  modelg: string = '';\r\n  texg: string = '';\r\n\r\n  modelh: string = '';\r\n  texh: string = '';\r\n\r\n  modeli: string = '';\r\n  texi: string = '';\r\n  texievil: string = ''; //TSL\r\n\r\n  modelj: string = '';\r\n  texj: string = '';\r\n\r\n  modelk: string = ''; //TSL\r\n  texk: string = ''; //TSL\r\n\r\n  modell: string = ''; //TSL\r\n  texl: string = ''; //TSL\r\n\r\n  modelm: string = ''; //TSL\r\n  texm: string = ''; //TSL\r\n\r\n  modeln: string = ''; //TSL\r\n  texn: string = ''; //TSL\r\n  texnevil: string = ''; //TSL\r\n\r\n  skin: string = '';\r\n  headtexve: string = '';\r\n  headtexe: string = '';\r\n  headtexg: string = '';\r\n  headtexvg: string = '';\r\n  envmap: string = '';\r\n  bloodcolr: 'R'|'S'|'G' = 'R';\r\n\r\n  weaponscale: number = 1.0;\r\n  wing_tail_scale: number = 1.0;\r\n  moverate: 'PLAYER'|'NOMOVE'|'VSLOW'|'SLOW'|'NORM'|'FAST'|'VFAST'|'DEFAULT'|'DFAST'|'HUGE'|'GIANT'|'WEE_FOLK' = 'NORM';\r\n  driveaccl: number = 50;\r\n  drivemaxspeed: number = 5.4;\r\n  hitradius: number = 0.25;\r\n  perspace: number = 0.35;\r\n  creperspace: number = 0.4;\r\n  cameraspace: number = 0;\r\n  height: number = 0;\r\n  targetheight: 'l' = 'l';\r\n  abortonparry: boolean = false;\r\n  racialtype: number = 20;\r\n  haslegs: boolean = true;\r\n  hasarms: boolean = true;\r\n  portrait: string = 'po_default';\r\n  footstepsound: string = '';\r\n  footstepvolume: number = 1;\r\n  sizecategory: number = 3;\r\n  \r\n  armor_sound: string = '';\r\n  combat_sound: string = '';\r\n  helmet_scale_m: number = 1.0;\r\n  helmet_scale_f: number = 1.0;\r\n  perceptiondist: number = 9.0;\r\n  footsteptype: number = 0;\r\n  soundapptype: number = 0;\r\n  headtrack: number = 0;\r\n  head_arc_h: number = 0;\r\n  head_arc_v: number = 0;\r\n  headbone: string = '';\r\n  hitdist: number = 1;\r\n  prefatckdist: number = 0.5;\r\n  groundtilt: number = 0;\r\n  body_bag: number = -1;\r\n  freelookeffect: number = -1;\r\n  cameraheightoffset: number = -1;\r\n  deathfx: number = -1;\r\n  deathfxnode: string = '';\r\n  fadedelayondeath: number = -1;\r\n  destroyobjectdelay: number = -1;\r\n  disableinjuredanim: boolean = false;\r\n  equipslotslocked: number = -1;\r\n\r\n  getBodyModelInfo(bodyVariation: string = '', textureVariation: number = 1): { model: string, texture: string } {\r\n    textureVariation = Math.max(1, textureVariation);\r\n    log.info('getBodyModelInfo', bodyVariation, textureVariation);\r\n    const defaultModel = this.modela.replace(/\\0[\\s\\S]*$/g,'');\r\n    const defaultTexture = this.texa.replace(/\\0[\\s\\S]*$/g,'');\r\n    let bodyModel = defaultModel; \r\n    let bodyTexture = defaultTexture;\r\n\r\n    if(this.modeltype != 'B'){\r\n      bodyModel = this.race.replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\r\n      bodyTexture = this.racetex.replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\r\n      return {\r\n        model: bodyModel,\r\n        texture: bodyTexture\r\n      }\r\n    }\r\n\r\n    switch(bodyVariation?.toLowerCase()){\r\n      case 'b':\r\n        bodyModel = this.modelb.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texb.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'c':\r\n        bodyModel = this.modelc.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texc.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'd':\r\n        bodyModel = this.modeld.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texd.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'e':\r\n        bodyModel = this.modele.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texe.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'f':\r\n        bodyModel = this.modelf.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texf.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'g':\r\n        bodyModel = this.modelg.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texg.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'h':\r\n        bodyModel = this.modelh.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texh.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      case 'i':\r\n        bodyModel = this.modeli.replace(/\\0[\\s\\S]*$/g,'');\r\n        bodyTexture = this.texi.replace(/\\0[\\s\\S]*$/g,'');\r\n      break;\r\n      default:\r\n        bodyModel = defaultModel;\r\n        bodyTexture = defaultTexture;\r\n      break;\r\n    }\r\n\r\n    if(bodyTexture){\r\n      bodyTexture += Utility.PadInt( textureVariation, 2);\r\n    }\r\n\r\n    return {\r\n      model: bodyModel ? bodyModel.toLowerCase() : defaultModel.toLowerCase(), \r\n      texture: bodyTexture ? bodyTexture.toLowerCase() : defaultTexture.toLowerCase()\r\n    };\r\n  }\r\n\r\n  static From2DA (row: ITwoDARowData = {} as ITwoDARowData): SWCreatureAppearance {\r\n    const appearance = new SWCreatureAppearance();\r\n\r\n    appearance.id = parseInt(String(row.__index ?? 0), 10);\r\n\r\n    if(row.hasOwnProperty('label'))\r\n      appearance.label = TwoDAObject.normalizeValue(row.label, 'string', '');\r\n    if(row.hasOwnProperty('string_ref'))\r\n      appearance.string_ref = TwoDAObject.normalizeValue(row.string_ref, 'number', -1);\r\n    if(row.hasOwnProperty('race'))\r\n      appearance.race = TwoDAObject.normalizeValue(row.race, 'string', '');\r\n    if(row.hasOwnProperty('walkdist'))\r\n      appearance.walkdist = TwoDAObject.normalizeValue(row.walkdist, 'number', 1.7);\r\n    if(row.hasOwnProperty('rundist'))\r\n      appearance.rundist = TwoDAObject.normalizeValue(row.rundist, 'number', 5.4);\r\n    if(row.hasOwnProperty('driveanimwalk'))\r\n      appearance.driveanimwalk = TwoDAObject.normalizeValue(row.driveanimwalk, 'number', 1.7);\r\n    if(row.hasOwnProperty('driveanimrun'))\r\n      appearance.driveanimrun = TwoDAObject.normalizeValue(row.driveanimrun, 'number', 5.4);\r\n    if(row.hasOwnProperty('driveanimrun_pc'))\r\n      appearance.driveanimrun_pc = TwoDAObject.normalizeValue(row.driveanimrun_pc, 'number', 5.4); //TSL\r\n    if(row.hasOwnProperty('driveanimrun_xbox'))\r\n      appearance.driveanimrun_xbox = TwoDAObject.normalizeValue(row.driveanimrun_xbox, 'number', 5.4); //TSL\r\n    if(row.hasOwnProperty('racetex'))\r\n      appearance.racetex = TwoDAObject.normalizeValue(row.racetex, 'string', '');\r\n    if(row.hasOwnProperty('modeltype'))\r\n      appearance.modeltype = TwoDAObject.normalizeValue(row.modeltype, 'string', 'B') as 'B'|'F'|'S'|'L';\r\n    if(row.hasOwnProperty('normalhead'))\r\n      appearance.normalhead = TwoDAObject.normalizeValue(row.normalhead, 'number', -1);\r\n    if(row.hasOwnProperty('backuphead'))\r\n      appearance.backuphead = TwoDAObject.normalizeValue(row.backuphead, 'number', -1);\r\n\r\n    if(row.hasOwnProperty('modela'))\r\n      appearance.modela = TwoDAObject.normalizeValue(row.modela, 'string', '');\r\n    if(row.hasOwnProperty('texa'))\r\n      appearance.texa = TwoDAObject.normalizeValue(row.texa, 'string', '');\r\n    if(row.hasOwnProperty('texaevil'))\r\n      appearance.texaevil = TwoDAObject.normalizeValue(row.texaevil, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modelb'))\r\n      appearance.modelb = TwoDAObject.normalizeValue(row.modelb, 'string', '');\r\n    if(row.hasOwnProperty('texb'))\r\n      appearance.texb = TwoDAObject.normalizeValue(row.texb, 'string', '');\r\n    if(row.hasOwnProperty('texbevil'))\r\n      appearance.texbevil = TwoDAObject.normalizeValue(row.texbevil, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('modelc'))\r\n      appearance.modelc = TwoDAObject.normalizeValue(row.modelc, 'string', '');\r\n    if(row.hasOwnProperty('texc'))\r\n      appearance.texc = TwoDAObject.normalizeValue(row.texc, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modeld'))\r\n      appearance.modeld = TwoDAObject.normalizeValue(row.modeld, 'string', '');\r\n    if(row.hasOwnProperty('texd'))\r\n      appearance.texd = TwoDAObject.normalizeValue(row.texd, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modele'))\r\n      appearance.modele = TwoDAObject.normalizeValue(row.modele, 'string', '');\r\n    if(row.hasOwnProperty('texe'))\r\n      appearance.texe = TwoDAObject.normalizeValue(row.texe, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modelf'))\r\n      appearance.modelf = TwoDAObject.normalizeValue(row.modelf, 'string', '');\r\n    if(row.hasOwnProperty('texf'))\r\n      appearance.texf = TwoDAObject.normalizeValue(row.texf, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modelg'))\r\n      appearance.modelg = TwoDAObject.normalizeValue(row.modelg, 'string', '');\r\n    if(row.hasOwnProperty('texg'))\r\n      appearance.texg = TwoDAObject.normalizeValue(row.texg, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modelh'))\r\n      appearance.modelh = TwoDAObject.normalizeValue(row.modelh, 'string', '');\r\n    if(row.hasOwnProperty('texh'))\r\n      appearance.texh = TwoDAObject.normalizeValue(row.texh, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modeli'))\r\n      appearance.modeli = TwoDAObject.normalizeValue(row.modeli, 'string', '');\r\n    if(row.hasOwnProperty('texi'))\r\n      appearance.texi = TwoDAObject.normalizeValue(row.texi, 'string', '');\r\n    if(row.hasOwnProperty('texievil'))\r\n      appearance.texievil = TwoDAObject.normalizeValue(row.texievil, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('modelj'))\r\n      appearance.modelj = TwoDAObject.normalizeValue(row.modelj, 'string', '');\r\n    if(row.hasOwnProperty('texj'))\r\n      appearance.texj = TwoDAObject.normalizeValue(row.texj, 'string', '');\r\n\r\n    if(row.hasOwnProperty('modelk'))\r\n      appearance.modelk = TwoDAObject.normalizeValue(row.modelk, 'string', ''); //TSL\r\n    if(row.hasOwnProperty('texk'))\r\n      appearance.texk = TwoDAObject.normalizeValue(row.texk, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('modell'))\r\n      appearance.modell = TwoDAObject.normalizeValue(row.modell, 'string', ''); //TSL\r\n    if(row.hasOwnProperty('texl'))\r\n      appearance.texl = TwoDAObject.normalizeValue(row.texl, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('modelm'))\r\n      appearance.modelm = TwoDAObject.normalizeValue(row.modelm, 'string', ''); //TSL\r\n    if(row.hasOwnProperty('texm'))\r\n      appearance.texm = TwoDAObject.normalizeValue(row.texm, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('modeln'))\r\n      appearance.modeln = TwoDAObject.normalizeValue(row.modeln, 'string', ''); //TSL\r\n    if(row.hasOwnProperty('texn'))\r\n      appearance.texn = TwoDAObject.normalizeValue(row.texn, 'string', ''); //TSL\r\n    if(row.hasOwnProperty('texnevil'))\r\n      appearance.texnevil = TwoDAObject.normalizeValue(row.texnevil, 'string', ''); //TSL\r\n\r\n    if(row.hasOwnProperty('skin'))\r\n      appearance.skin = TwoDAObject.normalizeValue(row.skin, 'string', '');\r\n    if(row.hasOwnProperty('headtexve'))\r\n      appearance.headtexve = TwoDAObject.normalizeValue(row.headtexve, 'string', '');\r\n    if(row.hasOwnProperty('headtexe'))\r\n      appearance.headtexe = TwoDAObject.normalizeValue(row.headtexe, 'string', '');\r\n    if(row.hasOwnProperty('headtexg'))\r\n      appearance.headtexg = TwoDAObject.normalizeValue(row.headtexg, 'string', '');\r\n    if(row.hasOwnProperty('headtexvg'))\r\n      appearance.headtexvg = TwoDAObject.normalizeValue(row.headtexvg, 'string', '');\r\n    if(row.hasOwnProperty('envmap'))\r\n      appearance.envmap = TwoDAObject.normalizeValue(row.envmap, 'string', '');\r\n    if(row.hasOwnProperty('bloodcolr'))\r\n      appearance.bloodcolr = TwoDAObject.normalizeValue(row.bloodcolr, 'string', 'R') as 'R'|'S'|'G';\r\n\r\n      if(row.hasOwnProperty('weaponscale'))\r\n      appearance.weaponscale = TwoDAObject.normalizeValue(row.weaponscale, 'number', 1.0);\r\n    if(row.hasOwnProperty('wing_tail_scale'))\r\n      appearance.wing_tail_scale = TwoDAObject.normalizeValue(row.wing_tail_scale, 'number', 1.0);\r\n    if(row.hasOwnProperty('moverate'))\r\n      appearance.moverate = TwoDAObject.normalizeValue(row.moverate, 'string', 'NORM') as SWCreatureAppearance['moverate'];\r\n    if(row.hasOwnProperty('driveaccl'))\r\n      appearance.driveaccl = TwoDAObject.normalizeValue(row.driveaccl, 'number', 50);\r\n    if(row.hasOwnProperty('drivemaxspeed'))\r\n      appearance.drivemaxspeed = TwoDAObject.normalizeValue(row.drivemaxspeed, 'number', 5.4);\r\n    if(row.hasOwnProperty('hitradius'))\r\n      appearance.hitradius = TwoDAObject.normalizeValue(row.hitradius, 'number', 0.25);\r\n    if(row.hasOwnProperty('perspace'))\r\n      appearance.perspace = TwoDAObject.normalizeValue(row.perspace, 'number', 0.35);\r\n    if(row.hasOwnProperty('creperspace'))\r\n      appearance.creperspace = TwoDAObject.normalizeValue(row.creperspace, 'number', 0.4);\r\n    if(row.hasOwnProperty('cameraspace'))\r\n      appearance.cameraspace = TwoDAObject.normalizeValue(row.cameraspace, 'number', 0);\r\n    if(row.hasOwnProperty('height'))\r\n      appearance.height = TwoDAObject.normalizeValue(row.height, 'number', 0);\r\n    if(row.hasOwnProperty('targetheight'))\r\n      appearance.targetheight = TwoDAObject.normalizeValue(row.targetheight, 'string', 'l') as 'l';\r\n    if(row.hasOwnProperty('abortonparry'))\r\n      appearance.abortonparry = TwoDAObject.normalizeValue(row.abortonparry, 'boolean', false);\r\n    if(row.hasOwnProperty('racialtype'))\r\n      appearance.racialtype = TwoDAObject.normalizeValue(row.racialtype, 'number', 20);\r\n    if(row.hasOwnProperty('haslegs'))\r\n      appearance.haslegs = TwoDAObject.normalizeValue(row.haslegs, 'boolean', true);\r\n    if(row.hasOwnProperty('hasarms'))\r\n      appearance.hasarms = TwoDAObject.normalizeValue(row.hasarms, 'boolean', true);\r\n    if(row.hasOwnProperty('portrait'))\r\n      appearance.portrait = TwoDAObject.normalizeValue(row.portrait, 'string', 'po_default');\r\n    if(row.hasOwnProperty('footstepsound'))\r\n      appearance.footstepsound = TwoDAObject.normalizeValue(row.footstepsound, 'string', '');\r\n    if(row.hasOwnProperty('footstepvolume'))\r\n      appearance.footstepvolume = TwoDAObject.normalizeValue(row.footstepvolume, 'number', 1);\r\n    if(row.hasOwnProperty('sizecategory'))\r\n      appearance.sizecategory = TwoDAObject.normalizeValue(row.sizecategory, 'number', 3);\r\n    \r\n    if(row.hasOwnProperty('armor_sound'))\r\n      appearance.armor_sound = TwoDAObject.normalizeValue(row.armor_sound, 'string', '');\r\n    if(row.hasOwnProperty('combat_sound'))\r\n      appearance.combat_sound = TwoDAObject.normalizeValue(row.combat_sound, 'string', '');\r\n    if(row.hasOwnProperty('helmet_scale_m'))\r\n      appearance.helmet_scale_m = TwoDAObject.normalizeValue(row.helmet_scale_m, 'number', 1.0);\r\n    if(row.hasOwnProperty('helmet_scale_f'))\r\n      appearance.helmet_scale_f = TwoDAObject.normalizeValue(row.helmet_scale_f, 'number', 1.0);\r\n    if(row.hasOwnProperty('perceptiondist'))\r\n      appearance.perceptiondist = TwoDAObject.normalizeValue(row.perceptiondist, 'number', 9.0);\r\n    if(row.hasOwnProperty('footsteptype'))\r\n      appearance.footsteptype = TwoDAObject.normalizeValue(row.footsteptype, 'number', 0);\r\n    if(row.hasOwnProperty('soundapptype'))\r\n      appearance.soundapptype = TwoDAObject.normalizeValue(row.soundapptype, 'number', 0);\r\n    if(row.hasOwnProperty('headtrack'))\r\n      appearance.headtrack = TwoDAObject.normalizeValue(row.headtrack, 'number', 0);\r\n    if(row.hasOwnProperty('head_arc_h'))\r\n      appearance.head_arc_h = TwoDAObject.normalizeValue(row.head_arc_h, 'number', 0);\r\n    if(row.hasOwnProperty('head_arc_v'))\r\n      appearance.head_arc_v = TwoDAObject.normalizeValue(row.head_arc_v, 'number', 0);\r\n    if(row.hasOwnProperty('headbone'))\r\n      appearance.headbone = TwoDAObject.normalizeValue(row.headbone, 'string', '');\r\n    if(row.hasOwnProperty('hitdist'))\r\n      appearance.hitdist = TwoDAObject.normalizeValue(row.hitdist, 'number', 1);\r\n    if(row.hasOwnProperty('prefatckdist'))\r\n      appearance.prefatckdist = TwoDAObject.normalizeValue(row.prefatckdist, 'number', 0.5);\r\n    if(row.hasOwnProperty('groundtilt'))\r\n      appearance.groundtilt = TwoDAObject.normalizeValue(row.groundtilt, 'number', 0);\r\n    if(row.hasOwnProperty('body_bag'))\r\n      appearance.body_bag = TwoDAObject.normalizeValue(row.body_bag, 'number', -1);\r\n    if(row.hasOwnProperty('freelookeffect'))\r\n      appearance.freelookeffect = TwoDAObject.normalizeValue(row.freelookeffect, 'number', -1);\r\n    if(row.hasOwnProperty('cameraheightoffset'))\r\n      appearance.cameraheightoffset = TwoDAObject.normalizeValue(row.cameraheightoffset, 'number', -1);\r\n    if(row.hasOwnProperty('deathfx'))\r\n      appearance.deathfx = TwoDAObject.normalizeValue(row.deathfx, 'number', -1);\r\n    if(row.hasOwnProperty('deathfxnode'))\r\n      appearance.deathfxnode = TwoDAObject.normalizeValue(row.deathfxnode, 'string', '');\r\n    if(row.hasOwnProperty('fadedelayondeath'))\r\n      appearance.fadedelayondeath = TwoDAObject.normalizeValue(row.fadedelayondeath, 'number', -1);\r\n    if(row.hasOwnProperty('destroyobjectdelay'))\r\n      appearance.destroyobjectdelay = TwoDAObject.normalizeValue(row.destroyobjectdelay, 'number', -1);\r\n    if(row.hasOwnProperty('disableinjuredanim'))\r\n      appearance.disableinjuredanim = TwoDAObject.normalizeValue(row.disableinjuredanim, 'boolean', false);\r\n    if(row.hasOwnProperty('equipslotslocked'))\r\n      appearance.equipslotslocked = TwoDAObject.normalizeValue(row.equipslotslocked, 'number', -1);\r\n\r\n    return appearance;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\engine\\rules\\SWSavingThrow.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":22,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":24,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ITwoDARowData } from \"@/resource/TwoDAObject\";\r\nimport { TwoDAObject } from \"@/resource/TwoDAObject\";\r\n\r\n/**\r\n * class SWSavingThrow\r\n * - used to get saving throw for a class per level\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file SWSavingThrow.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class SWSavingThrow {\r\n\r\n  index: number = 0;\r\n  level: number = 0;\r\n  fortsave: number = 0;\r\n  willsave: number = 0;\r\n  refsave: number = 0;\r\n\r\n  constructor(index: number = 0){\r\n    // this.index = index;\r\n  }\r\n\r\n  apply2DA(row: ITwoDARowData | Record<string, string | number>): void {\r\n    this.index = TwoDAObject.normalizeValue(row.__index, 'number', 0);\r\n    this.level = TwoDAObject.normalizeValue(row.level, 'number', 0);\r\n    this.fortsave = TwoDAObject.normalizeValue(row.fortsave, 'number', 0);\r\n    this.willsave = TwoDAObject.normalizeValue(row.willsave, 'number', 0);\r\n    this.refsave = TwoDAObject.normalizeValue(row.refsave, 'number', 0);\r\n  }\r\n\r\n  static From2DA(row: ITwoDARowData | Record<string, string | number>): SWSavingThrow {\r\n    const st = new SWSavingThrow();\r\n    st.apply2DA(row);\r\n    return st;\r\n  }\r\n\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\actions\\ActionStatus.ts","messages":[{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":13,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":13,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ActionStatus enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ActionStatus.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ActionStatus {\r\n  /** Indicates that the action has failed to complete */\r\n  FAILED = undefined,\r\n\r\n  /** Indicates that the action is currently being executed */\r\n  IN_PROGRESS = 1,\r\n\r\n  /** Indicates that the action has successfully completed */\r\n  COMPLETE = 2,\r\n\r\n  /** Indicates that the action encountered an error during execution */\r\n  ERROR = 3,\r\n\r\n  /** Indicates that the action is waiting to be executed */\r\n  WAITING = 4,\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\actions\\ActionType.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 61.","line":132,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":132,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ActionType enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ActionType.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ActionType {\r\n  /** Invalid action type */\r\n  ActionInvalid = -1,\r\n  \r\n  /** Move creature to a specific point */\r\n  ActionMoveToPoint = 0x01,\r\n  /** Check if creature can move to an object */\r\n  ActionCheckMoveToObject = 0x02,\r\n  /** Check if creature can move away from an object */\r\n  ActionCheckMoveAwayFromObject = 0x03,\r\n  /** Check if pathfinding between areas is possible */\r\n  ActionCheckInterAreaPathfinding = 0x04,\r\n  /** Make creature jump to a point */\r\n  ActionJumpToPoint = 0x05,\r\n  /** Play an animation on creature */\r\n  ActionPlayAnimation = 0x06,\r\n  /** Make creature pick up an item */\r\n  ActionPickUpItem = 0x07,\r\n  /** Make creature equip an item */\r\n  ActionEquipItem = 0x08,\r\n  /** Make creature drop an item */\r\n  ActionDropItem = 0x09,\r\n  /** Check if creature can move to a point */\r\n  ActionCheckMoveToPoint = 0x0A,\r\n  /** Make creature unequip an item */\r\n  ActionUnequipItem = 0x0B,\r\n  /** Perform physical attacks */\r\n  ActionPhysicalAttacks = 0x0C,\r\n  /** Make creature speak */\r\n  ActionSpeak = 0x0E,\r\n  /** Cast a spell */\r\n  ActionCastSpell = 0x0F,\r\n  /** Wait for the end of combat round */\r\n  ActionWaitForEndOfRound = 0x10,\r\n  /** Check if creature can move to object within radius */\r\n  ActionCheckMoveToObjectRadius = 0x11,\r\n  /** Check if creature can move to point within radius */\r\n  ActionCheckMoveToPointRadius = 0x12,\r\n  /** Change creature facing to look at object */\r\n  ActionChangeFacingObject = 0x13,\r\n  /** Open a door */\r\n  ActionOpenDoor = 0x14,\r\n  /** Close a door */\r\n  ActionCloseDoor = 0x15,\r\n  /** Orient the camera */\r\n  ActionOrientCamera = 0x16,\r\n  /** Play a sound effect */\r\n  ActionPlaySound = 0x17,\r\n  /** Start dialog with an object */\r\n  ActionDialogObject = 0x18,\r\n  /** Disarm a mine */\r\n  ActionDisarmMine = 0x19,\r\n  /** Recover a mine */\r\n  ActionRecoverMine = 0x1A,\r\n  /** Flag a mine */\r\n  ActionFlagMine = 0x1B,\r\n  /** Examine a mine */\r\n  ActionExamineMine = 0x1C,\r\n  /** Set a mine */\r\n  ActionSetMine = 0x1D,\r\n  /** Wait for specified duration */\r\n  ActionWait = 0x1E,\r\n  /** Pause dialog */\r\n  ActionPauseDialog = 0x1F,\r\n  /** Resume dialog */\r\n  ActionResumeDialog = 0x20,\r\n  /** Speak using string reference */\r\n  ActionSpeakStrRef = 0x21,\r\n  /** Give an item to target */\r\n  ActionGiveItem = 0x22,\r\n  /** Take an item from target */\r\n  ActionTakeItem = 0x23,\r\n  /** Destroy self in encounter */\r\n  ActionEncounterCreatureDestroySelf = 0x24,\r\n  /** Execute a command */\r\n  ActionDoCommand = 0x25,\r\n  /** Unlock an object */\r\n  ActionUnlockObject = 0x26,\r\n  /** Lock an object */\r\n  ActionLockObject = 0x27,\r\n  /** Use an object */\r\n  ActionUseObject = 0x28,\r\n  /** Use Animal Empathy skill */\r\n  ActionAnimalEmpathy = 0x29,\r\n  /** Rest */\r\n  ActionRest = 0x2A,\r\n  /** Perform taunt action */\r\n  ActionTaunt = 0x2B,\r\n  /** Check if creature can move away from location */\r\n  ActionCheckMoveAwayFromLocation = 0x2C,\r\n  /** Perform random walk */\r\n  ActionRandomWalk = 0x2D,\r\n  /** Cast spell using an item */\r\n  ActionItemCastSpell = 0x2E,\r\n  /** Set whether creature is commandable */\r\n  ActionSetCommandable = 0x2F,\r\n  /** Make creature jump to object */\r\n  ActionJumpToObject = 0x30,\r\n  /** Change creature facing to point */\r\n  ActionChangeFacingPoint = 0x31,\r\n  /** Counter a spell */\r\n  ActionCounterSpell = 0x32,\r\n  /** Drive action */\r\n  ActionDrive = 0x33,\r\n  /** Make creature appear */\r\n  ActionAppear = 0x34,\r\n  /** Make creature disappear */\r\n  ActionDisappear = 0x35,\r\n  /** Attempt pickpocket */\r\n  ActionPickPocket = 0x36,\r\n  /** Force creature to follow object */\r\n  ActionForceFollowObject = 0x37,\r\n  /** Perform healing action */\r\n  ActionHeal = 0x38,\r\n  /** Check if creature can force follow object */\r\n  ActionCheckForceFollowObject = 0x3A,\r\n  /** Make creature follow leader */\r\n  ActionFollowLeader = 0x3D,\r\n  /** Wait in area */\r\n  ActionAreaWait = 0x3C,\r\n  /** Make party follow leader */\r\n  ActionPartyFollowLeader = 0x3D,\r\n  /** Display bark string */\r\n  ActionBarkString = 0x3E,\r\n  /** Enter combat mode */\r\n  ActionCombat = 0x3F,\r\n  /** Check if creature can move to follow within radius */\r\n  ActionCheckMoveToFollowRadius = 0x40,\r\n  /** Surrender to enemies */\r\n  ActionSurrenderToEnemies = 0x41,\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\combat\\BaseItemType.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 91.","line":96,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":96,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export enum BaseItemType {\r\n  QUARTER_STAFF = 0,\r\n  STUN_BATON = 1,\r\n  LONG_SWORD = 2,\r\n  VIBRO_SWORD = 3,\r\n  SHORT_SWORD = 4,\r\n  VIBRO_BLADE = 5,\r\n  DOUBLE_BLADED_SWORD = 6,\r\n  VIBRO_DOUBLE_BLADE = 7,\r\n  LIGHTSABER = 8,\r\n  DOUBLE_BLADED_LIGHTSABER = 9,\r\n  SHORT_LIGHTSABER = 10,\r\n  LIGHTSABER_CRYSTALS = 11,\r\n  BLASTER_PISTOL = 12,\r\n  HEAVY_BLASTER = 13,\r\n  HOLD_OUT_BLASTER = 14,\r\n  ION_BLASTER = 15,\r\n  DISRUPTER_PISTOL = 16,\r\n  SONIC_PISTOL = 17,\r\n  ION_RIFLE = 18,\r\n  BOWCASTER = 19,\r\n  BLASTER_CARBINE = 20,\r\n  DISRUPTER_RIFLE = 21,\r\n  SONIC_RIFLE = 22,\r\n  REPEATING_BLASTER = 23,\r\n  HEAVY_REPEATING_BLASTER = 24,\r\n  FRAGMENTATION_GRENADES = 25,\r\n  STUN_GRENADES = 26,\r\n  THERMAL_DETONATOR = 27,\r\n  POISON_GRENADE = 28,\r\n  FLASH_GRENADE = 29,\r\n  SONIC_GRENADE = 30,\r\n  ADHESIVE_GRENADE = 31,\r\n  CRYOBAN_GRENADE = 32,\r\n  FIRE_GRENADE = 33,\r\n  ION_GRENADE = 34,\r\n  JEDI_ROBE = 35,\r\n  JEDI_KNIGHT_ROBE = 36,\r\n  JEDI_MASTER_ROBE = 37,\r\n  ARMOR_CLASS_4 = 38,\r\n  ARMOR_CLASS_5 = 39,\r\n  ARMOR_CLASS_6 = 40,\r\n  ARMOR_CLASS_7 = 41,\r\n  ARMOR_CLASS_8 = 42,\r\n  ARMOR_CLASS_9 = 43,\r\n  MASK = 44,\r\n  GAUNTLETS = 45,\r\n  FOREARM_BANDS = 46,\r\n  BELT = 47,\r\n  IMPLANT_1 = 48,\r\n  IMPLANT_2 = 49,\r\n  IMPLANT_3 = 50,\r\n  DATA_PAD = 52,\r\n  ADRENALINE = 53,\r\n  COMBAT_SHOTS = 54,\r\n  MEDICAL_EQUIPMENT = 55,\r\n  DROID_REPAIR_EQUIPMENT = 56,\r\n  CREDITS = 57,\r\n  TRAP_KIT = 58,\r\n  SECURITY_SPIKES = 59,\r\n  PROGRAMMING_SPIKES = 60,\r\n  GLOW_ROD = 61,\r\n  COLLAR_LIGHT = 62,\r\n  TORCH = 63,\r\n  PLOT_USEABLE_ITEMS = 64,\r\n  AESTHETIC_ITEM = 65,\r\n  DROID_LIGHT_PLATING = 66,\r\n  DROID_MEDIUM_PLATING = 67,\r\n  DROID_HEAVY_PLATING = 68,\r\n  DROID_SEARCH_SCOPE_X = 69,\r\n  DROID_MOTION_SENSORS_X = 70,\r\n  DROID_SONIC_SENSORS_X = 71,\r\n  DROID_TARGETING_COMPUTERS = 72,\r\n  DROID_COMPUTER_SPIKE_MOUNT_X = 73,\r\n  DROID_SECURITY_SPIKE_MOUNT = 74,\r\n  DROID_SHIELD = 75,\r\n  DROID_UTILITY_DEVICE = 76,\r\n  BLASTER_RIFLE = 77,\r\n  GHAFFI_STICK = 78,\r\n  WOKIE_WARBLADE = 79,\r\n  GAMMOREAN_BATTLEAXE = 80,\r\n  CREATURE_ITEM_SLASH = 81,\r\n  CREATURE_ITEM_PIERCE = 82,\r\n  CREATURE_WEAPON_SL_PRC = 83,\r\n  CREATURE_HIDE_ITEM = 84,\r\n  BASIC_CLOTHING = 85,\r\n  PAZAAK_CARD = 86,\r\n  PAZAAK_SIZEBOARD = 87,\r\n  STEALTH_UNIT = 88,\r\n  REVAN_ARMOR = 89,\r\n  DISGUISE_ITEM = 90,\r\n  SQUAD_RECOVERY_KIT = 91,\r\n  /**\r\n   * TSL\r\n   */\r\n  TSL_WRIST_LAUNCHER = 91,\r\n  TSL_ROCKET = 92,\r\n  TSL_FORCE_PIKE = 93,\r\n  TSL_SQUAD_RECOVERY_KIT = 94,\r\n  TSL_CHEMICALS = 95,\r\n  TSL_COMPONENTS = 96,\r\n  TSL_SONIC_GENADE_TYPE_2 = 97,\r\n  TSL_ARMOR_ARMD_FLIGHT_SUIT = 98,\r\n  TSL_RESTICTIVE_JEDI_ROBE = 99,\r\n  TSL_SALVE_OUTFIT = 100,\r\n  TSL_UPGRADE_ITEMS = 101,\r\n  TSL_ARMOR_ZEISON_SHA = 102,\r\n  TSL_MINER_UNIFORM = 103\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\controls\\KeyMapAction.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value action1004.","line":102,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":102,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * KeyMapAction enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file KeyMapAction.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum KeyMapAction {\r\n\r\n  MoveForward = \"action200\",\r\n  MoveBack = \"action201\",\r\n  StrafeLeft = \"action202\",\r\n  StrafeRight = \"action203\",\r\n  SelectPrev = \"action204\",\r\n  SelectNext = \"action205\",\r\n  ChangeChar = \"action206\",\r\n  PartyActive = \"action207\",\r\n  Freelook = \"action208\",\r\n  Equip = \"action209\",\r\n  Inventory = \"action210\",\r\n  Character = \"action211\",\r\n  SkillsAndFeats = \"action212\",\r\n  Messages = \"action213\",\r\n  Quests = \"action214\",\r\n  Map = \"action215\",\r\n  Options = \"action216\",\r\n  MGshoot = \"action217\",\r\n  Quicksave = \"action218\",\r\n  LeftLookabout = \"action219\",\r\n  RightLookabout = \"action220\",\r\n  AlternateActions = \"action221\",\r\n  AlternateActions2 = \"action222\",\r\n  GUI = \"action223\",\r\n  Pause = \"action224\",\r\n  ToolTips = \"action225\",\r\n  TargetLeftAct = \"action226\",\r\n  DEFAULTChg = \"action227\",\r\n  TargetMiddleAct = \"action228\",\r\n  FEATSSKILLChg = \"action229\",\r\n  TargetRightAct = \"action230\",\r\n  HOSTILEPOWERChg = \"action231\",\r\n  PersonalPowerAct = \"action232\",\r\n  HOSTILEITEMChg = \"action233\",\r\n  PersonalMedicalAct = \"action234\",\r\n  FRIENDLYPOWERChg = \"action235\",\r\n  PersonalMinesAct = \"action236\",\r\n  minesMenuChg = \"action237\",\r\n  PersonalOtherAct = \"action238\",\r\n  DefaultAction = \"action239\",\r\n  CancleCombat = \"action240\",\r\n  Pause1 = \"action241\",\r\n  Flourish = \"action242\",\r\n  PrevMenu = \"action243\",\r\n  NextMenu = \"action244\",\r\n  ClearOneAction = \"action245\",\r\n  ActionMenuLeft = \"action246\",\r\n  ActionMenuRight = \"action247\",\r\n  ActionMenuUp = \"action248\",\r\n  ActionMenuDown = \"action249\",\r\n  ActionMenuQueue = \"action250\",\r\n  ActionMenuRemoveQ = \"action251\",\r\n  ActionMenuShowMenu = \"action252\",\r\n  PauseMinigame = \"action253\",\r\n  Dialog1 = \"action254\",\r\n  Dialog2 = \"action255\",\r\n  Dialog3 = \"action256\",\r\n  Dialog4 = \"action257\",\r\n  Dialog5 = \"action258\",\r\n  Dialog6 = \"action259\",\r\n  Dialog7 = \"action260\",\r\n  Dialog8 = \"action261\",\r\n  Dialog9 = \"action262\",\r\n  QUICKLOAD = \"action263\",\r\n  STEALTH = \"action264\",\r\n  SwitchWeaps = \"action265\",  //TSL\r\n  WALKMODIFY = \"action268\",   //TSL\r\n  ActionUp = \"action280a\",\r\n  ActionDown = \"action280b\",\r\n  ActionLeft = \"action281a\",\r\n  ActionRight = \"action281b\",\r\n  MGActionUp = \"action282a\",\r\n  MGActionDown = \"action282b\",\r\n  MGActionLeft = \"action283a\",\r\n  MGActionRight = \"action283b\",\r\n  CameraRotateLeft = \"action284a\",\r\n  CameraRotateRight = \"action284b\",\r\n  ArrowUp = \"action285a\",\r\n  ArrowDown = \"action285b\",\r\n  ArrowLeft = \"action286a\",\r\n  ArrowRight = \"action286b\",\r\n\r\n  DialogSkip = \"action900\",\r\n  DialogAbort = \"action901\",\r\n\r\n  FlyUp = \"action1001\",\r\n  FlyDown = \"action1002\",\r\n  ResolutionScaleUp = \"action1003\",\r\n  ResolutionScaleDown = \"action1004\",\r\n  ResolutionScaleReset = \"action1004\",\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\effects\\GameEffectSubType.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 24.","line":16,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":16,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GameEffectSubType enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GameEffectSubType.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum GameEffectSubType {\r\n  MAGICAL =       8,\r\n  SUPERNATURAL =  16,\r\n  EXTRAORDINARY = 24,\r\n\r\n  MASK = 0x18\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\gui\\GUIControlTypeMask.ts","messages":[{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":12,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":12,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":13,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":13,"endColumn":12},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":14,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":14,"endColumn":14},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":15,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":15,"endColumn":11},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":16,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":16,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":17,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":17,"endColumn":11},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":18,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":18,"endColumn":17},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":19,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":19,"endColumn":15},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":20,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":20,"endColumn":15},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":21,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":21,"endColumn":12}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GUIControlTypeMask enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIControlTypeMask.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum GUIControlTypeMask {\r\n  GUIControl      = (1 << 0),\r\n  GUIButton       = (1 << 1),\r\n  GUICheckBox     = (1 << 2),\r\n  GUILabel        = (1 << 3),\r\n  GUIListBox      = (1 << 4),\r\n  GUIPanel        = (1 << 5),\r\n  GUIProgressBar  = (1 << 6),\r\n  GUIProtoItem    = (1 << 7),\r\n  GUIScrollBar    = (1 << 8),\r\n  GUISlider       = (1 << 9),\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\minigames\\PazaakCards.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 18.","line":31,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":31,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Pazaak Cards enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file PazaakCards.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport enum PazaakCards {\r\n  INVALID = -1,\r\n  PLUS_1 = 0,\r\n  PLUS_2 = 1,\r\n  PLUS_3 = 2,\r\n  PLUS_4 = 3,\r\n  PLUS_5 = 4,\r\n  PLUS_6 = 5,\r\n  MINUS_1 = 6,\r\n  MINUS_2 = 7,\r\n  MINUS_3 = 8,\r\n  MINUS_4 = 9,\r\n  MINUS_5 = 10,\r\n  MINUS_6 = 11,\r\n  PLUS_MINUS_1 = 12,\r\n  PLUS_MINUS_2 = 13,\r\n  PLUS_MINUS_3 = 14,\r\n  PLUS_MINUS_4 = 15,\r\n  PLUS_MINUS_5 = 16,\r\n  PLUS_MINUS_6 = 17,\r\n  UNUSED_CARD = 18, //appears to be unused\r\n  MAX_CARDS = 18,\r\n  MAIN_CARD_1 = 101,\r\n  MAIN_CARD_2 = 102,\r\n  MAIN_CARD_3 = 103,\r\n  MAIN_CARD_4 = 104,\r\n  MAIN_CARD_5 = 105,\r\n  MAIN_CARD_6 = 106,\r\n  MAIN_CARD_7 = 107,\r\n  MAIN_CARD_8 = 108,\r\n  MAIN_CARD_9 = 109,\r\n  MAIN_CARD_10 = 110\r\n}\r\n  \r\n  \r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\module\\ModuleCreatureAnimState.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 10000.","line":15,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":15,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ModuleCreatureAnimState enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ModuleCreatureAnimState.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ModuleCreatureAnimState {\r\n  IDLE = 10000,\r\n  ANIMATING = 4,\r\n  //CREATURE\r\n  PAUSE = 10000,\r\n\r\n\r\n  //READY - depends on equipped weapons\r\n  //1=92,2=133,3=174,4=215,5=223,6=237,7=245,8=249,9=245\r\n  READY = 10001,\r\n\r\n\r\n  //WALK - depends on equipped weapons\r\n  //2=338,3=341,4=339,5=0,6=0,7=340,8=0,9=340 simple 253\r\n  WALKING = 10002,\r\n\r\n\r\n  //WALKING_BACK - depends on equipped weapons\r\n  //2=338,3=341,4=339,5=0,6=0,7=340,8=0,9=340 simple 253\r\n  WALKING_BACK = 10003,\r\n  RUNNING = 10004,\r\n  DEAD = 10006,\r\n  DEAD1 = 10008,\r\n  ATTACK = 10009,\r\n  DODGE = 10011,\r\n  PARRY = 10012,\r\n  DAMAGE = 10014,\r\n  CASTOUT1 = 10015,\r\n  CASTOUT2 = 10016,\r\n  CASTOUT1_LP = 10017,\r\n  CASTOUT2_LP = 10018,\r\n  SPASM = 10023,\r\n  TAUNT = 10028,\r\n  GREETING = 10029,\r\n  LISTEN = 10030,\r\n  MEDITATE = 10032,\r\n  WORSHIP = 10033,\r\n  SALUTE = 10034,\r\n  BOW = 10035,\r\n  TALK_NORMAL = 10038,\r\n  TALK_PLEADING = 10039,\r\n  TALK_FORCEFUL = 10040,\r\n  TALK_LAUGHING = 10041,\r\n  TALK_SAD = 10042,\r\n  VICTORY = 10044,\r\n  PAUSE2 = 10052,\r\n  HEAD_TURN_LEFT = 10053,\r\n  HEAD_TURN_RIGHT = 10054,\r\n  PAUSE_SCRATCH_HEAD = 10055,\r\n  PAUSE_BORED = 10056,\r\n  PAUSE_TIRED = 10057,\r\n  PAUSE_DRUNK = 10058,\r\n  GET_LOW = 10059,\r\n  GET_MID = 10060,\r\n  THROW_SABER_LP = 10061,\r\n  INJECT = 10070,\r\n  DAMAGE2 = 10077,\r\n  PAUSE_INJ = 10092,\r\n  WALK_INJ = 10093,\r\n  RUN_INJ = 10094,\r\n  ATTACK_DUELING = 10109,\r\n  USE_COMPUTER_LP = 10112,\r\n  WHIRLWIND = 10117,\r\n  DEACTIVATE = 10118,\r\n  FLIRT = 10120,\r\n  USE_COMPUTER = 10121,\r\n  DANCE = 10122,\r\n  DANCE1 = 10123,\r\n  HORROR = 10124,\r\n  USE_COMPUTER2 = 10125,\r\n  PERSUADE = 10126,\r\n  ACTIVATE_ITEM = 10127,\r\n  UNLOCK_DOOR = 10128,\r\n  THROW_HIGH = 10129,\r\n  THROW_LOW = 10130,\r\n  UNLOCK_CONTAINER = 10131,\r\n  DISABLE_MINE = 10132,\r\n  WALK_STEALTH = 10133,\r\n  UNLOCK_DOOR2 = 10134,\r\n  UNLOCK_CONTAINER2 = 10135,\r\n  ACTIVATE_ITEM2 = 10136,\r\n  SLEEP = 10137,\r\n  PARALYZED = 10138,\r\n  PRONE = 10139,\r\n  SET_MINE = 10140,\r\n  DISABLE_MINE2 = 10141,\r\n  CUSTOM01 = 10142,\r\n  FBLOCK = 10145,\r\n  PAUSE4 = 10147,\r\n\r\n\r\n  //READY_ALT - depends on equipped weapons\r\n  //1=92,2=133,3=174,4=215,5=223,6=237,7=245,8=249,9=245\r\n  READY_ALT = 10148,\r\n  PAUSE_ALT = 10149,\r\n  CHOKE = 10150,\r\n  PAUSE3 = 10151,\r\n  WELD = 10152,\r\n  TALK_INJURED = 10154,\r\n  LISTEN_INJURED = 10155,\r\n  DEAD_PRONE = 10156,\r\n\r\n\r\n  //MELEE_WIELD - depends on equipped weapons\r\n  //1=378,2=377,3=378,4=376,5=378,6=378,7=378,8=378,9=378\r\n  MELEE_WIELD = 10157,\r\n\r\n\r\n  //MELEE_COMBAT_WIELD - depends on equipped weapons\r\n  //2=132,3=214,4=173\r\n  MELEE_COMBAT_WIELD = 10158,\r\n  TREAT_INJURED = 10159,\r\n  TREAT_INJURED_LP = 10160,\r\n  CATCH_SABER = 10161,\r\n  THROW_SABER = 10162,\r\n  KID_TALK_ANGRY = 10163,\r\n  KID_TALK_SAD = 10164,\r\n  KNOCKED_DOWN = 10219,\r\n  KNOCKED_DOWN2 = 10220,\r\n  DIE = 10221,\r\n  DIE1 = 10222,\r\n  GET_UP_DEAD = 10223,\r\n  GET_UP_DEAD1 = 10224,\r\n  KNEEL = 10237,\r\n  KNEEL1 = 10238,\r\n\r\n\r\n  //FLOURISH - depends on equipped weapons\r\n  //1=91,2=132,3=173,4=214,5=222,6=136,7=244,8=373,9=244\r\n  FLOURISH = 10246,\r\n  KNEELING = 10271,\r\n\r\n\r\n  //DAMAGED - depends on equipped weapons\r\n  //1=unknown,2=124,3=206,4=165,5=220,6=234,7=242,8=280,9=242\r\n  DAMAGED = 10302,\r\n\r\n\r\n  //BLASTER_DEFLECTION_1H - depends on equipped weapons\r\n  //2=109,3=151,4=192\r\n  BLASTER_DEFLECTION_1H = 10300,\r\n\r\n\r\n  //BLASTER_DEFLECTION_2H - depends on equipped weapons\r\n  //2=110,3=151,4=192\r\n  BLASTER_DEFLECTION_2H = 10301,\r\n  KNOCKED_DOWN_LP = 10400,\r\n  POWER_ATTACK_SS = 10401,\r\n  KNOCKED_DOWN2_LP = 10402,\r\n\r\n\r\n\r\n  //BEGIN TSL ANIMATIONS\r\n  TOUCH_HEART = 10403,\r\n  ROLL_EYES = 10404,\r\n  USE_ITEM_ON_OTHER = 10405,\r\n  STAND_ATTENTION = 10406,\r\n  NOD_YES = 10407,\r\n  NOD_NO = 10408,\r\n  POINT = 10409,\r\n  POINT_LP = 10410,\r\n  POINT_DOWN = 10411,\r\n  SCANNING = 10412,\r\n  SHRUG = 10413,\r\n  SIT_CHAIR = 10424,\r\n  SIT_CHAIR_DRUNK = 10425,\r\n  SIT_CHAIR_PAZAAK = 10426,\r\n  SIT_CHAIR_COMP1 = 10427,\r\n  SIT_CHAIR_COMP2 = 10428,\r\n  CUT_HANDS = 10499,\r\n  L_HAND_CHOP = 10500,\r\n  COLLAPSE = 10501,\r\n  COLLAPSE_STAND = 10503,\r\n  BAO_DUR_POWER_PUNCH = 10504,\r\n  HOOD_OFF = 10507,\r\n  HOOD_ON = 10508,\r\n\r\n  //END TSL ANIMATIONS\r\n  CASTOUT3 = 11000,\r\n  CRITICAL_STRIKE2_SS = 11001,\r\n  CRITICAL_STRIKE3_SS = 11002,\r\n  \r\n  KNEEL_TALK_ANGRY,\r\n  KNEEL_TALK_SAD,\r\n  COLLAPSE_LP,\r\n  POINT_UP,\r\n  POINT_UP_LOWER,\r\n  DIVE_ROLL\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\module\\ModuleDoorOpenState.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 0.","line":13,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":13,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ModuleDoorOpenState enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ModuleDoorOpenState.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ModuleDoorOpenState {\r\n  DEFAULT   = 0,\r\n  CLOSED    = 0,\r\n  OPEN1     = 1,\r\n  OPEN2     = 2,\r\n  DESTROYED = 3,\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\module\\ModuleObjectScript.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":57,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":57,"endColumn":39},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnUserDefined.","line":66,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":66,"endColumn":43},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnClosed.","line":70,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":70,"endColumn":28},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDamaged.","line":71,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":71,"endColumn":30},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDeath.","line":72,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":72,"endColumn":26},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDisarm.","line":73,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":73,"endColumn":28},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":75,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":75,"endColumn":34},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnInvDisturbed.","line":76,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":76,"endColumn":40},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnLock.","line":77,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":77,"endColumn":24},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnMeleeAttacked.","line":78,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":78,"endColumn":42},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnOpen.","line":79,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":79,"endColumn":24},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnSpellCastAt.","line":80,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":80,"endColumn":38},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnTrapTriggered.","line":81,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":81,"endColumn":42},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnUnlock.","line":82,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":82,"endColumn":28},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnUserDefined.","line":83,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":83,"endColumn":38},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnClick.","line":86,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":86,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDisarm.","line":87,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":87,"endColumn":31},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnTrapTriggered.","line":88,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":88,"endColumn":45},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value ScriptHeartbeat.","line":89,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":89,"endColumn":41},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value ScriptUserDefine.","line":92,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":92,"endColumn":44},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnExit.","line":97,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":97,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":98,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":98,"endColumn":39},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnUserDefined.","line":99,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":99,"endColumn":43},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDeath.","line":107,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":107,"endColumn":30},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":109,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":109,"endColumn":38},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnAccelerate.","line":117,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":117,"endColumn":39},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnAnimEvent.","line":118,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":118,"endColumn":37},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnBrake.","line":119,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":119,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnCreate.","line":120,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":120,"endColumn":31},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDamage.","line":121,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":121,"endColumn":31},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnDeath.","line":122,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":122,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnFire.","line":123,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":123,"endColumn":27},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":124,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":124,"endColumn":37},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitBullet.","line":125,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":125,"endColumn":37},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitFollower.","line":126,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":126,"endColumn":41},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitObstacle.","line":127,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":127,"endColumn":41},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitWorld.","line":128,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":128,"endColumn":35},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnTrackLoop.","line":129,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":129,"endColumn":37},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnAnimEvent.","line":132,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":132,"endColumn":40},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnCreate.","line":133,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":133,"endColumn":34},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHeartbeat.","line":134,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":134,"endColumn":40},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitBullet.","line":135,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":135,"endColumn":40},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value OnHitFollower.","line":136,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":136,"endColumn":44}],"suppressedMessages":[],"errorCount":43,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ModuleObjectScript enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ModuleObjectScript.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ModuleObjectScript {\r\n  //Module\r\n  ModuleOnPlayerAcquireItem = 'Mod_OnAcquirItem',\r\n  ModuleOnPlayerActivateItem = 'Mod_OnActvtItem',\r\n  ModuleOnPlayerClientEnter = 'Mod_OnClientEntr',\r\n  ModuleOnPlayerClientLeave = 'Mod_OnClientLeav',\r\n  ModuleOnHeartbeat = 'Mod_OnHeartbeat',\r\n  ModuleOnLoad = 'Mod_OnModLoad',\r\n  ModuleOnStart = 'Mod_OnModStart',\r\n  ModuleOnPlayerDeath = 'Mod_OnPlrDeath',\r\n  ModuleOnPlayerDying = 'Mod_OnPlrDying',\r\n  ModuleOnPlayerLevelUp = 'Mod_OnPlrLvlUp',\r\n  ModuleOnPlayerRest = 'Mod_OnPlrRest',\r\n  ModuleOnSpawnButtonDown = 'Mod_OnSpawnBtnDn',\r\n  ModuleOnUnAcquireItem = 'Mod_OnUnAqreItem',\r\n  ModuleOnUserDefined = 'Mod_OnUsrDefined',\r\n\r\n\r\n  //Area\r\n  AreaOnEnter = 'OnEnter',\r\n  AreaOnExit = 'OnExit',\r\n  AreaOnHeartbeat = 'OnHeartbeat',\r\n  AreaOnUserDefined = 'OnUserDefined',\r\n\r\n  //Creature\r\n  CreatureOnAttacked = 'ScriptAttacked',\r\n  CreatureOnDamaged = 'ScriptDamaged',\r\n  CreatureOnDeath = 'ScriptDeath',\r\n  CreatureOnDialog = 'ScriptDialogue',\r\n  CreatureOnDisturbed = 'ScriptDisturbed',\r\n  CreatureOnEndDialog = 'ScriptEndDialogu',\r\n  CreatureOnEndRound = 'ScriptEndRound',\r\n  CreatureOnHeartbeat = 'ScriptHeartbeat',\r\n  CreatureOnBlocked = 'ScriptOnBlocked',\r\n  CreatureOnNotice = 'ScriptOnNotice',\r\n  CreatureOnRested = 'ScriptRested',\r\n  CreatureOnSpawn = 'ScriptSpawn',\r\n  CreatureOnSpellAt = 'ScriptSpellAt',\r\n  CreatureOnUserDefined = 'ScriptUserDefine',\r\n\r\n  //Placeable\r\n  PlaceableOnClosed = 'OnClosed',\r\n  PlaceableOnDamaged = 'OnDamaged',\r\n  PlaceableOnDeath = 'OnDeath',\r\n  PlaceableOnDisarm = 'OnDisarm',\r\n  PlaceableOnEndDialogue = 'OnEndDialogue',\r\n  PlaceableOnHeartbeat = 'OnHeartbeat',\r\n  PlaceableOnInvDisturbed = 'OnInvDisturbed',\r\n  PlaceableOnLock = 'OnLock',\r\n  PlaceableOnMeleeAttacked = 'OnMeleeAttacked',\r\n  PlaceableOnOpen = 'OnOpen',\r\n  PlaceableOnSpellCastAt = 'OnSpellCastAt',\r\n  PlaceableOnTrapTriggered = 'OnTrapTriggered',\r\n  PlaceableOnUnlock = 'OnUnlock',\r\n  PlaceableOnUsed = 'OnUsed',\r\n  PlaceableOnUserDefined = 'OnUserDefined',\r\n\r\n  //Door\r\n  DoorOnClick = 'OnClick',\r\n  DoorOnClosed = 'OnClosed',\r\n  DoorOnDamaged = 'OnDamaged',\r\n  DoorOnDeath = 'OnDeath',\r\n  DoorOnDisarm = 'OnDisarm',\r\n  DoorOnFailToOpen = 'OnFailToOpen',\r\n  DoorOnHeartbeat = 'OnHeartbeat',\r\n  DoorOnInvDisturbed = 'OnInvDisturbed',\r\n  DoorOnLock = 'OnLock',\r\n  DoorOnMeleeAttacked = 'OnMeleeAttacked',\r\n  DoorOnOpen = 'OnOpen',\r\n  DoorOnSpellCastAt = 'OnSpellCastAt',\r\n  DoorOnTrapTriggered = 'OnTrapTriggered',\r\n  DoorOnUnlock = 'OnUnlock',\r\n  DoorOnUserDefined = 'OnUserDefined',\r\n\r\n  //Trigger\r\n  TriggerOnClick = 'OnClick',\r\n  TriggerOnDisarm = 'OnDisarm',\r\n  TriggerOnTrapTriggered = 'OnTrapTriggered',\r\n  TriggerOnHeartbeat = 'ScriptHeartbeat',\r\n  TriggerOnEnter = 'ScriptOnEnter',\r\n  TriggerOnExit = 'ScriptOnExit',\r\n  TriggerOnUserDefined = 'ScriptUserDefine',\r\n  \r\n  //Encounter\r\n  EncounterOnEntered = 'OnEntered',\r\n  EncounterOnExhausted = 'OnExhausted',\r\n  EncounterOnExit = 'OnExit',\r\n  EncounterOnHeartbeat = 'OnHeartbeat',\r\n  EncounterOnUserDefined = 'OnUserDefined',\r\n  \r\n  //MGPlayer\r\n  MGPlayerOnAccelerate = 'OnAccelerate',\r\n  MGPlayerOnAnimEvent = 'OnAnimEvent',\r\n  MGPlayerOnBrake = 'OnBrake',\r\n  MGPlayerOnCreate = 'OnCreate',\r\n  MGPlayerOnDamage = 'OnDamage',\r\n  MGPlayerOnDeath = 'OnDeath',\r\n  MGPlayerOnFire = 'OnFire',\r\n  MGPlayerOnHeartbeat = 'OnHeartbeat',\r\n  MGPlayerOnHitBullet = 'OnHitBullet',\r\n  MGPlayerOnHitFollower = 'OnHitFollower',\r\n  MGPlayerOnHitObstacle = 'OnHitObstacle',\r\n  MGPlayerOnHitWorld = 'OnHitWorld',\r\n  MGPlayerOnTrackLoop = 'OnTrackLoop',\r\n  \r\n  //MGEnemy\r\n  MGEnemyOnAccelerate = 'OnAccelerate',\r\n  MGEnemyOnAnimEvent = 'OnAnimEvent',\r\n  MGEnemyOnBrake = 'OnBrake',\r\n  MGEnemyOnCreate = 'OnCreate',\r\n  MGEnemyOnDamage = 'OnDamage',\r\n  MGEnemyOnDeath = 'OnDeath',\r\n  MGEnemyOnFire = 'OnFire',\r\n  MGEnemyOnHeartbeat = 'OnHeartbeat',\r\n  MGEnemyOnHitBullet = 'OnHitBullet',\r\n  MGEnemyOnHitFollower = 'OnHitFollower',\r\n  MGEnemyOnHitObstacle = 'OnHitObstacle',\r\n  MGEnemyOnHitWorld = 'OnHitWorld',\r\n  MGEnemyOnTrackLoop = 'OnTrackLoop',\r\n\r\n  //MGObstacle\r\n  MGObstacleOnAnimEvent = 'OnAnimEvent',\r\n  MGObstacleOnCreate = 'OnCreate',\r\n  MGObstacleOnHeartbeat = 'OnHeartbeat',\r\n  MGObstacleOnHitBullet = 'OnHitBullet',\r\n  MGObstacleOnHitFollower = 'OnHitFollower',\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\module\\ModuleObjectType.ts","messages":[{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":12,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":12,"endColumn":15},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":13,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":13,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":14,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":14,"endColumn":21},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":15,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":15,"endColumn":17},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":16,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":16,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":17,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":17,"endColumn":18},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":18,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":18,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":19,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":19,"endColumn":16},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":20,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":20,"endColumn":18},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":21,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":21,"endColumn":20},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":22,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":22,"endColumn":19},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":23,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":23,"endColumn":17},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":24,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":24,"endColumn":16},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":25,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":25,"endColumn":18},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":26,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":26,"endColumn":15},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":27,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":27,"endColumn":14},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":28,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":28,"endColumn":14},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":29,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":29,"endColumn":16},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":30,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":30,"endColumn":17},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":31,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":31,"endColumn":13},{"ruleId":"@typescript-eslint/prefer-literal-enum-member","severity":2,"message":"Explicit enum value must only be a literal value (string or number).","line":32,"column":3,"nodeType":"Identifier","messageId":"notLiteral","endLine":32,"endColumn":15}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ModuleObjectType enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file ModuleObjectType.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum ModuleObjectType {\r\n  ModuleObject        = (1 << 0),\r\n  ModuleArea          = (1 << 1),\r\n  ModuleAreaOfEffect  = (1 << 2),\r\n  ModuleCreature      = (1 << 3),\r\n  ModuleDoor          = (1 << 4),\r\n  ModuleEncounter     = (1 << 5),\r\n  ModuleItem          = (1 << 6),\r\n  ModuleMGEnemy       = (1 << 7),\r\n  ModuleMGGunBank     = (1 << 8),\r\n  ModuleMGGunBullet   = (1 << 9),\r\n  ModuleMGObstacle    = (1 << 10),\r\n  ModuleMGPlayer      = (1 << 11),\r\n  ModuleMGTrack       = (1 << 12),\r\n  ModulePlaceable     = (1 << 13),\r\n  ModulePlayer        = (1 << 14),\r\n  ModuleSound         = (1 << 15),\r\n  ModuleStore         = (1 << 16),\r\n  ModuleTrigger       = (1 << 17),\r\n  ModuleWaypoint      = (1 << 18),\r\n  ModuleRoom          = (1 << 19),\r\n  ModuleCamera        = (1 << 20),\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\odyssey\\OdysseyModelControllerType.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 100.","line":25,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":25,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 88.","line":31,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":31,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 96.","line":33,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":33,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 100.","line":34,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":34,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 132.","line":43,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":43,"endColumn":29},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 140.","line":45,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":45,"endColumn":36}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * OdysseyModelControllerType enum.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyModelControllerType.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @enum\r\n */\r\nexport enum OdysseyModelControllerType {\r\n  //Node\r\n  Position             =   8,\r\n  Orientation          =  20,\r\n  Scale                =  36,\r\n\r\n  //Mesh\r\n  SelfIllumColor       = 100,\r\n  Alpha                = 132,\r\n\r\n  //Light\r\n  Color                =  76,\r\n  Radius               =  88,\r\n  ShadowRadius         =  96,\r\n  VerticalDisplacement = 100,\r\n  Multiplier           = 140,\r\n\r\n  //Emitter\r\n  AlphaEnd             =  80,\r\n  AlphaStart           =  84,\r\n  BirthRate            =  88,\r\n  Bounce_Co            =  92,\r\n  CombineTime          =  96,\r\n  Drag                 = 100,\r\n  FPS                  = 104,\r\n  FrameEnd             = 108,\r\n  FrameStart           = 112,\r\n  Gravity                 = 116,\r\n  LifeExp              = 120,\r\n  Mass                 = 124,\r\n  Threshold            = 164,\r\n  P2P_Bezier2          = 128,\r\n  P2P_Bezier3          = 132,\r\n  ParticleRot          = 136,\r\n  RandomVelocity              = 140,\r\n  SizeStart            = 144,\r\n  SizeEnd              = 148,\r\n  SizeStart_Y          = 152,\r\n  SizeEnd_Y            = 156,\r\n  Spread               = 160,\r\n  Velocity             = 168,\r\n  XSize                = 172,\r\n  YSize                = 176,\r\n  BlurLength           = 180,\r\n  LightningDelay       = 184,\r\n  LightningRadius      = 188,\r\n  LightningSubDiv      = 196,\r\n  LightningScale       = 192,\r\n  LightningZigZag      = 200,\r\n  AlphaMid             = 216,\r\n  PercentStart         = 220,\r\n  PercentMid           = 224,\r\n  PercentEnd           = 228,\r\n  SizeMid              = 232,\r\n  SizeMid_Y            = 236,\r\n  TargetSize           = 252,\r\n  ControlPTCount       = 256,\r\n  ControlPTRadius      = 260,\r\n  ControlPTDelay       = 264,\r\n  TangentSpread        = 268,\r\n  TangentLength        = 272,\r\n  RandomBirthRate      = 240,\r\n  ColorEnd             = 380,\r\n  ColorMid             = 284,\r\n  ColorStart           = 392,\r\n  Detonate             = 502,\r\n  INVALID              =   0,\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\enums\\server\\ipc\\IPCMessageType.ts","messages":[{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 1.","line":11,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":11,"endColumn":22},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 2.","line":12,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":12,"endColumn":23},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 3.","line":13,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":13,"endColumn":22},{"ruleId":"@typescript-eslint/no-duplicate-enum-values","severity":2,"message":"Duplicate enum member value 4.","line":14,"column":3,"nodeType":"TSEnumMember","messageId":"duplicateValue","endLine":14,"endColumn":23}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export enum IPCMessageType {\r\n  LogMessage = 0x00,\r\n\r\n  Module = 0x01,\r\n  Area = 0x02,\r\n  Object = 0x03,\r\n  Script = 0x04,\r\n  Debug = 0x0FF,\r\n\r\n\r\n  CreateObject = 0x01,\r\n  DestroyObject = 0x02,\r\n  CreateScript = 0x03,\r\n  DestroyScript = 0x04,\r\n  LoadModule = 0x05,\r\n  UnloadModule = 0x06,\r\n  SetScriptBreakpoint = 0x07,\r\n  RemoveScriptBreakpoint = 0x08,\r\n  UpdateScriptState = 0x09,\r\n  ContinueScript = 0x0A,\r\n  StepOverInstruction = 0x0B\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\gui\\GUIFeatItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":93,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":93,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":94,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":94,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":95,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":95,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":96,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":96,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":97,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":97,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":110,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":110,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":112,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":113,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":114,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on an `any` value.","line":115,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":116,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":116,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":119,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":119,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":120,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .opacity on an `any` value.","line":123,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":125,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":125,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":126,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":126,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":129,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":129,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":166,"column":46,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":166,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":167,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":167,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":168,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":168,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":169,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":169,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":170,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":170,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":172,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":172,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":173,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":173,"endColumn":57}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { GameState } from \"@/GameState\";\nimport { GUIProtoItem, GUIButton } from \"@/gui\";\nimport type { GUIControl, GameMenu } from \"@/gui\";\nimport { TextureLoader } from \"@/loaders\";\nimport type { ModuleCreature } from \"@/module/ModuleCreature\";\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n/**\n * GUIFeatItem class.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file GUIFeatItem.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nconst log = createScopedLogger(LogScope.Game);\n\n/** Feat row shape for list iteration. */\ninterface FeatRowLike { __index: string; prereqfeat1?: string; prereqfeat2?: string; constant?: string; icon?: string }\n\nexport class GUIFeatItem extends GUIProtoItem {\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl | null = null, scale = false){\n    super(menu, control, parent, scale);\n    this.disableSelection = true;\n    this.extent.height = 48;\n  }\n\n  buildFill(){}\n  buildBorder(){}\n  buildHighlight(){}\n  buildText(){}\n\n  createControl(){\n    try{\n      super.createControl();\n      //Create the actual control elements below\n\n      const node = this.node;\n      const featList: FeatRowLike[] = Array.isArray(node) ? node as FeatRowLike[] : (node && typeof node === 'object' && 'length' in node ? Array.from(node as ArrayLike<FeatRowLike>) : []);\n      const spacing = 5;\n      const player = GameState.getCurrentPlayer();\n      const creature = player && BitWise.InstanceOfObject(player, ModuleObjectType.ModuleCreature) ? (player as ModuleCreature) : null;\n      for(let i = 0; i < featList.length; i++){\n        const feat = featList[i];\n\n        const hasPrereqfeat1 = (feat.prereqfeat1 == '****' || (creature?.getHasFeat(feat.prereqfeat1 ?? '') ?? false));\n        const hasPrereqfeat2 = (feat.prereqfeat2 == '****' || (creature?.getHasFeat(feat.prereqfeat2 ?? '') ?? false));\n        const hasFeat = creature?.getHasFeat(feat.__index) ?? false;\n\n        log.info('GUIFeatItem', feat.constant, hasPrereqfeat1, hasPrereqfeat2);\n\n        const locked = !hasFeat || (!hasPrereqfeat1 || !hasPrereqfeat2);\n\n        const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\n        buttonIcon.setText('');\n        buttonIcon.disableTextAlignment();\n        buttonIcon.extent.width = 56;\n        buttonIcon.extent.height = 56;\n        buttonIcon.extent.top = 0;\n        buttonIcon.extent.left = 0;\n        buttonIcon.hasBorder = false;\n        buttonIcon.hasHighlight = false;\n        buttonIcon.hasText = false;\n        buttonIcon.autoCalculatePosition = false;\n        this.children.push(buttonIcon);\n\n        const _buttonIconWidget = buttonIcon.createControl();\n        switch(i){\n          case 2:\n            _buttonIconWidget.position.x = (this.extent.width/2 - buttonIcon.extent.width/2);\n          break;\n          case 1:\n            _buttonIconWidget.position.x = 0;\n          break;\n          default:\n            _buttonIconWidget.position.x = -(this.extent.width/2 - buttonIcon.extent.width/2);\n          break;\n        }\n        _buttonIconWidget.position.y = 0;\n        _buttonIconWidget.position.z = this.zIndex + 1;\n\n        this.widget.add(_buttonIconWidget);\n\n        TextureLoader.enQueue('lbl_indent', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n          buttonIcon.setMaterialTexture( buttonIcon.border.fill.material, texture);\n          buttonIcon.border.fill.material.transparent = true;\n          buttonIcon.setMaterialTexture( buttonIcon.highlight.fill.material, texture);\n          buttonIcon.highlight.fill.material.transparent = true;\n          if(locked){\n            (buttonIcon.getFill().material as THREE.ShaderMaterial).uniforms.opacity.value = 0.00;\n          }\n        });\n\n        buttonIcon.addEventListener('click', (e) => {\n          e.stopPropagation();\n        });\n\n        /* FEAT ICON */\n\n        this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\n        this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\n\n        this.widget.userData.iconSprite.scale.x = 32;\n        this.widget.userData.iconSprite.scale.y = 32;\n        this.widget.userData.iconSprite.position.z = 5;\n        this.widget.userData.iconSprite.renderOrder = 5;\n        TextureLoader.enQueue(feat.icon, this.widget.userData.iconMaterial, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n          const img = (texture as { image?: { width: number; height: number } }).image;\n          if (img) {\n            this.widget.userData.iconSprite.scale.x = img.width;\n            this.widget.userData.iconSprite.scale.y = img.height;\n          }\n          if(locked){\n            this.widget.userData.iconMaterial.opacity = 0.00;\n          }\n          this.widget.userData.iconMaterial.transparent = true;\n          this.widget.userData.iconMaterial.needsUpdate = true;\n        });\n\n        _buttonIconWidget.add(this.widget.userData.iconSprite);\n\n        /*\n        * BLUE ARROW\n        */\n        \n        const arrowOffset = (this.extent.width/2 - buttonIcon.extent.width/2)/2;\n        if(i > 0){\n          const arrowIcon = new GUIButton(this.menu, this.control, this, this.scale);\n          arrowIcon.setText('');\n          arrowIcon.disableTextAlignment();\n          arrowIcon.extent.width = 32;\n          arrowIcon.extent.height = 32;\n          arrowIcon.extent.top = 0;\n          arrowIcon.extent.left = 0;\n          arrowIcon.hasBorder = false;\n          arrowIcon.hasHighlight = false;\n          arrowIcon.disableBorder();\n          arrowIcon.disableHighlight();\n          arrowIcon.hasText = false;\n          arrowIcon.autoCalculatePosition = false;\n          this.children.push(arrowIcon);\n\n          const _arrowIconWidget = arrowIcon.createControl();\n          switch(i){\n            case 2:\n              _arrowIconWidget.position.x = arrowOffset;\n            break;\n            case 1:\n              _arrowIconWidget.position.x = -arrowOffset;\n            break;\n          }\n          _arrowIconWidget.position.y = 0;\n          _arrowIconWidget.position.z = this.zIndex + 1;\n\n          this.widget.add(_arrowIconWidget);\n\n          TextureLoader.enQueue('lbl_skarr', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n            arrowIcon.setMaterialTexture( arrowIcon.border.fill.material, texture);\n            arrowIcon.border.fill.material.transparent = true;\n            arrowIcon.setMaterialTexture( arrowIcon.highlight.fill.material, texture);\n            arrowIcon.highlight.fill.material.transparent = true;\n            if(locked){\n              arrowIcon.border.fill.material.uniforms.opacity.value = 0.25;\n              arrowIcon.highlight.fill.material.uniforms.opacity.value = 0.25;\n            }\n          });\n\n          //lbl_skarr\n        }\n\n      }\n      return this.widget;\n    }catch(e){\n      log.error(e);\n    }\n    return this.widget;\n\n  }\n\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\gui\\GUIInventoryItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":39,"column":20,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":39,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":39,"column":20,"nodeType":"MemberExpression","messageId":"errorCall","endLine":39,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":51,"column":24,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":51,"endColumn":95},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":51,"column":24,"nodeType":"MemberExpression","messageId":"errorCall","endLine":51,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":51,"column":55,"nodeType":"MemberExpression","messageId":"errorCall","endLine":51,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":51,"column":55,"nodeType":"MemberExpression","messageId":"errorCall","endLine":51,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on a type that cannot be resolved.","line":51,"column":80,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":51,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":70,"column":8,"nodeType":"MemberExpression","messageId":"errorCall","endLine":70,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":71,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":71,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":71,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":72,"column":14,"nodeType":"MemberExpression","messageId":"errorCall","endLine":72,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":73,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":73,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":73,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":75,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":75,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":75,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":75,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":81,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":81,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":82,"column":57,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":82,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | string[]`.","line":84,"column":27,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":84,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":84,"column":27,"nodeType":"MemberExpression","messageId":"errorCall","endLine":84,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":84,"column":48,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":84,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":89,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":90,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":90,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":91,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":91,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":94,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":94,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":95,"column":56,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":95,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":96,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":96,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":97,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":100,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":100,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":100,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":102,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":102,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":102,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":104,"column":8,"nodeType":"MemberExpression","messageId":"errorCall","endLine":104,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":105,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":105,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":106,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":107,"column":14,"nodeType":"MemberExpression","messageId":"errorCall","endLine":107,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":108,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":109,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":109,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":111,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":112,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":153,"column":27,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":153,"endColumn":59}],"suppressedMessages":[],"errorCount":41,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { TextureType } from \"@/enums/loaders/TextureType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GUIButton, GUIListBox, GUIProtoItem } from \"@/gui\";\r\nimport type { GUIControl, GameMenu } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { GameEngineType } from \"@/enums/engine\";\r\n\r\n/**\r\n * GUIInventoryItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIInventoryItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIInventoryItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    super.createControl();\r\n    //Create the actual control elements below\r\n    const button = new GUIButton(this.menu, this.control, this, this.scale);\r\n    button.extent.width = 200;\r\n    button.setText(this.node.getName());\r\n    button.text.alignment = 9;\r\n    button.autoCalculatePosition = false;\r\n    this.children.push(button);\r\n\r\n    const _buttonWidget = button.createControl();\r\n    _buttonWidget.position.x = (this.extent.width - button.extent.width) / 2;\r\n    _buttonWidget.position.y = 0;\r\n    _buttonWidget.position.z = this.zIndex + 1;\r\n    this.widget.add(_buttonWidget);\r\n\r\n    const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n    buttonIcon.setText(this.node.getStackSize() > 1 ? this.node.getStackSize().toString() : '');\r\n    buttonIcon.text.mesh.scale.setScalar(.9);\r\n    buttonIcon.disableTextAlignment();\r\n    buttonIcon.extent.width = 42;\r\n    buttonIcon.extent.height = 42;\r\n    buttonIcon.extent.top = 0;\r\n    buttonIcon.extent.left = 0;\r\n    buttonIcon.hasBorder = false;\r\n    buttonIcon.hasHighlight = false;\r\n    buttonIcon.hasText = true;\r\n    buttonIcon.autoCalculatePosition = false;\r\n    this.children.push(buttonIcon);\r\n\r\n    const _buttonIconWidget = buttonIcon.createControl();\r\n    _buttonIconWidget.position.x = -(this.extent.width/2 - buttonIcon.extent.width/2);\r\n    _buttonIconWidget.position.y = 0;\r\n    _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n    //Stack Count Text Position\r\n    if(this.node.getStackSize() >= 100){\r\n      buttonIcon.widget.userData.text.position.set(6, -8, 5);\r\n    }else if(this.node.getStackSize() >= 10){\r\n      buttonIcon.widget.userData.text.position.set(10, -8, 5);\r\n    }else{\r\n      buttonIcon.widget.userData.text.position.set(14, -8, 5);\r\n    }\r\n\r\n    this.widget.add(_buttonIconWidget);\r\n\r\n    this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n    this.widget.userData.iconMaterial.transparent = true;\r\n    this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n    //log.info(this.node.getIcon());\r\n    TextureLoader.enQueue(this.node.getIcon(), this.widget.userData.iconMaterial, TextureType.TEXTURE);\r\n    \r\n    this.widget.userData.spriteGroup = new THREE.Group();\r\n    //this.widget.spriteGroup.position.x = -(this.extent.width/2)-(52/2); //HACK\r\n    //this.widget.spriteGroup.position.y -= 4;\r\n    this.widget.userData.iconSprite.scale.x = 52;\r\n    this.widget.userData.iconSprite.scale.y = 52;\r\n    this.widget.userData.iconSprite.position.z = 1;\r\n\r\n    this.widget.userData.hexMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n    this.widget.userData.hexMaterial.transparent = true;\r\n    this.widget.userData.hexSprite = new THREE.Sprite( this.widget.userData.hexMaterial );\r\n    this.widget.userData.hexSprite.scale.x = this.widget.userData.hexSprite.scale.y = 52;\r\n    this.widget.userData.hexSprite.position.z = 1;\r\n\r\n    if(GameState.GameKey != GameEngineType.TSL)\r\n      this.widget.userData.spriteGroup.add(this.widget.userData.hexSprite);\r\n      \r\n    this.widget.userData.spriteGroup.add(this.widget.userData.iconSprite);\r\n\r\n    if(this.node.getStackSize() >= 100){\r\n      this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex_4');\r\n      this.widget.userData.hexMaterial.needsUpdate = true;\r\n    }else if(this.node.getStackSize() > 1){\r\n      this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex_4');\r\n      this.widget.userData.hexMaterial.needsUpdate = true;\r\n    }else{\r\n      this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex');\r\n      this.widget.userData.hexMaterial.needsUpdate = true;\r\n    }\r\n\r\n    this.onSelect = () => {\r\n      if(this.selected){\r\n        /*this.showHighlight();\r\n        this.hideBorder();\r\n        this.pulsing = true;\r\n        this.text.color.setRGB(1, 1, 0);\r\n        this.text.material.color = this.text.color;\r\n        this.text.material.needsUpdate = true;\r\n        button.showHighlight();\r\n        button.hideBorder();\r\n        this.widget.hexMaterial.color.setRGB(1, 1, 0);\r\n        button.setHighlightColor(1, 1, 0);\r\n        button.pulsing = true;\r\n        buttonIcon.pulsing = true;\r\n        button.text.color.setRGB(1, 1, 0);\r\n        button.text.material.color = button.text.color;\r\n        button.text.material.needsUpdate = true;*/\r\n      }else{\r\n        /*this.hideHighlight();\r\n        this.showBorder();\r\n        this.pulsing = false;\r\n        this.text.color.setRGB(0, 0.658824, 0.980392);\r\n        this.text.material.color = this.text.color;\r\n        this.text.material.needsUpdate = true;\r\n        button.hideHighlight();\r\n        button.showBorder();\r\n        this.widget.hexMaterial.color.setRGB(0, 0.658823549747467, 0.9803921580314636);\r\n        button.setBorderColor(0, 0.658823549747467, 0.9803921580314636);\r\n        button.pulsing = false;\r\n        buttonIcon.pulsing = false;\r\n        button.text.color.setRGB(0, 0.658824, 0.980392);\r\n        button.text.material.color = button.text.color;\r\n        button.text.material.needsUpdate = true;*/\r\n      }\r\n    };\r\n    this.onSelect.call(this);\r\n\r\n    //StackCount Text\r\n    _buttonIconWidget.add(this.widget.userData.spriteGroup);\r\n    return this.widget;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\CharGenClass.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":209,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":209,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .blending on a type that cannot be resolved.","line":210,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":210,"endColumn":44}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { CharGenClasses } from \"@/game/CharGenClasses\";\nimport { GameMenu } from \"@/gui\";\nimport type { GUIControl, GUILabel, GUIButton } from \"@/gui\";\nimport { TextureLoader } from \"@/loaders\";\nimport type { ModulePlayer } from \"@/module\";\nimport { OdysseyModel3D } from \"@/three/odyssey\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { GameState } from \"@/GameState\";\n\n/**\n * CharGenClass class.\n * Character generation \"CHOOSE YOUR CLASS\" screen; displays six class portrait slots\n * (_3D_MODEL16) with hover animation. Layout from ClassSel / classsel.gui.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file CharGenClass.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class CharGenClass extends GameMenu {\n\n  _3D_MODEL2: GUILabel;\n  LBL_CHAR_GEN: GUILabel;\n  LBL_CLASS: GUILabel;\n  LBL_INSTRUCTION: GUILabel;\n  _3D_MODEL1: GUILabel;\n  LBL_DESC: GUILabel;\n  BTN_BACK: GUIButton;\n  _3D_MODEL3: GUILabel;\n  _3D_MODEL4: GUILabel;\n  _3D_MODEL5: GUILabel;\n  _3D_MODEL6: GUILabel;\n  BTN_SEL1: GUIButton;\n  BTN_SEL2: GUIButton;\n  BTN_SEL3: GUIButton;\n  BTN_SEL4: GUIButton;\n  BTN_SEL6: GUIButton;\n  BTN_SEL5: GUIButton;\n\n  selecting: boolean = false;\n\n  /** Base extent sizes from the layout (classsel.gui) for model and button; used so hover animation does not shrink below layout size. */\n  private _baseModelExtent: { width: number; height: number } = { width: 0, height: 0 };\n  private _baseBtnExtent: { width: number; height: number } = { width: 0, height: 0 };\n  /** Hovered (larger) target sizes; non-hovered slots animate toward base, hovered toward hover. */\n  private _hoverModelExtent: { width: number; height: number } = { width: 0, height: 0 };\n  private _hoverBtnExtent: { width: number; height: number } = { width: 0, height: 0 };\n  private _baseExtentsCaptured: boolean = false;\n\n  constructor(){\n    super();\n    this.gui_resref = 'classsel';\n    this.background = '1600x1200back';\n    this.voidFill = true;\n    this.userCanClose = false;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if(skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n      this.BTN_BACK.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MainMenu.Start();\n      });\n\n      this.BTN_SEL1.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 0;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.BTN_SEL2.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 1;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.BTN_SEL3.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 2;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.BTN_SEL4.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 3;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.BTN_SEL5.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 4;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.BTN_SEL6.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(this.selecting) return;\n        this.selecting = true;\n        GameState.CharGenManager.selectedClass = 5;\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\n        GameState.CharGenManager.selectedCreature = new GameState.Module.ModuleArea.ModulePlayer(template);\n        GameState.CharGenManager.selectedCreature.load();\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\n          TextureLoader.LoadQueue().then(() => {\n            this.selecting = false;\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\n            this.manager.CharGenMain.open();\n          });\n        });\n      });\n\n      this.tGuiPanel.getFill().position.z = -0.5;\n\n      for(let i = 0; i < 6; i++){\n        const control = this.getControlByName('_3D_MODEL'+(i+1));\n        const _3dView = GameState.CharGenManager.lbl_3d_views.get(i);\n        _3dView.visible = true;\n        _3dView.camera.aspect = control.extent.width / control.extent.height;\n        _3dView.camera.updateProjectionMatrix();\n        control.setFillTexture(_3dView.texture.texture);\n        (control.getFill().material as THREE.ShaderMaterial).transparent = true;\n        (control.getFill().material as THREE.ShaderMaterial).blending = 1;\n      }\n\n      this.captureBaseExtents();\n\n      resolve();\n    });\n  }\n\n  async load3D() {\n    await this.initCharacter3D(this._3D_MODEL1, 0);\n    await this.initCharacter3D(this._3D_MODEL2, 1);\n    await this.initCharacter3D(this._3D_MODEL3, 2);\n    await this.initCharacter3D(this._3D_MODEL4, 3);\n    await this.initCharacter3D(this._3D_MODEL5, 4);\n    await this.initCharacter3D(this._3D_MODEL6, 5);\n  }\n\n  initCharacter3D(control: GUIControl, nth = 0) {\n    return new Promise<void>( (resolve, reject) => {\n      const _3dView = GameState.CharGenManager.lbl_3d_views.get(nth);\n      let _3dViewModel = GameState.CharGenManager.models.get(nth);\n      const creature = GameState.CharGenManager.creatures.get(nth);\n      _3dView.setControl(control);\n      _3dView.visible = true;\n      control.border.fill.material.transparent = true;\n      control.border.fill.material.blending = 1;\n\n      if(_3dViewModel) _3dViewModel.removeFromParent();\n\n      OdysseyModel3D.FromMDL(GameState.CharGenManager.cgmain_light, {\n        onComplete: (background_model: OdysseyModel3D) => {\n          GameState.CharGenManager.models.set(nth, background_model);\n          _3dViewModel = background_model;\n          _3dView.addModel(_3dViewModel);\n          _3dView.camera.position.copy(_3dViewModel.camerahook.position);\n          _3dView.camera.quaternion.copy(_3dViewModel.camerahook.quaternion);\n          _3dView.camera.position.z = 0.9;\n          creature.load();\n          creature.loadModel().then((creature_model: OdysseyModel3D) => {\n            creature.model.position.set(0, 0, 0);\n            creature.model.rotation.z = -Math.PI / 2;\n            _3dView.addModel(creature.model);\n            TextureLoader.LoadQueue().then(() => {\n              this.manager.LoadScreen.setProgress((nth + 1) / 6 * 100);\n              _3dViewModel.playAnimation(0, true);\n              resolve();\n            });\n          });\n        },\n        manageLighting: false,\n        context: _3dView\n      });\n    });\n  }\n\n  /**\n   * Capture base (rest) and hover target extents from the first model/button control.\n   * Layout (classsel.gui) defines the intended size; we animate between base and a slightly\n   * larger hover size so portraits never shrink below the layout dimensions.\n   */\n  private captureBaseExtents(): void {\n    if (this._baseExtentsCaptured) return;\n    const modelControl = this.getControlByName('_3D_MODEL1');\n    const btnControl = this.getControlByName('BTN_SEL1');\n    if (!modelControl || !btnControl || modelControl.extent.width <= 0 || modelControl.extent.height <= 0) return;\n    this._baseModelExtent.width = modelControl.extent.width;\n    this._baseModelExtent.height = modelControl.extent.height;\n    this._baseBtnExtent.width = btnControl.extent.width;\n    this._baseBtnExtent.height = btnControl.extent.height;\n    const hoverDelta = 20;\n    this._hoverModelExtent.width = this._baseModelExtent.width + hoverDelta;\n    this._hoverModelExtent.height = this._baseModelExtent.height + hoverDelta;\n    this._hoverBtnExtent.width = this._baseBtnExtent.width + hoverDelta;\n    this._hoverBtnExtent.height = this._baseBtnExtent.height + hoverDelta;\n    this._baseExtentsCaptured = true;\n  }\n\n  update(delta = 0) {\n    super.update(delta);\n    if (!this.bVisible)\n      return;\n    try {\n      if (!this._baseExtentsCaptured) this.captureBaseExtents();\n\n      for (let i = 0; i < 6; i++) {\n        const modelControl = this.getControlByName('_3D_MODEL' + (i + 1));\n        const btnControl = this.getControlByName('BTN_SEL' + (i + 1));\n        const _3dView = GameState.CharGenManager.lbl_3d_views.get(i);\n        const creature = GameState.CharGenManager.creatures.get(i);\n        if (creature) {\n          creature.update(delta);\n        }\n        if (btnControl.hover) {\n          if (GameState.CharGenManager.hoveredClass != i) {\n            GameState.CharGenManager.hoveredClass = i;\n            this.textNeedsUpdate = true;\n          }\n          if (btnControl.extent.height < this._hoverBtnExtent.height) {\n            btnControl.extent.height = Math.min(btnControl.extent.height + 1, this._hoverBtnExtent.height);\n            btnControl.extent.width = Math.min(btnControl.extent.width + 1, this._hoverBtnExtent.width);\n          }\n          if (modelControl.extent.height < this._hoverModelExtent.height) {\n            modelControl.extent.height = Math.min(modelControl.extent.height + 1, this._hoverModelExtent.height);\n            modelControl.extent.width = Math.min(modelControl.extent.width + 1, this._hoverModelExtent.width);\n          }\n        } else {\n          if (btnControl.extent.height > this._baseBtnExtent.height) {\n            btnControl.extent.height = Math.max(btnControl.extent.height - 1, this._baseBtnExtent.height);\n            btnControl.extent.width = Math.max(btnControl.extent.width - 1, this._baseBtnExtent.width);\n          }\n          if (modelControl.extent.height > this._baseModelExtent.height) {\n            modelControl.extent.height = Math.max(modelControl.extent.height - 1, this._baseModelExtent.height);\n            modelControl.extent.width = Math.max(modelControl.extent.width - 1, this._baseModelExtent.width);\n          }\n        }\n        _3dView.setSize(modelControl.extent.width * 2, modelControl.extent.height * 2);\n        _3dView.render(delta);\n        (modelControl.getFill().material as THREE.ShaderMaterial).needsUpdate = true;\n        btnControl.resizeControl();\n        modelControl.resizeControl();\n      }\n      if (this.textNeedsUpdate) {\n        this.LBL_DESC.setText(GameState.TLKManager.TLKStrings[CharGenClasses[GameState.CharGenManager.hoveredClass].strings.description].Value);\n        this.LBL_CLASS.setText(GameState.TLKManager.TLKStrings[CharGenClasses[GameState.CharGenManager.hoveredClass].strings.gender].Value + ' ' + GameState.TLKManager.TLKStrings[CharGenClasses[GameState.CharGenManager.hoveredClass].strings.name].Value);\n        this.textNeedsUpdate = false;\n      }\n    } catch (e: unknown) {\n      log.error(e);\n    }\n  }\n\n  show() {\n    super.show();\n  }\n\n  async Init() {\n    this.manager.LoadScreen.setProgress(0);\n    await this.load3D();\n  }\n\n  GetRandomAnimation() {\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\CharGenPortCust.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":177,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":177,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { CharGenClasses } from \"@/game/CharGenClasses\";\nimport { GameMenu, LBL_3DView } from \"@/gui\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { GameState } from \"@/GameState\";\r\n\r\n/**\r\n * CharGenPortCust class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenPortCust.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenPortCust extends GameMenu {\r\n\r\n  LBL_HEAD: GUILabel;\r\n  MAIN_TITLE_LBL: GUILabel;\r\n  SUB_TITLE_LBL: GUILabel;\r\n  LBL_BEVEL_L: GUILabel;\r\n  LBL_BEVEL_M: GUILabel;\r\n  LBL_BEVEL_R: GUILabel;\r\n  LBL_PORTRAIT: GUILabel;\r\n  LBL_BEVEL_B: GUILabel;\r\n  LBL_BEVEL_T: GUILabel;\r\n  BTN_ARRL: GUIButton;\r\n  BTN_ARRR: GUIButton;\r\n  BTN_ACCEPT: GUIButton;\r\n  BTN_BACK: GUIButton;\r\n  exiting: boolean;\r\n  appearance: number;\r\n  portraitId: number;\r\n\r\n  _3dView: LBL_3DView;\r\n  sceneModel3D: OdysseyModel3D;\r\n\r\n  isCharLoading: boolean = false;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'portcust';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n    this._3dView = new LBL_3DView();\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    this.BTN_ARRL.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      if(this.isCharLoading) return;\r\n      this.isCharLoading = true;\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n    \r\n      let idx = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.indexOf(creature.appearance);\r\n      const arrayLength = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.length;\r\n      if(idx <= 0){\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[arrayLength - 1];\r\n      }else{\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[--idx];\r\n      }\r\n      creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n\r\n      for(let i = 0; i < GameState.SWRuleSet.portraits.length; i++){\r\n        const port = GameState.SWRuleSet.portraits[i];\r\n        if(port.appearancenumber == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_l == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_s == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      creature.loadModel().then( (model: OdysseyModel3D) => {\r\n        this.updateCamera();\r\n        this.UpdatePortrait();\r\n        if(model){\r\n          model.rotation.z = -Math.PI/2;\r\n          model.removeFromParent();\r\n          this._3dView.addModel(model);\r\n        }\r\n        this.isCharLoading = false;\r\n      });\r\n\r\n    });\r\n\r\n    this.BTN_ARRR.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      if(this.isCharLoading) return;\r\n      this.isCharLoading = true;\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n\r\n      let idx = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.indexOf(creature.appearance);\r\n      const arrayLength = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.length;\r\n      if(idx >= arrayLength - 1){\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[0];\r\n      }else{\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[++idx];\r\n      }\r\n      creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n\r\n      for(let i = 0; i < GameState.SWRuleSet.portraits.length; i++){\r\n        const port = GameState.SWRuleSet.portraits[i];\r\n        if(port.appearancenumber == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_l == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_s == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      creature.loadModel().then( (model: OdysseyModel3D) => {\r\n        this.updateCamera();\r\n        this.UpdatePortrait();\r\n        if(model){\r\n          model.rotation.z = -Math.PI/2;\r\n          model.removeFromParent();\r\n          this._3dView.addModel(model);\r\n        }\r\n        this.isCharLoading = false;\r\n      });\r\n\r\n    });\r\n\r\n    this.BTN_BACK.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n      if(!this.exiting){\r\n        this.exiting = true;\r\n        //Restore previous appearance\r\n        creature.appearance = this.appearance;\r\n        creature.portraitId = this.portraitId;\r\n        creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n        creature.loadModel().then( (model: OdysseyModel3D) => {\r\n          model.rotation.z = -Math.PI/2;\r\n          this.exiting = false;\r\n          this.close();\r\n        });\r\n      }\r\n    });\r\n\r\n    this.BTN_ACCEPT.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n      \r\n      //Save appearance choice\r\n      creature.template.getFieldByLabel('Appearance_Type').setValue(creature.appearance);\r\n      creature.template.getFieldByLabel('PortraitId').setValue(creature.portraitId);\r\n      this.manager.CharGenQuickPanel.step1 = true;\r\n\r\n      this.close();\r\n    });\r\n\r\n    this.tGuiPanel.widget.userData.fill.position.z = -0.5\r\n\r\n    this._3dView.visible = true;\r\n    this._3dView.camera.aspect = this.LBL_HEAD.extent.width / this.LBL_HEAD.extent.height;\r\n    this._3dView.camera.updateProjectionMatrix();\r\n    this.LBL_HEAD.setFillTexture(this._3dView.texture.texture);\r\n    (this.LBL_HEAD.getFill().material as THREE.ShaderMaterial).transparent = false;\r\n\r\n    this.Init3D();\r\n  }\r\n\r\n  Init3D() {\r\n    const control = this.LBL_HEAD;\r\n    const creature = GameState.CharGenManager.selectedCreature;\r\n    if(creature.model){\r\n      creature.model.removeFromParent();\r\n    }\r\n    OdysseyModel3D.FromMDL(GameState.CharGenManager.cghead_light, {\r\n      context: this._3dView\r\n    }).then( (sceneModel3D: OdysseyModel3D) => {\r\n      try{\r\n        this.sceneModel3D = sceneModel3D;\r\n        this._3dView.addModel(this.sceneModel3D);\r\n        if(creature.getGender()){\r\n          this._3dView.camera.position.copy(this.sceneModel3D.camerahookf.position);\r\n          this._3dView.camera.quaternion.copy(this.sceneModel3D.camerahookf.quaternion);\r\n        }else{\r\n          this._3dView.camera.position.copy(this.sceneModel3D.camerahookm.position);\r\n          this._3dView.camera.quaternion.copy(this.sceneModel3D.camerahookm.quaternion);\r\n        }\r\n        this.sceneModel3D.playAnimation(0, true);\r\n      }catch(e){\r\n        log.error(e);\r\n      }\r\n    });\r\n    (control.getFill().material as THREE.ShaderMaterial).uniforms.map.value = this._3dView.texture.texture;\r\n    (control.getFill().material as THREE.ShaderMaterial).transparent = false;\r\n    (control.getFill().material as THREE.ShaderMaterial).blending = 1;\r\n  }\r\n\r\n  update(delta = 0) {\r\n    super.update(delta);\r\n    if (!this.bVisible)\r\n      return;\r\n    try {\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n      const modelControl = this.LBL_HEAD;\r\n      creature.update(delta);\r\n      this._3dView.render(delta);\r\n      (modelControl.getFill().material as THREE.ShaderMaterial).needsUpdate = true;\r\n    } catch (e: unknown) {\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n  UpdatePortrait() {\r\n    const creature = GameState.CharGenManager.selectedCreature;\r\n    const portraitResRef = creature.portrait?.getPortraitGoodEvil(50);\r\n    this.LBL_PORTRAIT.show();\r\n    if (this.LBL_PORTRAIT.getFillTextureName() != portraitResRef) {\r\n      this.LBL_PORTRAIT.setFillTextureName(portraitResRef);\r\n      TextureLoader.tpcLoader.fetch(portraitResRef).then((texture: OdysseyTexture) => {\r\n        this.LBL_PORTRAIT.setFillTexture(texture);\r\n      });\r\n    }\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    const creature = GameState.CharGenManager.selectedCreature;\r\n    this.appearance = creature.appearance;\r\n    this.portraitId = creature.portraitId;\r\n    try {\r\n      creature.model.removeFromParent();\r\n    } catch (e: unknown) {\r\n      log.error(e);\r\n    }\r\n    this._3dView.addModel(creature.model);\r\n    (this.LBL_PORTRAIT.getFill().material as THREE.ShaderMaterial).blending = 1;\r\n    this.updateCamera();\r\n    this.UpdatePortrait();\r\n  }\r\n\r\n  updateCamera() {\r\n    const creature = GameState.CharGenManager.selectedCreature;\r\n    if (creature.getGender() == 0) {\r\n      this._3dView.camera.position.copy(this.sceneModel3D.camerahookm.position);\r\n      this._3dView.camera.quaternion.copy(this.sceneModel3D.camerahookm.quaternion);\r\n    } else {\r\n      this._3dView.camera.position.copy(this.sceneModel3D.camerahookf.position);\r\n      this._3dView.camera.quaternion.copy(this.sceneModel3D.camerahookf.quaternion);\r\n    }\r\n    const v3 = new THREE.Vector3();\r\n    creature.model.camerahook.getWorldPosition(v3)\r\n    this._3dView.camera.position.z = v3.z;\r\n  }\r\n    \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\CharGenQuickOrCustom.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":71,"column":20,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":71,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUIListBox, GUILabel, GUIButton } from \"@/gui\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { TalentFeat } from \"@/talents\";\r\n\r\n/**\r\n * CharGenQuickOrCustom class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenQuickOrCustom.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenQuickOrCustom extends GameMenu {\r\n\r\n  LBL_DECORATION: GUILabel;\r\n  BTN_BACK: GUIButton;\r\n  LBL_RBG: GUILabel;\r\n  LB_DESC: GUIListBox;\r\n  QUICK_CHAR_BTN: GUIButton;\r\n  CUST_CHAR_BTN: GUIButton;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'qorcpnl';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.QUICK_CHAR_BTN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        try{\r\n          const class_data = GameState.SWRuleSet.classes[GameState.CharGenManager.selectedClass];\r\n          const saving_throw_label = class_data['savingthrowtable'].toLowerCase();\r\n          const saving_throw_data = GameState.TwoDAManager.datatables.get(saving_throw_label).rows[0];\r\n          const feats_table = GameState.SWRuleSet.feats;\r\n\r\n          GameState.CharGenManager.selectedCreature.str = class_data.str;\r\n          GameState.CharGenManager.selectedCreature.dex = class_data.dex;\r\n          GameState.CharGenManager.selectedCreature.con = class_data.con;\r\n          GameState.CharGenManager.selectedCreature.wis = class_data.wis;\r\n          GameState.CharGenManager.selectedCreature.int = class_data.int;\r\n          GameState.CharGenManager.selectedCreature.cha = class_data.cha;\r\n          GameState.CharGenManager.selectedCreature.str = class_data.str;\r\n\r\n          GameState.CharGenManager.selectedCreature.fortbonus = parseInt(saving_throw_data.fortsave);\r\n          GameState.CharGenManager.selectedCreature.willbonus = parseInt(saving_throw_data.willsave);\r\n          GameState.CharGenManager.selectedCreature.refbonus = parseInt(saving_throw_data.refsave);\r\n\r\n          for(let i = 0, len = feats_table.length; i < len; i++){\r\n            const feat_data = feats_table[i];\r\n            if(feat_data.getGranted(class_data) == 1){\r\n              GameState.CharGenManager.selectedCreature.feats.push(new TalentFeat(i));\r\n            }\r\n          }\r\n          \r\n          this.manager.CharGenMain.close();\r\n          this.manager.CharGenMain.childMenu = this.manager.CharGenQuickPanel;\r\n          this.manager.CharGenQuickPanel.tGuiPanel.widget.position.x = 142.5;\r\n          this.manager.CharGenQuickPanel.tGuiPanel.widget.position.y = 0;\r\n          this.manager.CharGenMain.open();\r\n        }catch(e){\r\n          log.info(e);\r\n        }\r\n      });\r\n\r\n      this.CUST_CHAR_BTN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //Game.CharGenMain.state = CharGenMain.STATES.CUSTOM;\r\n        //Game.CharGenCustomPanel.Show();\r\n        this.manager.CharGenMain.close();\r\n        this.manager.CharGenMain.childMenu = this.manager.CharGenCustomPanel;\r\n        this.manager.CharGenCustomPanel.tGuiPanel.widget.position.x = 142.5;\r\n        this.manager.CharGenCustomPanel.tGuiPanel.widget.position.y = 0;\r\n        this.manager.CharGenMain.open();\r\n\r\n        //Reset the Attributes window\r\n        this.manager.CharGenAbilities.reset();\r\n\r\n        //Reset the Skills window\r\n        this.manager.CharGenSkills.reset();\r\n      });\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //Game.CharGenMain.Hide();\r\n\r\n        try{\r\n          GameState.CharGenManager.selectedCreature.model.parent.remove(GameState.CharGenManager.selectedCreature.model);\r\n        }catch(e){}\r\n\r\n        // this.manager.CharGenClass.getControlByName('_3D_MODEL'+(GameState.CharGenManager.selectedClass+1))\r\n        //  .userData._3dView.scene.add(GameState.CharGenManager.selectedCreature.model);\r\n        this.manager.CharGenMain.close();\r\n      });\r\n\r\n      //Hide because this submenu is very incomplete.\r\n      //Comment out this line to work on the custom chargen screen\r\n      this.CUST_CHAR_BTN.hide();\r\n\r\n      this.tGuiPanel.offset.x = -180;\r\n      this.tGuiPanel.offset.y = 100;\r\n      this.recalculatePosition();\r\n      resolve();\r\n    });\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\InGameBark.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":86,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":86,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":86,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":86,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":89,"column":23,"nodeType":"MemberExpression","messageId":"errorCall","endLine":89,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":90,"column":22,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":90,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":90,"column":22,"nodeType":"MemberExpression","messageId":"errorCall","endLine":90,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":92,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":92,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setLIP on a type that cannot be resolved.","line":92,"column":25,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":95,"column":61,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":95,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":95,"column":61,"nodeType":"MemberExpression","messageId":"errorCall","endLine":95,"endColumn":81}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { DLGNodeType, ModuleObjectType } from \"@/enums\";\r\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUILabel } from \"@/gui\";\r\nimport { ResourceLoader } from \"@/loaders\";\r\nimport { DLGNode } from \"@/resource/DLGNode\";\r\nimport { LIPObject } from \"@/resource/LIPObject\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { BitWise } from \"@/utility/BitWise\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/**\r\n * InGameBark class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file InGameBark.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class InGameBark extends GameMenu {\r\n\r\n  engineMode: EngineMode = EngineMode.INGAME;\r\n  LBL_BARKTEXT: GUILabel;\r\n  isOverlayGUI = true;\r\n\r\n  static BARK_TIMER: number = 3;\r\n  barkTimer: number = 0;\r\n  bHasAudio: boolean = false;\r\n  bAudioPlayed: boolean = false;\r\n\r\n  audioNode: AudioBufferSourceNode;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'barkbubble';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.LBL_BARKTEXT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.bHasAudio = false;\r\n        this.bAudioPlayed = true;\r\n        this.barkTimer = 0;\r\n      });\r\n      this.tGuiPanel.widget.position.z = 5;\r\n      resolve();\r\n    });\r\n  }\r\n  \r\n  bark(entry: { text: string }) {\r\n\r\n    const outText = this.gameStringParse(entry.text);\r\n    log.info('bark', entry, outText);\r\n\r\n    if (!entry || !outText?.length) {\r\n      return;\r\n    }\r\n\r\n    //reset the last audioNode\r\n    if(this.audioNode){\r\n      this.audioNode.onended = undefined;\r\n    }\r\n\r\n    this.barkTimer = InGameBark.BARK_TIMER;\r\n    this.show();\r\n    this.LBL_BARKTEXT.setText(entry.text);\r\n    const size = new THREE.Vector3();\r\n    this.LBL_BARKTEXT.text.geometry.boundingBox?.getSize(size);\r\n    this.tGuiPanel.extent.height = Math.ceil(size.y) + 14;\r\n    this.tGuiPanel.resizeControl();\r\n    this.tGuiPanel.widget.position.x = -GameState.ResolutionManager.getViewportWidth() / 2 + this.tGuiPanel.extent.width / 2 + 10;\r\n    this.tGuiPanel.widget.position.y = GameState.ResolutionManager.getViewportHeight() / 2 - this.tGuiPanel.extent.height / 2 - 134;\r\n    this.LBL_BARKTEXT.setText(entry.text);\r\n\r\n    if (entry.getVoiceResRef()?.length) {\r\n      this.bHasAudio = true;\r\n      this.bAudioPlayed = false;\r\n      log.info('lip', entry.getVoiceResRef());\r\n      LIPObject.Load(entry.getVoiceResRef()).then((lip: LIPObject) => {\r\n        if (BitWise.InstanceOfObject(entry.speaker, ModuleObjectType.ModuleCreature)) {\r\n          entry.speaker.setLIP(lip);\r\n        }\r\n      });\r\n      GameState.CutsceneManager.audioEmitter.playStreamWave(entry.getVoiceResRef()).then((audioNode) => {\r\n        this.audioNode = audioNode;\r\n        this.bHasAudio = true;\r\n        audioNode.onended = () => {\r\n          this.bAudioPlayed = true;\r\n        };\r\n      }).catch((e) => {\r\n        this.bHasAudio = false;\r\n        this.bAudioPlayed = true;\r\n      });\r\n    } else {\r\n      this.bAudioPlayed = true;\r\n      this.bHasAudio = false;\r\n      log.error('VO ERROR', entry);\r\n    }\r\n  }\r\n\r\n  barkFromString(text: string){\r\n    const entry = new DLGNode();\r\n    entry.nodeType = DLGNodeType.ENTRY;\r\n    entry.text = text;\r\n    this.bark(entry);\r\n  }\r\n\r\n  barkFromStringRef(strRef: number){\r\n    const tlkString = GameState.TLKManager.GetStringById(strRef);\r\n    if(!tlkString){ return; }\r\n    const entry = new DLGNode();\r\n    entry.nodeType = DLGNodeType.ENTRY;\r\n    entry.text = tlkString.Value;\r\n    this.bark(entry);\r\n  }\r\n\r\n  update(delta = 0){\r\n    super.update(delta);\r\n    if(this.bHasAudio){\r\n      if(this.bAudioPlayed){\r\n        this.close();\r\n      }\r\n    }else{\r\n      this.barkTimer -= delta;\r\n      if(this.barkTimer < 0){ this.barkTimer = 0; }\r\n      if(!this.barkTimer){ \r\n        this.close();\r\n      }else{\r\n        this.show();\r\n      }\r\n    }\r\n  }\r\n\r\n  close(){\r\n    super.close();\r\n    if(this.audioNode){\r\n      this.audioNode.onended = undefined;\r\n      this.audioNode = undefined;\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\InGameOverlay.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":194,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":194,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":376,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":376,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":566,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":566,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":567,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":567,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":574,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":574,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":575,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":575,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":584,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":584,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":585,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":585,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":586,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":586,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":587,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":587,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":601,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":601,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":602,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":602,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":603,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":603,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":604,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":604,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":608,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":608,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":609,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":609,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":613,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":613,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":614,"column":37,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":614,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":944,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":944,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":956,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":956,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":968,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":968,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":980,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":980,"endColumn":61}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AutoPauseState } from \"@/enums/engine/AutoPauseState\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { EngineState } from \"@/enums/engine/EngineState\";\nimport { Anchor } from \"@/enums/gui/Anchor\";\nimport { SSFType } from \"@/enums/resource/SSFType\";\nimport { GameState } from \"@/GameState\";\nimport { GameMenu, LBL_MapView } from \"@/gui\";\nimport type { GUILabel, GUIButton, GUICheckBox, GUIProgressBar } from \"@/gui\";\nimport { TextureLoader } from \"@/loaders\";\nimport { ResolutionManager } from \"@/managers/ResolutionManager\";\nimport { TalentObject } from \"@/talents\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { KeyMapAction, ModuleObjectType } from \"@/enums\";\n\nconst TLK_TOOLTIP_FULL_HEALTH = 42498;\n\nconst TLK_TOOLTIP_SOLOMODE = 48035;\nconst TLK_TOOLTIP_STEALTH = 247;\nconst TLK_TOOLTIP_PAUSE = 48019;\n\nconst TLK_TOOLTIP_QUEST = 48218;\nconst TLK_TOOLTIP_EQUIPMENT = 48219;\nconst TLK_TOOLTIP_INVENTORY = 48220;\nconst TLK_TOOLTIP_MAP = 48221;\nconst TLK_TOOLTIP_OPTIONS = 48222;\nconst TLK_TOOLTIP_MESSAGES = 48223;\nconst TLK_TOOLTIP_ABILITIES = 48224;\nconst TLK_TOOLTIP_CHARACTER = 48225;\n\nconst TLK_TOOLTIP_FRIENDLY_POWER = 48486;\nconst TLK_TOOLTIP_FRIENDLY_ITEM = 48291;\nconst TLK_TOOLTIP_FRIENDLY_NON_MEDICAL_ITEM = 48299;\nconst TLK_TOOLTIP_FRIENDLY_MINE = 48295;\n\n/**\n * InGameOverlay class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file InGameOverlay.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class InGameOverlay extends GameMenu {\n\n  engineMode: EngineMode = EngineMode.INGAME;\n  LBL_CMBTMODEMSG: GUILabel;\n  LBL_COMBATBG2: GUILabel;\n  LBL_COMBATBG3: GUILabel;\n  LBL_COMBATBG1: GUILabel;\n  LBL_MAP: GUILabel;\n  LBL_CMBTMSGBG: GUILabel;\n  LBL_MOULDING1: GUILabel;\n  LBL_ACTIONDESCBG: GUILabel;\n  LBL_ACTIONDESC: GUILabel;\n  LBL_MOULDING2: GUILabel;\n  TB_STEALTH: GUICheckBox;\n  LBL_ARROW_MARGIN: GUILabel;\n  TB_SOLO: GUICheckBox;\n  LBL_MAPBORDER: GUILabel;\n  LBL_MAPVIEW: GUILabel;\n  BTN_MINIMAP: GUIButton;\n  LBL_MOULDING3: GUILabel;\n  LBL_MENUBG: GUILabel;\n  TB_PAUSE: GUICheckBox;\n  LBL_NAMEBG: GUILabel;\n  LBL_HEALTHBG: GUILabel;\n  BTN_MSG: GUIButton;\n  BTN_JOU: GUIButton;\n  BTN_MAP: GUIButton;\n  BTN_OPT: GUIButton;\n  BTN_CHAR: GUIButton;\n  BTN_ABI: GUIButton;\n  BTN_INV: GUIButton;\n  BTN_EQU: GUIButton;\n  LBL_BACK2: GUILabel;\n  LBL_BACK3: GUILabel;\n  LBL_CHAR3: GUILabel;\n  LBL_DISABLE3: GUILabel;\n  LBL_DEBILATATED3: GUILabel;\n  LBL_LVLUPBG3: GUILabel;\n  LBL_LEVELUP3: GUILabel;\n  LBL_STEALTHXP: GUILabel;\n  BTN_ACTION0: GUIButton;\n  BTN_ACTIONUP0: GUIButton;\n  BTN_ACTIONDOWN0: GUIButton;\n  LBL_ACTION0: GUIButton;\n  BTN_ACTION3: GUIButton;\n  BTN_ACTIONUP3: GUIButton;\n  BTN_ACTIONDOWN3: GUIButton;\n  LBL_ACTION3: GUIButton;\n  BTN_ACTION2: GUIButton;\n  BTN_ACTIONUP2: GUIButton;\n  BTN_ACTIONDOWN2: GUIButton;\n  LBL_ACTION2: GUIButton;\n  BTN_ACTION1: GUIButton;\n  BTN_ACTIONUP1: GUIButton;\n  BTN_ACTIONDOWN1: GUIButton;\n  LBL_ACTION1: GUIButton;\n  LBL_DARKSHIFT: GUILabel;\n  LBL_BACK1: GUILabel;\n  PB_FORCE2: GUIProgressBar;\n  PB_VIT2: GUIProgressBar;\n  PB_VIT1: GUIProgressBar;\n  LBL_CHAR1: GUILabel;\n  LBL_DISABLE1: GUILabel;\n  LBL_DEBILATATED1: GUILabel;\n  LBL_LVLUPBG1: GUILabel;\n  LBL_LEVELUP1: GUILabel;\n  LBL_CHAR2: GUILabel;\n  LBL_DEBILATATED2: GUILabel;\n  LBL_DISABLE2: GUILabel;\n  PB_FORCE1: GUIProgressBar;\n  PB_FORCE3: GUIProgressBar;\n  PB_VIT3: GUIProgressBar;\n  LBL_NAME: GUILabel;\n  LBL_LVLUPBG2: GUILabel;\n  PB_HEALTH: GUIProgressBar;\n  LBL_LEVELUP2: GUILabel;\n  LBL_CMBTEFCTRED1: GUILabel;\n  LBL_CMBTEFCTINC1: GUILabel;\n  LBL_CMBTEFCTRED2: GUILabel;\n  LBL_CMBTEFCTINC2: GUILabel;\n  LBL_CMBTEFCTINC3: GUILabel;\n  LBL_CMBTEFCTRED3: GUILabel;\n  LBL_ARROW: GUILabel;\n  LBL_JOURNAL: GUILabel;\n  LBL_CASH: GUILabel;\n  LBL_PLOTXP: GUILabel;\n  LBL_ITEMRCVD: GUILabel;\n  LBL_ITEMLOST: GUILabel;\n  BTN_CLEARALL: GUIButton;\n  LBL_LIGHTSHIFT: GUILabel;\n  BTN_CHAR3: GUIButton;\n  BTN_CHAR1: GUIButton;\n  BTN_CHAR2: GUIButton;\n  LBL_QUEUE0: GUILabel;\n  LBL_QUEUE1: GUILabel;\n  LBL_QUEUE2: GUILabel;\n  LBL_QUEUE3: GUILabel;\n  BTN_CLEARONE: GUIButton;\n  BTN_CLEARONE2: GUIButton;\n  BTN_TARGET0: GUIButton;\n  BTN_TARGETUP0: GUIButton;\n  BTN_TARGETDOWN0: GUIButton;\n  LBL_TARGET0: GUIButton;\n  BTN_TARGET1: GUIButton;\n  BTN_TARGETUP1: GUIButton;\n  BTN_TARGETDOWN1: GUIButton;\n  LBL_TARGET1: GUIButton;\n  BTN_TARGET2: GUIButton;\n  BTN_TARGETUP2: GUIButton;\n  BTN_TARGETDOWN2: GUIButton;\n  LBL_TARGET2: GUIButton;\n  miniMap: LBL_MapView;\n\n  constructor() {\n    super();\n    this.gui_resref = InGameOverlay.getMainInterfaceResref(\n      ResolutionManager.getViewportWidth(),\n      ResolutionManager.getViewportHeight()\n    );\n    this.background = '';\n    this.voidFill = false;\n    this.enablePositionScaling = false;\n    this.userCanClose = false;\n    this.panelBitFlags = 0x87;\n  }\n\n  /**\n   * GUI resref by viewport: 1024 -> mipc210x7, 1280x960 -> mipc212x9, 1280x1024 -> mipc212x10,\n   * 1600 -> mipc216x12, else mipc28x6. Panel extent in each GFF matches that resolution.\n   */\n  static getMainInterfaceResref(viewportWidth: number, viewportHeight: number): string {\n    if (viewportWidth === 1024) return 'mipc210x7';\n    if (viewportWidth === 1280) {\n      if (viewportHeight === 960) return 'mipc212x9';\n      if (viewportHeight === 1024) return 'mipc212x10';\n    }\n    if (viewportWidth === 1600) return 'mipc216x12';\n    return 'mipc28x6';\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if (skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n      this.tGuiPanel.widget.userData.fill.visible = false;\n      //this.TB_STEALTH.hideBorder();\n      //this.TB_PAUSE.hideBorder();\n      //this.TB_SOLO.hideBorder();\n\n      this.LBL_LIGHTSHIFT?.hide();\n      this.LBL_DARKSHIFT?.hide();\n      this.LBL_JOURNAL?.hide();\n      this.LBL_CASH?.hide();\n      this.LBL_PLOTXP?.hide();\n      this.LBL_STEALTHXP?.hide();\n      this.LBL_ITEMRCVD?.hide();\n      this.LBL_ITEMLOST?.hide();\n\n      //Map INIT\n      //this.LBL_MAPBORDER.hideBorder();\n      this.LBL_MAP?.hide();\n      this.LBL_ARROW_MARGIN?.hide();\n      this.LBL_ARROW?.hide();\n      this.miniMap = new LBL_MapView(this.LBL_MAPVIEW);\n      this.miniMap.setControl(this.LBL_MAPVIEW);\n      this.miniMap.setSize(120, 120);\n\n      this.LBL_CMBTEFCTRED1?.hide();\n      this.LBL_CMBTEFCTINC1?.hide();\n      this.LBL_LEVELUP1?.hide();\n      this.LBL_LVLUPBG1?.hide();\n      this.LBL_DEBILATATED1?.hide();\n      this.LBL_DISABLE1?.hide();\n\n      this.LBL_CMBTEFCTRED2?.hide();\n      this.LBL_CMBTEFCTINC2?.hide();\n      this.LBL_LEVELUP2?.hide();\n      this.LBL_LVLUPBG2?.hide();\n      this.LBL_DEBILATATED2?.hide();\n      this.LBL_DISABLE2?.hide();\n\n      this.LBL_CMBTEFCTRED3?.hide();\n      this.LBL_CMBTEFCTINC3?.hide();\n      this.LBL_LEVELUP3?.hide();\n      this.LBL_LVLUPBG3?.hide();\n      this.LBL_DEBILATATED3?.hide();\n      this.LBL_DISABLE3?.hide();\n\n\n      this.LBL_ACTIONDESC?.hide();\n      this.LBL_ACTIONDESCBG?.hide();\n\n      this.LBL_NAME?.hide();\n      this.LBL_NAMEBG?.hide();\n      this.PB_HEALTH?.hide();\n      this.LBL_HEALTHBG?.hide();\n\n      this.LBL_CMBTMSGBG?.hide();\n      this.LBL_CMBTMODEMSG?.hide();\n      //this.BTN_CLEARALL.hideBorder();\n\n\n      this.BTN_MSG.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuMessages.open();\n      }).setKeymapAction(KeyMapAction.Messages).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_MESSAGES].Value\n      );\n\n      this.BTN_JOU.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuJournal.open();\n      }).setKeymapAction(KeyMapAction.Quests).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_QUEST].Value\n      );\n\n      this.BTN_MAP.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuMap.open();\n      }).setKeymapAction(KeyMapAction.Map).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_MAP].Value\n      );\n\n      this.BTN_OPT.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuOptions.open();\n      }).setKeymapAction(KeyMapAction.Options).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_OPTIONS].Value\n      );\n\n      this.BTN_CHAR.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuCharacter.open();\n      }).setKeymapAction(KeyMapAction.Character).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_CHARACTER].Value\n      );\n\n      this.BTN_ABI.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuAbilities.open();\n      }).setKeymapAction(KeyMapAction.SkillsAndFeats).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_ABILITIES].Value\n      );\n\n      this.BTN_INV.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuInventory.open();\n      }).setKeymapAction(KeyMapAction.Inventory).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_INVENTORY].Value\n      );\n\n      this.BTN_EQU.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuEquipment.open();\n      }).setKeymapAction(KeyMapAction.Equip).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_EQUIPMENT].Value\n      );\n\n      this.TB_PAUSE.addEventListener('click', (e) => {\n        e.stopPropagation();\n\n        if (GameState.State == EngineState.PAUSED) {\n          GameState.AutoPauseManager.Unpause();\n        } else {\n          GameState.AutoPauseManager.SignalAutoPauseEvent(AutoPauseState.Generic);\n        }\n\n      }).setKeymapAction(KeyMapAction.Pause).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_PAUSE].Value\n      );\n\n      this.TB_SOLO.addEventListener('click', (e) => {\n        e.stopPropagation();\n        GameState.SOLOMODE = !GameState.SOLOMODE;\n      }).setKeymapAction(KeyMapAction.PartyActive).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_SOLOMODE].Value\n      );\n\n      this.TB_STEALTH.addEventListener('click', (e) => {\n        e.stopPropagation();\n      }).setKeymapAction(KeyMapAction.STEALTH).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_STEALTH].Value\n      );\n\n      this.BTN_CHAR1.addEventListener('click', (e) => {\n        if (GameState.PartyManager.party[0].canLevelUp()) {\n          this.manager.MenuCharacter.open();\n        } else {\n          this.manager.MenuEquipment.open();\n        }\n      });\n\n      this.BTN_CHAR2.addEventListener('click', (e) => {\n        GameState.PartyManager.SwitchLeaderAtIndex(2);\n        switch (Math.floor(Math.random() * (4 - 1) + 1)) {\n          case 2:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_2);\n            break;\n          case 3:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_3);\n            break;\n          default:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_1);\n            break;\n        }\n      });\n\n      this.BTN_CHAR3.addEventListener('click', (e) => {\n        GameState.PartyManager.SwitchLeaderAtIndex(1);\n        switch (Math.floor(Math.random() * (4 - 1) + 1)) {\n          case 2:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_2);\n            break;\n          case 3:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_3);\n            break;\n          default:\n            GameState.PartyManager.party[0].playSoundSet(SSFType.SELECT_1);\n            break;\n        }\n      });\n\n      this.BTN_CLEARALL.addEventListener('click', (e) => {\n        e.stopPropagation();\n        GameState.getCurrentPlayer().clearAllActions();\n        GameState.getCurrentPlayer().combatData.combatState = false;\n        GameState.getCurrentPlayer().cancelCombat();\n      });\n\n      this.LBL_QUEUE0.addEventListener('click', (e) => {\n        e.stopPropagation();\n        // GameState.getCurrentPlayer().clearCombatAction(GameState.getCurrentPlayer().combatData.combatAction);\n      });\n\n      this.LBL_QUEUE1.addEventListener('click', (e) => {\n        e.stopPropagation();\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(0);\n      });\n\n      this.LBL_QUEUE2.addEventListener('click', (e) => {\n        e.stopPropagation();\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(1);\n      });\n\n      this.LBL_QUEUE3.addEventListener('click', (e) => {\n        e.stopPropagation();\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(2);\n      });\n\n      for (let i = 0; i < GameState.ActionMenuManager.TARGET_MENU_COUNT; i++) {\n\n        this.getControlByName('LBL_TARGET' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.onTargetMenuAction(i);\n        });\n\n        this.getControlByName('BTN_TARGETUP' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.ActionPanels.targetPanels[i].previousAction();\n          this.UpdateTargetUIIcon(i);\n        });\n\n        this.getControlByName('BTN_TARGETDOWN' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.ActionPanels.targetPanels[i].nextAction();\n          this.UpdateTargetUIIcon(i);\n        });\n\n      }\n\n      for (let i = 0; i < GameState.ActionMenuManager.SELF_MENU_COUNT; i++) {\n\n        this.getControlByName('LBL_ACTION' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.onSelfMenuAction(i);\n        });\n\n        this.getControlByName('BTN_ACTIONUP' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.ActionPanels.selfPanels[i].previousAction();\n          this.UpdateSelfUIIcon(i);\n        });\n\n        this.getControlByName('BTN_ACTIONDOWN' + i).addEventListener('click', (e) => {\n          e.stopPropagation();\n          GameState.ActionMenuManager.ActionPanels.selfPanels[i].nextAction();\n          this.UpdateSelfUIIcon(i);\n        });\n\n      }\n\n      this.BTN_ACTION0.setKeymapAction(KeyMapAction.PersonalPowerAct).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_FRIENDLY_POWER].Value\n      );\n      this.BTN_ACTION1.setKeymapAction(KeyMapAction.PersonalMedicalAct).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_FRIENDLY_ITEM].Value\n      );\n      this.BTN_ACTION2.setKeymapAction(KeyMapAction.PersonalOtherAct).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_FRIENDLY_NON_MEDICAL_ITEM].Value\n      );\n      this.BTN_ACTION3.setKeymapAction(KeyMapAction.PersonalMinesAct).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_FRIENDLY_MINE].Value\n      );\n\n      this.BTN_MINIMAP.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.manager.MenuMap.open();\n      }).setKeymapAction(KeyMapAction.Map).setTooltipText(\n        GameState.TLKManager.TLKStrings[TLK_TOOLTIP_MAP].Value\n      );\n\n      // this.LBL_COMBATBG2.visible = false;\n      resolve();\n    });\n  }\n\n  showCombatUI() {\n    this.BTN_CLEARALL?.show();\n    this.BTN_CLEARONE?.show();\n    this.LBL_COMBATBG1?.show();\n    this.LBL_COMBATBG2?.show();\n    this.LBL_COMBATBG3?.show();\n    this.LBL_QUEUE0?.show();\n    this.LBL_QUEUE1?.show();\n    this.LBL_QUEUE2?.show();\n    this.LBL_QUEUE3?.show();\n  }\n\n  hideCombatUI() {\n    this.BTN_CLEARALL?.hide();\n    this.BTN_CLEARONE?.hide();\n    this.LBL_COMBATBG1?.hide();\n    this.LBL_COMBATBG2?.hide();\n    this.LBL_COMBATBG3?.hide();\n    this.LBL_QUEUE0?.hide();\n    this.LBL_QUEUE1?.hide();\n    this.LBL_QUEUE2?.hide();\n    this.LBL_QUEUE3?.hide();\n    this.LBL_CMBTMSGBG?.hide();\n    this.LBL_CMBTMODEMSG?.hide();\n  }\n\n  TogglePartyMember(nth = 0, bVisible = false) {\n    if (!bVisible) {\n      this.getControlByName('LBL_CMBTEFCTRED' + (nth + 1))?.hide();\n      this.getControlByName('LBL_CMBTEFCTINC' + (nth + 1))?.hide();\n      this.getControlByName('LBL_LEVELUP' + (nth + 1))?.hide();\n      this.getControlByName('LBL_LVLUPBG' + (nth + 1))?.hide();\n      this.getControlByName('LBL_DEBILATATED' + (nth + 1))?.hide();\n      this.getControlByName('LBL_DISABLE' + (nth + 1))?.hide();\n      this.getControlByName('LBL_CHAR' + (nth + 1))?.hide();\n      this.getControlByName('BTN_CHAR' + (nth + 1))?.hide();\n      this.getControlByName('LBL_BACK' + (nth + 1))?.hide();\n      this.getControlByName('PB_FORCE' + (nth + 1))?.hide();\n      this.getControlByName('PB_VIT' + (nth + 1))?.hide();\n    } else {\n      this.getControlByName('LBL_CHAR' + (nth + 1))?.show();\n      this.getControlByName('BTN_CHAR' + (nth + 1))?.show();\n      this.getControlByName('LBL_BACK' + (nth + 1))?.show();\n      this.getControlByName('PB_FORCE' + (nth + 1))?.show();\n      this.getControlByName('PB_VIT' + (nth + 1))?.show();\n      if (!GameState.module.area.miniGame && GameState.PartyManager.party[nth]) {\n        switch (nth) {\n          case 0:\n            if (GameState.PartyManager.party[nth].canLevelUp()) {\n              this.getControlByName('LBL_LEVELUP1').pulsing = true;\n              this.getControlByName('LBL_LEVELUP1')?.show();\n            } else {\n              this.getControlByName('LBL_LEVELUP1')?.hide();\n            }\n            break;\n          case 1:\n            if (GameState.PartyManager.party[nth].canLevelUp()) {\n              this.getControlByName('LBL_LEVELUP3').pulsing = true;\n              this.getControlByName('LBL_LEVELUP3')?.show();\n            } else {\n              this.getControlByName('LBL_LEVELUP3')?.hide();\n            }\n            break;\n          case 2:\n            if (GameState.PartyManager.party[nth].canLevelUp()) {\n              this.getControlByName('LBL_LEVELUP2').pulsing = true;\n              this.getControlByName('LBL_LEVELUP2')?.show();\n            } else {\n              this.getControlByName('LBL_LEVELUP2')?.hide();\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  SetMapTexture(sTexture = '') {\n    try {\n      TextureLoader.Load(sTexture).then((texture: OdysseyTexture) => {\n        this.miniMap.setTexture(texture);\n      });\n    } catch (e: unknown) {\n      log.error(e);\n    }\n  }\n\n  _canShowTargetUI() {\n    if (BitWise.InstanceOfObject(GameState.CursorManager.selectedObject, ModuleObjectType.ModuleCreature) && GameState.CursorManager.selectedObject.isDead())\n      return false;\n    return (\n      !this.manager.MenuContainer.bVisible &&\n      GameState.CursorManager.reticle2.visible &&\n      BitWise.InstanceOfObject(GameState.CursorManager.selectedObject, ModuleObjectType.ModuleObject) &&\n      !BitWise.InstanceOfObject(GameState.CursorManager.selectedObject, ModuleObjectType.ModuleRoom)\n    );\n  }\n\n  UpdateTargetUIIcon(index = 0) {\n    const guiControl = this.getControlByName('LBL_TARGET' + index);\n    if (!GameState.ActionMenuManager.ActionPanels.targetPanels[index].actions.length) {\n      guiControl.setMaterialTexture(guiControl.border.fill.material, undefined);\n      guiControl.setMaterialTexture(guiControl.highlight.fill.material, undefined);\n      guiControl.setFillTextureName('');\n      return;\n    }\n\n    const action = GameState.ActionMenuManager.ActionPanels.targetPanels[index].getSelectedAction();\n    if (!action) {\n      guiControl.setMaterialTexture(guiControl.border.fill.material, undefined);\n      guiControl.setMaterialTexture(guiControl.highlight.fill.material, undefined);\n      guiControl.setFillTextureName('');\n      return;\n    }\n\n    if (guiControl.getFillTextureName() != action.icon) {\n      guiControl.setFillTextureName(action.icon);\n      guiControl.setHighlightFillTexture(action.icon);\n      TextureLoader.tpcLoader.fetch(action.icon).then((texture: OdysseyTexture) => {\n        guiControl.setMaterialTexture(guiControl.border.fill.material, texture);\n        guiControl.setMaterialTexture(guiControl.highlight.fill.material, texture);\n        guiControl.border.fill.material.transparent = true;\n        guiControl.highlight.fill.material.transparent = true;\n        guiControl.widget.position.z = 5;\n      });\n    }\n  }\n\n  UpdateSelfUIIcon(index = 0) {\n    const guiControl = this.getControlByName('LBL_ACTION' + index);\n    if (GameState.ActionMenuManager.ActionPanels.selfPanels[index].actions.length) {\n      const action = GameState.ActionMenuManager.ActionPanels.selfPanels[index].getSelectedAction();\n      if (action && guiControl.getFillTextureName() != action.icon) {\n        guiControl.setFillTextureName(action.icon);\n        guiControl.setHighlightFillTexture(action.icon);\n        TextureLoader.tpcLoader.fetch(action.icon).then((texture: OdysseyTexture) => {\n          guiControl.setMaterialTexture(guiControl.border.fill.material, texture);\n          guiControl.setMaterialTexture(guiControl.highlight.fill.material, texture);\n          guiControl.border.fill.material.transparent = true;\n          guiControl.highlight.fill.material.transparent = true;\n          guiControl.widget.position.z = 5;\n        });\n      } else if (!action) {\n        guiControl.setMaterialTexture(guiControl.border.fill.material, undefined);\n        guiControl.setMaterialTexture(guiControl.highlight.fill.material, undefined);\n        guiControl.setFillTextureName('');\n      }\n    } else {\n      guiControl.setMaterialTexture(guiControl.border.fill.material, undefined);\n      guiControl.setMaterialTexture(guiControl.highlight.fill.material, undefined);\n      guiControl.setFillTextureName('');\n    }\n  }\n\n  UpdateTargetUIPanels() {\n    if (!this._canShowTargetUI()) {\n      GameState.ActionMenuManager.SetTarget(undefined);\n      this.LBL_NAME?.hide();\n      this.LBL_NAMEBG?.hide();\n      this.PB_HEALTH?.hide();\n      this.LBL_HEALTHBG?.hide();\n      for (let i = 0; i < 3; i++) {\n        this.getControlByName('BTN_TARGET' + i)?.hide();\n        this.getControlByName('LBL_TARGET' + i)?.hide();\n        this.getControlByName('BTN_TARGETUP' + i)?.hide();\n        this.getControlByName('BTN_TARGETDOWN' + i)?.hide();\n      }\n      return;\n    }\n\n    if (BitWise.InstanceOfObject(GameState.CursorManager.selectedObject, ModuleObjectType.ModuleCreature)) {\n      if (GameState.CursorManager.selectedObject.isHostile(GameState.getCurrentPlayer()) && this.PB_HEALTH.getFillTextureName() == 'friend_bar') {\n        this.PB_HEALTH.setFillTextureName('enemy_bar');\n        TextureLoader.Load('enemy_bar').then((map: OdysseyTexture) => {\n          this.PB_HEALTH.setFillTexture(map);\n        });\n      } else if (!GameState.CursorManager.selectedObject.isHostile(GameState.getCurrentPlayer()) && this.PB_HEALTH.getFillTextureName() == 'enemy_bar') {\n        this.PB_HEALTH.setFillTextureName('friend_bar');\n        TextureLoader.Load('friend_bar').then((map: OdysseyTexture) => {\n          this.PB_HEALTH.setFillTexture(map);\n        });\n      }\n    } else {\n      if (this.PB_HEALTH.getFillTextureName() != 'friend_bar') {\n        this.PB_HEALTH.setFillTextureName('friend_bar');\n        TextureLoader.Load('friend_bar').then((map: OdysseyTexture) => {\n          this.PB_HEALTH.setFillTexture(map);\n        });\n      }\n    }\n    if (this.manager.InGameOverlay.LBL_NAME.text.text != GameState.CursorManager.selectedObject.getName()) {\n      this.LBL_NAME.setText(GameState.CursorManager.selectedObject.getName(), 25);\n    }\n    let health = 100 * Math.min(Math.max(GameState.CursorManager.selectedObject.getHP() / GameState.CursorManager.selectedObject.getMaxHP(), 0), 1);\n    if (health > 100)\n      health = 100;\n    this.PB_HEALTH.setProgress(health);\n    const maxBoundsX = GameState.ResolutionManager.getViewportWidth() / 2 + 640 / 2 - 125;\n    const maxBoundsX2 = GameState.ResolutionManager.getViewportWidth() / 2 - 640 / 2 - 125;\n    const targetScreenPosition = new THREE.Vector3(640 / 2, 480 / 2, 0);\n    let pos = new THREE.Vector3();\n    if (BitWise.InstanceOfObject(GameState.CursorManager.selectedObject, ModuleObjectType.ModuleCreature)) {\n      pos.copy(GameState.CursorManager.selectedObject.position);\n      pos.z += 2;\n    } else {\n      pos = pos.setFromMatrixPosition(GameState.CursorManager.reticle2.matrixWorld);\n    }\n    pos.project(GameState.currentCamera);\n    const widthHalf = GameState.ResolutionManager.getViewportWidth() / 2;\n    const heightHalf = GameState.ResolutionManager.getViewportHeight() / 2;\n    pos.x = pos.x * widthHalf;\n    pos.y = -(pos.y * heightHalf);\n    pos.z = 0;\n    targetScreenPosition.add(pos);\n    if (targetScreenPosition.x > maxBoundsX) {\n      targetScreenPosition.x = maxBoundsX;\n    }\n    if (targetScreenPosition.x < -maxBoundsX2) {\n      targetScreenPosition.x = -maxBoundsX2;\n    }\n    if (targetScreenPosition.y > 640 / 2) {\n      targetScreenPosition.y = 640 / 2;\n    }\n    if (targetScreenPosition.y < 100) {\n      targetScreenPosition.y = 100;\n    }\n    this.LBL_NAME.scale = this.LBL_NAMEBG.scale = this.PB_HEALTH.scale = this.LBL_HEALTHBG.scale = false;\n    this.LBL_NAME?.show();\n    this.LBL_NAMEBG?.show();\n    this.PB_HEALTH?.show();\n    this.LBL_HEALTHBG?.show();\n    this.LBL_NAME.extent.left = targetScreenPosition.x - 20;\n    this.LBL_NAME.anchor = Anchor.User;\n    this.LBL_NAMEBG.extent.left = targetScreenPosition.x - 20;\n    this.LBL_NAMEBG.anchor = Anchor.User;\n    this.PB_HEALTH.extent.left = targetScreenPosition.x - 20;\n    this.PB_HEALTH.anchor = Anchor.User;\n    this.LBL_HEALTHBG.extent.left = targetScreenPosition.x - 20;\n    this.LBL_HEALTHBG.anchor = Anchor.User;\n    this.LBL_NAME.extent.top = targetScreenPosition.y - 38;\n    this.LBL_NAMEBG.extent.top = targetScreenPosition.y - 38;\n    this.PB_HEALTH.extent.top = targetScreenPosition.y - 12;\n    this.LBL_HEALTHBG.extent.top = targetScreenPosition.y - 12;\n    this.LBL_NAME.recalculate();\n    this.LBL_NAMEBG.recalculate();\n    this.PB_HEALTH.recalculate();\n    this.LBL_HEALTHBG.recalculate();\n    if (GameState.ActionMenuManager.targetActionCount()) {\n      for (let i = 0; i < GameState.ActionMenuManager.TARGET_MENU_COUNT; i++) {\n        const xPos = (this.getControlByName('BTN_TARGET' + i).extent.width + 5) * i + 20;\n        this.getControlByName('BTN_TARGET' + i).scale = false;\n        this.getControlByName('BTN_TARGET' + i).extent.left = targetScreenPosition.x + xPos;\n        this.getControlByName('BTN_TARGET' + i).extent.top = targetScreenPosition.y;\n        this.getControlByName('BTN_TARGET' + i).anchor = Anchor.User;\n        this.getControlByName('LBL_TARGET' + i).scale = false;\n        this.getControlByName('LBL_TARGET' + i).extent.left = targetScreenPosition.x + xPos + 3;\n        this.getControlByName('LBL_TARGET' + i).extent.top = targetScreenPosition.y + 14;\n        this.getControlByName('LBL_TARGET' + i).anchor = Anchor.User;\n        this.getControlByName('BTN_TARGETUP' + i).scale = false;\n        this.getControlByName('BTN_TARGETUP' + i).extent.left = targetScreenPosition.x + xPos;\n        this.getControlByName('BTN_TARGETUP' + i).extent.top = targetScreenPosition.y + 5;\n        this.getControlByName('BTN_TARGETUP' + i).anchor = Anchor.User;\n        this.getControlByName('BTN_TARGETDOWN' + i).scale = false;\n        this.getControlByName('BTN_TARGETDOWN' + i).extent.left = targetScreenPosition.x + xPos;\n        this.getControlByName('BTN_TARGETDOWN' + i).extent.top = targetScreenPosition.y + (this.getControlByName('BTN_TARGET' + i).extent.height / 2 + 12);\n        this.getControlByName('BTN_TARGETDOWN' + i).widget.rotation.z = Math.PI;\n        this.getControlByName('BTN_TARGETDOWN' + i).anchor = Anchor.User;\n        this.UpdateTargetUIIcon(i);\n        this.getControlByName('BTN_TARGETUP' + i).recalculate();\n        this.getControlByName('BTN_TARGETDOWN' + i).recalculate();\n        this.getControlByName('BTN_TARGET' + i).recalculate();\n        this.getControlByName('LBL_TARGET' + i).recalculate();\n        this.getControlByName('BTN_TARGET' + i)?.show();\n        this.getControlByName('LBL_TARGET' + i)?.show();\n\n        if (GameState.ActionMenuManager.ActionPanels.targetPanels[i].actions.length <= 1) {\n          this.getControlByName('BTN_TARGETUP' + i)?.hide();\n          this.getControlByName('BTN_TARGETDOWN' + i)?.hide();\n        } else {\n          this.getControlByName('BTN_TARGETUP' + i)?.show();\n          this.getControlByName('BTN_TARGETDOWN' + i)?.show();\n        }\n      }\n    } else {\n      for (let i = 0; i < 3; i++) {\n        this.getControlByName('BTN_TARGET' + i)?.hide();\n        this.getControlByName('LBL_TARGET' + i)?.hide();\n        this.getControlByName('BTN_TARGETUP' + i)?.hide();\n        this.getControlByName('BTN_TARGETDOWN' + i)?.hide();\n      }\n    }\n  }\n\n  UpdateSelfUIPanels(delta = 0) {\n    for (let i = 0; i < GameState.ActionMenuManager.SELF_MENU_COUNT; i++) {\n      this.UpdateSelfUIIcon(i);\n      this.getControlByName('BTN_ACTIONUP' + i).recalculate();\n      this.getControlByName('BTN_ACTIONDOWN' + i).recalculate();\n\n      if (GameState.ActionMenuManager.ActionPanels.selfPanels[i].actions.length <= 1) {\n        this.getControlByName('BTN_ACTIONUP' + i)?.hide();\n        this.getControlByName('BTN_ACTIONDOWN' + i)?.hide();\n      } else {\n        this.getControlByName('BTN_ACTIONUP' + i)?.show();\n        this.getControlByName('BTN_ACTIONDOWN' + i)?.show();\n      }\n    }\n  }\n\n  /**\n   * Update HUD Notification Icons\n   *\n   * @param delta\n   */\n  UpdateHUDNotificationIcons(delta = 0) {\n    if (GameState.UINotificationManager.bNotificationSoundQueued) {\n      GameState.UINotificationManager.bNotificationSoundQueued = false;\n      GameState.guiAudioEmitter.playSoundFireAndForget('gui_quest');\n    }\n    /**\n     * Item Lost\n     */\n    if (GameState.UINotificationManager.ItemLostTimer > 0) {\n      this.LBL_ITEMLOST.show();\n      this.LBL_ITEMLOST.pulsing = true;\n      GameState.UINotificationManager.ItemLostTimer -= delta;\n    } else {\n      GameState.UINotificationManager.ItemLostTimer = 0;\n      this.LBL_ITEMLOST.hide();\n    }\n\n    /**\n     * Item Received\n     */\n    if (GameState.UINotificationManager.ItemReceivedTimer > 0) {\n      this.LBL_ITEMRCVD.show();\n      this.LBL_ITEMRCVD.pulsing = true;\n      GameState.UINotificationManager.ItemReceivedTimer -= delta;\n    } else {\n      GameState.UINotificationManager.ItemReceivedTimer = 0;\n      this.LBL_ITEMRCVD.hide();\n    }\n\n    /**\n     * Credits Received\n     */\n    if (GameState.UINotificationManager.CreditsReceivedTimer > 0) {\n      this.LBL_CASH.show();\n      this.LBL_CASH.pulsing = true;\n      GameState.UINotificationManager.CreditsReceivedTimer -= delta;\n    } else {\n      GameState.UINotificationManager.CreditsReceivedTimer = 0;\n      this.LBL_CASH.hide();\n    }\n\n    /**\n     * Journal Entry Added\n     */\n    if (GameState.UINotificationManager.JournalEntryAddedTimer > 0) {\n      this.LBL_JOURNAL.show();\n      this.LBL_JOURNAL.pulsing = true;\n      GameState.UINotificationManager.JournalEntryAddedTimer -= delta;\n    } else {\n      GameState.UINotificationManager.JournalEntryAddedTimer = 0;\n      this.LBL_JOURNAL.hide();\n    }\n\n    /**\n     * Light Shift\n     */\n    if (GameState.UINotificationManager.LightShiftTimer > 0) {\n      this.LBL_LIGHTSHIFT.show();\n      this.LBL_LIGHTSHIFT.pulsing = true;\n      GameState.UINotificationManager.LightShiftTimer -= delta;\n    } else {\n      GameState.UINotificationManager.LightShiftTimer = 0;\n      this.LBL_LIGHTSHIFT.hide();\n    }\n\n    /**\n     * Dark Shift\n     */\n    if (GameState.UINotificationManager.DarkShiftTimer > 0) {\n      this.LBL_DARKSHIFT.show();\n      this.LBL_DARKSHIFT.pulsing = true;\n      GameState.UINotificationManager.DarkShiftTimer -= delta;\n    } else {\n      GameState.UINotificationManager.DarkShiftTimer = 0;\n      this.LBL_DARKSHIFT.hide();\n    }\n\n    /**\n     * Plot XP Received\n     */\n    if (GameState.UINotificationManager.PlotXPReceivedTimer > 0) {\n      this.LBL_PLOTXP.show();\n      this.LBL_PLOTXP.pulsing = true;\n      GameState.UINotificationManager.PlotXPReceivedTimer -= delta;\n    } else {\n      GameState.UINotificationManager.PlotXPReceivedTimer = 0;\n      this.LBL_PLOTXP.hide();\n    }\n\n    /**\n     * Stealth XP Received\n     */\n    if (GameState.UINotificationManager.StealthXPReceivedTimer > 0) {\n      this.LBL_STEALTHXP.show();\n      this.LBL_STEALTHXP.pulsing = true;\n      GameState.UINotificationManager.StealthXPReceivedTimer -= delta;\n    } else {\n      GameState.UINotificationManager.StealthXPReceivedTimer = 0;\n      this.LBL_STEALTHXP.hide();\n    }\n  }\n\n  update(delta = 0) {\n    super.update(delta);\n    if (!this.bVisible)\n      return;\n\n    if (GameState.module.area.miniGame) { return; }\n\n    const oPC = GameState.getCurrentPlayer();\n    GameState.ActionMenuManager.SetPC(oPC);\n    GameState.ActionMenuManager.SetTarget(GameState.CursorManager.selectedObject);\n    GameState.ActionMenuManager.UpdateMenuActions();\n    this.UpdateTargetUIPanels();\n    this.UpdateSelfUIPanels();\n    this.UpdateHUDNotificationIcons(delta);\n\n    //update minimap\n    this.miniMap.setPosition(oPC.position.x, oPC.position.y);\n    this.miniMap.setRotation(GameState.controls.camera.rotation.z);\n    this.miniMap.render(delta);\n\n    this.TogglePartyMember(0, false);\n    this.TogglePartyMember(1, false);\n    this.TogglePartyMember(2, false);\n\n    for (let i = 0; i < GameState.PartyManager.party.length; i++) {\n      const partyMember = GameState.PartyManager.party[i];\n      let id = i;\n      switch (i) {\n        case 1:\n          id = 2;\n          break;\n        case 2:\n          id = 1;\n          break;\n      }\n      this.TogglePartyMember(id, true);\n      const pmBG = this.getControlByName('LBL_CHAR' + (id + 1));\n      const portraitResRef = partyMember.getPortraitResRef();\n      if (pmBG.getFillTextureName() != portraitResRef) {\n        pmBG.setFillTextureName(portraitResRef);\n        TextureLoader.tpcLoader.fetch(portraitResRef).then((texture: OdysseyTexture) => {\n          pmBG.setFillTexture(texture);\n        });\n      }\n      (this.getControlByName('PB_VIT' + (id + 1)) as GUIProgressBar).setProgress(Math.min(Math.max(partyMember.getHP() / partyMember.getMaxHP(), 0), 1) * 100);\n      (this.getControlByName('PB_FORCE' + (id + 1)) as GUIProgressBar).setProgress(Math.min(Math.max(partyMember.getFP() / partyMember.getMaxFP(), 0), 1) * 100);\n      if (partyMember.isDebilitated()) {\n        this.getControlByName('LBL_DEBILATATED' + (id + 1))?.show();\n      } else {\n        this.getControlByName('LBL_DEBILATATED' + (id + 1))?.hide();\n      }\n    }\n    if (oPC.excitedDuration || oPC.combatRound.scheduledActionList.length) {\n      this.showCombatUI();\n      const action0 = oPC.combatRound.action;\n      const action1 = oPC.combatRound.scheduledActionList[0];\n      const action2 = oPC.combatRound.scheduledActionList[1];\n      const action3 = oPC.combatRound.scheduledActionList[2];\n      if (action0 != undefined) {\n        if (this.LBL_QUEUE0.getFillTextureName() != action0.iconResRef) {\n          this.LBL_QUEUE0.setFillTextureName(action0.iconResRef);\n          TextureLoader.tpcLoader.fetch(action0.iconResRef).then((texture: OdysseyTexture) => {\n            this.LBL_QUEUE0.setFillTexture(texture);\n            this.LBL_QUEUE0.border.fill.material.transparent = true;\n          });\n        }\n      } else {\n        this.LBL_QUEUE0.setFillTextureName('');\n        this.LBL_QUEUE0.setFillTexture(undefined);\n      }\n      if (action1 != undefined) {\n        if (this.LBL_QUEUE1.getFillTextureName() != action1.iconResRef) {\n          this.LBL_QUEUE1.setFillTextureName(action1.iconResRef);\n          TextureLoader.tpcLoader.fetch(action1.iconResRef).then((texture: OdysseyTexture) => {\n            this.LBL_QUEUE1.setFillTexture(texture);\n            this.LBL_QUEUE1.border.fill.material.transparent = true;\n          });\n        }\n      } else {\n        this.LBL_QUEUE1.setFillTextureName('');\n        this.LBL_QUEUE1.setFillTexture(undefined);\n      }\n      if (action2 != undefined) {\n        if (this.LBL_QUEUE2.getFillTextureName() != action2.iconResRef) {\n          this.LBL_QUEUE2.setFillTextureName(action2.iconResRef);\n          TextureLoader.tpcLoader.fetch(action2.iconResRef).then((texture: OdysseyTexture) => {\n            this.LBL_QUEUE2.setFillTexture(texture);\n            this.LBL_QUEUE2.border.fill.material.transparent = true;\n          });\n        }\n      } else {\n        this.LBL_QUEUE2.setFillTextureName('');\n        this.LBL_QUEUE2.setFillTexture(undefined);\n      }\n      if (action3 != undefined) {\n        if (this.LBL_QUEUE3.getFillTextureName() != action3.iconResRef) {\n          this.LBL_QUEUE3.setFillTextureName(action3.iconResRef);\n          TextureLoader.tpcLoader.fetch(action3.iconResRef).then((texture: OdysseyTexture) => {\n            this.LBL_QUEUE3.setFillTexture(texture);\n            this.LBL_QUEUE3.border.fill.material.transparent = true;\n          });\n        }\n      } else {\n        this.LBL_QUEUE3.setFillTextureName('');\n        this.LBL_QUEUE3.setFillTexture(undefined);\n      }\n    } else {\n      this.hideCombatUI();\n    }\n  }\n\n  show() {\n    super.show();\n    this.BTN_ACTIONDOWN0.flipY();\n    this.BTN_ACTIONDOWN1.flipY();\n    this.BTN_ACTIONDOWN2.flipY();\n    this.BTN_ACTIONDOWN3.flipY();\n  }\n\n  resize() {\n    this.recalculatePosition();\n  }\n\n  triggerControllerAPress() {\n    if (GameState.CursorManager.selectedObject) {\n      if (typeof GameState.CursorManager.selectedObject.onClick === 'function') {\n        GameState.getCurrentPlayer().clearAllActions();\n        GameState.CursorManager.selectedObject.onClick(GameState.getCurrentPlayer());\n      } else {\n        const distance = GameState.getCurrentPlayer().position.distanceTo(GameState.CursorManager.selectedObject.position);\n        if (distance > 1.5) {\n          GameState.getCurrentPlayer().clearAllActions();\n          GameState.CursorManager.selectedObject.clearAllActions();\n          GameState.getCurrentPlayer().actionDialogObject(GameState.CursorManager.selectedObject);\n        }\n      }\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\LoadScreen.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":42,"column":7,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":42,"endColumn":104}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUILabel, GUIProgressBar } from \"@/gui\";\nimport type { ITwoDARowData } from \"@/resource/TwoDAObject\";\r\nimport { createScopedLogger } from \"@/utility/Logger\";\r\n\r\n/**\r\n * LoadScreen class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file LoadScreen.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class LoadScreen extends GameMenu {\r\n\r\n  engineMode: EngineMode = EngineMode.LOADING;\r\n  PB_PROGRESS: GUIProgressBar;\r\n  LBL_HINT: GUILabel;\r\n  LBL_LOGO: GUILabel;\r\n  LBL_LOADING: GUILabel;\r\n  defaultTex: THREE.Texture | null = null;\r\n\r\n  private static readonly log = createScopedLogger(LoadScreen.name);\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'loadscreen';\r\n    this.background = '1600x1200load';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.LBL_HINT.visible = false;\r\n      (this.defaultTex = this.tGuiPanel.getFill().material as THREE.ShaderMaterial).uniforms.map.value;\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  setProgress(val = 0) {\r\n    this.PB_PROGRESS.setProgress(val);\r\n  }\r\n\r\n  setLoadBackground(resref: string): Promise<boolean> {\r\n    return new Promise<boolean>( async (resolve, reject) => {\r\n      if (resref) {\r\n        const texture = await this.loadTexture(resref);\r\n        if (texture) {\r\n          (this.tGuiPanel.getFill().material as THREE.ShaderMaterial).uniforms.map.value = texture;\r\n          resolve(true);\r\n          return;\r\n        } else {\r\n          const default_texture = await this.loadTexture('load_default');\r\n          if(default_texture){\r\n            (this.tGuiPanel.getFill().material as THREE.ShaderMaterial).uniforms.map.value = this.defaultTex = default_texture;\r\n            resolve(true);\r\n            return;\r\n          }else{\r\n            resolve(true);\r\n            return;\r\n          }\r\n        }\r\n      } else {\r\n        resolve(false);\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  showRandomHint() {\r\n    this.LBL_LOADING.setText(GameState.TLKManager.TLKStrings[42493].Value);\r\n    const table = GameState.TwoDAManager.datatables.get('loadscreenhints');\r\n    const rowCount = table.RowCount ?? 0;\r\n    const id = Math.floor(Math.random() * (rowCount - 0 + 1)) + 0;\r\n    let hint: ITwoDARowData | undefined = table.rows[String(id)];\r\n    if (!hint) {\r\n      LoadScreen.log.info('showRandomHint fallback', id);\r\n      hint = table.rows['0'];\r\n    }\r\n    const hintRef = hint?.gameplayhint;\r\n    this.LBL_HINT.setText(GameState.TLKManager.TLKStrings[typeof hintRef === 'number' ? hintRef : 0].Value);\r\n  }\r\n\r\n  showSavingMessage() {\r\n    this.LBL_LOADING.setText(GameState.TLKManager.TLKStrings[42528].Value);\r\n    this.LBL_HINT.setText(GameState.TLKManager.TLKStrings[41926].Value);\r\n    this.setProgress(0);\r\n  }\r\n\r\n  setHintMessage(message: string = ''){\r\n    this.LBL_HINT.setText(message);\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.setProgress(0);\r\n    GameState.FadeOverlayManager.plane.visible = false;\r\n  }\r\n\r\n  hide() {\r\n    super.hide();\r\n    GameState.FadeOverlayManager.plane.visible = true;\r\n    this.setProgress(0);\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MainMenu.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":95,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":99,"column":70,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":99,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":100,"column":70,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":100,"endColumn":81}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AudioEngine } from \"@/audio/AudioEngine\";\r\nimport { AudioLoader } from \"@/audio/AudioLoader\";\r\nimport { CurrentGame } from \"@/engine/CurrentGame\";\r\nimport { MenuSaveLoadMode } from \"@/enums/gui/MenuSaveLoadMode\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu, LBL_3DView } from \"@/gui\";\r\nimport type { GUIListBox, GUILabel, GUIButton } from \"@/gui\";\r\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/**\r\n * MainMenu class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MainMenu.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MainMenu extends GameMenu {\r\n\r\n  LB_MODULES: GUIListBox;\r\n  LBL_3DVIEW: GUILabel;\r\n  LBL_GAMELOGO: GUILabel;\r\n  LBL_BW: GUILabel;\r\n  LBL_LUCAS: GUILabel;\r\n  LBL_MENUBG: GUILabel;\r\n  BTN_LOADGAME: GUIButton;\r\n  BTN_NEWGAME: GUIButton;\r\n  BTN_MOVIES: GUIButton;\r\n  BTN_OPTIONS: GUIButton;\r\n  LBL_NEWCONTENT: GUILabel;\r\n  BTN_WARP: GUIButton;\r\n  BTN_EXIT: GUIButton;\r\n  _3dViewModel: OdysseyModel3D;\r\n  _3dView: LBL_3DView;\r\n  bgMusicBuffer: ArrayBuffer;\r\n  bgMusicResRef: string = 'mus_theme_cult';\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'mainmenu16x12';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n    this.userCanClose = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.selectedControl = this.BTN_NEWGAME;\r\n\r\n      this.LB_MODULES.hide();\r\n      this.LBL_BW.hide();\r\n      this.LBL_LUCAS.hide();\r\n      this.LBL_NEWCONTENT.hide();\r\n      this.BTN_WARP.hide();\r\n\r\n      this.BTN_NEWGAME.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.CharGenManager.Start();\r\n      });\r\n\r\n      this.BTN_LOADGAME.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //Game.LoadModule('danm14aa', null, () => { log.info('ready to load'); })\r\n        this.manager.MenuSaveLoad.mode = MenuSaveLoadMode.LOADGAME;\r\n        this.manager.MenuSaveLoad.open()\r\n      });\r\n\r\n      this.BTN_MOVIES.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //this.Hide();\r\n        this.manager.MainMovies.open();\r\n        //Game.LoadModule('danm14aa', null, () => { log.info('ready to load'); })\r\n      });\r\n\r\n      this.BTN_OPTIONS.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //this.Hide();\r\n        this.manager.MainOptions.open();\r\n      });\r\n\r\n      this.BTN_EXIT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        window.close();\r\n      });\r\n\r\n      MDLLoader.loader.load('mainmenu').then((mdl: OdysseyModel) => {\r\n        this.tGuiPanel.widget.userData.fill.visible = false;\r\n        this._3dView = new LBL_3DView();\r\n        this._3dView.setControl(this.LBL_3DVIEW);\r\n        this._3dView.visible = true;\r\n        (this.LBL_3DVIEW.getFill().material as THREE.ShaderMaterial).uniforms.map.value = this._3dView.texture.texture;\r\n        (this.LBL_3DVIEW.getFill().material as THREE.ShaderMaterial).transparent = false;\r\n        this._3dView.setControl(this.LBL_3DVIEW);\r\n        (this.LBL_3DVIEW.getFill().material as { visible?: boolean }).visible = true;\r\n        \r\n        OdysseyModel3D.FromMDL(mdl, { \r\n          // manageLighting: false,\r\n          context: this._3dView\r\n        }).then( (model: OdysseyModel3D) => {\r\n          log.debug('Model Loaded', model);\r\n          this._3dViewModel = model;\r\n          \r\n          this._3dView.camera.position.copy(model.camerahook.position);\r\n          this._3dView.camera.quaternion.copy(model.camerahook.quaternion);\r\n\r\n          this._3dView.addModel(this._3dViewModel);\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this._3dViewModel.playAnimation(0, true);\r\n            resolve();\r\n          });\r\n        }).catch((e: unknown) => {\r\n\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  Start(){\r\n    return new Promise<void>( (resolve, reject) => {\r\n      this.manager.ClearMenus(); \r\n      AudioLoader.LoadMusic(this.bgMusicResRef).then((data: Uint8Array) => {\r\n        AudioEngine.GetAudioEngine().setAudioBuffer('BACKGROUND_MUSIC_DAY', data.buffer as ArrayBuffer, this.bgMusicResRef);\r\n        AudioEngine.GetAudioEngine().areaMusicDayAudioEmitter.play();\r\n        this.open();\r\n        resolve();\r\n      }, () => {\r\n        this.open();\r\n        log.error('Background Music not found', this.bgMusicResRef);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  update(delta = 0) {\r\n    super.update(delta);\r\n    try {\r\n      this._3dView.render(delta);\r\n    } catch (e: unknown) {\r\n      log.error(e instanceof Error ? e : String(e));\r\n    }\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    if(this.bgMusicBuffer){\r\n      AudioEngine.GetAudioEngine().setAudioBuffer('BACKGROUND_MUSIC_DAY', this.bgMusicBuffer, this.bgMusicResRef);\r\n      AudioEngine.GetAudioEngine().areaMusicDayAudioEmitter.play();\r\n    }\r\n    GameState.AlphaTest = 0.5;\r\n    CurrentGame.InitGameInProgressFolder(false).then( () => {\r\n\r\n    });\r\n  }\r\n\r\n  triggerControllerDUpPress() {\r\n    if (!this.selectedControl) {\r\n      this.selectedControl = this.BTN_NEWGAME;\r\n    }\r\n    this.BTN_NEWGAME.onHoverOut();\r\n    this.BTN_LOADGAME.onHoverOut();\r\n    this.BTN_MOVIES.onHoverOut();\r\n    this.BTN_OPTIONS.onHoverOut();\r\n    this.BTN_EXIT.onHoverOut();\r\n    if (this.selectedControl == this.BTN_EXIT) {\r\n      this.selectedControl = this.BTN_OPTIONS;\r\n    } else if (this.selectedControl == this.BTN_OPTIONS) {\r\n      this.selectedControl = this.BTN_MOVIES;\r\n    } else if (this.selectedControl == this.BTN_MOVIES) {\r\n      this.selectedControl = this.BTN_LOADGAME;\r\n    } else if (this.selectedControl == this.BTN_LOADGAME) {\r\n      this.selectedControl = this.BTN_NEWGAME;\r\n    } else if (this.selectedControl == this.BTN_NEWGAME) {\r\n      this.selectedControl = this.BTN_EXIT;\r\n    }\r\n    this.selectedControl.onHoverIn();\r\n  }\r\n\r\n  triggerControllerDDownPress() {\r\n    if (!this.selectedControl) {\r\n      this.selectedControl = this.BTN_NEWGAME;\r\n    }\r\n    this.BTN_NEWGAME.onHoverOut();\r\n    this.BTN_LOADGAME.onHoverOut();\r\n    this.BTN_MOVIES.onHoverOut();\r\n    this.BTN_OPTIONS.onHoverOut();\r\n    this.BTN_EXIT.onHoverOut();\r\n    if (this.selectedControl == this.BTN_NEWGAME) {\r\n      this.selectedControl = this.BTN_LOADGAME;\r\n    } else if (this.selectedControl == this.BTN_LOADGAME) {\r\n      this.selectedControl = this.BTN_MOVIES;\r\n    } else if (this.selectedControl == this.BTN_MOVIES) {\r\n      this.selectedControl = this.BTN_OPTIONS;\r\n    } else if (this.selectedControl == this.BTN_OPTIONS) {\r\n      this.selectedControl = this.BTN_EXIT;\r\n    } else if (this.selectedControl == this.BTN_EXIT) {\r\n      this.selectedControl = this.BTN_NEWGAME;\r\n    }\r\n    this.selectedControl.onHoverIn();\r\n  }\r\n\r\n  triggerControllerAPress() {\r\n    if (this.selectedControl) {\r\n      this.selectedControl.click();\r\n    }\r\n  }\r\n\r\n  triggerControllerBPress() {\r\n    this.BTN_EXIT.click();\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuCharacter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":118,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":118,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":119,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":119,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Texture<unknown>`.","line":190,"column":44,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":190,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":254,"column":33,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":254,"endColumn":160},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":254,"column":33,"nodeType":"MemberExpression","messageId":"errorCall","endLine":254,"endColumn":130}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { GameState } from \"@/GameState\";\nimport { GameMenu, LBL_3DView } from \"@/gui\";\nimport type { GUILabel, GUIButton, GUISlider, GUIControl } from \"@/gui\";\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\nimport type { ModuleCreature, ModuleItem } from \"@/module\";\nimport { OdysseyModel3D } from \"@/three/odyssey\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { OdysseyModel } from \"@/odyssey\";\n\n/**\n * MenuCharacter class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file MenuCharacter.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class MenuCharacter extends GameMenu {\n\n  LBL_3DCHAR: GUILabel;\n  BTN_3DCHAR: GUIButton;\n  LBL_ADORN: GUILabel;\n  SLD_ALIGN: GUISlider;\n  LBL_STR: GUILabel;\n  LBL_FORTITUDE_STAT: GUILabel;\n  LBL_REFLEX_STAT: GUILabel;\n  LBL_WILL_STAT: GUILabel;\n  LBL_DEFENSE_STAT: GUILabel;\n  LBL_FORCE_STAT: GUILabel;\n  LBL_VITALITY_STAT: GUILabel;\n  LBL_DEX: GUILabel;\n  LBL_CON: GUILabel;\n  LBL_INT: GUILabel;\n  LBL_CHA: GUILabel;\n  LBL_WIS: GUILabel;\n  LBL_STR_MOD: GUILabel;\n  LBL_DEX_MOD: GUILabel;\n  LBL_CON_MOD: GUILabel;\n  LBL_INT_MOD: GUILabel;\n  LBL_WIS_MOD: GUILabel;\n  LBL_CHA_MOD: GUILabel;\n  LBL_CLASS1: GUILabel;\n  LBL_EXPERIENCE_STAT: GUILabel;\n  LBL_NAME: GUILabel;\n  LBL_NEEDED_XP: GUILabel;\n  LBL_STRENGTH: GUILabel;\n  LBL_DEXTERITY: GUILabel;\n  LBL_CONSTITUTION: GUILabel;\n  LBL_INTELLIGENCE: GUILabel;\n  LBL_CHARISMA: GUILabel;\n  LBL_REFLEX: GUILabel;\n  LBL_WILL: GUILabel;\n  LBL_EXPERIENCE: GUILabel;\n  LBL_NEXT_LEVEL: GUILabel;\n  LBL_FORCE: GUILabel;\n  LBL_VITALITY: GUILabel;\n  LBL_DEFENSE: GUILabel;\n  LBL_FORTITUDE: GUILabel;\n  LBL_BEVEL: GUILabel;\n  LBL_CLASS2: GUILabel;\n  LBL_WISDOM: GUILabel;\n  LBL_CLASS: GUILabel;\n  LBL_LEVEL: GUILabel;\n  LBL_LEVEL1: GUILabel;\n  LBL_LEVEL2: GUILabel;\n  LBL_GOOD1: GUIButton;\n  LBL_GOOD2: GUIButton;\n  LBL_GOOD3: GUIButton;\n  LBL_GOOD4: GUIButton;\n  LBL_GOOD5: GUIButton;\n  LBL_GOOD6: GUIButton;\n  LBL_GOOD7: GUIButton;\n  LBL_GOOD8: GUIButton;\n  LBL_GOOD9: GUIButton;\n  LBL_GOOD10: GUIButton;\n  LBL_BEVEL2: GUILabel;\n  LBL_MORE: GUILabel;\n  LBL_LIGHT: GUILabel;\n  LBL_DARK: GUILabel;\n  BTN_EXIT: GUIButton;\n  BTN_SCRIPTS: GUIButton;\n  BTN_AUTO: GUIButton;\n  BTN_LEVELUP: GUIButton;\n  BTN_CHANGE1: GUIButton;\n  BTN_CHANGE2: GUIButton;\n  _3dViewModel: OdysseyModel3D;\n  _3dView: LBL_3DView;\n  char: OdysseyModel3D;\n\n  constructor(){\n    super();\n    this.gui_resref = 'character';\n    this.background = '1600x1200back';\n    this.voidFill = true;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if(skipInit) return;\n    this.childMenu = this.manager.MenuTop;\n    return new Promise<void>((resolve, reject) => {\n      this.SLD_ALIGN.setVertical();\n      this.SLD_ALIGN.disableSelection = true;\n\n      this.BTN_EXIT.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.close();\n      });\n      this._button_b = this.BTN_EXIT;\n\n      this.BTN_AUTO.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(GameState.getCurrentPlayer().canLevelUp()){\n          GameState.getCurrentPlayer().autoLevelUp();\n          this.updateCharacterStats(GameState.getCurrentPlayer());\n        }\n      });\n      this._button_y = this.BTN_AUTO;\n\n      this.BTN_CHANGE1?.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (GameState.PartyManager.party.length > 1) {\n          GameState.PartyManager.SwitchLeaderAtIndex(1);\n          this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n          this.updateCharacterStats(GameState.PartyManager.party[0]);\n          this.updatePartyMemberPortraitButtons();\n        }\n      });\n      this.BTN_CHANGE2?.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (GameState.PartyManager.party.length > 2) {\n          GameState.PartyManager.SwitchLeaderAtIndex(2);\n          this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n          this.updateCharacterStats(GameState.PartyManager.party[0]);\n          this.updatePartyMemberPortraitButtons();\n        }\n      });\n\n      GameState.PartyManager.AddEventListener('change', () => {\n        if (!this.bVisible) return;\n        this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n        this.updateCharacterStats(GameState.PartyManager.party[0]);\n        this.updatePartyMemberPortraitButtons();\n      });\n\n      MDLLoader.loader.load('charrec_light').then((mdl: OdysseyModel) => {\n\n        //this.tGuiPanel.widget.children[2].children[0].position.z = -0.5;\n        this._3dView = new LBL_3DView(this.LBL_3DCHAR.extent.width, this.LBL_3DCHAR.extent.height);\n        this._3dView.setControl(this.LBL_3DCHAR);\n        this._3dView.visible = true;\n\n        this.LBL_GOOD1?.hide();\n        this.LBL_GOOD2?.hide();\n        this.LBL_GOOD3?.hide();\n        this.LBL_GOOD4?.hide();\n        this.LBL_GOOD5?.hide();\n        this.LBL_GOOD6?.hide();\n        this.LBL_GOOD7?.hide();\n        this.LBL_GOOD8?.hide();\n        this.LBL_GOOD9?.hide();\n        this.LBL_GOOD10?.hide();\n        this.LBL_MORE?.hide();\n\n        this.BTN_AUTO?.hide();\n        this.BTN_LEVELUP?.hide();\n\n        OdysseyModel3D.FromMDL(mdl, {\n          // manageLighting: false,\n          context: this._3dView\n        }).then((model: OdysseyModel3D) => {\n          //log.info('Model Loaded', model);\n          this._3dViewModel = model;\n          this._3dView.addModel(this._3dViewModel);\n\n          this._3dView.camera.position.copy(\n            model.camerahook.position\n          );\n\n          this._3dView.camera.quaternion.copy(\n            model.camerahook.quaternion\n          );\n\n          TextureLoader.LoadQueue().then(() => {\n            this.LBL_3DCHAR.setFillTexture(this.LBL_3DCHAR.getFillTexture());\n            this._3dViewModel.playAnimation(0, true);\n            resolve();\n          });\n\n        }).catch((e: unknown) => {\n          resolve();\n        });\n      }).catch((e: unknown) => {\n        resolve();\n      });\n    });\n  }\n\n  update(delta = 0) {\n    super.update(delta);\n    if (!this.bVisible)\n      return;\n    if (this.char)\n      this.char.update(delta);\n    try {\n      this._3dView.render(delta);\n    } catch (e: unknown) {\n    }\n  }\n\n  updateCharacterStats(character: ModuleCreature) {\n    if(!character) return;\n    this.LBL_CLASS1?.hide();\n    this.LBL_LEVEL1?.hide();\n    this.LBL_CLASS2?.hide();\n    this.LBL_LEVEL2?.hide();\n    if (character.classes[0]) {\n      this.LBL_LEVEL1?.setText(character.classes[0].level);\n      this.LBL_LEVEL1?.show();\n      if(this.LBL_CLASS1){\n        this.LBL_CLASS1.setText(character.classes[0].getName());\n        this.LBL_CLASS1.show();\n        this.LBL_CLASS1.extent.top = 98;\n        this.LBL_CLASS1.recalculate();\n      }\n    }\n    if (character.classes[1]) {\n      this.LBL_CLASS2?.setText(character.classes[1].getName());\n      this.LBL_LEVEL2?.setText(character.classes[1].level);\n      this.LBL_CLASS2?.show();\n      this.LBL_LEVEL2?.show();\n    }\n    this.LBL_VITALITY_STAT?.setText(character.getHP() + '/' + character.getMaxHP());\n    this.LBL_FORCE_STAT?.setText(character.getFP() + '/' + character.getMaxFP());\n    this.LBL_DEFENSE_STAT?.setText(character.getAC());\n    this.LBL_STR?.setText(character.getSTR());\n    this.LBL_DEX?.setText(character.getDEX());\n    this.LBL_CON?.setText(character.getCON());\n    this.LBL_INT?.setText(character.getINT());\n    this.LBL_WIS?.setText(character.getWIS());\n    this.LBL_CHA?.setText(character.getCHA());\n    this.LBL_STR_MOD?.setText(Math.floor((character.getSTR() - 10) / 2));\n    this.LBL_DEX_MOD?.setText(Math.floor((character.getDEX() - 10) / 2));\n    this.LBL_CON_MOD?.setText(Math.floor((character.getCON() - 10) / 2));\n    this.LBL_INT_MOD?.setText(Math.floor((character.getINT() - 10) / 2));\n    this.LBL_WIS_MOD?.setText(Math.floor((character.getWIS() - 10) / 2));\n    this.LBL_CHA_MOD?.setText(Math.floor((character.getCHA() - 10) / 2));\n    this.LBL_EXPERIENCE_STAT?.setText(character.experience.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ','));\n    this.LBL_NEEDED_XP?.setText(GameState.TwoDAManager.datatables.get('exptable').rows[character.getTotalClassLevel()].xp.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ','));\n    if (character.canLevelUp()) {\n      this.BTN_AUTO?.show();\n    } else {\n      this.BTN_AUTO?.hide();\n    }\n  }\n\n  /**\n   * Refresh the party member portrait buttons (BTN_CHANGE1, BTN_CHANGE2) to match current party order.\n   */\n  updatePartyMemberPortraitButtons() {\n    this.BTN_CHANGE1?.hide();\n    this.BTN_CHANGE2?.hide();\n    let btn_change: GUIControl;\n    for (let i = 0; i < GameState.PartyManager.party.length; i++) {\n      btn_change = this.getControlByName('BTN_CHANGE' + i);\n      if (btn_change) {\n        const partyMember = GameState.PartyManager.party[i];\n        const portraitResRef = partyMember.getPortraitResRef();\n        if (i) {\n          btn_change.show();\n          if (btn_change.getFillTextureName() != portraitResRef) {\n            btn_change.setFillTextureName(portraitResRef);\n          }\n        }\n      }\n    }\n  }\n\n  show() {\n    super.show();\n    this.manager.MenuTop.LBLH_CHA.onHoverIn();\n    this.recalculatePosition();\n    this.SLD_ALIGN?.setValue(0.5);\n    this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n    this.updateCharacterStats(GameState.PartyManager.party[0]);\n    this.updatePartyMemberPortraitButtons();\n  }\n\n  updateCharacterPortrait( creature: ModuleCreature ){\n    if(!creature) return;\n\n    this.SLD_ALIGN?.setValue(creature.getGoodEvil()/100);\n\n    if (this.char) {\n      this._3dViewModel.children[0].children[0].remove(this.char);\n    }\n    if(creature){\n      this._3dView.camera.position.z = 1;\n      const objectCreature = new GameState.Module.ModuleArea.ModuleCreature();\n      const clone = creature;\n      objectCreature.appearance = clone.appearance;\n      objectCreature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(objectCreature.appearance);\n      if (clone.equipment.ARMOR) {\n        objectCreature.equipment.ARMOR = new GameState.Module.ModuleArea.ModuleItem(clone.equipment.ARMOR.template);\n      }\n      if (clone.goodEvil >= 95) {\n        this._3dViewModel.playAnimation('good');\n      } else if (clone.goodEvil >= 90) {\n        this._3dViewModel.playAnimation('align18');\n      } else if (clone.goodEvil >= 85) {\n        this._3dViewModel.playAnimation('align17');\n      } else if (clone.goodEvil >= 80) {\n        this._3dViewModel.playAnimation('align16');\n      } else if (clone.goodEvil >= 75) {\n        this._3dViewModel.playAnimation('align15');\n      } else if (clone.goodEvil >= 70) {\n        this._3dViewModel.playAnimation('align14');\n      } else if (clone.goodEvil >= 65) {\n        this._3dViewModel.playAnimation('align13');\n      } else if (clone.goodEvil >= 60) {\n        this._3dViewModel.playAnimation('align12');\n      } else if (clone.goodEvil >= 55) {\n        this._3dViewModel.playAnimation('align11');\n      } else if (clone.goodEvil >= 50) {\n        this._3dViewModel.playAnimation('align10');\n      } else if (clone.goodEvil >= 45) {\n        this._3dViewModel.playAnimation('align9');\n      } else if (clone.goodEvil >= 40) {\n        this._3dViewModel.playAnimation('align8');\n      } else if (clone.goodEvil >= 35) {\n        this._3dViewModel.playAnimation('align7');\n      } else if (clone.goodEvil >= 30) {\n        this._3dViewModel.playAnimation('align6');\n      } else if (clone.goodEvil >= 25) {\n        this._3dViewModel.playAnimation('align5');\n      } else if (clone.goodEvil >= 20) {\n        this._3dViewModel.playAnimation('align4');\n      } else if (clone.goodEvil >= 15) {\n        this._3dViewModel.playAnimation('align3');\n      } else if (clone.goodEvil >= 10) {\n        this._3dViewModel.playAnimation('align2');\n      } else if (clone.goodEvil >= 5) {\n        this._3dViewModel.playAnimation('align1');\n      } else if (clone.goodEvil >= 0) {\n        this._3dViewModel.playAnimation('evil');\n      }\n      objectCreature.loadModel().then( (model: OdysseyModel3D) => {\n        model.position.set(0, 0, 0);\n        model.rotation.x = -Math.PI / 2;\n        model.rotation.z = Math.PI;\n        model.box = new THREE.Box3().setFromObject(model);\n        this.char = model;\n        this._3dViewModel.children[0].children[0].add(this.char);\n        TextureLoader.LoadQueue().then(() => {\n          if (clone.goodEvil >= 95) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 90) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 85) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 80) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 75) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 70) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 65) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 60) {\n            this.char.playAnimation('good', true);\n          } else if (clone.goodEvil >= 55) {\n            this.char.playAnimation('neutral', true);\n          } else if (clone.goodEvil >= 50) {\n            this.char.playAnimation('neutral', true);\n          } else if (clone.goodEvil >= 45) {\n            this.char.playAnimation('neutral', true);\n          } else if (clone.goodEvil >= 40) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 35) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 30) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 25) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 20) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 15) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 10) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 5) {\n            this.char.playAnimation('evil', true);\n          } else if (clone.goodEvil >= 0) {\n            this.char.playAnimation('evil', true);\n          }\n        });\n      });\n    }\n  }\n\n  triggerControllerBumperLPress() {\n    this.manager.MenuTop.BTN_INV.click();\n  }\n\n  triggerControllerBumperRPress() {\n    this.manager.MenuTop.BTN_ABI.click();\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuEquipment.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":92,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":93,"column":52,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":93,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":94,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":94,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":95,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":95,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":96,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":96,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":97,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":97,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":98,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":98,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":99,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":99,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":100,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":100,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":101,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":101,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":102,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":102,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":103,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":103,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":104,"column":48,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":104,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":105,"column":51,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":105,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":106,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":106,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":107,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":107,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":108,"column":48,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":108,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .alphaTest on a type that cannot be resolved.","line":109,"column":51,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":109,"endColumn":60}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleCreatureArmorSlot } from \"@/enums/module/ModuleCreatureArmorSlot\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUIListBox, GUILabel, GUIButton, GUIControl } from \"@/gui\";\r\nimport { GUIInventoryItem } from \"@/gui/protoitem/GUIInventoryItem\";\r\nimport { GUIItemEquipped } from \"@/gui/protoitem/GUIItemEquipped\";\r\nimport { GUIItemNone } from \"@/gui/protoitem/GUIItemNone\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport type { ModuleCreature } from \"@/module/ModuleCreature\";\r\nimport { ModuleItem } from \"@/module/ModuleItem\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\r\n/**\r\n * MenuEquipment class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuEquipment.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuEquipment extends GameMenu {\r\n\r\n  LBL_CANTEQUIP: GUILabel;\r\n  LBL_ATTACK_INFO: GUILabel;\r\n  LBL_TOHITR: GUILabel;\r\n  LBL_PORT_BORD: GUILabel;\r\n  LBL_PORTRAIT: GUILabel;\r\n  LB_ITEMS: GUIListBox;\r\n  LBL_DEF_INFO: GUILabel;\r\n  BTN_INV_HEAD: GUIButton;\r\n  LBL_INV_HEAD: GUILabel;\r\n  BTN_INV_IMPLANT: GUIButton;\r\n  LBL_INV_IMPLANT: GUILabel;\r\n  BTN_INV_BODY: GUIButton;\r\n  LBL_INV_BODY: GUILabel;\r\n  BTN_INV_ARM_L: GUIButton;\r\n  LBL_INV_ARM_L: GUILabel;\r\n  BTN_INV_WEAP_L: GUIButton;\r\n  LBL_INV_WEAP_L: GUILabel;\r\n  BTN_INV_BELT: GUIButton;\r\n  LBL_INV_BELT: GUILabel;\r\n  BTN_INV_WEAP_R: GUIButton;\r\n  LBL_INV_WEAP_R: GUILabel;\r\n  BTN_INV_ARM_R: GUIButton;\r\n  LBL_INV_ARM_R: GUILabel;\r\n  BTN_INV_HANDS: GUIButton;\r\n  LBL_INV_HANDS: GUILabel;\r\n  LBL_ATKL: GUILabel;\r\n  LBL_ATKR: GUILabel;\r\n  LBL_TXTBAR: GUILabel;\r\n  LBL_DEF: GUILabel;\r\n  LBL_TITLE: GUILabel;\r\n  LBL_VITALITY: GUILabel;\r\n  LBL_DAMAGE: GUILabel;\r\n  LBL_TOHITL: GUILabel;\r\n  LBL_TOHIT: GUILabel;\r\n  LBL_SLOTNAME: GUILabel;\r\n  LBL_SELECTTITLE: GUILabel;\r\n  BTN_BACK: GUIButton;\r\n  BTN_EQUIP: GUIButton;\r\n  LB_DESC: GUIListBox;\r\n  BTN_CHANGE1: GUIButton;\r\n  BTN_CHANGE2: GUIButton;\r\n\r\n  defaultControl: GUIControl;\r\n  slot: ModuleCreatureArmorSlot;\r\n  equipmentSelectionActive: boolean;\r\n  selectedItem: ModuleItem;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'equip';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    this.childMenu = this.manager.MenuTop;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.defaultControl = this.BTN_INV_BODY;\r\n\r\n      // this.LB_ITEMS.offset.x = 0;\r\n      \r\n      this.LB_DESC.hide();\r\n      this.LBL_CANTEQUIP.hide();\r\n\r\n      this.LBL_INV_IMPLANT.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_IMPLANT.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_HEAD.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_HEAD.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_HANDS.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_HANDS.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_ARM_L.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_ARM_L.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_BODY.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_BODY.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_ARM_R.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_ARM_R.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_WEAP_L.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_WEAP_L.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_BELT.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_BELT.highlight.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_WEAP_R.border.fill.material.alphaTest = 0.5;\r\n      this.LBL_INV_WEAP_R.highlight.fill.material.alphaTest = 0.5;\r\n\r\n      this.BTN_BACK = this.getControlByName('BTN_BACK');\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.equipmentSelectionActive){\r\n          this.slot = null;\r\n          this.equipmentSelectionActive = false;\r\n          this.updateList();\r\n        }else{\r\n          this.close();\r\n        }\r\n      });\r\n      this._button_b = this.BTN_BACK;\r\n\r\n      this.BTN_INV_IMPLANT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.IMPLANT;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.IMPLANT);\r\n      });\r\n\r\n      this.BTN_INV_HEAD.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.HEAD;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.HEAD);\r\n      });\r\n\r\n      this.BTN_INV_HANDS.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.ARMS;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.ARMS);\r\n      });\r\n\r\n      this.BTN_INV_ARM_L.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.LEFTARMBAND;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.LEFTARMBAND);\r\n      });\r\n\r\n      this.BTN_INV_BODY.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.ARMOR;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.ARMOR);\r\n      });\r\n\r\n      this.BTN_INV_ARM_R.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.RIGHTARMBAND;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.RIGHTARMBAND);\r\n      });\r\n\r\n      this.BTN_INV_WEAP_L.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.LEFTHAND;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.LEFTHAND);\r\n      });\r\n\r\n      this.BTN_INV_BELT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.BELT;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.BELT);\r\n      });\r\n\r\n      this.BTN_INV_WEAP_R.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.slot = ModuleCreatureArmorSlot.RIGHTHAND;\r\n        this.equipmentSelectionActive = true;\r\n        this.updateList();\r\n      }).addEventListener('hover', (e) => {\r\n        this.updateListHover(ModuleCreatureArmorSlot.RIGHTHAND);\r\n      });\r\n\r\n      this.BTN_EQUIP.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selectedItem instanceof ModuleItem){\r\n          //log.info('selectedItem', this.selectedItem, this.slot, );\r\n          const currentPC = GameState.PartyManager.party[0];\r\n          if(this.selectedItem instanceof GUIItemNone){\r\n            currentPC.unequipSlot(this.slot);\r\n          }else if(this.selectedItem instanceof ModuleItem){\r\n            currentPC.equipItem(this.slot, this.selectedItem).then( () => {\r\n              this.updateSlotIcons();\r\n            });\r\n          }\r\n          this.slot = null;\r\n          this.equipmentSelectionActive = false;\r\n          this.updateSelected(null);\r\n          this.updateSlotIcons();\r\n          this.updateList();\r\n        }\r\n      });\r\n\r\n      this.LB_ITEMS.GUIProtoItemClass = GUIInventoryItem;\r\n      this.LB_ITEMS.onSelected = (item: ModuleItem|GUIItemEquipped|GUIItemNone) => {\r\n        this.updateSelected(item);\r\n      }\r\n\r\n      this.BTN_CHANGE1.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.party.length > 0){\r\n          GameState.PartyManager.SwitchLeaderAtIndex(1);\r\n        }\r\n      });\r\n      this.BTN_CHANGE2.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.party.length > 1){\r\n          GameState.PartyManager.SwitchLeaderAtIndex(2);\r\n        }\r\n      });\r\n\r\n      GameState.PartyManager.AddEventListener('change', (pm: ModuleCreature) => {\r\n        if(!this.isVisible()) return;\r\n        this.updateCharacterStats();\r\n      });\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update the list hover.\r\n   */\r\n  updateListHover(slot: number) {\r\n    if (slot) {\r\n      this.LB_ITEMS.clearItems();\r\n      const inv = GameState.InventoryManager.getInventory(slot, GameState.getCurrentPlayer());\r\n      const currentPC = GameState.PartyManager.party[0];\r\n      this.LB_ITEMS.addItem(new GUIItemNone());\r\n      if(currentPC.GetItemInSlot(slot)){\r\n        this.LB_ITEMS.addItem(new GUIItemEquipped(currentPC.GetItemInSlot(slot)));\r\n      }\r\n      this.LB_ITEMS.select(this.LB_ITEMS.children[this.LB_ITEMS.children.length-1]);\r\n      for (let i = 0; i < inv.length; i++) {\r\n        this.LB_ITEMS.addItem(inv[i]);\r\n        TextureLoader.LoadQueue();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the list.\r\n   */\r\n  updateList() {\r\n    if (!this.equipmentSelectionActive) {\r\n      this.BTN_EQUIP?.hide();\r\n      this.BTN_BACK?.setText(GameState.TLKManager.GetStringById(1582).Value);\r\n      this.LB_DESC?.hide();\r\n      this.BTN_INV_IMPLANT?.show();\r\n      this.BTN_INV_HEAD?.show();\r\n      this.BTN_INV_HANDS?.show();\r\n      this.BTN_INV_ARM_L?.show();\r\n      this.BTN_INV_BODY?.show();\r\n      this.BTN_INV_ARM_R?.show();\r\n      this.BTN_INV_WEAP_L?.show();\r\n      this.BTN_INV_BELT?.show();\r\n      this.BTN_INV_WEAP_R?.show();\r\n      this.LBL_INV_IMPLANT?.show();\r\n      this.LBL_INV_HEAD?.show();\r\n      this.LBL_INV_HANDS?.show();\r\n      this.LBL_INV_ARM_L?.show();\r\n      this.LBL_INV_BODY?.show();\r\n      this.LBL_INV_ARM_R?.show();\r\n      this.LBL_INV_WEAP_L?.show();\r\n      this.LBL_INV_BELT?.show();\r\n      this.LBL_INV_WEAP_R?.show();\r\n      this.LBL_PORTRAIT?.show();\r\n      this.LBL_PORT_BORD?.show();\r\n      this.LBL_SLOTNAME?.show();\r\n      this.LBL_TXTBAR?.show();\r\n      this.LBL_SELECTTITLE?.setText('');\r\n    } else {\r\n      this.BTN_EQUIP?.show();\r\n      this.BTN_EQUIP?.setText(GameState.TLKManager.GetStringById(31387).Value);\r\n      this.BTN_BACK?.setText(GameState.TLKManager.GetStringById(1581).Value);\r\n      this.LB_DESC?.show();\r\n      this.BTN_INV_IMPLANT?.hide();\r\n      this.BTN_INV_HEAD?.hide();\r\n      this.BTN_INV_HANDS?.hide();\r\n      this.BTN_INV_ARM_L?.hide();\r\n      this.BTN_INV_BODY?.hide();\r\n      this.BTN_INV_ARM_R?.hide();\r\n      this.BTN_INV_WEAP_L?.hide();\r\n      this.BTN_INV_BELT?.hide();\r\n      this.BTN_INV_WEAP_R?.hide();\r\n      this.LBL_INV_IMPLANT?.hide();\r\n      this.LBL_INV_HEAD?.hide();\r\n      this.LBL_INV_HANDS?.hide();\r\n      this.LBL_INV_ARM_L?.hide();\r\n      this.LBL_INV_BODY?.hide();\r\n      this.LBL_INV_ARM_R?.hide();\r\n      this.LBL_INV_WEAP_L?.hide();\r\n      this.LBL_INV_BELT?.hide();\r\n      this.LBL_INV_WEAP_R?.hide();\r\n      this.LBL_PORTRAIT?.hide();\r\n      this.LBL_PORT_BORD?.hide();\r\n      this.LBL_SLOTNAME?.hide();\r\n      this.LBL_TXTBAR?.hide();\r\n      this.LBL_SELECTTITLE?.setText('');\r\n    }\r\n    this.LB_ITEMS.clearItems();\r\n    this.selectedItem = null;\r\n    this.updateSelected(null);\r\n    const currentPC = GameState.PartyManager.party[0];\r\n    if (this.slot) {\r\n      const inv = GameState.InventoryManager.getInventory(this.slot, currentPC);\r\n      this.LB_ITEMS.addItem(new GUIItemNone());\r\n      if(currentPC.GetItemInSlot(this.slot)){\r\n        this.LB_ITEMS.addItem(new GUIItemEquipped(currentPC.GetItemInSlot(this.slot)))\r\n      }\r\n      this.LB_ITEMS.select(this.LB_ITEMS.children[this.LB_ITEMS.children.length-1]);\r\n      for (let i = 0; i < inv.length; i++) {\r\n        this.LB_ITEMS.addItem(inv[i]);\r\n        TextureLoader.LoadQueue();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the selected item.\r\n   */\r\n  updateSelected(item: ModuleItem|GUIItemEquipped|GUIItemNone) {\r\n    this.LB_DESC.clearItems();\r\n    this.selectedItem = undefined;\r\n    if (item instanceof ModuleItem) {\r\n      this.selectedItem = item;\r\n      this.LB_DESC.addItem(this.selectedItem.getDescription());\r\n    } else if(item instanceof GUIItemEquipped) {\r\n      this.LB_DESC.addItem(item.node.getDescription());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the slot icons.\r\n   */\r\n  updateSlotIcons(force: boolean = false) {\r\n    const currentPC = GameState.PartyManager.party[0];\r\n    if(!currentPC) return;\r\n\r\n    if (currentPC.getRace() == 6) {\r\n      const implant = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.IMPLANT);\r\n      if (implant) {\r\n        const icon = 'i' + implant.baseItem.itemClass + '_' + ('000' + implant.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_IMPLANT.getFillTextureName() != icon) {\r\n          this.LBL_INV_IMPLANT.setFillTextureName(icon);\r\n\r\n        }\r\n      } else if (force || this.LBL_INV_IMPLANT.getFillTextureName() != 'iimplant') {\r\n        this.LBL_INV_IMPLANT.setFillTextureName('iimplant');\r\n      }\r\n      const head = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.HEAD);\r\n      if (head) {\r\n        const icon = 'i' + head.baseItem.itemClass + '_' + ('000' + head.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_HEAD.getFillTextureName() != icon) {\r\n          this.LBL_INV_HEAD.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_HEAD.getFillTextureName() != 'ihead') {\r\n        this.LBL_INV_HEAD.setFillTextureName('ihead');\r\n      }\r\n      const hands = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.ARMS);\r\n      if (hands) {\r\n        const icon = 'i' + hands.baseItem.itemClass + '_' + ('000' + hands.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_HANDS.getFillTextureName() != icon) {\r\n          this.LBL_INV_HANDS.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_HANDS.getFillTextureName() != 'ihands') {\r\n        this.LBL_INV_HANDS.setFillTextureName('ihands');\r\n      }\r\n      const l_arm = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.LEFTARMBAND);\r\n      if (l_arm) {\r\n        const icon = 'i' + l_arm.baseItem.itemClass + '_' + ('000' + l_arm.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_ARM_L.getFillTextureName() != icon) {\r\n          this.LBL_INV_ARM_L.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_ARM_L.getFillTextureName() != 'iforearm_l') {\r\n        this.LBL_INV_ARM_L.setFillTextureName('iforearm_l');\r\n      }\r\n      const armor = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.ARMOR);\r\n      if (armor) {\r\n        const icon = 'i' + armor.baseItem.itemClass + '_' + ('000' + armor.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_BODY.getFillTextureName() != icon) {\r\n          this.LBL_INV_BODY.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_BODY.getFillTextureName() != 'iarmor') {\r\n        this.LBL_INV_BODY.setFillTextureName('iarmor');\r\n      }\r\n      const r_arm = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.RIGHTARMBAND);\r\n      if (r_arm) {\r\n        const icon = 'i' + r_arm.baseItem.itemClass + '_' + ('000' + r_arm.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_ARM_R.getFillTextureName() != icon) {\r\n          this.LBL_INV_ARM_R.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_ARM_R.getFillTextureName() != 'iforearm_r') {\r\n        this.LBL_INV_ARM_R.setFillTextureName('iforearm_r');\r\n      }\r\n      const l_weap = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.LEFTHAND);\r\n      if (l_weap) {\r\n        const icon = 'i' + l_weap.baseItem.itemClass + '_' + ('000' + l_weap.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_WEAP_L.getFillTextureName() != icon) {\r\n          this.LBL_INV_WEAP_L.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_WEAP_L.getFillTextureName() != 'iweap_l') {\r\n        this.LBL_INV_WEAP_L.setFillTextureName('iweap_l');\r\n      }\r\n      const belt = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.BELT);\r\n      if (belt) {\r\n        const icon = 'i' + belt.baseItem.itemClass + '_' + ('000' + belt.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_BELT.getFillTextureName() != icon) {\r\n          this.LBL_INV_BELT.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_BELT.getFillTextureName() != 'ibelt') {\r\n        this.LBL_INV_BELT.setFillTextureName('ibelt');\r\n      }\r\n      const r_weap = currentPC.GetItemInSlot(ModuleCreatureArmorSlot.RIGHTHAND);\r\n      if (r_weap) {\r\n        const icon = 'i' + r_weap.baseItem.itemClass + '_' + ('000' + r_weap.getModelVariation()).slice(-3);\r\n        if (force || this.LBL_INV_WEAP_R.getFillTextureName() != icon) {\r\n          this.LBL_INV_WEAP_R.setFillTextureName(icon);\r\n        }\r\n      } else if (force || this.LBL_INV_WEAP_R.getFillTextureName() != 'iweap_r') {\r\n        this.LBL_INV_WEAP_R.setFillTextureName('iweap_r');\r\n      }\r\n    } else {\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the character stats.\r\n   */\r\n  updateCharacterStats(){\r\n    this.selectedControl = this.defaultControl;\r\n    this.equipmentSelectionActive = false;\r\n    const currentPC = GameState.PartyManager.party[0];\r\n    if (!currentPC) {\r\n      return;\r\n    }\r\n    this.LB_DESC.clearItems();\r\n    this.LB_ITEMS.clearItems();\r\n    this.LBL_VITALITY?.setText(currentPC.getHP() + '/' + currentPC.getMaxHP());\r\n    this.LBL_DEF?.setText(currentPC.getAC());\r\n    if(this.LBL_PORTRAIT.getFillTextureName() != currentPC.getPortraitResRef()){\r\n      this.LBL_PORTRAIT.setFillTextureName(currentPC.getPortraitResRef());\r\n    }\r\n    this.updateSlotIcons(true);\r\n    this.updateList();\r\n  }\r\n\r\n  /**\r\n   * Update the party member buttons.\r\n   */\r\n  updatePartyMemberButtons(){\r\n    this.BTN_CHANGE1?.hide();\r\n    this.BTN_CHANGE2?.hide();\r\n    for (let i = 0; i < GameState.PartyManager.party.length; i++) {\r\n      if (i == 0) { continue; }\r\n      \r\n      const btn_change = this.getControlByName('BTN_CHANGE' + i);\r\n      if(!btn_change){ continue; }\r\n\r\n      const partyMember = GameState.PartyManager.party[i];\r\n      if(!partyMember){ continue; }\r\n\r\n      btn_change.show();\r\n      const portraitResRef = partyMember.getPortraitResRef();\r\n      if (btn_change.getFillTextureName() != portraitResRef) {\r\n        btn_change.setFillTextureName(portraitResRef);\r\n      }\r\n    }\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.manager.MenuTop.LBLH_EQU.onHoverIn();\r\n    this.equipmentSelectionActive = false;\r\n    this.selectedControl = this.defaultControl;\r\n    this.updateList();\r\n    this.updateCharacterStats();\r\n    this.updatePartyMemberButtons();\r\n  }\r\n\r\n  triggerControllerAPress() {\r\n    if (this.equipmentSelectionActive) {\r\n      if (this.selectedControl) {\r\n        this.selectedControl.click();\r\n      }\r\n    } else {\r\n      this.BTN_EQUIP.click();\r\n    }\r\n  }\r\n\r\n  triggerControllerBumperLPress() {\r\n    this.manager.MenuTop.BTN_OPT.click();\r\n  }\r\n\r\n  triggerControllerBumperRPress() {\r\n    this.manager.MenuTop.BTN_INV.click();\r\n  }\r\n\r\n  triggerControllerDUpPress() {\r\n    if (this.equipmentSelectionActive) {\r\n      this.LB_ITEMS.directionalNavigate('up');\r\n    } else {\r\n      this.BTN_INV_IMPLANT.onHoverOut();\r\n      this.BTN_INV_HEAD.onHoverOut();\r\n      this.BTN_INV_HANDS.onHoverOut();\r\n      this.BTN_INV_ARM_L.onHoverOut();\r\n      this.BTN_INV_BODY.onHoverOut();\r\n      this.BTN_INV_ARM_R.onHoverOut();\r\n      this.BTN_INV_WEAP_L.onHoverOut();\r\n      this.BTN_INV_BELT.onHoverOut();\r\n      this.BTN_INV_WEAP_R.onHoverOut();\r\n      if (this.selectedControl == this.BTN_INV_IMPLANT) {\r\n      } else if (this.selectedControl == this.BTN_INV_HEAD) {\r\n      } else if (this.selectedControl == this.BTN_INV_HANDS) {\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_L) {\r\n        this.selectedControl = this.BTN_INV_IMPLANT;\r\n      } else if (this.selectedControl == this.BTN_INV_BODY) {\r\n        this.selectedControl = this.BTN_INV_HEAD;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_R) {\r\n        this.selectedControl = this.BTN_INV_HANDS;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_L) {\r\n        this.selectedControl = this.BTN_INV_ARM_L;\r\n      } else if (this.selectedControl == this.BTN_INV_BELT) {\r\n        this.selectedControl = this.BTN_INV_BODY;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_R) {\r\n        this.selectedControl = this.BTN_INV_ARM_R;\r\n      }\r\n      if (this.selectedControl) {\r\n        this.selectedControl.onHoverIn();\r\n      }\r\n    }\r\n  }\r\n\r\n  triggerControllerDDownPress() {\r\n    if (this.equipmentSelectionActive) {\r\n      this.LB_ITEMS.directionalNavigate('down');\r\n    } else {\r\n      this.BTN_INV_IMPLANT.onHoverOut();\r\n      this.BTN_INV_HEAD.onHoverOut();\r\n      this.BTN_INV_HANDS.onHoverOut();\r\n      this.BTN_INV_ARM_L.onHoverOut();\r\n      this.BTN_INV_BODY.onHoverOut();\r\n      this.BTN_INV_ARM_R.onHoverOut();\r\n      this.BTN_INV_WEAP_L.onHoverOut();\r\n      this.BTN_INV_BELT.onHoverOut();\r\n      this.BTN_INV_WEAP_R.onHoverOut();\r\n      if (this.selectedControl == this.BTN_INV_IMPLANT) {\r\n        this.selectedControl = this.BTN_INV_ARM_L;\r\n      } else if (this.selectedControl == this.BTN_INV_HEAD) {\r\n        this.selectedControl = this.BTN_INV_BODY;\r\n      } else if (this.selectedControl == this.BTN_INV_HANDS) {\r\n        this.selectedControl = this.BTN_INV_BODY;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_L) {\r\n        this.selectedControl = this.BTN_INV_WEAP_L;\r\n      } else if (this.selectedControl == this.BTN_INV_BODY) {\r\n        this.selectedControl = this.BTN_INV_BELT;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_R) {\r\n        this.selectedControl = this.BTN_INV_WEAP_R;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_L) {\r\n      } else if (this.selectedControl == this.BTN_INV_BELT) {\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_R) {\r\n      }\r\n      if (this.selectedControl) {\r\n        this.selectedControl.onHoverIn();\r\n      }\r\n    }\r\n  }\r\n\r\n  triggerControllerDLeftPress() {\r\n    if (this.equipmentSelectionActive) {\r\n    } else {\r\n      this.BTN_INV_IMPLANT.onHoverOut();\r\n      this.BTN_INV_HEAD.onHoverOut();\r\n      this.BTN_INV_HANDS.onHoverOut();\r\n      this.BTN_INV_ARM_L.onHoverOut();\r\n      this.BTN_INV_BODY.onHoverOut();\r\n      this.BTN_INV_ARM_R.onHoverOut();\r\n      this.BTN_INV_WEAP_L.onHoverOut();\r\n      this.BTN_INV_BELT.onHoverOut();\r\n      this.BTN_INV_WEAP_R.onHoverOut();\r\n      if (this.selectedControl == this.BTN_INV_IMPLANT) {\r\n      } else if (this.selectedControl == this.BTN_INV_HEAD) {\r\n        this.selectedControl = this.BTN_INV_IMPLANT;\r\n      } else if (this.selectedControl == this.BTN_INV_HANDS) {\r\n        this.selectedControl = this.BTN_INV_HEAD;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_L) {\r\n      } else if (this.selectedControl == this.BTN_INV_BODY) {\r\n        this.selectedControl = this.BTN_INV_ARM_L;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_R) {\r\n        this.selectedControl = this.BTN_INV_BODY;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_L) {\r\n      } else if (this.selectedControl == this.BTN_INV_BELT) {\r\n        this.selectedControl = this.BTN_INV_WEAP_L;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_R) {\r\n        this.selectedControl = this.BTN_INV_BELT;\r\n      }\r\n      if (this.selectedControl) {\r\n        this.selectedControl.onHoverIn();\r\n      }\r\n    }\r\n  }\r\n\r\n  triggerControllerDRightPress() {\r\n    if (this.equipmentSelectionActive) {\r\n    } else {\r\n      this.BTN_INV_IMPLANT.onHoverOut();\r\n      this.BTN_INV_HEAD.onHoverOut();\r\n      this.BTN_INV_HANDS.onHoverOut();\r\n      this.BTN_INV_ARM_L.onHoverOut();\r\n      this.BTN_INV_BODY.onHoverOut();\r\n      this.BTN_INV_ARM_R.onHoverOut();\r\n      this.BTN_INV_WEAP_L.onHoverOut();\r\n      this.BTN_INV_BELT.onHoverOut();\r\n      this.BTN_INV_WEAP_R.onHoverOut();\r\n      if (this.selectedControl == this.BTN_INV_IMPLANT) {\r\n        this.selectedControl = this.BTN_INV_HEAD;\r\n      } else if (this.selectedControl == this.BTN_INV_HEAD) {\r\n        this.selectedControl = this.BTN_INV_HANDS;\r\n      } else if (this.selectedControl == this.BTN_INV_HANDS) {\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_L) {\r\n        this.selectedControl = this.BTN_INV_BODY;\r\n      } else if (this.selectedControl == this.BTN_INV_BODY) {\r\n        this.selectedControl = this.BTN_INV_ARM_R;\r\n      } else if (this.selectedControl == this.BTN_INV_ARM_R) {\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_L) {\r\n        this.selectedControl = this.BTN_INV_BELT;\r\n      } else if (this.selectedControl == this.BTN_INV_BELT) {\r\n        this.selectedControl = this.BTN_INV_WEAP_R;\r\n      } else if (this.selectedControl == this.BTN_INV_WEAP_R) {\r\n      }\r\n      if (this.selectedControl) {\r\n        this.selectedControl.onHoverIn();\r\n      }\r\n    }\r\n  }\r\n\r\n  triggerControllerLStickYPress(positive = false) {\r\n    if (positive) {\r\n      this.LB_DESC.scrollUp();\r\n    } else {\r\n      this.LB_DESC.scrollDown();\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuGalaxyMap.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":113,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":147,"column":75,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":147,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":183,"column":66,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":183,"endColumn":77}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Planet, Planetary } from \"@/engine/Planetary\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu, LBL_3DView } from \"@/gui\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\r\nimport { NWScript } from \"@/nwscript/NWScript\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\r\nconst STR_ALREADY_AT_THAT_LOCATION = 125629;\r\n\r\ninterface PlanetAnimStateInfo {\r\n  lastAnimState: 'zoomin'|'rotate';\r\n  currentAnimState: 'zoomin'|'rotate';\r\n  started: boolean;\r\n}\r\n\r\n/**\r\n * MenuGalaxyMap class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuGalaxyMap.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuGalaxyMap extends GameMenu {\r\n\r\n  _3D_PlanetDisplay: GUILabel;\r\n  LBL_Planet_Taris: GUIButton;\r\n  LBL_Planet_Dantooine: GUIButton;\r\n  LBL_Planet_Tatooine: GUIButton;\r\n  LBL_Planet_Kashyyyk: GUIButton;\r\n  LBL_Planet_Manaan: GUIButton;\r\n  LBL_Planet_Korriban: GUIButton;\r\n  LBL_Planet_UnknownWorld: GUIButton;\r\n  LBL_Planet_EndarSpire: GUIButton;\r\n  LBL_Planet_Leviathan: GUIButton;\r\n  LBL_Planet_StarForge: GUIButton;\r\n  _3D_PlanetModel: GUILabel;\r\n  LBL_PLANETNAME: GUILabel;\r\n  LBL_DESC: GUILabel;\r\n  BTN_ACCEPT: GUIButton;\r\n  BTN_BACK: GUIButton;\r\n  LBL_Live01: GUIButton;\r\n  LBL_Live02: GUIButton;\r\n  LBL_Live03: GUIButton;\r\n  LBL_Live04: GUIButton;\r\n  LBL_Live05: GUIButton;\r\n  script: NWScriptInstance;\r\n  _3dView: LBL_3DView;\r\n  _3dViewModel: OdysseyModel3D;\r\n  selectedPlanet: Planetary | undefined;\r\n\r\n  _3dViewPlanet: LBL_3DView;\r\n  _3dViewPlanetModel: OdysseyModel3D;\r\n\r\n  activePlanet: Planet;\r\n\r\n  planetModelAnimationState: PlanetAnimStateInfo = {\r\n    lastAnimState: undefined,\r\n    currentAnimState: undefined,\r\n    started: false\r\n  }\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'galaxymap';\r\n    this.background = '1600x1200map';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    this.BTN_BACK.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      this.close();\r\n      // Planetary.SetSelectedPlanet(GameState.GlobalVariableManager.GetGlobalNumber('K_CURRENT_PLANET'));\r\n    });\r\n    this._button_b = this.BTN_BACK;\r\n\r\n    this.BTN_ACCEPT.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      if(!this.activePlanet?.selectable){\r\n        if(this.activePlanet.lockedOutReason >= 0){\r\n          GameState.MenuManager.InGameConfirm.fromStringRef(this.activePlanet.lockedOutReason);\r\n        }\r\n      }else if(this.activePlanet.id == Planetary.selectedIndex){\r\n        GameState.MenuManager.InGameConfirm.fromStringRef(STR_ALREADY_AT_THAT_LOCATION);\r\n      }else{\r\n        if(this.script instanceof NWScriptInstance){\r\n          this.script.run(GameState.PartyManager.party[0]);\r\n        }\r\n        this.close();\r\n      }\r\n    });\r\n\r\n    this._3dViewPlanet = new LBL_3DView();\r\n    this._3dViewPlanet.visible = true;\r\n    this._3dViewPlanet.setControl(this._3D_PlanetModel);\r\n\r\n    this.script = NWScript.Load('k_sup_galaxymap');\r\n    NWScript.SetGlobalScript('k_sup_galaxymap', true);\r\n\r\n    GameState.PerformanceMonitor.start('MenuGalaxyMap.loadGalaxyModel');\r\n    const mdl = await MDLLoader.loader.load('galaxy');\r\n    GameState.PerformanceMonitor.stop('MenuGalaxyMap.loadGalaxyModel');\r\n    this.tGuiPanel.widget.userData.fill.visible = false;\r\n\r\n    this._3dView = new LBL_3DView();\r\n    this._3dView.visible = true;\r\n    this._3dView.setControl(this._3D_PlanetDisplay);\r\n    \r\n    GameState.PerformanceMonitor.start('MenuGalaxyMap.loadGalaxyModel.FromMDL');\r\n    const model = await OdysseyModel3D.FromMDL(mdl, {\r\n      context: this._3dView\r\n    });\r\n\r\n    GameState.PerformanceMonitor.stop('MenuGalaxyMap.loadGalaxyModel.FromMDL');\r\n    //log.info('Model Loaded', model);\r\n    this._3dViewModel = model;\r\n    \r\n    this._3dView.camera.position.copy(model.camerahook.position);\r\n    this._3dView.camera.quaternion.copy(model.camerahook.quaternion);\r\n\r\n    this._3dView.addModel(this._3dViewModel);\r\n    GameState.PerformanceMonitor.start('MenuGalaxyMap.loadGalaxyModel.TextureLoader.LoadQueue');\r\n    TextureLoader.LoadQueue().then(() => {\r\n      GameState.PerformanceMonitor.stop('MenuGalaxyMap.loadGalaxyModel.TextureLoader.LoadQueue');\r\n    });\r\n  }\r\n\r\n  update(delta = 0) {\r\n    super.update(delta);\r\n    this.UpdateScale();\r\n    this.updatePlanetView(delta);\r\n  }\r\n\r\n  updateGalaxyMapView(delta: number = 0){\r\n    try {\r\n      this._3dView.render(delta);\r\n      (this._3D_PlanetDisplay.getFill().material as THREE.ShaderMaterial).needsUpdate = true;\r\n    } catch (e: unknown) {\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n  updatePlanetView(delta: number = 0){\r\n    try {\r\n      const planetControl = this._3D_PlanetModel;\r\n      const planetModel = this._3dViewPlanetModel;\r\n      const _3dView = this._3dViewPlanet;\r\n      if(planetModel){\r\n        const currentAnimation = planetModel.getAnimationName();\r\n        if(!currentAnimation){\r\n          if(!this.planetModelAnimationState.started){\r\n            this.planetModelAnimationState.started = true;\r\n            planetModel.playAnimation(this.planetModelAnimationState.currentAnimState, false);\r\n          }else{\r\n            if(this.planetModelAnimationState.currentAnimState == 'rotate'){\r\n              this.planetModelAnimationState.lastAnimState = 'zoomin';\r\n              this.planetModelAnimationState.currentAnimState = 'rotate';\r\n              this.planetModelAnimationState.started = false;\r\n            }else{\r\n              this.planetModelAnimationState.lastAnimState = 'rotate';\r\n              this.planetModelAnimationState.currentAnimState = 'rotate';\r\n              this.planetModelAnimationState.started = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        planetModel.update(delta);\r\n        _3dView.camera.position.copy(planetModel.camerahook.position);\r\n        _3dView.camera.quaternion.copy(planetModel.camerahook.quaternion);\r\n      }\r\n\r\n      _3dView.render(delta);\r\n      (planetControl.getFill().material as THREE.ShaderMaterial).needsUpdate = true;\r\n    } catch (e: unknown) {\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n  UpdateScale() {\r\n    const controls = this.manager.MenuGalaxyMap.tGuiPanel.children;\r\n    for (let i = 0; i < controls.length; i++) {\r\n      const control = controls[i];\r\n      const plnt = Planetary.GetPlanetByGUITag(control.name);\r\n      if (plnt) {\r\n        if (plnt.enabled) {\r\n          control.show();\r\n          if (plnt == Planetary.selected) {\r\n            control.widget.scale.setScalar(1.25);\r\n          } else {\r\n            control.widget.scale.setScalar(1);\r\n          }\r\n        }else{\r\n          control.hide();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  changePlanet(planet: Planet){\r\n    if(!planet){ return; }\r\n\r\n    this.LBL_PLANETNAME.setText(planet.getName());\r\n    this.LBL_DESC.setText(planet.getDescription());\r\n    this.activePlanet = planet;\r\n    // Planetary.SetSelectedPlanet(planet.getId());\r\n    if(Planetary.models.has(planet.model)){\r\n      this._3dViewPlanet.removeModel(this._3dViewPlanetModel);\r\n      const mdl = Planetary.models.get(planet.model);\r\n      OdysseyModel3D.FromMDL(mdl, {\r\n        context: this._3dView\r\n      }).then((model: OdysseyModel3D) => {\r\n        this._3dViewPlanetModel = model;\r\n        \r\n        this._3dViewPlanet.camera.position.copy(model.camerahook.position);\r\n        this._3dViewPlanet.camera.quaternion.copy(model.camerahook.quaternion);\r\n\r\n        this._3dViewPlanet.addModel(this._3dViewPlanetModel);\r\n        this.planetModelAnimationState.started = false;\r\n        this.planetModelAnimationState.lastAnimState = undefined;\r\n        this.planetModelAnimationState.currentAnimState = 'zoomin';\r\n\r\n        TextureLoader.LoadQueue();\r\n      });\r\n    }\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    // Planetary.SetSelectedPlanet(GameState.GlobalVariableManager.GetGlobalNumber('K_CURRENT_PLANET'));\r\n    this.changePlanet(Planetary.selected);\r\n    this.UpdateScale();\r\n    const planets = Planetary.planets;\r\n    for (let i = 0; i < planets.length; i++) {\r\n      const planet = planets[i];\r\n\r\n      if(!planet){\r\n        log.warn('invalid planet index', i);\r\n        continue;\r\n      }\r\n\r\n      const control = this.getControlByName(planet.guitag);\r\n      if (!control) {\r\n        log.warn('invalid guitag', planet.guitag);\r\n        continue;\r\n      }\r\n\r\n      control.removeEventListener('click');\r\n      log.info(planet.label, planet.enabled);\r\n\r\n      if (!planet.enabled) {\r\n        control.hide();\r\n        control.disableBorder();\r\n        continue;\r\n      }\r\n\r\n      control.show();\r\n      control.disableBorder();\r\n      control.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.changePlanet(planet);\r\n      });\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuGraphicsAdvanced.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":112,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":112,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":114,"column":67,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":114,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strrefname on a type that cannot be resolved.","line":114,"column":75,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":114,"endColumn":85}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUIListBox, GUILabel, GUIButton, GUICheckBox } from \"@/gui\";\r\nimport { TextureLoaderState } from \"@/loaders/TextureLoaderState\";\r\n\r\n/**\r\n * MenuGraphicsAdvanced class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuGraphicsAdvanced.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuGraphicsAdvanced extends GameMenu {\r\n\r\n  LBL_TITLE: GUILabel;\r\n  LB_DESC: GUIListBox;\r\n  BTN_DEFAULT: GUIButton;\r\n  BTN_CANCEL: GUIButton;\r\n  BTN_BACK: GUIButton;\r\n  BTN_ANTIALIAS: GUIButton;\r\n  BTN_ANTIALIASLEFT: GUIButton;\r\n  BTN_ANTIALIASRIGHT: GUIButton;\r\n  BTN_ANISOTROPY: GUIButton;\r\n  BTN_ANISOTROPYLEFT: GUIButton;\r\n  BTN_ANISOTROPYRIGHT: GUIButton;\r\n  BTN_TEXQUAL: GUIButton;\r\n  BTN_TEXQUALLEFT: GUIButton;\r\n  BTN_TEXQUALRIGHT: GUIButton;\r\n  CB_FRAMEBUFF: GUICheckBox;\r\n  CB_VSYNC: GUICheckBox;\r\n  CB_SOFTSHADOWS: GUICheckBox;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'optgraphicsadv';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.BTN_ANTIALIASLEFT.border.dimension = 0;\r\n      this.BTN_ANISOTROPYLEFT.border.dimension = 0;\r\n      this.BTN_TEXQUALLEFT.border.dimension = 0;\r\n\r\n      this.tGuiPanel.widget.add(this.BTN_TEXQUALLEFT.createControl());\r\n      this.tGuiPanel.widget.add(this.BTN_ANISOTROPYLEFT.createControl());\r\n      this.tGuiPanel.widget.add(this.BTN_ANTIALIASLEFT.createControl());\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_b = this.BTN_BACK;\r\n\r\n      this.BTN_TEXQUALRIGHT.addEventListener('click', (e) => {\r\n        let quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n        quality++;\r\n        if(quality >= GameState.TwoDAManager.datatables.get('texpacks').RowCount) quality = GameState.TwoDAManager.datatables.get('texpacks').RowCount-1;\r\n        GameState.iniConfig.setProperty('Graphics Options.Texture Quality', quality);\r\n        this.updateTextureQualityLabel();\r\n      });\r\n\r\n      this.BTN_TEXQUALLEFT.addEventListener('click', (e) => {\r\n        let quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n        quality--;\r\n        if(quality < 0) quality = 0;\r\n        GameState.iniConfig.setProperty('Graphics Options.Texture Quality', quality);\r\n        this.updateTextureQualityLabel();\r\n      });\r\n\r\n      // this.CB_FRAMEBUFF.onValueChanged = (value) => {\r\n      // \r\n      // };\r\n      // this.CB_FRAMEBUFF.attachINIProperty('Graphics Options.Grass');\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.updateTextureQualityLabel();\r\n    this.BTN_ANTIALIAS.hide();\r\n    this.BTN_ANTIALIASLEFT.hide();\r\n    this.BTN_ANTIALIASRIGHT.hide();\r\n    this.BTN_ANISOTROPY.hide();\r\n    this.BTN_ANISOTROPYLEFT.hide();\r\n    this.BTN_ANISOTROPYRIGHT.hide();\r\n    this.CB_FRAMEBUFF.hide();\r\n    this.CB_VSYNC.hide();\r\n    this.CB_SOFTSHADOWS.hide();\r\n  }\r\n\r\n  close() {\r\n    super.close();\r\n    const quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n    if (quality != TextureLoaderState.TextureQuality) {\r\n      TextureLoaderState.TextureQuality = quality;\r\n      GameState.ReloadTextureCache();\r\n      GameState.iniConfig.save();\r\n    }\r\n  }\r\n\r\n  updateTextureQualityLabel() {\r\n    const quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n    \r\n    const _2darow = GameState.TwoDAManager.datatables.get('texpacks').rows[quality];\r\n    if (_2darow) {\r\n      this.BTN_TEXQUAL.setText(GameState.TLKManager.GetStringById(_2darow.strrefname).Value);\r\n    }\r\n    if (quality <= 0) {\r\n      this.BTN_TEXQUALLEFT.hide();\r\n    } else {\r\n      this.BTN_TEXQUALLEFT.show();\r\n    }\r\n    if (quality >= GameState.TwoDAManager.datatables.get('texpacks').RowCount - 1) {\r\n      this.BTN_TEXQUALRIGHT.hide();\r\n    } else {\r\n      this.BTN_TEXQUALRIGHT.show();\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuMap.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":59,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":59,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Mouse } from \"@/controls\";\r\nimport { MapMode } from \"@/enums/engine/MapMode\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu, LBL_MapView } from \"@/gui\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport type { ModuleWaypoint } from \"@/module\";\r\nimport { NWScript } from \"@/nwscript/NWScript\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { CExoLocString } from \"@/resource/CExoLocString\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\r\n/**\r\n * MenuMap class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuMap.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuMap extends GameMenu {\r\n\r\n  LBL_Map: GUILabel;\r\n  LBL_MapNote: GUILabel;\r\n  LBL_Area: GUILabel;\r\n  LBL_COMPASS: GUILabel;\r\n  BTN_UP: GUIButton;\r\n  BTN_DOWN: GUIButton;\r\n  BTN_PRTYSLCT: GUIButton;\r\n  BTN_RETURN: GUIButton;\r\n  BTN_EXIT: GUIButton;\r\n\r\n  onOpenScript: NWScriptInstance;\r\n  openScript: string;\r\n\r\n  onTransitScript: NWScriptInstance;\r\n  transitScript: string;\r\n  miniMap: LBL_MapView;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'map';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    this.childMenu = this.manager.MenuTop;\r\n    return new Promise<void>( async (resolve, reject) => {\r\n      this.LBL_MapNote.setText('');\r\n      this.LBL_Map.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        const mapNote: ModuleWaypoint = this.miniMap.onClick();\r\n        if(mapNote && mapNote.mapNote instanceof CExoLocString){\r\n          this.LBL_MapNote.setText(mapNote.mapNote.getValue())\r\n        }\r\n      });\r\n\r\n      this.BTN_PRTYSLCT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuPartySelection.open();\r\n      });\r\n\r\n      this.BTN_RETURN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n        if(!GameState.module.area.unescapable){\r\n          if(this.onTransitScript instanceof NWScriptInstance)\r\n            this.onTransitScript.run();\r\n        }\r\n      });\r\n\r\n      this.BTN_EXIT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_b = this.BTN_EXIT;\r\n\r\n      this.openScript = 'k_sup_guiopen';\r\n      this.transitScript = 'k_sup_gohawk';\r\n\r\n      this.onOpenScript = NWScript.Load('k_sup_guiopen');\r\n      this.onTransitScript = NWScript.Load('k_sup_gohawk');\r\n      NWScript.SetGlobalScript('k_sup_guiopen', true);\r\n      NWScript.SetGlobalScript('k_sup_gohawk', true);\r\n\r\n      this.miniMap = new LBL_MapView(this.LBL_Map);\r\n      this.miniMap.setControl(this.LBL_Map);\r\n      this.miniMap.setSize(this.LBL_Map.extent.width, this.LBL_Map.extent.height);\r\n      this.miniMap.setMode(MapMode.FULLMAP);\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  update(delta = 0) {\r\n    super.update(delta);\r\n    if (!this.bVisible)\r\n      return;\r\n\r\n    if (!GameState.module.area.miniGame) {\r\n      const oPC = GameState.getCurrentPlayer();\r\n\r\n      //update minimap\r\n      this.miniMap.setPosition(oPC.position.x, oPC.position.y);\r\n      this.miniMap.setRotation(GameState.controls.camera.rotation.z);\r\n      this.miniMap.updateMousePosition(\r\n        Mouse.positionUI.x + (this.LBL_Map.extent.width/2)  + (this.LBL_Map.widget.position.x * -1),\r\n        Mouse.positionUI.y + (this.LBL_Map.extent.height/2) + (this.LBL_Map.widget.position.y * -1),\r\n      )\r\n      this.miniMap.render(delta);\r\n    }\r\n  }\r\n\r\n  SetMapTexture(sTexture = '') {\r\n    try {\r\n      TextureLoader.Load(sTexture).then((texture: OdysseyTexture) => {\r\n        this.miniMap.setTexture(texture);\r\n      });\r\n    } catch (e: unknown) {\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.manager.MenuTop.LBLH_MAP.onHoverIn();\r\n    if (this.onOpenScript instanceof NWScriptInstance)\r\n      this.onOpenScript.run();\r\n\r\n    this.LBL_MapNote.setText('');\r\n    this.miniMap.mapNoteSelected = this.miniMap.areaMap.getRevealedMapNotes()[0];\r\n    if(this.miniMap.mapNoteSelected){\r\n      this.LBL_MapNote.setText(this.miniMap.mapNoteSelected.mapNote.getValue());\r\n    }\r\n\r\n    this.BTN_PRTYSLCT.disableSelection = (GameState.module.area.unescapable);\r\n    this.BTN_RETURN.disableSelection = (GameState.module.area.unescapable);\r\n  }\r\n\r\n  triggerControllerBumperLPress() {\r\n    this.manager.MenuTop.BTN_JOU.click();\r\n  }\r\n\r\n  triggerControllerBumperRPress() {\r\n    this.manager.MenuTop.BTN_OPT.click();\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuPartySelection.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":307,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":307,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":307,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":307,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":308,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":308,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":308,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":308,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":310,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":310,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":310,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":310,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":311,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":311,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":311,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":311,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":375,"column":61,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":375,"endColumn":69}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\nimport { GameMenu, GUIControl } from \"@/gui\";\r\nimport type { GUILabel, GUIButton, GUICheckBox } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { NWScript } from \"@/nwscript/NWScript\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\n\r\nconst TLK_REMOVE = 38456;\r\nconst TLK_ADD = 38455;\r\n\r\n/**\r\n * MenuPartySelection class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuPartySelection.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuPartySelection extends GameMenu {\r\n\r\n  LBL_CHAR8: GUILabel;\r\n  LBL_CHAR7: GUILabel;\r\n  LBL_CHAR6: GUILabel;\r\n  LBL_CHAR3: GUILabel;\r\n  LBL_CHAR4: GUILabel;\r\n  LBL_CHAR5: GUILabel;\r\n  LBL_CHAR2: GUILabel;\r\n  LBL_CHAR1: GUILabel;\r\n  LBL_CHAR0: GUILabel;\r\n  BTN_NPC0: GUICheckBox;\r\n  BTN_NPC1: GUICheckBox;\r\n  BTN_NPC2: GUICheckBox;\r\n  BTN_NPC3: GUICheckBox;\r\n  BTN_NPC4: GUICheckBox;\r\n  BTN_NPC5: GUICheckBox;\r\n  BTN_NPC6: GUICheckBox;\r\n  BTN_NPC7: GUICheckBox;\r\n  BTN_NPC8: GUICheckBox;\r\n  LBL_NA8: GUILabel;\r\n  LBL_NA5: GUILabel;\r\n  LBL_NA2: GUILabel;\r\n  LBL_NA6: GUILabel;\r\n  LBL_NA3: GUILabel;\r\n  LBL_NA0: GUILabel;\r\n  LBL_NA1: GUILabel;\r\n  LBL_NA4: GUILabel;\r\n  LBL_NA7: GUILabel;\r\n  LBL_3D: GUILabel;\r\n  LBL_TITLE: GUILabel;\r\n  LBL_AVAILABLE: GUILabel;\r\n  LBL_COUNT: GUILabel;\r\n  LBL_BEVEL_M: GUILabel;\r\n  LBL_NPC_NAME: GUILabel;\r\n  LBL_NPC_LEVEL: GUILabel;\r\n  LBL_BEVEL_R: GUILabel;\r\n  LBL_BEVEL_L: GUILabel;\r\n  BTN_DONE: GUIButton;\r\n  BTN_BACK: GUIButton;\r\n  BTN_ACCEPT: GUIButton;\r\n\r\n  ignoreUnescapable = false;\r\n  forceNPC1 = -1;\r\n  forceNPC2 = -1;\r\n\r\n  party: Record<number, { selected: boolean; available: boolean }> = {\r\n    0: { selected: false, available: false },\r\n    1: {selected: false, available: false},\r\n    2: {selected: false, available: false},\r\n    3: {selected: false, available: false},\r\n    4: {selected: false, available: false},\r\n    5: {selected: false, available: false},\r\n    6: {selected: false, available: false},\r\n    7: {selected: false, available: false},\r\n    8: {selected: false, available: false}\r\n  };\r\n\r\n  selectedNPC: number = -1;\r\n  scriptName: string;\r\n  onCloseScript: NWScriptInstance;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'partyselection';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.BTN_NPC0.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(0)){\r\n          this.selectNPC(0)\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC1.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(1)){\r\n          this.selectNPC(1);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC2.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(2)){\r\n          this.selectNPC(2);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC3.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(3)){\r\n          this.selectNPC(3);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC4.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(4)){\r\n          this.selectNPC(4);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC5.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(5)){\r\n          this.selectNPC(5);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC6.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(6)){\r\n          this.selectNPC(6);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC7.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(7)){\r\n          this.selectNPC(7);\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC8.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(8)){\r\n          this.selectNPC(8);\r\n        }\r\n      });\r\n\r\n      this.BTN_DONE.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n\r\n        if(!this.canClose())\r\n          return;\r\n\r\n        if(this.onCloseScript instanceof NWScriptInstance){\r\n          this.close();\r\n          this.onCloseScript.run(undefined, 0);\r\n          this.onCloseScript = undefined;\r\n        }else{\r\n          this.close();\r\n        }\r\n        \r\n      });\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n\r\n      this.BTN_ACCEPT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n\r\n        if(this.canRemove(this.selectedNPC)){\r\n          log.warn(`MenuPartySelection:RemoveNPC`, `Cannot remove a required party member ${this.selectedNPC}`);\r\n          return false;\r\n        }\r\n\r\n        //Area Unescapable disables party selection as well as transit\r\n        if(!GameState.module.area.unescapable || this.ignoreUnescapable){\r\n          if(GameState.PartyManager.IsNPCInParty(this.selectedNPC)){\r\n            GameState.PartyManager.RemoveNPCById(this.selectedNPC);\r\n            this.updateSelection();\r\n          }else if(this.isSelectable(this.selectedNPC) && GameState.PartyManager.CurrentMembers.length < GameState.PartyManager.MaxNPCCount){\r\n            this.addToParty(this.selectedNPC);\r\n          }\r\n          this.updateCount();\r\n        }\r\n\r\n      });\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Hides the menu.\r\n   */\r\n  hide() {\r\n    super.hide();\r\n    this.ignoreUnescapable = false;\r\n  }\r\n\r\n  /**\r\n   * Opens the menu.\r\n   * @param scriptName - The name of the script to run on close.\r\n   * @param forceNPC1 - The ID of the first NPC to force.\r\n   * @param forceNPC2 - The ID of the second NPC to force.\r\n   */\r\n  open(scriptName = '', forceNPC1 = -1, forceNPC2 = -1) {\r\n    this.scriptName = scriptName;\r\n    this.forceNPC1 = forceNPC1;\r\n    this.forceNPC2 = forceNPC2;\r\n    super.open();\r\n  }\r\n\r\n  /**\r\n   * Shows the menu.\r\n   */\r\n  async show() {\r\n    super.show();\r\n    if (this.forceNPC1 > -1)\r\n      await this.addToParty(this.forceNPC1);\r\n    if (this.forceNPC2 > -1)\r\n      await this.addToParty(this.forceNPC2);\r\n\r\n    const selectionRequired = this.forceNPC1 > -1 || this.forceNPC2 > -1;\r\n\r\n    this.selectedNPC = this.forceNPC1 > -1 ? this.forceNPC1 : this.forceNPC2 > -1 ? this.forceNPC2 : -1;\r\n    this.updateSelection();\r\n    this.updateCount();\r\n\r\n    await this.initPortraits();\r\n    this.updateSelection();\r\n    if(selectionRequired){\r\n      this.BTN_BACK.hide();\r\n    }else{\r\n      this.BTN_BACK.show();\r\n    }\r\n    TextureLoader.LoadQueue();\r\n    this.onCloseScript = (this.scriptName != '' || this.scriptName != null) ? \r\n      NWScript.Load(this.scriptName) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Selects the NPC.\r\n   * @param npcId - The ID of the NPC.\r\n   */\r\n  selectNPC(npcId: number = -1){\r\n    if(npcId < 0 || npcId >= GameState.PartyManager.MaxNPCCount) return;\r\n    // if(PartyManager.CurrentMembers.length >= 2) return;\r\n    this.selectedNPC = npcId;\r\n    this.updateSelection();\r\n  }\r\n\r\n  /**\r\n   * Checks if the NPC is required.\r\n   * @param npcId - The ID of the NPC.\r\n   * @returns boolean\r\n   */\r\n  isNPCRequired(npcId: number = -1){\r\n    if(npcId < 0 || npcId >= GameState.PartyManager.MaxNPCCount) return false;\r\n    return (this.forceNPC1 == npcId || this.forceNPC2 == npcId);\r\n  }\r\n\r\n  /**\r\n   * Adds the NPC to the party.\r\n   * @param npcId - The ID of the NPC.\r\n   */\r\n  async addToParty(npcId: number) {\r\n    await GameState.PartyManager.AddNPCById(npcId);\r\n    this.updateCount();\r\n    this.updateSelection();\r\n  }\r\n\r\n  /**\r\n   * Gets the index of the selected NPC.\r\n   * @param npcId - The ID of the NPC.\r\n   * @returns number\r\n   */\r\n  indexOfSelectedNPC(npcId: number) {\r\n    for (let i = 0; i < GameState.PartyManager.CurrentMembers.length; i++) {\r\n      const cpm = GameState.PartyManager.CurrentMembers[i];\r\n      if (cpm.memberID == npcId) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Updates the selection of the NPC.\r\n   */\r\n  updateSelection() {\r\n    for (let i = 0; i < GameState.PartyManager.MaxPartyCount; i++) {\r\n      const btn = this.getControlByName('BTN_NPC' + i);\r\n      if (GameState.PartyManager.IsNPCInParty(i)) {\r\n        btn.highlight.edge_material.uniforms.diffuse.value.setRGB(0, 1, 0);\r\n        btn.highlight.corner_material.uniforms.diffuse.value.setRGB(0, 1, 0);\r\n      } else {\r\n        btn.highlight.edge_material.uniforms.diffuse.value.setRGB(1, 1, 0);\r\n        btn.highlight.corner_material.uniforms.diffuse.value.setRGB(1, 1, 0);\r\n      }\r\n      btn.disableBorder();\r\n      btn.disableHighlight();\r\n      btn.pulsing = false;\r\n    }\r\n    const btn = this.getControlByName('BTN_NPC' + this.selectedNPC);\r\n    if (btn instanceof GUIControl) {\r\n      btn.enableHighlight();\r\n      btn.pulsing = true;\r\n    }\r\n    if (GameState.PartyManager.IsNPCInParty(this.selectedNPC)) {\r\n      this.BTN_ACCEPT.setText(GameState.TLKManager.GetStringById(TLK_REMOVE).Value);\r\n      if(!this.canRemove(this.selectedNPC)){\r\n        this.BTN_ACCEPT.hide();\r\n      } else {\r\n        this.BTN_ACCEPT.show();\r\n      }\r\n    } else {\r\n      this.BTN_ACCEPT.setText(GameState.TLKManager.GetStringById(TLK_ADD).Value);\r\n      if(!this.canAdd(this.selectedNPC)){\r\n        this.BTN_ACCEPT.hide();\r\n      } else {\r\n        this.BTN_ACCEPT.show();\r\n      }\r\n    }\r\n    if(this.selectedNPC == this.forceNPC1 || this.selectedNPC == this.forceNPC2){  \r\n      this.BTN_ACCEPT.hide();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the count of the current members.\r\n   * @returns number\r\n   */\r\n  getCurrentMemberCount() {\r\n    return GameState.PartyManager.CurrentMembers.length;\r\n  }\r\n\r\n  /**\r\n   * Updates the count of the current members.\r\n   */\r\n  updateCount() {\r\n    this.LBL_COUNT.setText((GameState.PartyManager.MaxNPCCount - GameState.PartyManager.CurrentMembers.length).toString());\r\n  }\r\n\r\n  async initPortraits() {\r\n    let LBL_CHAR: GUIControl;\r\n    let LBL_NA: GUIControl;\r\n    for (let i = 0; i < GameState.PartyManager.MaxPartyCount; i++) {\r\n      LBL_CHAR = this.getControlByName('LBL_CHAR' + i);\r\n      LBL_NA = this.getControlByName('LBL_NA' + i);\r\n      LBL_CHAR.hide();\r\n      LBL_NA.show();\r\n      if (!GameState.PartyManager.IsAvailable(i)) {\r\n        continue;\r\n      }\r\n      LBL_NA.hide();\r\n      const portrait = GameState.PartyManager.GetPortraitByIndex(i);\r\n      if (LBL_NA.getFillTextureName() != portrait && !!portrait) {\r\n        LBL_CHAR.setFillTextureName(portrait);\r\n        const texture = await TextureLoader.Load(portrait);\r\n        if(texture)LBL_CHAR.setFillTexture(texture);\r\n      }\r\n      (LBL_CHAR.getFill().material as THREE.ShaderMaterial).uniforms.opacity.value = this.isSelectable(i) ? 1 : 0.5;\r\n      LBL_CHAR.show();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can remove the selected NPC.\r\n   * @returns boolean\r\n   */\r\n  canRemove(npcId: number = -1): boolean {\r\n    return GameState.PartyManager.IsNPCInParty(npcId) && !this.isNPCRequired(npcId);\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can add the selected NPC.\r\n   * @returns boolean\r\n   */\r\n  canAdd(npcId: number = -1): boolean {\r\n    return !GameState.PartyManager.IsNPCInParty(npcId) && !this.isNPCRequired(npcId) && this.isSelectable(npcId);\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can be closed.\r\n   * @returns boolean\r\n   */\r\n  canClose() {\r\n    if (this.forceNPC1 > -1 || this.forceNPC2 > -1) {\r\n      const force1 = this.forceNPC1 == -1 || ( !!GameState.PartyManager.CurrentMembers.find( (cm) => cm.memberID == this.forceNPC1 ) );\r\n      const force2 = this.forceNPC2 == -1 || ( !!GameState.PartyManager.CurrentMembers.find( (cm) => cm.memberID == this.forceNPC2 ) );\r\n      return (force1 && force2);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can accept the selected NPC.\r\n   * @returns boolean\r\n   */\r\n  canAccept() {\r\n    if (this.forceNPC1 > -1 && this.forceNPC2 > -1 && this.getCurrentMemberCount() < 2) {\r\n      return false;\r\n    } else if ((this.forceNPC1 > -1 || this.forceNPC2 > -1) && this.getCurrentMemberCount() < 1) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can add the selected NPC.\r\n   * @returns boolean\r\n   */\r\n  isAvailable(npcId: number = -1): boolean {\r\n    return GameState.PartyManager.IsAvailable(npcId);\r\n  }\r\n\r\n  /**\r\n   * Checks if the menu can select the selected NPC.\r\n   * @returns boolean\r\n   */\r\n  isSelectable(npcId: number = 0) {\r\n    return GameState.PartyManager.IsSelectable(npcId);\r\n  }\r\n\r\n  triggerControllerDUpPress() {\r\n\r\n  }\r\n\r\n  triggerControllerDDownPress() {\r\n\r\n  }\r\n\r\n  triggerControllerDLeftPress() {\r\n\r\n  }\r\n\r\n  triggerControllerDRightPress() {\r\n\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuPazaakSetup.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":273,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":273,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":277,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":277,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":281,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":281,"endColumn":70}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PazaakCardGUITextures } from \"@/enums/minigames/PazaakCardGUITextures\";\nimport { PazaakCards } from \"@/enums/minigames/PazaakCards\";\nimport { PazaakSideDeckSlots } from \"@/enums/minigames/PazaakSideDeckSlots\";\nimport { GameState } from \"@/GameState\";\nimport { GameMenu } from \"@/gui\";\nimport type { GUIControl , GUILabel, GUIButton } from \"@/gui\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nconst MSG_CONFIRM_SIDE_DECK = 32322;\nconst MSG_YOU_WIN = 32334;\nconst MSG_TIED = 32338;\nconst MSG_YOU_LOSE = 32335;\n\n/**\n * MenuPazaakSetup class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file MenuPazaakSetup.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class MenuPazaakSetup extends GameMenu {\n\n  LBL_TITLE: GUILabel;\n  BTN_AVAIL00: GUIButton;\n  BTN_AVAIL01: GUIButton;\n  BTN_AVAIL02: GUIButton;\n  BTN_AVAIL03: GUIButton;\n  BTN_AVAIL04: GUIButton;\n  BTN_AVAIL05: GUIButton;\n  BTN_AVAIL15: GUIButton;\n  BTN_AVAIL14: GUIButton;\n  BTN_AVAIL13: GUIButton;\n  BTN_AVAIL12: GUIButton;\n  BTN_AVAIL11: GUIButton;\n  BTN_AVAIL10: GUIButton;\n  BTN_AVAIL24: GUIButton;\n  BTN_AVAIL23: GUIButton;\n  BTN_AVAIL25: GUIButton;\n  BTN_AVAIL22: GUIButton;\n  BTN_AVAIL21: GUIButton;\n  BTN_AVAIL20: GUIButton;\n  BTN_CHOSEN8: GUIButton;\n  BTN_CHOSEN6: GUIButton;\n  BTN_CHOSEN4: GUIButton;\n  BTN_CHOSEN2: GUIButton;\n  BTN_CHOSEN9: GUIButton;\n  BTN_CHOSEN0: GUIButton;\n  BTN_CHOSEN7: GUIButton;\n  BTN_CHOSEN5: GUIButton;\n  BTN_CHOSEN3: GUIButton;\n  BTN_CHOSEN1: GUIButton;\n  LBL_AVAIL00: GUILabel;\n  LBL_AVAIL01: GUILabel;\n  LBL_AVAIL02: GUILabel;\n  LBL_AVAIL03: GUILabel;\n  LBL_AVAIL04: GUILabel;\n  LBL_AVAIL05: GUILabel;\n  LBL_AVAIL10: GUILabel;\n  LBL_AVAIL11: GUILabel;\n  LBL_AVAIL12: GUILabel;\n  LBL_AVAIL13: GUILabel;\n  LBL_AVAIL14: GUILabel;\n  LBL_AVAIL15: GUILabel;\n  LBL_AVAIL20: GUILabel;\n  LBL_AVAIL21: GUILabel;\n  LBL_AVAIL22: GUILabel;\n  LBL_AVAIL23: GUILabel;\n  LBL_AVAIL24: GUILabel;\n  LBL_AVAIL25: GUILabel;\n  LBL_CHOSEN0: GUILabel;\n  LBL_CHOSEN2: GUILabel;\n  LBL_CHOSEN4: GUILabel;\n  LBL_CHOSEN6: GUILabel;\n  LBL_CHOSEN8: GUILabel;\n  LBL_CHOSEN1: GUILabel;\n  LBL_CHOSEN3: GUILabel;\n  LBL_CHOSEN5: GUILabel;\n  LBL_CHOSEN7: GUILabel;\n  LBL_CHOSEN9: GUILabel;\n  LBL_AVAILNUM05: GUILabel;\n  LBL_AVAILNUM15: GUILabel;\n  LBL_AVAILNUM25: GUILabel;\n  LBL_AVAILNUM24: GUILabel;\n  LBL_AVAILNUM14: GUILabel;\n  LBL_AVAILNUM04: GUILabel;\n  LBL_AVAILNUM03: GUILabel;\n  LBL_AVAILNUM13: GUILabel;\n  LBL_AVAILNUM23: GUILabel;\n  LBL_AVAILNUM22: GUILabel;\n  LBL_AVAILNUM12: GUILabel;\n  LBL_AVAILNUM02: GUILabel;\n  LBL_AVAILNUM01: GUILabel;\n  LBL_AVAILNUM11: GUILabel;\n  LBL_AVAILNUM21: GUILabel;\n  LBL_AVAILNUM20: GUILabel;\n  LBL_AVAILNUM10: GUILabel;\n  LBL_AVAILNUM00: GUILabel;\n  LBL_RTEXT: GUILabel;\n  LBL_LTEXT: GUILabel;\n  BTN_YTEXT: GUIButton;\n  BTN_ATEXT: GUIButton;\n\n  selectedCard: PazaakCards = PazaakCards.INVALID;\n  selectedSideCard: PazaakSideDeckSlots = PazaakSideDeckSlots.INVALID;\n\n  knownCards: Map<number, boolean> = new Map();\n\n  constructor(){\n    super();\n    this.gui_resref = 'pazaaksetup';\n    this.background = '1600x1200pazaak';\n    this.voidFill = true;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if(skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n      /**\n       * Begin the game\n       */\n      this.BTN_ATEXT.addEventListener('click', () => {\n        log.debug('PazaakSetup: Begin Game');\n        this.close();\n        GameState.MenuManager.MenuPazaakGame.open();\n      });\n\n      /**\n       * Add card to the side deck\n       */\n      this.BTN_YTEXT.addEventListener('click', () => {\n        log.trace('BTN_YTEXT clicked');\n      });\n      this.BTN_YTEXT.hide();\n\n      /**\n       * Available cards\n       */\n      for(let i = 0; i < PazaakCards.MAX_CARDS; i++){\n        const card = GameState.PazaakManager.Cards.get(i);\n        if(card){\n          const button = this.getCardButton(i);\n          if(!button){\n            continue;\n          }\n          button.swapBorderAndHighliteOnHover = false;\n          button.addEventListener('click', () => {\n            this.selectedCard = i;\n            log.debug(`PazaakSetup: Selected card ${i}, count: ${card.count}`);\n            if(card.count <= 0){\n              return;\n            }\n            for(let j = 0; j < PazaakSideDeckSlots.MAX_SLOTS; j++){\n              const sideCard = GameState.PazaakManager.PlayerSideDeck.get(j);\n              if(sideCard != PazaakCards.INVALID){\n                continue;\n              }\n              GameState.PazaakManager.MoveCardToSideDeck(card.card, j);\n              this.rebuild();\n              break;\n            }\n          });\n        }\n      }\n\n      /**\n       * Side deck cards\n       */\n      for(let i = 0; i < PazaakSideDeckSlots.MAX_SLOTS; i++){\n        const button = this.getSideCardButton(i);\n        if(!button){\n          continue;\n        }\n        button.swapBorderAndHighliteOnHover = false;\n        button.addEventListener('click', () => {\n          const card = GameState.PazaakManager.PlayerSideDeck.get(i);\n          this.selectedSideCard = i;\n          log.debug(`PazaakSetup: Side card ${i} - ${card}`);\n          if(card != PazaakCards.INVALID){\n            GameState.PazaakManager.MoveSideDeckCardToMainDeck(i);\n            this.rebuild();\n          }\n        });\n      }\n\n      resolve();\n    });\n  }\n\n  open(){\n    super.open();\n    if(GameState.PazaakManager.MaxWager > 0){\n      GameState.MenuManager.MenuPazaakWager.open();\n    }\n    this.knownCards.clear();\n    for(let i = 0; i < PazaakCards.MAX_CARDS; i++){\n      const card = GameState.PazaakManager.Cards.get(i);\n      if(card && card.count > 0){\n        this.knownCards.set(i, true);\n      }else{\n        this.knownCards.set(i, false);\n      }\n    }\n    for(let i = 0; i < PazaakSideDeckSlots.MAX_SLOTS; i++){\n      const card = GameState.PazaakManager.PlayerSideDeck.get(i);\n      if(card && card != PazaakCards.INVALID){\n        this.knownCards.set(card, true);\n      }\n    }\n    this.rebuild();\n  }\n\n  getCardButton(cardIndex: PazaakCards){\n    const rowIndex = Math.floor(cardIndex / 6);\n    const columnIndex = cardIndex % 6;\n    const buttonTag = `BTN_AVAIL${rowIndex}${columnIndex}`;\n    return (this as unknown as Record<string, GUIButton | undefined>)[buttonTag] as GUIButton;\n  }\n\n  getCardLabel(cardIndex: PazaakCards){\n    const rowIndex = Math.floor(cardIndex / 6);\n    const columnIndex = cardIndex % 6;\n    const labelTag = `LBL_AVAIL${rowIndex}${columnIndex}`;\n    return (this as unknown as Record<string, GUIControl | undefined>)[labelTag] as GUIControl;\n  }\n\n  getCardCountLabel(cardIndex: PazaakCards){\n    const rowIndex = Math.floor(cardIndex / 6);\n    const columnIndex = cardIndex % 6;\n    const labelTag = `LBL_AVAILNUM${rowIndex}${columnIndex}`;\n    return (this as unknown as Record<string, GUIControl | undefined>)[labelTag] as GUIControl;\n  }\n\n  getSideCardButton(cardIndex: PazaakCards){\n    const buttonTag = `BTN_CHOSEN${cardIndex}`;\n    return (this as unknown as Record<string, GUIButton | undefined>)[buttonTag] as GUIButton;\n  }\n\n  getSideCardLabel(cardIndex: PazaakCards){\n    const labelTag = `LBL_CHOSEN${cardIndex}`;\n    return (this as unknown as Record<string, GUIControl | undefined>)[labelTag] as GUIControl;\n  }\n\n  setCardCount(cardIndex: PazaakCards, count: number){\n    const rowIndex = Math.floor(cardIndex / 6);\n    const columnIndex = cardIndex % 6;\n    const labelTag = `LBL_AVAILNUM${rowIndex}${columnIndex}`;\n    const label = (this as unknown as Record<string, GUIControl | undefined>)[labelTag] as GUIControl;\n    if(!label){\n      log.error(`Label ${labelTag} - ${cardIndex} not found`);\n      return;\n    }\n    label.setText(count.toString());\n  }\n\n  rebuild(){\n    for(let i = 0; i < PazaakCards.MAX_CARDS; i++){\n      const card = GameState.PazaakManager.Cards.get(i);\n      if(card){\n        this.setCardCount(i, card.count);\n      }\n\n      const bCardAvailable = card.count > 0;\n      const bCardKnown = this.knownCards.get(i);\n\n      const button = this.getCardButton(i);\n      if(button){\n        button.swapBorderAndHighliteOnHover = false;\n        button.disableSelection = !bCardAvailable;\n        bCardAvailable || bCardKnown ? button.show() : button.hide();\n      }\n      const label = this.getCardCountLabel(i);\n      if(label){\n        bCardAvailable || bCardKnown ? label.show() : label.hide();\n      }\n      const label2 = this.getCardLabel(i);\n      if(label2){\n        bCardAvailable || bCardKnown ? label2.show() : label2.hide();\n      }\n    }\n\n    for(let i = 0; i < PazaakSideDeckSlots.MAX_SLOTS; i++){\n      const card = GameState.PazaakManager.PlayerSideDeck.get(i);\n      const button = this.getSideCardButton(i);\n      const label = this.getSideCardLabel(i);\n      if(!button || !label){\n        continue;\n      }\n      button.swapBorderAndHighliteOnHover = false;\n      if(typeof card === 'number' && card != PazaakCards.INVALID){\n        label.setText(card.toString());\n        const type = Math.floor(card/6);\n        const modifier = (card % 6) + 1;\n        if(type === 0){\n          button.setFillTextureName(PazaakCardGUITextures.CARD_POS, false);\n          label.setText(`+${modifier}`);\n        }else if(type === 1){\n          button.setFillTextureName(PazaakCardGUITextures.CARD_NEG, false);\n          label.setText(`-${modifier}`);\n        }else if(type === 2){\n          button.setFillTextureName(PazaakCardGUITextures.CARD_TWOSIDED_POS, false);\n          label.setText(`${modifier}`);\n        }\n      }else{\n        label.setText('');\n        button.setFillTextureName(PazaakCardGUITextures.CARD_BACK, false);\n      }\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuSaveLoad.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":150,"column":76,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":150,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":154,"column":69,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":154,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":158,"column":69,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":158,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":162,"column":69,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":162,"endColumn":80}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { SaveGame } from \"@/engine/SaveGame\";\nimport { MenuSaveLoadMode } from \"@/enums/gui/MenuSaveLoadMode\";\nimport { GUISaveGameItem } from \"@/game/kotor/gui/GUISaveGameItem\";\nimport { GameState } from \"@/GameState\";\nimport { GameMenu } from \"@/gui\";\nimport type { GUIListBox, GUILabel, GUIButton } from \"@/gui\";\nimport { TextureLoader } from \"@/loaders\";\nimport { Module } from \"@/module\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\n\n/**\n * MenuSaveLoad class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file MenuSaveLoad.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class MenuSaveLoad extends GameMenu {\n\n  LB_GAMES: GUIListBox;\n  LBL_PANELNAME: GUILabel;\n  LBL_SCREENSHOT: GUILabel;\n  LBL_PLANETNAME: GUILabel;\n  LBL_PM2: GUILabel;\n  LBL_AREANAME: GUILabel;\n  LBL_PM1: GUILabel;\n  LBL_PM3: GUILabel;\n  BTN_DELETE: GUIButton;\n  BTN_BACK: GUIButton;\n  BTN_SAVELOAD: GUIButton;\n\n  mode: MenuSaveLoadMode;\n  saves: SaveGame[] = [];\n  selected: SaveGame;\n\n  constructor() {\n    super();\n    this.gui_resref = 'saveload';\n    this.background = '1600x1200back';\n    this.voidFill = true;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if (skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n\n      this._button_y = this.BTN_DELETE;\n\n      this.BTN_SAVELOAD.setText('Load');\n      this.BTN_SAVELOAD.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const savegame = this.selected;\n        if (this.mode == MenuSaveLoadMode.LOADGAME) {\n          if (savegame) {\n            this.manager.ClearMenus();\n            if (GameState.module instanceof Module) {\n              GameState.module.dispose();\n              GameState.module = undefined;\n            }\n            savegame.load();\n          }\n        } else {\n          if (savegame instanceof NewSaveItem) {\n            this.manager.MenuSaveName.onSave = async (name = '') => {\n              await SaveGame.SaveCurrentGame(name);\n              this.reloadSaves();\n            };\n            this.manager.MenuSaveName.open();\n          } else {\n\n          }\n        }\n      });\n      this._button_a = this.BTN_SAVELOAD;\n\n      this.BTN_BACK = this.getControlByName('BTN_BACK');\n      this.BTN_BACK.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.close();\n      });\n      this._button_b = this.BTN_BACK;\n\n      this.LB_GAMES.GUIProtoItemClass = GUISaveGameItem;\n      this.LB_GAMES.listMarginTop = 5;\n      this.LB_GAMES.onSelected = (save: SaveGame) => {\n        this.selected = save;\n        this.UpdateSelected();\n      }\n\n      this.tGuiPanel.getFill().position.z = -1;\n      resolve();\n    });\n  }\n\n  show() {\n    super.show();\n    this.selectedControl = this.LB_GAMES;\n    this.reloadSaves();\n    if (this.mode == MenuSaveLoadMode.SAVEGAME) {\n      this.BTN_SAVELOAD.setText(GameState.TLKManager.TLKStrings[1587].Value);\n    } else {\n      this.BTN_SAVELOAD.setText(GameState.TLKManager.TLKStrings[1589].Value);\n    }\n    TextureLoader.LoadQueue();\n  }\n\n  getSaveGames(): SaveGame[] {\n    let saves: SaveGame[] = [];\n    if (this.mode == MenuSaveLoadMode.SAVEGAME) {\n      saves = SaveGame.saves.filter(save => {\n        return !save.getIsQuickSave() && !save.getIsAutoSave();\n      });\n      saves.unshift(new NewSaveItem());\n    } else {\n      saves = SaveGame.saves;\n    }\n    return saves;\n  }\n\n  reloadSaves() {\n    this.LB_GAMES.clearItems();\n    const saves = this.getSaveGames();\n    for (let i = 0; i < saves.length; i++) {\n      const save = saves[i];\n      this.LB_GAMES.addItem(save);\n    }\n    this.selected = saves[0];\n    this.UpdateSelected();\n    this.LB_GAMES.updateList();\n  }\n\n  UpdateSelected() {\n    this.LBL_SCREENSHOT.setFillTexture(undefined);\n    this.LBL_PM1.setFillTexture(undefined);\n    this.LBL_PM2.setFillTexture(undefined);\n    this.LBL_PM3.setFillTexture(undefined);\n    this.LBL_PLANETNAME.setText('');\n    this.LBL_AREANAME.setText('');\n    if (this.selected instanceof SaveGame) {\n      this.LB_GAMES.selectItem(this.selected);\n      if (this.selected instanceof NewSaveItem) {\n\n      } else {\n        this.selected.getThumbnail().then((texture: OdysseyTexture) => {\n          this.LBL_SCREENSHOT.setFillTexture(texture);\n          (this.LBL_SCREENSHOT.getFill().material as THREE.ShaderMaterial).transparent = false;\n        });\n        this.selected.getPortrait(0).then((texture: OdysseyTexture) => {\n          this.LBL_PM1.setFillTexture(texture);\n          (this.LBL_PM1.getFill().material as THREE.ShaderMaterial).transparent = false;\n        });\n        this.selected.getPortrait(1).then((texture: OdysseyTexture) => {\n          this.LBL_PM2.setFillTexture(texture);\n          (this.LBL_PM2.getFill().material as THREE.ShaderMaterial).transparent = false;\n        });\n        this.selected.getPortrait(2).then((texture: OdysseyTexture) => {\n          this.LBL_PM3.setFillTexture(texture);\n          (this.LBL_PM3.getFill().material as THREE.ShaderMaterial).transparent = false;\n        });\n        const areaNames = this.selected.getAreaName().split(' - ');\n        if (areaNames.length == 2) {\n          this.LBL_PLANETNAME.setText(areaNames[0]);\n          this.LBL_AREANAME.setText(areaNames[1]);\n        } else {\n          this.LBL_PLANETNAME.setText('');\n          this.LBL_AREANAME.setText(areaNames[0]);\n        }\n      }\n      this.BTN_SAVELOAD.show();\n      this.BTN_DELETE.show();\n    } else {\n      this.BTN_SAVELOAD.hide();\n      this.BTN_DELETE.hide();\n    }\n  }\n\n  triggerControllerDUpPress() {\n    this.LB_GAMES.directionalNavigate('up');\n  }\n\n  triggerControllerDDownPress() {\n    this.LB_GAMES.directionalNavigate('down');\n  }\n\n}\n\nexport class NewSaveItem extends SaveGame {\n  constructor() {\n    super();\n    this.isNewSave = true;\n  }\n\n  getFullName() {\n    return GameState.TLKManager.TLKStrings[1586].Value;\n  }\n\n  async load(): Promise<void> { }\n  async loadNFO(): Promise<void> { }\n  async loadPIFO(): Promise<void> { }\n  async loadGlobalVARS(): Promise<void> { }\n  async loadInventory(): Promise<void> { }\n  async loadPartyTable(): Promise<void> { }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuSaveName.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":20,"column":11,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":20,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a `Function` typed value.","line":37,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":37,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameMenu } from \"@/gui\";\nimport type { GUILabel, GUIButton } from \"@/gui\";\n\n/**\n * MenuSaveName class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file MenuSaveName.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class MenuSaveName extends GameMenu {\n\n  BTN_OK: GUIButton;\n  BTN_CANCEL: GUIButton;\n  EDITBOX: GUILabel;\n  LBL_TITLE: GUILabel;\n\n  onSave: Function;\n\n  constructor() {\n    super();\n    this.gui_resref = 'savename';\n    this.background = '';\n    this.voidFill = false;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer();\n    if (skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n      this.EDITBOX.setEditable(true);\n\n      this.BTN_OK.addEventListener('click', () => {\n        if (typeof this.onSave === 'function') {\n          this.onSave(this.EDITBOX.getValue());\n        }\n        this.close();\n      });\n      this._button_b = this.BTN_OK;\n\n      this.BTN_CANCEL.addEventListener('click', () => {\n        this.close();\n      });\n      this._button_a = this.BTN_CANCEL;\n\n      this.addEventListener('keydown', (e: KeyboardEvent) => {\n        if (e.which === 13) {\n          e.preventDefault();\n          this.BTN_OK.click();\n        }\n      });\n      resolve();\n    });\n  }\n\n  show() {\n    this.tGuiPanel.widget.position.z = 10;\n    this.EDITBOX.setText('');\n    super.show();\n    this.manager.activeGUIElement = this.EDITBOX;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\kotor\\menu\\MenuUpgradeSelect.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":47,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":47,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":47,"column":31,"nodeType":"MemberExpression","messageId":"errorCall","endLine":47,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .clone on a type that cannot be resolved.","line":47,"column":64,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":47,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":48,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":48,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":48,"column":29,"nodeType":"MemberExpression","messageId":"errorCall","endLine":48,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .clone on a type that cannot be resolved.","line":48,"column":57,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":48,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":89,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":89,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on a type that cannot be resolved.","line":89,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":89,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":90,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":90,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on a type that cannot be resolved.","line":90,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":90,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":91,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":91,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on a type that cannot be resolved.","line":91,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":91,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":92,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":92,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on a type that cannot be resolved.","line":92,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":37}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui\";\r\nimport type { GUIButton, GUILabel } from \"@/gui\";\r\n\r\ntype ItemType = 'RANGED' | 'MELEE' | 'LIGHTSABER' | 'ARMOR' | 'NONE';\r\n\r\n/**\r\n * MenuUpgradeSelect class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuUpgradeSelect.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuUpgradeSelect extends GameMenu {\r\n\r\n  BTN_RANGED: GUIButton;\r\n  LBL_RANGED: GUILabel;\r\n  BTN_LIGHTSABER: GUIButton;\r\n  LBL_LSABER: GUILabel;\r\n  BTN_MELEE: GUIButton;\r\n  LBL_MELEE: GUILabel;\r\n  BTN_ARMOR: GUIButton;\r\n  LBL_ARMOR: GUILabel;\r\n  LBL_TITLE: GUILabel;\r\n  BTN_UPGRADEITEMS: GUIButton;\r\n  BTN_BACK: GUIButton;\r\n\r\n  selected: ItemType = 'LIGHTSABER';\r\n  btnNormalColor: THREE.Color;\r\n  btnSelectedColor: THREE.Color;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'upgradesel';\r\n    this.background = '1600x1200back';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer();\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.btnSelectedColor = this.BTN_LIGHTSABER.border.color.clone();\r\n      this.btnNormalColor = this.BTN_MELEE.border.color.clone();\r\n      this.BTN_RANGED.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.select('RANGED');\r\n      });\r\n      this.BTN_LIGHTSABER.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.select('LIGHTSABER');\r\n      });\r\n      this.BTN_MELEE.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.select('MELEE');\r\n      });\r\n      this.BTN_ARMOR.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.select('ARMOR');\r\n      });\r\n      this.BTN_UPGRADEITEMS.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.MenuManager.MenuUpgradeItems.itemType = this.selected;\r\n        GameState.MenuManager.MenuUpgradeItems.open();\r\n      });\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_b = this.BTN_BACK;\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  select(type: ItemType) {\r\n    this.selected = type;\r\n    this.BTN_RANGED.selected = this.selected == 'RANGED';\r\n    this.BTN_LIGHTSABER.selected = this.selected == 'LIGHTSABER';\r\n    this.BTN_MELEE.selected = this.selected == 'MELEE';\r\n    this.BTN_ARMOR.selected = this.selected == 'ARMOR';\r\n    this.BTN_RANGED.hover = (this.BTN_RANGED.selected);\r\n    this.BTN_MELEE.hover = (this.BTN_MELEE.selected);\r\n    this.BTN_LIGHTSABER.hover = (this.BTN_LIGHTSABER.selected);\r\n    this.BTN_ARMOR.hover = (this.BTN_ARMOR.selected); \r\n    this.BTN_LIGHTSABER.border.color.copy( this.selected == 'LIGHTSABER' ? this.btnSelectedColor : this.btnNormalColor);\r\n    this.BTN_MELEE.border.color.copy( this.selected == 'MELEE' ? this.btnSelectedColor : this.btnNormalColor);\r\n    this.BTN_RANGED.border.color.copy( this.selected == 'RANGED' ? this.btnSelectedColor : this.btnNormalColor);\r\n    this.BTN_ARMOR.border.color.copy( this.selected == 'ARMOR' ? this.btnSelectedColor : this.btnNormalColor);\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.select('LIGHTSABER');\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\gui\\GUICreatureSkill.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":87,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":87,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":88,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":88,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":92,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":92,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":93,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":93,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":100,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":101,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":102,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":105,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":105,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":106,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":106,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":107,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":107,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":108,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":109,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":109,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":111,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":111,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":111,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":112,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":112,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":112,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":114,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":115,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":128,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":128,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":128,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":128,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":146,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":146,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":146,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":146,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":159,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":159,"endColumn":61}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { GameEngineType } from \"@/enums/engine\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu, GUIButton, GUIControl, GUIListBox, GUIProtoItem } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport type { TalentSkill } from \"@/talents/TalentSkill\";\r\n\r\n/**\r\n * GUICreatureSkill class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUICreatureSkill.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUICreatureSkill extends GUIProtoItem {\r\n\r\n  declare node: TalentSkill;\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n    this.extent.height = 43.5;\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n\r\n      const spacing = 2;\r\n      const protoWidth = this.extent.width;\r\n      const protoHeight = this.extent.height - spacing;\r\n      const iconWidth = this.extent.height - spacing;\r\n      const iconHeight = this.extent.height - spacing;\r\n\r\n      const labelWidth = protoWidth - iconWidth - this.parent.border.inneroffset;\r\n\r\n      //Label\r\n      const buttonLabel = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonLabel.extent.left = 0;\r\n      buttonLabel.extent.width = labelWidth;\r\n      buttonLabel.extent.height = protoHeight;\r\n      buttonLabel.setText(this.node.getName() || '');\r\n      buttonLabel.autoCalculatePosition = false;\r\n      this.children.push(buttonLabel);\r\n\r\n      const _buttonWidget = buttonLabel.createControl();\r\n      _buttonWidget.position.x = (protoWidth - buttonLabel.extent.width) / 2;\r\n      _buttonWidget.position.y = 0;\r\n      _buttonWidget.position.z = this.zIndex + 1;\r\n      this.widget.add(_buttonWidget);\r\n\r\n      //Icon\r\n      const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonIcon.setText('');\r\n      buttonIcon.disableTextAlignment();\r\n      buttonIcon.extent.width = iconWidth;\r\n      buttonIcon.extent.height = iconHeight;\r\n      buttonIcon.extent.top = 0;\r\n      buttonIcon.extent.left = 0;\r\n      buttonIcon.disableBorder();\r\n      buttonIcon.disableHighlight();\r\n      buttonIcon.hasText = true;\r\n      buttonIcon.autoCalculatePosition = false;\r\n      this.children.push(buttonIcon);\r\n\r\n      const _buttonIconWidget = buttonIcon.createControl();\r\n      _buttonIconWidget.position.x = -(protoWidth/2 - buttonIcon.extent.width/2);\r\n      _buttonIconWidget.position.y = 0;\r\n      _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n      this.widget.add(_buttonIconWidget);\r\n\r\n      this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.iconMaterial.transparent = true;\r\n      this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n      //log.info(this.node.getIcon());\r\n      TextureLoader.Load(this.node.getIcon()).then((texture: OdysseyTexture) => {\r\n        if(texture){\r\n          this.widget.userData.iconMaterial.map = texture;\r\n          this.widget.userData.iconMaterial.needsUpdate = true;\r\n        }\r\n      });\r\n      \r\n      this.widget.userData.spriteGroup = new THREE.Group();\r\n      //this.widget.spriteGroup.position.x = -(protoWidth/2)-(52/2); //HACK\r\n      //this.widget.spriteGroup.position.y -= 4;\r\n      this.widget.userData.iconSprite.scale.x = iconWidth * 0.5;\r\n      this.widget.userData.iconSprite.scale.y = iconHeight * 0.5;\r\n      this.widget.userData.iconSprite.position.z = 2;\r\n\r\n      this.widget.userData.hexMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.hexMaterial.transparent = true;\r\n      this.widget.userData.hexSprite = new THREE.Sprite( this.widget.userData.hexMaterial );\r\n      this.widget.userData.hexSprite.scale.x = \r\n      this.widget.userData.hexSprite.scale.y = iconWidth;\r\n      this.widget.userData.hexSprite.position.z = 1;\r\n\r\n      this.widget.userData.spriteGroup.add(this.widget.userData.hexSprite);  \r\n      this.widget.userData.spriteGroup.add(this.widget.userData.iconSprite);\r\n\r\n      this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('uibit_eqp_itm1');\r\n      this.widget.userData.hexMaterial.needsUpdate = true;\r\n\r\n      this.onSelect = () => {\r\n        if(this.selected){\r\n          this.showHighlight();\r\n          this.hideBorder();\r\n          this.pulsing = true;\r\n          this.text.color.copy(this.defaultColor);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.showHighlight();\r\n          buttonLabel.hideBorder();\r\n          this.widget.userData.hexMaterial.color.copy(this.defaultHighlightColor);\r\n          buttonLabel.setHighlightColor(this.defaultHighlightColor.r, this.defaultHighlightColor.g, this.defaultHighlightColor.b);\r\n          buttonLabel.pulsing = true;\r\n          buttonIcon.pulsing = true;\r\n\r\n          buttonLabel.text.color.copy(this.defaultHighlightColor);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }else{\r\n          this.hideHighlight();\r\n          this.showBorder();\r\n          this.pulsing = false;\r\n          this.text.color.copy(this.defaultColor);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.hideHighlight();\r\n          buttonLabel.showBorder();\r\n          this.widget.userData.hexMaterial.color.copy(this.defaultColor);\r\n          buttonLabel.setBorderColor(this.defaultColor.r, this.defaultColor.g, this.defaultColor.b);\r\n          buttonLabel.pulsing = false;\r\n          buttonIcon.pulsing = false;\r\n\r\n          buttonLabel.text.color.copy(this.defaultColor);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }\r\n      };\r\n      this.onSelect.call(this);\r\n\r\n      //StackCount Text\r\n      _buttonIconWidget.add(this.widget.userData.spriteGroup);\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\gui\\GUIFeatItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":46,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":46,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":48,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":48,"endColumn":121},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .prereqfeat1 on a type that cannot be resolved.","line":48,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":48,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":48,"column":63,"nodeType":"MemberExpression","messageId":"errorCall","endLine":48,"endColumn":102},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .prereqfeat1 on a type that cannot be resolved.","line":48,"column":108,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":48,"endColumn":119},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":49,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":49,"endColumn":121},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .prereqfeat2 on a type that cannot be resolved.","line":49,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":49,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":49,"column":63,"nodeType":"MemberExpression","messageId":"errorCall","endLine":49,"endColumn":102},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .prereqfeat2 on a type that cannot be resolved.","line":49,"column":108,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":49,"endColumn":119},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":50,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":50,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":50,"column":25,"nodeType":"MemberExpression","messageId":"errorCall","endLine":50,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__index on a type that cannot be resolved.","line":50,"column":70,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":50,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .constant on a type that cannot be resolved.","line":52,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":52,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":88,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":88,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":89,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":89,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":90,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":90,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":91,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":91,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":92,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":107,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":107,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":109,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":109,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":110,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":110,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":111,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on an `any` value.","line":112,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | string[]`.","line":113,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":113,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .icon on a type that cannot be resolved.","line":113,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":113,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":113,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":113,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":114,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":114,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":114,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":115,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":115,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":115,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .opacity on an `any` value.","line":117,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":119,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":119,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":120,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":123,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":123,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":161,"column":52,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":161,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":162,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":162,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":163,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":163,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":164,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":164,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":165,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":165,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":167,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":167,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":168,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":168,"endColumn":57}],"suppressedMessages":[],"errorCount":41,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { TextureType } from \"@/enums/loaders/TextureType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GUIProtoItem, GUIButton } from \"@/gui\";\r\nimport type { GUIControl, GameMenu } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/**\r\n * GUIFeatItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIFeatItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIFeatItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl | null | undefined = undefined, scale = false){\r\n    super(menu, control, parent ?? undefined, scale);\r\n    this.disableSelection = true;\r\n    this.extent.height = 45;\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n\r\n      const iconHeight = this.extent.height;\r\n      const arrowHeight = iconHeight/2; //32\r\n\r\n      const featList = this.node;\r\n      for(let i = 0; i < featList.length; i++){\r\n        const feat = featList[i];\r\n\r\n        const hasPrereqfeat1 = (feat.prereqfeat1 == '****' || GameState.getCurrentPlayer().getHasFeat(feat.prereqfeat1));\r\n        const hasPrereqfeat2 = (feat.prereqfeat2 == '****' || GameState.getCurrentPlayer().getHasFeat(feat.prereqfeat2));\r\n        const hasFeat = GameState.getCurrentPlayer().getHasFeat(feat.__index);\r\n\r\n        log.debug('feat', feat.constant, hasPrereqfeat1, hasPrereqfeat2);\r\n\r\n        const locked = !hasFeat || (!hasPrereqfeat1 || !hasPrereqfeat2);\r\n        if(locked){ continue; }\r\n\r\n        const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n        buttonIcon.name = 'BUTTON';\r\n        buttonIcon.setText('');\r\n        buttonIcon.disableTextAlignment();\r\n        buttonIcon.extent.width = iconHeight;\r\n        buttonIcon.extent.height = iconHeight;\r\n        buttonIcon.extent.top = 0;\r\n        buttonIcon.extent.left = 0;\r\n        buttonIcon.hasBorder = false;\r\n        buttonIcon.hasHighlight = false;\r\n        buttonIcon.hasText = false;\r\n        buttonIcon.autoCalculatePosition = false;\r\n        this.children.push(buttonIcon);\r\n\r\n        const _buttonIconWidget = buttonIcon.createControl();\r\n        switch(i){\r\n          case 2:\r\n            _buttonIconWidget.position.x = (this.extent.width/2 - buttonIcon.extent.width/2);\r\n          break;\r\n          case 1:\r\n            _buttonIconWidget.position.x = 0;\r\n          break;\r\n          default:\r\n            _buttonIconWidget.position.x = -(this.extent.width/2 - buttonIcon.extent.width/2);\r\n          break;\r\n        }\r\n        _buttonIconWidget.position.y = 0;\r\n        _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n        this.widget.add(_buttonIconWidget);\r\n\r\n        TextureLoader.enQueue('uibit_abi_back', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n          buttonIcon.setMaterialTexture( buttonIcon.border.fill.material, texture);\r\n          buttonIcon.border.fill.material.transparent = true;\r\n          buttonIcon.setMaterialTexture( buttonIcon.highlight.fill.material, texture);\r\n          buttonIcon.highlight.fill.material.transparent = true;\r\n          if(locked){\r\n            (buttonIcon.getFill().material as THREE.ShaderMaterial).uniforms.opacity.value = 0.25;\r\n          }\r\n        });\r\n\r\n        buttonIcon.addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n        });\r\n\r\n        /**\r\n         * FEAT ICON \r\n         */ \r\n\r\n        this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n        this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n\r\n        this.widget.userData.iconSprite.scale.x = 32;\r\n        this.widget.userData.iconSprite.scale.y = 32;\r\n        this.widget.userData.iconSprite.position.z = 5;\r\n        this.widget.userData.iconSprite.renderOrder = 5;\r\n        TextureLoader.enQueue(feat.icon, this.widget.userData.iconMaterial, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n          this.widget.userData.iconSprite.scale.x = texture.image.width;\r\n          this.widget.userData.iconSprite.scale.y = texture.image.height;\r\n          if(locked){\r\n            this.widget.userData.iconMaterial.opacity = 0.25;\r\n          }\r\n          this.widget.userData.iconMaterial.transparent = true;\r\n          this.widget.userData.iconMaterial.needsUpdate = true;\r\n        });\r\n\r\n        _buttonIconWidget.add(this.widget.userData.iconSprite);\r\n\r\n        /**\r\n         * BLUE ARROW\r\n         */\r\n        \r\n        const arrowOffset = (this.extent.width/2 - buttonIcon.extent.width/2)/2;\r\n        if(i > 0){\r\n          const arrowIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n          arrowIcon.name = 'ARROW';\r\n          arrowIcon.setText('');\r\n          arrowIcon.disableTextAlignment();\r\n          arrowIcon.extent.width = arrowHeight;\r\n          arrowIcon.extent.height = arrowHeight;\r\n          arrowIcon.extent.top = 0;\r\n          arrowIcon.extent.left = 0;\r\n          arrowIcon.hasBorder = false;\r\n          arrowIcon.hasHighlight = false;\r\n          arrowIcon.disableBorder();\r\n          arrowIcon.disableHighlight();\r\n          arrowIcon.hasText = false;\r\n          arrowIcon.autoCalculatePosition = false;\r\n          this.children.push(arrowIcon);\r\n\r\n          const _arrowIconWidget = arrowIcon.createControl();\r\n          switch(i){\r\n            case 2:\r\n              _arrowIconWidget.position.x = arrowOffset;\r\n            break;\r\n            case 1:\r\n              _arrowIconWidget.position.x = -arrowOffset;\r\n            break;\r\n          }\r\n          _arrowIconWidget.position.y = 0;\r\n          _arrowIconWidget.position.z = this.zIndex + 1;\r\n\r\n          this.widget.add(_arrowIconWidget);\r\n\r\n          TextureLoader.enQueue('uibit_abi_arrow', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n            arrowIcon.setMaterialTexture( arrowIcon.border.fill.material, texture);\r\n            arrowIcon.border.fill.material.transparent = true;\r\n            arrowIcon.setMaterialTexture( arrowIcon.highlight.fill.material, texture);\r\n            arrowIcon.highlight.fill.material.transparent = true;\r\n            if(locked){\r\n              arrowIcon.border.fill.material.uniforms.opacity.value = 0.25;\r\n              arrowIcon.highlight.fill.material.uniforms.opacity.value = 0.25;\r\n            }\r\n          });\r\n        }\r\n\r\n      }\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error('GUIFeatItem createControl', e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\gui\\GUIInventoryItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":53,"column":27,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":53,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":53,"column":27,"nodeType":"MemberExpression","messageId":"errorCall","endLine":53,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":65,"column":26,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":65,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":65,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":65,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":65,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":65,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":65,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":65,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on a type that cannot be resolved.","line":65,"column":82,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":65,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":95,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":96,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":96,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":98,"column":26,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":98,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":98,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":98,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":100,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":101,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":108,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":109,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":109,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":110,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":110,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":113,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":114,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":114,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":115,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":116,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":116,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":117,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":119,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":119,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":119,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":119,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":120,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":120,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":120,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":122,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":122,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":123,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":124,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":124,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":125,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":125,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":126,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":126,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":127,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":127,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":129,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":129,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":130,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":144,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":144,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":144,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":144,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":162,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":162,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":162,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":162,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":175,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":175,"endColumn":61}],"suppressedMessages":[],"errorCount":38,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { GameEngineType } from \"@/enums/engine\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu, GUIButton, GUIControl, GUIListBox, GUIProtoItem } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { GUIControlAlignment } from \"@/enums/gui/GUIControlAlignment\";\r\n\r\n/**\r\n * GUIInventoryItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIInventoryItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIInventoryItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n    this.extent.height = 48;\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n\r\n      const spacing = 5;\r\n      const protoWidth = this.extent.width;\r\n      const protoHeight = this.extent.height;\r\n      const iconWidth = this.extent.height;\r\n      const iconHeight = this.extent.height;\r\n\r\n      const labelWidth = protoWidth - iconWidth - this.parent.border.inneroffset;\r\n\r\n      //Label\r\n      const buttonLabel = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonLabel.extent.left = 0;\r\n      buttonLabel.extent.width = labelWidth;\r\n      buttonLabel.extent.height = protoHeight;\r\n      buttonLabel.setText(this.node.getName());\r\n      buttonLabel.autoCalculatePosition = false;\r\n      this.children.push(buttonLabel);\r\n\r\n      const _buttonWidget = buttonLabel.createControl();\r\n      _buttonWidget.position.x = (protoWidth - buttonLabel.extent.width) / 2;\r\n      _buttonWidget.position.y = 0;\r\n      _buttonWidget.position.z = this.zIndex + 1;\r\n      this.widget.add(_buttonWidget);\r\n\r\n      //Icon\r\n      const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonIcon.setText(this.node.getStackSize() > 1 ? this.node.getStackSize().toString() : '');\r\n      // buttonIcon.disableTextAlignment();\r\n      buttonIcon.text.alignment = GUIControlAlignment.HorizontalRight | GUIControlAlignment.VerticalBottom;\r\n      buttonIcon.extent.width = iconWidth;\r\n      buttonIcon.extent.height = iconHeight;\r\n      buttonIcon.extent.top = 0;\r\n      buttonIcon.extent.left = 0;\r\n      buttonIcon.disableBorder();\r\n      buttonIcon.disableHighlight();\r\n      buttonIcon.hasText = true;\r\n      buttonIcon.autoCalculatePosition = false;\r\n      this.children.push(buttonIcon);\r\n\r\n      const _buttonIconWidget = buttonIcon.createControl();\r\n      _buttonIconWidget.position.x = -(protoWidth/2 - buttonIcon.extent.width/2);\r\n      _buttonIconWidget.position.y = 0;\r\n      _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n      //Stack Count Text Position\r\n      // if(this.node.getStackSize() >= 100){\r\n      //   buttonIcon.widget.userData.text.position.set(6, -10, 5);\r\n      // }else if(this.node.getStackSize() >= 10){\r\n      //   buttonIcon.widget.userData.text.position.set(10, -10, 5);\r\n      // }else{\r\n      //   buttonIcon.widget.userData.text.position.set(14, -10, 5);\r\n      // }\r\n\r\n      this.widget.add(_buttonIconWidget);\r\n\r\n      this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.iconMaterial.transparent = true;\r\n      this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n      //log.info(this.node.getIcon());\r\n      TextureLoader.Load(this.node.getIcon()).then((texture: OdysseyTexture) => {\r\n        if(texture){\r\n          this.widget.userData.iconMaterial.map = texture;\r\n          this.widget.userData.iconMaterial.needsUpdate = true;\r\n        }\r\n      });\r\n      \r\n      this.widget.userData.spriteGroup = new THREE.Group();\r\n      //this.widget.spriteGroup.position.x = -(protoWidth/2)-(52/2); //HACK\r\n      //this.widget.spriteGroup.position.y -= 4;\r\n      this.widget.userData.iconSprite.scale.x = iconWidth * 0.95;\r\n      this.widget.userData.iconSprite.scale.y = iconHeight * 0.95;\r\n      this.widget.userData.iconSprite.position.z = 2;\r\n\r\n      this.widget.userData.hexMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.hexMaterial.transparent = true;\r\n      this.widget.userData.hexSprite = new THREE.Sprite( this.widget.userData.hexMaterial );\r\n      this.widget.userData.hexSprite.scale.x = \r\n        this.widget.userData.hexSprite.scale.y = iconWidth;\r\n      this.widget.userData.hexSprite.position.z = 1;\r\n\r\n      this.widget.userData.spriteGroup.add(this.widget.userData.hexSprite);  \r\n      this.widget.userData.spriteGroup.add(this.widget.userData.iconSprite);\r\n\r\n      if(this.node.getStackSize() >= 100){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_7' : 'uibit_eqp_itm3');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else if(this.node.getStackSize() > 1){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_6' : 'uibit_eqp_itm2');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else{\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_3' : 'uibit_eqp_itm1');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }\r\n\r\n      this.onSelect = () => {\r\n        if(this.selected){\r\n          this.showHighlight();\r\n          this.hideBorder();\r\n          this.pulsing = true;\r\n          this.text.color.copy(this.defaultColor);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.showHighlight();\r\n          buttonLabel.hideBorder();\r\n          this.widget.userData.hexMaterial.color.copy(this.defaultHighlightColor);\r\n          buttonLabel.setHighlightColor(this.defaultHighlightColor.r, this.defaultHighlightColor.g, this.defaultHighlightColor.b);\r\n          buttonLabel.pulsing = true;\r\n          buttonIcon.pulsing = true;\r\n\r\n          buttonLabel.text.color.copy(this.defaultHighlightColor);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }else{\r\n          this.hideHighlight();\r\n          this.showBorder();\r\n          this.pulsing = false;\r\n          this.text.color.copy(this.defaultColor);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.hideHighlight();\r\n          buttonLabel.showBorder();\r\n          this.widget.userData.hexMaterial.color.copy(this.defaultColor);\r\n          buttonLabel.setBorderColor(this.defaultColor.r, this.defaultColor.g, this.defaultColor.b);\r\n          buttonLabel.pulsing = false;\r\n          buttonIcon.pulsing = false;\r\n\r\n          buttonLabel.text.color.copy(this.defaultColor);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }\r\n      };\r\n      this.onSelect.call(this);\r\n\r\n      //StackCount Text\r\n      _buttonIconWidget.add(this.widget.userData.spriteGroup);\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\gui\\GUISpellItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":46,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":46,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":59,"column":70,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":59,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__index on a type that cannot be resolved.","line":59,"column":76,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":59,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .constant on a type that cannot be resolved.","line":61,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":61,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":64,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":64,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__index on a type that cannot be resolved.","line":64,"column":55,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":64,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":100,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":100,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":101,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":101,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":102,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":102,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":103,"column":42,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":103,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":104,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":104,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":118,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":118,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":120,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":121,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":122,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on an `any` value.","line":123,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | string[]`.","line":124,"column":31,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":124,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .iconresref on a type that cannot be resolved.","line":124,"column":78,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":124,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":124,"column":90,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":124,"endColumn":123},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":125,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":125,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":125,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":125,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":126,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":126,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":126,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":126,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .opacity on an `any` value.","line":128,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":128,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":130,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":131,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":131,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":134,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":134,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":171,"column":52,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":171,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":172,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":172,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":173,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":173,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ShaderMaterial`.","line":174,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":174,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":175,"column":47,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":175,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":177,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":177,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":178,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":178,"endColumn":57}],"suppressedMessages":[],"errorCount":34,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { TextureType } from \"@/enums/loaders/TextureType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { GUIProtoItem, GUIButton } from \"@/gui\";\r\nimport type { GUIControl, GameMenu } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/**\r\n * GUISpellItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUISpellItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUISpellItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl | null | undefined = undefined, scale = false){\r\n    super(menu, control, parent ?? undefined, scale);\r\n    this.disableSelection = true;\r\n    this.extent.height = 45;\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n\r\n      const iconHeight = this.extent.height;\r\n      const arrowHeight = iconHeight; //32\r\n\r\n      const spellList = this.node;\r\n      for(let i = 0; i < spellList.length; i++){\r\n        const spell = spellList[i];\r\n\r\n        const hasPrereq = true;\r\n        /*if(spell.prerequisites != '****'){\r\n          const requiredSpellIds = spell.prerequisites.split('_').map((id:string) => parseInt(id));\r\n          for(let j = 0; j < requiredSpellIds.length; j++){\r\n            if(!GameState.PartyManager.party[0].getHasSpell(requiredSpellIds[j])){\r\n              hasPrereq = false;\r\n              break;\r\n            }\r\n          }\r\n        }*/\r\n\r\n        const hasSpell = GameState.PartyManager.party[0].getHasSpell(spell.__index);\r\n\r\n        log.debug('spell', spell.constant, hasPrereq);\r\n\r\n        const unknownSpells: number[] = [176, 177, 178, 179, 180, 181, 182];\r\n        const isUnknown = unknownSpells.indexOf(spell.__index) >= 0;\r\n\r\n        const locked = !hasSpell;//!hasSpell || !hasPrereq;\r\n        // if(locked){ continue; }\r\n\r\n        const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n        buttonIcon.name = 'BUTTON';\r\n        buttonIcon.setText('');\r\n        buttonIcon.disableTextAlignment();\r\n        buttonIcon.extent.width = iconHeight;\r\n        buttonIcon.extent.height = iconHeight;\r\n        buttonIcon.extent.top = 0;\r\n        buttonIcon.extent.left = 0;\r\n        buttonIcon.hasBorder = false;\r\n        buttonIcon.hasHighlight = false;\r\n        buttonIcon.hasText = false;\r\n        buttonIcon.autoCalculatePosition = false;\r\n        this.children.push(buttonIcon);\r\n\r\n        const _buttonIconWidget = buttonIcon.createControl();\r\n        switch(i){\r\n          case 2:\r\n            _buttonIconWidget.position.x = (this.extent.width/2 - buttonIcon.extent.width/2);\r\n          break;\r\n          case 1:\r\n            _buttonIconWidget.position.x = 0;\r\n          break;\r\n          default:\r\n            _buttonIconWidget.position.x = -(this.extent.width/2 - buttonIcon.extent.width/2);\r\n          break;\r\n        }\r\n        _buttonIconWidget.position.y = 0;\r\n        _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n        this.widget.add(_buttonIconWidget);\r\n\r\n        TextureLoader.enQueue('uibit_abi_back', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n          buttonIcon.setMaterialTexture( buttonIcon.border.fill.material, texture);\r\n          buttonIcon.border.fill.material.transparent = true;\r\n          buttonIcon.setMaterialTexture( buttonIcon.highlight.fill.material, texture);\r\n          buttonIcon.highlight.fill.material.transparent = true;\r\n          if(locked){\r\n            (buttonIcon.getFill().material as THREE.ShaderMaterial).uniforms.opacity.value = 0.25;\r\n          }\r\n        });\r\n\r\n        buttonIcon.addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n        });\r\n\r\n        /**\r\n         * FEAT ICON \r\n         */ \r\n        this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n        this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n\r\n        this.widget.userData.iconSprite.scale.x = 32;\r\n        this.widget.userData.iconSprite.scale.y = 32;\r\n        this.widget.userData.iconSprite.position.z = 5;\r\n        this.widget.userData.iconSprite.renderOrder = 5;\r\n        TextureLoader.enQueue((isUnknown && !hasSpell) ? 'ip_secret' : spell.iconresref, this.widget.userData.iconMaterial, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n          this.widget.userData.iconSprite.scale.x = texture.image.width;\r\n          this.widget.userData.iconSprite.scale.y = texture.image.height;\r\n          if(locked && !isUnknown){\r\n            this.widget.userData.iconMaterial.opacity = 0.25;\r\n          }\r\n          this.widget.userData.iconMaterial.transparent = true;\r\n          this.widget.userData.iconMaterial.needsUpdate = true;\r\n        });\r\n\r\n        _buttonIconWidget.add(this.widget.userData.iconSprite);\r\n\r\n        /**\r\n         * BLUE ARROW\r\n         */\r\n        const arrowOffset = (this.extent.width/2 - buttonIcon.extent.width/2)/2;\r\n        if(i > 0){\r\n          const arrowIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n          arrowIcon.name = 'ARROW';\r\n          arrowIcon.setText('');\r\n          arrowIcon.disableTextAlignment();\r\n          arrowIcon.extent.width = arrowHeight;\r\n          arrowIcon.extent.height = arrowHeight;\r\n          arrowIcon.extent.top = 0;\r\n          arrowIcon.extent.left = 0;\r\n          arrowIcon.hasBorder = false;\r\n          arrowIcon.hasHighlight = false;\r\n          arrowIcon.disableBorder();\r\n          arrowIcon.disableHighlight();\r\n          arrowIcon.hasText = false;\r\n          arrowIcon.autoCalculatePosition = false;\r\n          this.children.push(arrowIcon);\r\n\r\n          const _arrowIconWidget = arrowIcon.createControl();\r\n          switch(i){\r\n            case 2:\r\n              _arrowIconWidget.position.x = arrowOffset;\r\n            break;\r\n            case 1:\r\n              _arrowIconWidget.position.x = -arrowOffset;\r\n            break;\r\n          }\r\n          _arrowIconWidget.position.y = 0;\r\n          _arrowIconWidget.position.z = this.zIndex + 1;\r\n\r\n          this.widget.add(_arrowIconWidget);\r\n\r\n          TextureLoader.enQueue('uibit_abi_arrow', this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n            arrowIcon.setMaterialTexture( arrowIcon.border.fill.material, texture);\r\n            arrowIcon.border.fill.material.transparent = true;\r\n            arrowIcon.setMaterialTexture( arrowIcon.highlight.fill.material, texture);\r\n            arrowIcon.highlight.fill.material.transparent = true;\r\n            if(locked && !isUnknown){\r\n              arrowIcon.border.fill.material.uniforms.opacity.value = 0.25;\r\n              arrowIcon.highlight.fill.material.uniforms.opacity.value = 0.25;\r\n            }\r\n          });\r\n        }\r\n\r\n      }\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error('GUISpellItem createControl', e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\CharGenClass.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":169,"column":62,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":169,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .blending on a type that cannot be resolved.","line":170,"column":62,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":170,"endColumn":70}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CharGenClass as K1_CharGenClass } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { ModulePlayer } from \"@/module\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\n\r\n/**\r\n * CharGenClass class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenClass.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenClass extends K1_CharGenClass {\r\n\r\n  declare _3D_MODEL2: GUILabel;\r\n  declare LBL_CHAR_GEN: GUILabel;\r\n  declare LBL_CLASS: GUILabel;\r\n  declare LBL_INSTRUCTION: GUILabel;\r\n  declare _3D_MODEL1: GUILabel;\r\n  declare LBL_DESC: GUILabel;\r\n  declare BTN_BACK: GUIButton;\r\n  declare _3D_MODEL3: GUILabel;\r\n  declare _3D_MODEL4: GUILabel;\r\n  declare _3D_MODEL5: GUILabel;\r\n  declare _3D_MODEL6: GUILabel;\r\n  declare BTN_SEL1: GUIButton;\r\n  declare BTN_SEL2: GUIButton;\r\n  declare BTN_SEL3: GUIButton;\r\n  declare BTN_SEL4: GUIButton;\r\n  declare BTN_SEL6: GUIButton;\r\n  declare BTN_SEL5: GUIButton;\r\n  cgmain_light: OdysseyModel;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'classsel_p';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n    this.userCanClose = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MainMenu.Start();\r\n      });\r\n\r\n      this.BTN_SEL1.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 0;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.BTN_SEL2.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 1;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.BTN_SEL3.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 2;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.BTN_SEL4.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 3;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.BTN_SEL5.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 4;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.BTN_SEL6.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(this.selecting) return;\r\n        this.selecting = true;\r\n        GameState.CharGenManager.selectedClass = 5;\r\n        const template = GameState.CharGenManager.templates.get(GameState.CharGenManager.selectedClass);\r\n        GameState.CharGenManager.selectedCreature = new ModulePlayer(template);\r\n        GameState.CharGenManager.selectedCreature.load();\r\n        GameState.CharGenManager.selectedCreature.loadModel().then((model: OdysseyModel3D) => {\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this.selecting = false;\r\n            this.manager.CharGenMain.childMenu = this.manager.CharGenQuickOrCustom;\r\n            this.manager.CharGenMain.open();\r\n          });\r\n        });\r\n      });\r\n\r\n      this.tGuiPanel.getFill().position.z = -0.5;\r\n\r\n      for(let i = 0; i < 6; i++){\r\n        const control = this.getControlByName('_3D_MODEL'+(i+1));\r\n        const _3dView = GameState.CharGenManager.lbl_3d_views.get(i);\r\n        if(_3dView){\r\n          _3dView.visible = true;\r\n          _3dView.camera.aspect = control.extent.width / control.extent.height;\r\n          _3dView.camera.updateProjectionMatrix();\r\n          control.setFillTexture(_3dView.texture.texture);\r\n        }\r\n        (control.getFill().material as THREE.ShaderMaterial).transparent = true;\r\n        (control.getFill().material as THREE.ShaderMaterial).blending = 1;\r\n      }\r\n\r\n      resolve();  \r\n    });\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\CharGenMain.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":68,"column":67,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":68,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .blending on a type that cannot be resolved.","line":69,"column":67,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":69,"endColumn":75}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CharGenMain as K1_CharGenMain } from \"@/game/kotor/KOTOR\";\nimport { LBL_3DView, type GUILabel } from \"@/gui\";\r\n\r\n/**\r\n * CharGenMain class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenMain.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenMain extends K1_CharGenMain {\r\n\r\n  declare LBL_BAR1: GUILabel;\r\n  declare LBL_STATSBACK: GUILabel;\r\n  declare LBL_STATSBORDER: GUILabel;\r\n  declare LBL_VIT: GUILabel;\r\n  declare LBL_DEF: GUILabel;\r\n  declare NEW_WILL_LBL: GUILabel;\r\n  declare MODEL_LBL: GUILabel;\r\n  declare NEW_REFL_LBL: GUILabel;\r\n  declare NEW_FORT_LBL: GUILabel;\r\n  declare LBL_FORTITUDE: GUILabel;\r\n  declare PORTRAIT_LBL: GUILabel;\r\n  declare MAIN_TITLE_LBL: GUILabel;\r\n  declare STR_LBL: GUILabel;\r\n  declare LBL_NAME: GUILabel;\r\n  declare DEX_LBL: GUILabel;\r\n  declare CON_LBL: GUILabel;\r\n  declare INT_LBL: GUILabel;\r\n  declare WIS_LBL: GUILabel;\r\n  declare CHA_LBL: GUILabel;\r\n  declare STR_AB_LBL: GUILabel;\r\n  declare DEX_AB_LBL: GUILabel;\r\n  declare CON_AB_LBL: GUILabel;\r\n  declare INT_AB_LBL: GUILabel;\r\n  declare WIS_AB_LBL: GUILabel;\r\n  declare CHA_AB_LBL: GUILabel;\r\n  declare LBL_WILL: GUILabel;\r\n  declare LBL_REFLEX: GUILabel;\r\n  declare LBL_BEVEL_L: GUILabel;\r\n  declare LBL_BEVEL_R: GUILabel;\r\n  declare LBL_LEVEL_VAL: GUILabel;\r\n  declare LBL_CLASS: GUILabel;\r\n  declare LBL_PORTBORDER: GUILabel;\r\n  declare LBL_VIT_NAME: GUILabel;\r\n  declare LBL_DEF_NAME: GUILabel;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'maincg_p';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.tGuiPanel.getFill().position.z = -0.5;\r\n\r\n      this._3dView = new LBL_3DView();\r\n      this._3dView.visible = true;\r\n      this._3dView.camera.aspect = this.MODEL_LBL.extent.width / this.MODEL_LBL.extent.height;\r\n      this._3dView.camera.updateProjectionMatrix();\r\n      this.MODEL_LBL.setFillTexture(this._3dView.texture.texture);\r\n      (this.MODEL_LBL.getFill().material as THREE.ShaderMaterial).transparent = true;\r\n      (this.MODEL_LBL.getFill().material as THREE.ShaderMaterial).blending = 1;\r\n\r\n      this.Init3D();\r\n      resolve(); \r\n    });\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\CharGenPortCust.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":168,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":168,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CharGenClasses } from \"@/game/CharGenClasses\";\nimport { CharGenPortCust as K1_CharGenPortCust } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\n\r\n/**\r\n * CharGenPortCust class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenPortCust.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenPortCust extends K1_CharGenPortCust {\r\n\r\n  declare LBL_HEAD: GUILabel;\r\n  declare MAIN_TITLE_LBL: GUILabel;\r\n  declare SUB_TITLE_LBL: GUILabel;\r\n  declare LBL_BEVEL_M: GUILabel;\r\n  declare LBL_PORTRAIT: GUILabel;\r\n  declare LBL_BEVEL_B: GUILabel;\r\n  declare LBL_BEVEL_T: GUILabel;\r\n  declare BTN_ARRL: GUIButton;\r\n  declare BTN_ARRR: GUIButton;\r\n  declare LBL_BEVEL_L: GUILabel;\r\n  declare LBL_BEVEL_R: GUILabel;\r\n  declare LBL_BAR1: GUILabel;\r\n  declare LBL_BAR2: GUILabel;\r\n  declare LBL_BAR3: GUILabel;\r\n  declare LBL_BAR4: GUILabel;\r\n  declare LBL_BAR5: GUILabel;\r\n  declare LBL_BAR6: GUILabel;\r\n  declare LBL_BAR7: GUILabel;\r\n  declare LBL_BAR8: GUILabel;\r\n  declare BTN_BACK: GUIButton;\r\n  declare BTN_ACCEPT: GUIButton;\r\n\r\n  isCharLoading: boolean = false;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'portcust_p';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    this.BTN_ARRL.addEventListener('click', async (e) => {\r\n      e.stopPropagation();\r\n      if(this.isCharLoading) return;\r\n      this.isCharLoading = true;\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n    \r\n      let idx = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.indexOf(creature.appearance);\r\n      const arrayLength = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.length;\r\n      if(idx <= 0){\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[arrayLength - 1];\r\n      }else{\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[--idx];\r\n      }\r\n      creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n\r\n      for(let i = 0; i < GameState.SWRuleSet.portraits.length; i++){\r\n        const port = GameState.SWRuleSet.portraits[i];\r\n        if(port.appearancenumber == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_l == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n\r\n          break;\r\n        }else if(port.appearance_s == creature.appearance){\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          creature.portraitId = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      const model = await creature.loadModel();\r\n      this.updateCamera();\r\n      this.UpdatePortrait();\r\n      if(model){\r\n        model.rotation.z = -Math.PI/2;\r\n        model.removeFromParent();\r\n        this._3dView.addModel(model);\r\n      }\r\n      this.isCharLoading = false;\r\n\r\n    });\r\n\r\n    this.BTN_ARRR.addEventListener('click', async (e) => {\r\n      e.stopPropagation();\r\n      if(this.isCharLoading) return;\r\n      this.isCharLoading = true;\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n\r\n      let idx = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.indexOf(creature.appearance);\r\n      const arrayLength = CharGenClasses[GameState.CharGenManager.selectedClass].appearances.length;\r\n      if(idx >= arrayLength - 1){\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[0];\r\n      }else{\r\n        creature.appearance = CharGenClasses[GameState.CharGenManager.selectedClass].appearances[++idx];\r\n      }\r\n      creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n\r\n      for(let i = 0; i < GameState.SWRuleSet.portraits.length; i++){\r\n        const port = GameState.SWRuleSet.portraits[i];\r\n        if(port.appearancenumber == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_l == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }else if(port.appearance_s == creature.appearance){\r\n          creature.portraitId = i;\r\n          creature.portrait = GameState.SWRuleSet.portraits[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      const model = await creature.loadModel();\r\n      this.updateCamera();\r\n      this.UpdatePortrait();\r\n      if(model){\r\n        model.rotation.z = -Math.PI/2;\r\n        model.removeFromParent();\r\n        this._3dView.addModel(model);\r\n      }\r\n      this.isCharLoading = false;\r\n\r\n    });\r\n\r\n    this.BTN_BACK.addEventListener('click', async (e) => {\r\n      e.stopPropagation();\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n      if(!this.exiting){\r\n        this.exiting = true;\r\n        //Restore previous appearance\r\n        creature.appearance = this.appearance;\r\n        creature.portraitId = this.portraitId;\r\n        creature.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(creature.appearance);\r\n        const model = await creature.loadModel();\r\n        this.exiting = false;\r\n        this.close();\r\n      }\r\n      this.isCharLoading = false;\r\n    });\r\n\r\n    this.BTN_ACCEPT.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n      const creature = GameState.CharGenManager.selectedCreature;\r\n      \r\n      //Save appearance choice\r\n      creature.template.getFieldByLabel('Appearance_Type').setValue(creature.appearance);\r\n      creature.template.getFieldByLabel('PortraitId').setValue(creature.portraitId);\r\n      this.manager.CharGenQuickPanel.step1 = true;\r\n      this.close();\r\n    });\r\n\r\n    this.tGuiPanel.widget.userData.fill.position.z = -0.5\r\n\r\n    this._3dView.visible = true;\r\n    this._3dView.camera.aspect = this.LBL_HEAD.extent.width / this.LBL_HEAD.extent.height;\r\n    this._3dView.camera.updateProjectionMatrix();\r\n    this.LBL_HEAD.setFillTexture(this._3dView.texture.texture);\r\n\r\n    this.Init3D();\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\CharGenQuickOrCustom.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":66,"column":20,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":66,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\nimport type { GUIListBox, GUIButton } from \"@/gui\";\r\nimport { TalentFeat } from \"@/talents\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { CharGenQuickOrCustom as K1_CharGenQuickOrCustom } from \"@/game/kotor/KOTOR\";\r\n\r\n/**\r\n * CharGenQuickOrCustom class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CharGenQuickOrCustom.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CharGenQuickOrCustom extends K1_CharGenQuickOrCustom {\r\n\r\n  declare BTN_BACK: GUIButton;\r\n  declare LB_DESC: GUIListBox;\r\n  declare QUICK_CHAR_BTN: GUIButton;\r\n  declare CUST_CHAR_BTN: GUIButton;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'qorcpnl_p';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.QUICK_CHAR_BTN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        try{\r\n          const creatureClass = GameState.SWRuleSet.classes[GameState.CharGenManager.selectedClass];\r\n          const saving_throw_label = creatureClass['savingthrowtable'].toLowerCase();\r\n          const saving_throw_data = GameState.TwoDAManager.datatables.get(saving_throw_label).rows[0];\r\n          const feats_table = GameState.SWRuleSet.feats;\r\n\r\n          GameState.CharGenManager.selectedCreature.str = creatureClass.str;\r\n          GameState.CharGenManager.selectedCreature.dex = creatureClass.dex;\r\n          GameState.CharGenManager.selectedCreature.con = creatureClass.con;\r\n          GameState.CharGenManager.selectedCreature.wis = creatureClass.wis;\r\n          GameState.CharGenManager.selectedCreature.int = creatureClass.int;\r\n          GameState.CharGenManager.selectedCreature.cha = creatureClass.cha;\r\n          GameState.CharGenManager.selectedCreature.str = creatureClass.str;\r\n\r\n          GameState.CharGenManager.selectedCreature.fortbonus = parseInt(saving_throw_data.fortsave);\r\n          GameState.CharGenManager.selectedCreature.willbonus = parseInt(saving_throw_data.willsave);\r\n          GameState.CharGenManager.selectedCreature.refbonus = parseInt(saving_throw_data.refsave);\r\n\r\n          for(let i = 0, len = feats_table.length; i < len; i++){\r\n            const feat_data = feats_table[i];\r\n            if(feat_data.getGranted(creatureClass) == 1){\r\n              GameState.CharGenManager.selectedCreature.feats.push(new TalentFeat(i));\r\n            }\r\n          }\r\n          this.manager.CharGenMain.close();\r\n          this.manager.CharGenMain.childMenu = this.manager.CharGenQuickPanel;\r\n          this.manager.CharGenMain.open();\r\n        }catch(e){\r\n          log.info(e);\r\n        }\r\n      });\r\n\r\n      this.CUST_CHAR_BTN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //GameState.CharGenMain.state = CharGenMain.STATES.CUSTOM;\r\n        //GameState.CharGenCustomPanel.Show();\r\n        this.manager.CharGenMain.close();\r\n        this.manager.CharGenMain.childMenu = this.manager.CharGenCustomPanel;\r\n        this.manager.CharGenMain.open();\r\n\r\n        //Reset the Attributes window\r\n        this.manager.CharGenAbilities.reset();\r\n\r\n        //Reset the Skills window\r\n        this.manager.CharGenSkills.reset();\r\n      });\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        //Game.CharGenMain.Hide();\r\n\r\n        try{\r\n          GameState.CharGenManager.selectedCreature.model.parent.remove(GameState.CharGenManager.selectedCreature.model);\r\n        }catch(e){}\r\n\r\n        // this.manager.CharGenClass.getControlByName('_3D_MODEL'+(CharGenManager.selectedClass+1))\r\n        //  .userData._3dView.scene.add(CharGenManager.selectedCreature.model);\r\n        this.manager.CharGenMain.close();\r\n      });\r\n\r\n      //Hide because this submenu is very incomplete.\r\n      //Comment out this line to work on the custom chargen screen\r\n      this.CUST_CHAR_BTN.hide();\r\n\r\n      // this.tGuiPanel.offset.x = -180;\r\n      // this.tGuiPanel.offset.y = 100;\r\n      this.recalculatePosition();\r\n      resolve();\r\n    });\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\InGameOverlay.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":156,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":156,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":293,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":293,"endColumn":50}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { ActionMenuManager } from \"@/engine/menu/ActionMenuManager\";\r\nimport { AutoPauseState } from \"@/enums/engine/AutoPauseState\";\r\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\r\nimport { EngineState } from \"@/enums/engine/EngineState\";\r\nimport { Anchor } from \"@/enums/gui/Anchor\";\r\nimport { InGameOverlay as K1_InGameOverlay } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\r\nimport { LBL_MapView } from \"@/gui\";\r\nimport type { GUILabel, GUIButton, GUICheckBox, GUIProgressBar } from \"@/gui\";\r\nimport { TalentObject } from \"@/talents\";\r\n\r\n/**\r\n * InGameOverlay class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file InGameOverlay.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class InGameOverlay extends K1_InGameOverlay {\r\n\r\n  declare LBL_MAPBORDER: GUILabel;\r\n  declare LBL_MOULDING3: GUILabel;\r\n  declare LBL_BACK3: GUILabel;\r\n  declare LBL_BACK1: GUILabel;\r\n  declare LBL_CHAR1: GUILabel;\r\n  declare LBL_ARROW_MARGIN: GUILabel;\r\n  declare LBL_COMBATBG3: GUILabel;\r\n  declare LBL_MAP: GUILabel;\r\n  declare BTN_ACTION5: GUIButton;\r\n  declare BTN_ACTIONUP5: GUIButton;\r\n  declare BTN_ACTIONDOWN5: GUIButton;\r\n  declare LBL_ACTION5: GUIButton;\r\n  declare LBL_CMBTMSGBG: GUILabel;\r\n  declare LBL_MOULDING1: GUILabel;\r\n  declare LBL_ACTIONDESCBG: GUILabel;\r\n  declare LBL_ACTIONDESC: GUILabel;\r\n  declare TB_STEALTH: GUICheckBox;\r\n  declare TB_SOLO: GUICheckBox;\r\n  declare LBL_MAPVIEW: GUILabel;\r\n  declare BTN_MINIMAP: GUIButton;\r\n  declare LBL_MENUBG: GUILabel;\r\n  declare TB_PAUSE: GUICheckBox;\r\n  declare BTN_SWAPWEAPONS: GUICheckBox;\r\n  declare LBL_NAMEBG: GUILabel;\r\n  declare LBL_HEALTHBG: GUILabel;\r\n  declare BTN_MSG: GUIButton;\r\n  declare BTN_JOU: GUIButton;\r\n  declare BTN_MAP: GUIButton;\r\n  declare BTN_OPT: GUIButton;\r\n  declare BTN_CHAR: GUIButton;\r\n  declare BTN_ABI: GUIButton;\r\n  declare BTN_INV: GUIButton;\r\n  declare BTN_EQU: GUIButton;\r\n  declare LBL_BACK2: GUILabel;\r\n  declare LBL_CHAR3: GUILabel;\r\n  declare LBL_DISABLE3: GUILabel;\r\n  declare LBL_DEBILATATED3: GUILabel;\r\n  declare LBL_LEVELUP3: GUILabel;\r\n  declare LBL_STEALTHXP: GUILabel;\r\n  declare BTN_ACTION0: GUIButton;\r\n  declare BTN_ACTIONUP0: GUIButton;\r\n  declare BTN_ACTIONDOWN0: GUIButton;\r\n  declare LBL_ACTION0: GUIButton;\r\n  declare BTN_ACTION3: GUIButton;\r\n  declare BTN_ACTIONUP3: GUIButton;\r\n  declare BTN_ACTIONDOWN3: GUIButton;\r\n  declare LBL_ACTION3: GUIButton;\r\n  declare BTN_ACTION2: GUIButton;\r\n  declare BTN_ACTIONUP2: GUIButton;\r\n  declare BTN_ACTIONDOWN2: GUIButton;\r\n  declare LBL_ACTION2: GUIButton;\r\n  declare BTN_ACTION1: GUIButton;\r\n  declare BTN_ACTIONUP1: GUIButton;\r\n  declare BTN_ACTIONDOWN1: GUIButton;\r\n  declare LBL_ACTION1: GUIButton;\r\n  declare LBL_DARKSHIFT: GUILabel;\r\n  declare PB_FORCE2: GUIProgressBar;\r\n  declare PB_VIT2: GUIProgressBar;\r\n  declare PB_VIT1: GUIProgressBar;\r\n  declare LBL_DISABLE1: GUILabel;\r\n  declare LBL_DEBILATATED1: GUILabel;\r\n  declare LBL_LEVELUP1: GUILabel;\r\n  declare LBL_CHAR2: GUILabel;\r\n  declare LBL_DEBILATATED2: GUILabel;\r\n  declare LBL_DISABLE2: GUILabel;\r\n  declare PB_FORCE1: GUIProgressBar;\r\n  declare PB_FORCE3: GUIProgressBar;\r\n  declare PB_VIT3: GUIProgressBar;\r\n  declare LBL_NAME: GUILabel;\r\n  declare PB_HEALTH: GUIProgressBar;\r\n  declare LBL_LEVELUP2: GUILabel;\r\n  declare LBL_CMBTEFCTRED1: GUILabel;\r\n  declare LBL_CMBTEFCTINC1: GUILabel;\r\n  declare LBL_CMBTEFCTRED2: GUILabel;\r\n  declare LBL_CMBTEFCTINC2: GUILabel;\r\n  declare LBL_CMBTEFCTINC3: GUILabel;\r\n  declare LBL_CMBTEFCTRED3: GUILabel;\r\n  declare LBL_ARROW: GUILabel;\r\n  declare LBL_JOURNAL: GUILabel;\r\n  declare LBL_CASH: GUILabel;\r\n  declare LBL_PLOTXP: GUILabel;\r\n  declare LBL_ITEMRCVD: GUILabel;\r\n  declare LBL_ITEMLOST: GUILabel;\r\n  declare BTN_CLEARALL: GUIButton;\r\n  declare LBL_LIGHTSHIFT: GUILabel;\r\n  declare BTN_CHAR3: GUIButton;\r\n  declare BTN_CHAR1: GUIButton;\r\n  declare BTN_CHAR2: GUIButton;\r\n  declare LBL_QUEUE0: GUILabel;\r\n  declare LBL_QUEUE1: GUILabel;\r\n  declare LBL_QUEUE2: GUILabel;\r\n  declare LBL_QUEUE3: GUILabel;\r\n  declare BTN_CLEARONE: GUIButton;\r\n  declare BTN_CLEARONE2: GUIButton;\r\n  declare BTN_TARGET0: GUIButton;\r\n  declare BTN_TARGETUP0: GUIButton;\r\n  declare BTN_TARGETDOWN0: GUIButton;\r\n  declare LBL_TARGET0: GUIButton;\r\n  declare BTN_TARGET1: GUIButton;\r\n  declare BTN_TARGETUP1: GUIButton;\r\n  declare BTN_TARGETDOWN1: GUIButton;\r\n  declare LBL_TARGET1: GUIButton;\r\n  declare BTN_TARGET2: GUIButton;\r\n  declare BTN_TARGETUP2: GUIButton;\r\n  declare BTN_TARGETDOWN2: GUIButton;\r\n  declare LBL_TARGET2: GUIButton;\r\n  declare LBL_CMBTMODEMSG: GUILabel;\r\n  declare BTN_ACTION4: GUIButton;\r\n  declare BTN_ACTIONUP4: GUIButton;\r\n  declare BTN_ACTIONDOWN4: GUIButton;\r\n  declare LBL_ACTION4: GUIButton;\r\n  declare miniMap: LBL_MapView;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'mipc28x6_p';\r\n    this.background = '';\r\n    this.voidFill = false;\r\n    this.userCanClose = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n\r\n      //Auto scale anchor hack/fix\r\n      this.BTN_ACTION5.anchor = Anchor.BottomLeft;\r\n      this.BTN_ACTION5.recalculate();\r\n      this.LBL_QUEUE0.anchor = Anchor.BottomCenter;\r\n      this.LBL_QUEUE0.recalculate();\r\n\r\n      this.tGuiPanel.widget.userData.fill.visible = false;\r\n\r\n      /*this.TB_STEALTH.hideBorder();\r\n      this.TB_PAUSE.hideBorder();\r\n      this.TB_SOLO.hideBorder();*/\r\n\r\n      this.LBL_LIGHTSHIFT.hide();\r\n      this.LBL_DARKSHIFT.hide();\r\n      this.LBL_JOURNAL.hide();\r\n      this.LBL_CASH.hide();\r\n      this.LBL_PLOTXP.hide();\r\n      this.LBL_STEALTHXP.hide();\r\n      this.LBL_ITEMRCVD.hide();\r\n      this.LBL_ITEMLOST.hide();\r\n\r\n      //Map INIT\r\n      //this.LBL_MAPBORDER.hideBorder();\r\n      this.LBL_MAP.hide();\r\n      this.LBL_ARROW_MARGIN.hide();\r\n      this.LBL_ARROW?.hide();\r\n      this.miniMap = new LBL_MapView(this.LBL_MAPVIEW);\r\n      this.miniMap.setControl(this.LBL_MAPVIEW);\r\n      this.miniMap.setSize(120, 120);\r\n\r\n      this.LBL_CMBTEFCTRED1.hide();\r\n      this.LBL_CMBTEFCTINC1.hide();\r\n      this.LBL_LEVELUP1.hide();\r\n      //this.LBL_LVLUPBG1.hide();\r\n      this.LBL_DEBILATATED1.hide();\r\n      this.LBL_DISABLE1.hide();\r\n\r\n      this.LBL_CMBTEFCTRED2.hide();\r\n      this.LBL_CMBTEFCTINC2.hide();\r\n      this.LBL_LEVELUP2.hide();\r\n      //this.LBL_LVLUPBG2.hide();\r\n      this.LBL_DEBILATATED2.hide();\r\n      this.LBL_DISABLE2.hide();\r\n\r\n      this.LBL_CMBTEFCTRED3.hide();\r\n      this.LBL_CMBTEFCTINC3.hide();\r\n      this.LBL_LEVELUP3.hide();\r\n      //this.LBL_LVLUPBG3.hide();\r\n      this.LBL_DEBILATATED3.hide();\r\n      this.LBL_DISABLE3.hide();\r\n\r\n\r\n      this.LBL_ACTIONDESC.hide();\r\n      this.LBL_ACTIONDESCBG.hide();\r\n\r\n      this.LBL_NAME.hide();\r\n      this.LBL_NAMEBG.hide();\r\n      this.PB_HEALTH.hide();\r\n      this.LBL_HEALTHBG.hide();\r\n\r\n      this.LBL_CMBTMSGBG.hide();\r\n      this.LBL_CMBTMODEMSG.hide();\r\n      this.BTN_CLEARALL.hideBorder();\r\n\r\n      this.LBL_MOULDING3.widget.position.z = -1;\r\n      this.LBL_MENUBG.widget.position.z = -1;\r\n\r\n\r\n      this.BTN_MSG.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuPartySelection.open();\r\n      });\r\n\r\n      this.BTN_JOU.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuJournal.open();\r\n      });\r\n\r\n      this.BTN_MAP.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuMap.open();\r\n      });\r\n\r\n      this.BTN_OPT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuOptions.open();\r\n      });\r\n\r\n      this.BTN_CHAR.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuCharacter.open();\r\n      });\r\n\r\n      this.BTN_ABI.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuAbilities.open();\r\n      });\r\n\r\n      this.BTN_INV.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuInventory.open();\r\n      });\r\n\r\n      this.BTN_EQU.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuEquipment.open();\r\n      });\r\n\r\n      this.TB_PAUSE.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        \r\n        if(GameState.State == EngineState.PAUSED){\r\n          GameState.AutoPauseManager.Unpause();\r\n        }else{\r\n          GameState.AutoPauseManager.SignalAutoPauseEvent(AutoPauseState.Generic);\r\n        }\r\n\r\n      });\r\n\r\n      this.TB_SOLO.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.TB_STEALTH.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.BTN_CHAR1.addEventListener('click', (e) => {\r\n        this.manager.MenuEquipment.open()\r\n      });\r\n\r\n      this.BTN_CHAR2.addEventListener('click', (e) => {\r\n        GameState.PartyManager.SwitchLeaderAtIndex(2);\r\n      });\r\n\r\n      this.BTN_CHAR3.addEventListener('click', (e) => {\r\n        GameState.PartyManager.SwitchLeaderAtIndex(1);\r\n      });\r\n\r\n      this.BTN_CLEARALL.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.getCurrentPlayer().clearAllActions();\r\n        GameState.getCurrentPlayer().combatData.combatState = false;\r\n        GameState.getCurrentPlayer().cancelCombat();\r\n      });\r\n\r\n      this.LBL_QUEUE0.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.getCurrentPlayer().clearCombatAction();\r\n      });\r\n\r\n      this.LBL_QUEUE1.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(0);\r\n      });\r\n\r\n      this.LBL_QUEUE2.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(1);\r\n      });\r\n\r\n      this.LBL_QUEUE3.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.getCurrentPlayer().clearCombatActionAtIndex(2);\r\n      });\r\n\r\n      for(let i = 0; i < ActionMenuManager.TARGET_MENU_COUNT; i++){\r\n\r\n        this.getControlByName('LBL_TARGET'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.onTargetMenuAction(i);\r\n        });\r\n\r\n        this.getControlByName('BTN_TARGETUP'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.ActionPanels.targetPanels[i].previousAction();\r\n          this.UpdateTargetUIIcon(i);\r\n        });\r\n\r\n        this.getControlByName('BTN_TARGETDOWN'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.ActionPanels.targetPanels[i].nextAction();\r\n          this.UpdateTargetUIIcon(i);\r\n        });\r\n\r\n      }\r\n\r\n      for(let i = 0; i < ActionMenuManager.SELF_MENU_COUNT; i++){\r\n\r\n        this.getControlByName('LBL_ACTION'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.onSelfMenuAction(i);\r\n        });\r\n\r\n        this.getControlByName('BTN_ACTIONUP'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.ActionPanels.selfPanels[i].previousAction();\r\n          this.UpdateSelfUIIcon(i);\r\n        });\r\n\r\n        this.getControlByName('BTN_ACTIONDOWN'+i).addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          ActionMenuManager.ActionPanels.selfPanels[i].nextAction();\r\n          this.UpdateSelfUIIcon(i);\r\n        });\r\n\r\n      }\r\n\r\n      //BTN_ACTION buttons alignment fix\r\n      this.BTN_ACTIONUP5.anchor = Anchor.BottomLeft;\r\n      this.BTN_ACTIONDOWN5.anchor = Anchor.BottomLeft;\r\n      this.recalculatePosition();\r\n\r\n      //this.lbl_combatbg2.visible = false;\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n\r\n  show() {\r\n    super.show();\r\n    GameState.SetEngineMode(EngineMode.INGAME);\r\n    // this.BTN_ACTIONDOWN0.flipY();\r\n    // this.BTN_ACTIONDOWN1.flipY();\r\n    // this.BTN_ACTIONDOWN2.flipY();\r\n    // this.BTN_ACTIONDOWN3.flipY();\r\n    this.BTN_ACTIONDOWN4.flipY();\r\n    this.BTN_ACTIONDOWN5.flipY();\r\n  }\r\n\r\n  resize() {\r\n    this.recalculatePosition();\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\MainMenu.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":91,"column":156,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":91,"endColumn":164},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":92,"column":156,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":167},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":94,"column":156,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":94,"endColumn":163}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MenuSaveLoadMode } from \"@/enums/gui/MenuSaveLoadMode\";\r\nimport { MainMenu as K1_MainMenu } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\r\nimport { LBL_3DView } from \"@/gui\";\r\nimport type { GUILabel, GUIListBox, GUIButton } from \"@/gui\";\r\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Game);\r\n\r\n/**\r\n * MainMenu class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MainMenu.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MainMenu extends K1_MainMenu {\r\n\r\n  declare LBL_3DVIEW: GUILabel;\r\n  declare LB_MODULES: GUIListBox;\r\n  declare LBL_GAMELOGO: GUILabel;\r\n  declare LBL_BW: GUILabel;\r\n  declare LBL_LUCAS: GUILabel;\r\n  declare BTN_LOADGAME: GUIButton;\r\n  declare BTN_NEWGAME: GUIButton;\r\n  declare BTN_MOVIES: GUIButton;\r\n  declare BTN_MUSIC: GUIButton;\r\n  declare BTN_OPTIONS: GUIButton;\r\n  declare LBL_NEWCONTENT: GUILabel;\r\n  declare BTN_WARP: GUIButton;\r\n  declare BTN_EXIT: GUIButton;\r\n\r\n  bgMusicResRef: string = 'mus_sion';\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'mainmenu8x6_p';\r\n    this.background = '';\r\n    this.voidFill = true;\r\n    this.userCanClose = false;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.LB_MODULES.hide();\r\n      this.LBL_NEWCONTENT.hide();\r\n      this.BTN_WARP.hide();\r\n\r\n      this.BTN_NEWGAME.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        GameState.CharGenManager.Start();\r\n      });\r\n\r\n      this.BTN_LOADGAME.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MenuSaveLoad.mode = MenuSaveLoadMode.LOADGAME;\r\n        this.manager.MenuSaveLoad.open();\r\n      });\r\n\r\n      this.BTN_MOVIES.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MainMovies.open();\r\n      });\r\n\r\n      this.BTN_MUSIC.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MainMusic.open();\r\n      });\r\n\r\n      this.BTN_OPTIONS.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.manager.MainOptions.open();\r\n      });\r\n\r\n      this.BTN_EXIT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        window.close();\r\n      });\r\n      \r\n      (this.tGuiPanel.widget.userData.fill as { visible?: boolean }).visible = false;\r\n\r\n      this._3dView = new LBL_3DView();\r\n      this._3dView.visible = true;\r\n      (this.LBL_3DVIEW.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).uniforms.map.value = this._3dView.texture.texture;\r\n      (this.LBL_3DVIEW.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).transparent = false;\r\n      this._3dView.setControl(this.LBL_3DVIEW);\r\n      (this.LBL_3DVIEW.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).visible = true;\r\n      \r\n      MDLLoader.loader.load('mainmenu01')\r\n      .then((mdl: OdysseyModel) => {\r\n        OdysseyModel3D.FromMDL(mdl, {\r\n          // manageLighting: false,\r\n          context: this._3dView\r\n        }).then((model: OdysseyModel3D) => {\r\n          log.debug('Model Loaded', model);\r\n          this._3dViewModel = model;\r\n          \r\n          this._3dView.camera.position.copy(model.camerahook.position);\r\n          this._3dView.camera.quaternion.copy(model.camerahook.quaternion);\r\n\r\n          this._3dView.addModel(this._3dViewModel);\r\n          TextureLoader.LoadQueue().then(() => {\r\n            this._3dViewModel.playAnimation(0, true);\r\n            resolve();\r\n          });\r\n        }).catch(resolve);\r\n      }).catch(resolve);\r\n    });\r\n  }\r\n\r\n  update(delta = 0) {\r\n    this._3dView.render(delta);\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    GameState.AlphaTest = 0.5;\r\n  }\r\n    \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\MenuCharacter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":98,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":98,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":99,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":99,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":141,"column":162,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":141,"endColumn":170},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":142,"column":162,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":142,"endColumn":173},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":144,"column":162,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":144,"endColumn":169},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":180,"column":156,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":180,"endColumn":167}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MenuCharacter as K1_MenuCharacter } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\nimport { LBL_3DView } from \"@/gui\";\nimport type { GUILabel, GUIButton, GUISlider } from \"@/gui\";\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\nimport { OdysseyModel } from \"@/odyssey\";\nimport { OdysseyModel3D } from \"@/three/odyssey\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * MenuCharacter class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file MenuCharacter.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class MenuCharacter extends K1_MenuCharacter {\n\n  declare LBL_BAR6: GUILabel;\n  declare LBL_STATSBORDER: GUILabel;\n  declare LBL_MORE_BACK: GUILabel;\n  declare LBL_XP_BACK: GUILabel;\n  declare LBL_3DCHAR: GUILabel;\n  declare BTN_3DCHAR: GUIButton;\n  declare SLD_ALIGN: GUISlider;\n  declare LBL_STR: GUILabel;\n  declare LBL_FORTITUDE_STAT: GUILabel;\n  declare LBL_REFLEX_STAT: GUILabel;\n  declare LBL_WILL_STAT: GUILabel;\n  declare LBL_DEFENSE_STAT: GUILabel;\n  declare LBL_FORCE_STAT: GUILabel;\n  declare LBL_VITALITY_STAT: GUILabel;\n  declare LBL_DEX: GUILabel;\n  declare LBL_CON: GUILabel;\n  declare LBL_INT: GUILabel;\n  declare LBL_CHA: GUILabel;\n  declare LBL_WIS: GUILabel;\n  declare LBL_STR_MOD: GUILabel;\n  declare LBL_DEX_MOD: GUILabel;\n  declare LBL_CON_MOD: GUILabel;\n  declare LBL_INT_MOD: GUILabel;\n  declare LBL_WIS_MOD: GUILabel;\n  declare LBL_CHA_MOD: GUILabel;\n  declare LBL_EXPERIENCE_STAT: GUILabel;\n  declare LBL_NEEDED_XP: GUILabel;\n  declare LBL_STRENGTH: GUILabel;\n  declare LBL_DEXTERITY: GUILabel;\n  declare LBL_CONSTITUTION: GUILabel;\n  declare LBL_INTELLIGENCE: GUILabel;\n  declare LBL_CHARISMA: GUILabel;\n  declare LBL_REFLEX: GUILabel;\n  declare LBL_WILL: GUILabel;\n  declare LBL_EXPERIENCE: GUILabel;\n  declare LBL_NEXT_LEVEL: GUILabel;\n  declare LBL_FORCE: GUILabel;\n  declare LBL_VITALITY: GUILabel;\n  declare LBL_DEFENSE: GUILabel;\n  declare LBL_FORTITUDE: GUILabel;\n  declare LBL_BEVEL: GUILabel;\n  declare LBL_WISDOM: GUILabel;\n  declare LBL_BEVEL2: GUILabel;\n  declare LBL_LIGHT: GUILabel;\n  declare LBL_DARK: GUILabel;\n  declare LBL_BAR1: GUILabel;\n  declare LBL_BAR5: GUILabel;\n  declare LBL_BAR2: GUILabel;\n  declare LBL_BAR3: GUILabel;\n  declare LBL_BAR4: GUILabel;\n  declare LBL_TITLE: GUILabel;\n  declare BTN_EXIT: GUIButton;\n  declare BTN_AUTO: GUIButton;\n  declare BTN_LEVELUP: GUIButton;\n  declare LBL_FORCEMASTERY: GUILabel;\n\n  constructor(){\n    super();\n    this.gui_resref = 'character_p';\n    this.background = 'blackfill';\n    this.voidFill = true;\n  }\n\n  async menuControlInitializer(skipInit: boolean = false) {\n    await super.menuControlInitializer(true);\n    if(skipInit) return;\n    return new Promise<void>((resolve, reject) => {\n      this.BTN_EXIT.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.close();\n      });\n      this._button_b = this.BTN_EXIT;\n\n      this.BTN_AUTO.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if(GameState.getCurrentPlayer().canLevelUp()){\n          GameState.getCurrentPlayer().autoLevelUp();\n          this.updateCharacterStats(GameState.getCurrentPlayer());\n        }\n      });\n      this._button_y = this.BTN_AUTO;\n\n      this.BTN_CHANGE1?.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (GameState.PartyManager.party.length > 1) {\n          GameState.PartyManager.SwitchLeaderAtIndex(1);\n          this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n          this.updateCharacterStats(GameState.PartyManager.party[0]);\n          this.updatePartyMemberPortraitButtons();\n        }\n      });\n      this.BTN_CHANGE2?.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (GameState.PartyManager.party.length > 2) {\n          GameState.PartyManager.SwitchLeaderAtIndex(2);\n          this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n          this.updateCharacterStats(GameState.PartyManager.party[0]);\n          this.updatePartyMemberPortraitButtons();\n        }\n      });\n\n      GameState.PartyManager.AddEventListener('change', () => {\n        if (!this.bVisible) return;\n        this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n        this.updateCharacterStats(GameState.PartyManager.party[0]);\n        this.updatePartyMemberPortraitButtons();\n      });\n\n      MDLLoader.loader.load('charmain_light').then((mdl: OdysseyModel) => {\n        OdysseyModel3D.FromMDL(mdl, {\n          context: this._3dView,\n          // manageLighting: false,\n        }).then((model: OdysseyModel3D) => {\n          try{\n            this._3dView = new LBL_3DView();\n            this._3dView.visible = true;\n            this._3dView.camera.aspect = this.LBL_3DCHAR.extent.width / this.LBL_3DCHAR.extent.height;\n            this._3dView.camera.updateProjectionMatrix();\n            (this.LBL_3DCHAR.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).uniforms.map.value = this._3dView.texture.texture;\n            (this.LBL_3DCHAR.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).transparent = false;\n            this._3dView.setControl(this.LBL_3DCHAR);\n            (this.LBL_3DCHAR.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).visible = true;\n\n            this._3dViewModel = model;\n            this._3dView.addModel(this._3dViewModel);\n\n            this._3dView.camera.position.copy(model.camerahook.position);\n            this._3dView.camera.quaternion.copy(model.camerahook.quaternion);\n          }catch(e){\n            log.error(e instanceof Error ? e : String(e));\n            resolve();\n            return;\n          }\n\n          TextureLoader.LoadQueue().then(() => {\n            this._3dViewModel.playAnimation(0, true);\n            resolve();\n          });\n        }).catch((e: unknown) => {\n          log.error(e instanceof Error ? e : String(e));\n          resolve();\n        });\n      }).catch((e: unknown) => {\n        log.error(e instanceof Error ? e : String(e));\n        resolve();\n      });\n    });\n  }\n\n  update(delta: number) {\n    super.update(delta);\n    if (!this.bVisible)\n      return;\n    if (this.char)\n      this.char.update(delta);\n    try {\n      this._3dView.render(delta);\n      (this.LBL_3DCHAR.getFill().material as THREE.Material & { uniforms?: { map?: { value: THREE.Texture } }; transparent?: boolean; visible?: boolean }).needsUpdate = true;\n    } catch (_e: unknown) { }\n  }\n\n  show() {\n    super.show();\n    try {\n      this.recalculatePosition();\n      this.updateCharacterPortrait(GameState.PartyManager.party[0]);\n      this.updateCharacterStats(GameState.PartyManager.party[0]);\n      this.updatePartyMemberPortraitButtons();\n    } catch (e) {\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\MenuGraphicsAdvanced.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":124,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":124,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":126,"column":67,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":126,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strrefname on a type that cannot be resolved.","line":126,"column":75,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":126,"endColumn":85}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MenuGraphicsAdvanced as K1_MenuGraphicsAdvanced } from \"@/game/kotor/KOTOR\";\nimport { GameState } from \"@/GameState\";\r\nimport type { GUILabel, GUIListBox, GUIButton, GUICheckBox } from \"@/gui\";\r\nimport { TextureLoaderState } from \"@/loaders/TextureLoaderState\";\r\n\r\n/**\r\n * MenuGraphicsAdvanced class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuGraphicsAdvanced.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuGraphicsAdvanced extends K1_MenuGraphicsAdvanced {\r\n\r\n  declare LBL_BAR4: GUILabel;\r\n  declare LBL_TITLE: GUILabel;\r\n  declare LB_DESC: GUIListBox;\r\n  declare BTN_ANTIALIAS: GUIButton;\r\n  declare BTN_ANTIALIASLEFT: GUIButton;\r\n  declare BTN_ANTIALIASRIGHT: GUIButton;\r\n  declare BTN_ANISOTROPY: GUIButton;\r\n  declare BTN_ANISOTROPYLEFT: GUIButton;\r\n  declare BTN_ANISOTROPYRIGHT: GUIButton;\r\n  declare BTN_TEXQUAL: GUIButton;\r\n  declare BTN_TEXQUALLEFT: GUIButton;\r\n  declare BTN_TEXQUALRIGHT: GUIButton;\r\n  declare CB_FRAMEBUFF: GUICheckBox;\r\n  declare CB_VSYNC: GUICheckBox;\r\n  declare CB_SOFTSHADOWS: GUICheckBox;\r\n  declare LBL_BAR1: GUILabel;\r\n  declare LBL_BAR2: GUILabel;\r\n  declare LBL_BAR3: GUILabel;\r\n  declare BTN_CANCEL: GUIButton;\r\n  declare BTN_BACK: GUIButton;\r\n  declare BTN_DEFAULT: GUIButton;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'optgraphicadv_p';\r\n    this.background = 'blackfill';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n\r\n      const texPacks = GameState.TwoDAManager.datatables.get('texpacks') || ({} as Record<string, import(\"../../../resource/TwoDAObject\").ITwoDARowData>);\r\n\r\n      this.BTN_ANTIALIASLEFT.border.dimension = 0;\r\n      this.BTN_ANISOTROPYLEFT.border.dimension = 0;\r\n      this.BTN_TEXQUALLEFT.border.dimension = 0;\r\n\r\n      this.tGuiPanel.widget.add(this.BTN_TEXQUALLEFT.createControl());\r\n      this.tGuiPanel.widget.add(this.BTN_ANISOTROPYLEFT.createControl());\r\n      this.tGuiPanel.widget.add(this.BTN_ANTIALIASLEFT.createControl());\r\n\r\n      this.BTN_CANCEL.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_a = this.BTN_CANCEL;\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_b = this.BTN_BACK;\r\n\r\n      this.BTN_TEXQUALRIGHT.addEventListener('click', (e) => {\r\n        let quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n        quality++;\r\n        if(quality >= texPacks.RowCount) quality = texPacks.RowCount-1;\r\n        GameState.iniConfig.setProperty('Graphics Options.Texture Quality', quality);\r\n        this.updateTextureQualityLabel();\r\n      });\r\n\r\n      this.BTN_TEXQUALLEFT.addEventListener('click', (e) => {\r\n        let quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n        quality--;\r\n        if(quality < 0) quality = 0;\r\n        GameState.iniConfig.setProperty('Graphics Options.Texture Quality', quality);\r\n        this.updateTextureQualityLabel();\r\n      });\r\n\r\n      // this.CB_FRAMEBUFF.onValueChanged = (value) => {\r\n      // \r\n      // };\r\n      // this.CB_FRAMEBUFF.attachINIProperty('Graphics Options.Grass');\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  show() {\r\n    super.show();\r\n    this.updateTextureQualityLabel();\r\n    this.BTN_ANTIALIAS.hide();\r\n    this.BTN_ANTIALIASLEFT.hide();\r\n    this.BTN_ANTIALIASRIGHT.hide();\r\n    this.BTN_ANISOTROPY.hide();\r\n    this.BTN_ANISOTROPYLEFT.hide();\r\n    this.BTN_ANISOTROPYRIGHT.hide();\r\n    this.CB_FRAMEBUFF.hide();\r\n    this.CB_VSYNC.hide();\r\n    this.CB_SOFTSHADOWS.hide();\r\n  }\r\n\r\n  close() {\r\n    super.close();\r\n    const quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n    if (quality != TextureLoaderState.TextureQuality) {\r\n      TextureLoaderState.TextureQuality = quality;\r\n      GameState.ReloadTextureCache();\r\n      GameState.iniConfig.save();\r\n    }\r\n  }\r\n\r\n  updateTextureQualityLabel() {\r\n    const texPacks = GameState.TwoDAManager.datatables.get('texpacks') || ({} as Record<string, import(\"../../../resource/TwoDAObject\").ITwoDARowData>);\r\n    const quality = GameState.iniConfig.getProperty('Graphics Options.Texture Quality') || 0;\r\n    const _2darow = texPacks.rows[quality];\r\n    if (_2darow) {\r\n      this.BTN_TEXQUAL.setText(GameState.TLKManager.GetStringById(_2darow.strrefname).Value);\r\n    }\r\n    if (quality <= 0) {\r\n      this.BTN_TEXQUALLEFT.hide();\r\n    } else {\r\n      this.BTN_TEXQUALLEFT.show();\r\n    }\r\n    if (quality >= texPacks.RowCount - 1) {\r\n      this.BTN_TEXQUALRIGHT.hide();\r\n    } else {\r\n      this.BTN_TEXQUALRIGHT.show();\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\MenuMap.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":47,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":47,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MapMode } from \"@/enums/engine/MapMode\";\r\nimport { MenuMap as K1_MenuMap } from \"@/game/kotor/KOTOR\";\nimport { LBL_MapView } from \"@/gui\";\r\nimport type { GUILabel, GUIButton } from \"@/gui\";\r\nimport type { ModuleWaypoint } from \"@/module\";\r\nimport { CExoLocString } from \"@/resource/CExoLocString\";\r\n\r\n/**\r\n * MenuMap class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuMap.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuMap extends K1_MenuMap {\r\n\r\n  declare LBL_Map: GUILabel;\r\n  declare LBL_MapNote: GUILabel;\r\n  declare BTN_RETURN: GUIButton;\r\n  declare LBL_BAR1: GUILabel;\r\n  declare LBL_BAR2: GUILabel;\r\n  declare LBL_Area: GUILabel;\r\n  declare LBL_BAR3: GUILabel;\r\n  declare LBL_BAR4: GUILabel;\r\n  declare LBL_BAR5: GUILabel;\r\n  declare LBL_TITLE: GUILabel;\r\n  declare BTN_EXIT: GUIButton;\r\n  declare BTN_UP: GUIButton;\r\n  declare BTN_DOWN: GUIButton;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'map_p';\r\n    this.background = 'blackfill';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.LBL_MapNote.setText('');\r\n      this.LBL_Map.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        const mapNote: ModuleWaypoint = this.miniMap.onClick();\r\n        if(mapNote && mapNote.mapNote instanceof CExoLocString){\r\n          this.LBL_MapNote.setText(mapNote.mapNote.getValue())\r\n        }\r\n      });\r\n\r\n      this.BTN_RETURN.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this.BTN_RETURN.hide();\r\n\r\n      this.BTN_EXIT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n      this._button_b = this.BTN_EXIT;\r\n\r\n      this.miniMap = new LBL_MapView(this.LBL_Map);\r\n      this.miniMap.setControl(this.LBL_Map);\r\n      this.miniMap.setSize(this.LBL_Map.extent.width, this.LBL_Map.extent.height);\r\n      this.miniMap.setMode(MapMode.FULLMAP);\r\n      this.miniMap.scene.scale.setScalar(this.LBL_Map.extent.width/512);\r\n\r\n      resolve();\r\n    });\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\game\\tsl\\menu\\MenuPartySelection.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":254,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":254,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":266,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":266,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":268,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":268,"endColumn":93},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":268,"column":41,"nodeType":"MemberExpression","messageId":"errorCall","endLine":268,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getObjectByName on a type that cannot be resolved.","line":268,"column":64,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":268,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":270,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":270,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":270,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":270,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":271,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":271,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":274,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":274,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .quaternion on a type that cannot be resolved.","line":274,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":274,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .quaternion on a type that cannot be resolved.","line":275,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":275,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":277,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":277,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":279,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":279,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updateProjectionMatrix on a type that cannot be resolved.","line":279,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":279,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":343,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":343,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":363,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":363,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .creatures on a type that cannot be resolved.","line":363,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":363,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":364,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":364,"endColumn":30}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\nimport { LBL_3DView } from \"@/gui\";\r\nimport type { GUILabel, GUICheckBox, GUIButton } from \"@/gui\";\r\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\r\nimport { ModuleCreature } from \"@/module\";\r\nimport { NWScript } from \"@/nwscript/NWScript\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { MenuPartySelection as K1_MenuPartySelection } from \"@/game/kotor/KOTOR\";\r\n\r\n/**\r\n * MenuPartySelection class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file MenuPartySelection.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class MenuPartySelection extends K1_MenuPartySelection {\r\n\r\n  declare LBL_NAMEBACK: GUILabel;\r\n  declare LBL_BAR2: GUILabel;\r\n  declare LBL_BAR1: GUILabel;\r\n  declare LBL_CHAR8: GUILabel;\r\n  declare LBL_CHAR7: GUILabel;\r\n  declare LBL_CHAR6: GUILabel;\r\n  declare LBL_CHAR3: GUILabel;\r\n  declare LBL_CHAR4: GUILabel;\r\n  declare LBL_CHAR5: GUILabel;\r\n  declare LBL_CHAR2: GUILabel;\r\n  declare LBL_CHAR9: GUILabel;\r\n  declare LBL_CHAR1: GUILabel;\r\n  declare LBL_CHAR0: GUILabel;\r\n  declare BTN_NPC0: GUICheckBox;\r\n  declare BTN_NPC1: GUICheckBox;\r\n  declare BTN_NPC2: GUICheckBox;\r\n  declare BTN_NPC9: GUICheckBox;\r\n  declare BTN_NPC3: GUICheckBox;\r\n  declare BTN_NPC4: GUICheckBox;\r\n  declare BTN_NPC5: GUICheckBox;\r\n  declare BTN_NPC6: GUICheckBox;\r\n  declare BTN_NPC7: GUICheckBox;\r\n  declare BTN_NPC8: GUICheckBox;\r\n  declare LBL_NA8: GUILabel;\r\n  declare LBL_NA5: GUILabel;\r\n  declare LBL_NA2: GUILabel;\r\n  declare LBL_NA9: GUILabel;\r\n  declare LBL_NA6: GUILabel;\r\n  declare LBL_NA3: GUILabel;\r\n  declare LBL_NA0: GUILabel;\r\n  declare LBL_NA1: GUILabel;\r\n  declare LBL_NA4: GUILabel;\r\n  declare LBL_NA7: GUILabel;\r\n  declare LBL_3D: GUILabel;\r\n  declare LBL_TITLE: GUILabel;\r\n  declare LBL_COUNT: GUILabel;\r\n  declare LBL_BEVEL_M: GUILabel;\r\n  declare LBL_NPC_NAME: GUILabel;\r\n  declare LBL_NPC_LEVEL: GUILabel;\r\n  declare LBL_BEVEL_L: GUILabel;\r\n  declare BTN_ACCEPT: GUIButton;\r\n  declare LBL_BAR3: GUILabel;\r\n  declare LBL_BAR4: GUILabel;\r\n  declare LBL_BAR5: GUILabel;\r\n  declare LBL_CHAR11: GUILabel;\r\n  declare LBL_CHAR10: GUILabel;\r\n  declare BTN_NPC11: GUICheckBox;\r\n  declare BTN_NPC10: GUICheckBox;\r\n  declare LBL_NA11: GUILabel;\r\n  declare LBL_NA10: GUILabel;\r\n  declare BTN_BACK: GUIButton;\r\n  declare BTN_DONE: GUIButton;\r\n\r\n  default0: string;\r\n  default1: string;\r\n  default2: string;\r\n  default3: string;\r\n  default4: string;\r\n  default5: string;\r\n  default6: string;\r\n  default7: string;\r\n  default8: string;\r\n  default9: string;\r\n  default10: string;\r\n  default11: string;\r\n  char: ModuleCreature | undefined;\r\n  LBL_3D_VIEW: GUILabel | undefined;\r\n  cgmain_light: OdysseyModel;\r\n\r\n  constructor(){\r\n    super();\r\n    this.gui_resref = 'partyselect_p';\r\n    this.background = 'blackfill';\r\n    this.voidFill = true;\r\n  }\r\n\r\n  async menuControlInitializer(skipInit: boolean = false) {\r\n    await super.menuControlInitializer(true);\r\n    if(skipInit) return;\r\n    return new Promise<void>((resolve, reject) => {\r\n      this.childMenu = this.manager.MenuTop;\r\n      this.default0 = this.LBL_NA0.getFillTextureName();\r\n      this.default1 = this.LBL_NA1.getFillTextureName();\r\n      this.default2 = this.LBL_NA2.getFillTextureName();\r\n      this.default3 = this.LBL_NA3.getFillTextureName();\r\n      this.default4 = this.LBL_NA4.getFillTextureName();\r\n      this.default5 = this.LBL_NA5.getFillTextureName();\r\n      this.default6 = this.LBL_NA6.getFillTextureName();\r\n      this.default7 = this.LBL_NA7.getFillTextureName();\r\n      this.default8 = this.LBL_NA8.getFillTextureName();\r\n      this.default9 = this.LBL_NA9.getFillTextureName();\r\n      this.default10 = this.LBL_NA10.getFillTextureName();\r\n      this.default11 = this.LBL_NA11.getFillTextureName();\r\n      this.BTN_NPC0.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(0)){\r\n          this.selectedNPC = 0;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC1.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(1)){\r\n          this.selectedNPC = 1;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC2.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(2)){\r\n          this.selectedNPC = 2;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC3.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(3)){\r\n          this.selectedNPC = 3;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC4.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(4)){\r\n          this.selectedNPC = 4;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC5.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(5)){\r\n          this.selectedNPC = 5;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC6.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(6)){\r\n          this.selectedNPC = 6;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC7.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(7)){\r\n          this.selectedNPC = 7;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC8.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(8)){\r\n          this.selectedNPC = 8;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC9.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(9)){\r\n          this.selectedNPC = 9;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC10.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(10)){\r\n          this.selectedNPC = 10;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_NPC11.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if(GameState.PartyManager.IsAvailable(11)){\r\n          this.selectedNPC = 11;\r\n          this.updateSelection();\r\n        }\r\n      });\r\n\r\n      this.BTN_DONE.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n\r\n        if(!this.canClose())\r\n          return;\r\n\r\n        if(this.onCloseScript instanceof NWScriptInstance){\r\n          this.close();\r\n          this.onCloseScript.run(undefined, 0);\r\n          this.onCloseScript = undefined;\r\n        }else{\r\n          this.close();\r\n        }\r\n        \r\n      });\r\n\r\n      this.BTN_BACK.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        this.close();\r\n      });\r\n\r\n      this.BTN_ACCEPT.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n\r\n        //Area Unescapable disables party selection as well as transit\r\n        if(!GameState.module.area.unescapable || this.ignoreUnescapable){\r\n          if(GameState.PartyManager.IsNPCInParty(this.selectedNPC)){\r\n            GameState.PartyManager.RemoveNPCById(this.selectedNPC);\r\n            this.updateSelection();\r\n          }else if(this.isSelectable(this.selectedNPC) && GameState.PartyManager.CurrentMembers.length < GameState.PartyManager.MaxNPCCount){\r\n            this.addToParty(this.selectedNPC);\r\n          }\r\n          this.updateCount();\r\n        }\r\n\r\n      });\r\n\r\n      this.LBL_3D_VIEW = new LBL_3DView(this.LBL_3D.extent.width, this.LBL_3D.extent.height);\r\n      this.LBL_3D_VIEW.setControl(this.LBL_3D);\r\n\r\n      MDLLoader.loader.load('cgmain_light')\r\n      .then((mdl: OdysseyModel) => {\r\n        this.cgmain_light = mdl;\r\n\r\n        OdysseyModel3D.FromMDL(this.cgmain_light, {\r\n          // manageLighting: false,\r\n          context: this.LBL_3D_VIEW\r\n        }).then((model: OdysseyModel3D) => {\r\n          //log.info('Model Loaded', model);\r\n          this.LBL_3D_VIEW.model = model;\r\n          this.LBL_3D_VIEW.addModel(this.LBL_3D_VIEW.model);\r\n\r\n          this.LBL_3D_VIEW.camerahook = this.LBL_3D_VIEW.model.getObjectByName('camerahook');\r\n          \r\n          this.LBL_3D_VIEW.camera.position.copy(\r\n            this.LBL_3D_VIEW.camerahook.position\r\n          );\r\n\r\n          this.LBL_3D_VIEW.camera.quaternion.copy(\r\n            this.LBL_3D_VIEW.camerahook.quaternion\r\n          ); \r\n          this.LBL_3D_VIEW.camera.position.z = 1;\r\n\r\n          this.LBL_3D_VIEW.camera.updateProjectionMatrix();\r\n          this.LBL_3D_VIEW.visible = true;\r\n          resolve();\r\n        }).catch(() => {\r\n          resolve();\r\n        });\r\n      }).catch(() => {\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Hides the menu.\r\n   */\r\n  hide() {\r\n    super.hide();\r\n    this.ignoreUnescapable = false;\r\n  }\r\n\r\n  /**\r\n   * Shows the menu.\r\n   * @param scriptName - The name of the script to run on close.\r\n   * @param forceNPC1 - The ID of the first NPC to force.\r\n   * @param forceNPC2 - The ID of the second NPC to force.\r\n   */\r\n  async show(scriptName = '', forceNPC1 = -1, forceNPC2 = -1) {\r\n    super.show();\r\n    this.forceNPC1 = forceNPC1;\r\n    this.forceNPC2 = forceNPC2;\r\n    if (this.forceNPC1 > -1)\r\n      this.addToParty(this.forceNPC1);\r\n    if (this.forceNPC2 > -1)\r\n      this.addToParty(this.forceNPC2);\r\n    if (this.ignoreUnescapable) {\r\n      // this.manager.MenuTop.toggleNavUI(false);\r\n    }\r\n\r\n    this.selectedNPC = this.forceNPC1 > -1 ? this.forceNPC1 : this.forceNPC2 > -1 ? this.forceNPC2 : -1;\r\n    this.updateSelection();\r\n    this.updateCount();\r\n    await this.initPortraits();\r\n    this.updateSelection();\r\n    TextureLoader.LoadQueue();\r\n    if (scriptName != '' || scriptName != null) {\r\n      this.onCloseScript = NWScript.Load(scriptName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the menu.\r\n   * @param delta - The delta time.\r\n   */\r\n  update(delta: number) {\r\n    super.update(delta);\r\n    if (!this.bVisible)\r\n      return;\r\n\r\n    if (this.char instanceof ModuleCreature){\r\n      this.char.update(delta);\r\n      if(this.char.model instanceof OdysseyModel3D && this.char.model.bonesInitialized){\r\n        this.char.model.update( delta );\r\n      }\r\n      try {\r\n        this.LBL_3D_VIEW.render(delta);\r\n      } catch (_e: unknown) { }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the selection of the NPC.\r\n   */\r\n  updateSelection() {\r\n    super.updateSelection();\r\n    if (!(this.char instanceof ModuleCreature) || this.char instanceof ModuleCreature && this.char.selectedNPC != this.selectedNPC) {\r\n      GameState.PartyManager.LoadPartyMemberCreature(this.selectedNPC, (creature: ModuleCreature) => {\r\n        if (creature instanceof ModuleCreature) {\r\n          if (this.char instanceof ModuleCreature) {\r\n            this.char.destroy();\r\n          }\r\n          this.char = creature;\r\n          creature.selectedNPC = this.selectedNPC;\r\n          creature.position.set(0, 0, 0);\r\n          creature.model.rotation.z = -Math.PI / 2;\r\n          this.LBL_3D_VIEW.group.creatures.add(creature.model);\r\n          this.char.LoadModel();\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUICheckBox.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":43,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":43,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":44,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":44,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":83,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":83,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":84,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":84,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":84,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":84,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":97,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":97,"endColumn":91},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":97,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":97,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":100,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":100,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":100,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":117,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":117,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":121,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":121,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":121,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":160,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":160,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":161,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":161,"endColumn":95},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":161,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":161,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":174,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":174,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":174,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":174,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":177,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":177,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":177,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":177,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":194,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":194,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":198,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":198,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":198,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":198,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":209,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":209,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":209,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":209,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":236,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":236,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":236,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":236,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":265,"column":55,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":265,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":274,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":274,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":274,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":274,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":275,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":275,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":275,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":275,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":280,"column":57,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":280,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":292,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":292,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":293,"column":63,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":293,"endColumn":96},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":295,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":295,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":299,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":299,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":307,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":307,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":319,"column":60,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":319,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":331,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":331,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":332,"column":66,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":332,"endColumn":102},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":334,"column":48,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":334,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":337,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":337,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":337,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":337,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":338,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":338,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":338,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":338,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":341,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":341,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":347,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":347,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":350,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":350,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":366,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":366,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":366,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":366,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":367,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":367,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":367,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":367,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":368,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":368,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":368,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":368,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":369,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":369,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":369,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":369,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":371,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":371,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":371,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":371,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":372,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":372,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":372,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":372,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":374,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":374,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":374,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":374,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":375,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":375,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":375,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":375,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":388,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":388,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":388,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":388,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":389,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":389,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":389,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":389,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":390,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":390,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":390,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":390,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":396,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":396,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":396,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":396,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":397,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":397,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":397,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":397,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":398,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":398,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":398,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":398,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":407,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":407,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":408,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":408,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":409,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":409,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":410,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":410,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":413,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":413,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":413,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":413,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":414,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":414,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":414,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":414,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":415,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":415,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":415,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":415,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":416,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":416,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":416,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":416,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":420,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":420,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":422,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":422,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":426,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":426,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":428,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":428,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":438,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":438,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":438,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":438,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":454,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":454,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":454,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":454,"endColumn":50}],"suppressedMessages":[],"errorCount":96,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { GameState } from \"@/GameState\";\nimport type { GameMenu } from \"@/gui/GameMenu\";\nimport { GUIControl } from \"@/gui/GUIControl\";\nimport type { IGUIControlBorder } from \"@/interface/gui/IGUIControlBorder\";\nimport { TextureLoader } from \"@/loaders\";\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\nimport type { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * GUICheckBox class.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file GUICheckBox.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GUICheckBox extends GUIControl{\n  value: number;\n  onValueChanged?: (value: number) => void;\n\n  borderSelected: IGUIControlBorder;\n  highlightSelected: IGUIControlBorder;\n  hasSelected: boolean;\n  hashighlightSelected: boolean;\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\n    super(menu, control, parent, scale);\n    this.objectType |= GUIControlTypeMask.GUICheckBox;\n\n    this.value = 0;\n\n    this.widget.userData.selected = new THREE.Group();\n    this.widget.userData.highlightSelected = new THREE.Group();\n    this.widget.add(this.widget.userData.selected);\n    this.widget.add(this.widget.userData.highlightSelected);\n\n    //----------//\n    // Selected\n    //----------//\n\n    this.borderSelected = {\n      color: new THREE.Color(0, 0.658824, 0.980392),\n      corner: '',\n      corner_material: {} as THREE.ShaderMaterial,\n      edge: '',\n      edge_material: {} as THREE.ShaderMaterial,\n      fill: {\n        texture: '',\n        material: {} as THREE.ShaderMaterial,\n        mesh: {} as THREE.Mesh,\n        geometry: {} as THREE.BufferGeometry,\n      },\n      mesh: {} as THREE.Mesh,\n      geometry: {} as THREE.BufferGeometry,\n      fillstyle: -1,\n      dimension: 0,\n      inneroffset: 0,\n      inneroffsety: 0,\n      pulsing: 0\n    };\n\n    this.borderSelected.geometry = new THREE.BufferGeometry();\n    \n    this.borderSelected.edge_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    this.borderSelected.edge_material.defines.USE_MAP = '';\n    this.borderSelected.edge_material.uniforms.diffuse.value = this.borderSelected.color;\n\n    this.borderSelected.corner_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.borderSelected.corner_material.defines.USE_MAP = '';\n    this.borderSelected.corner_material.uniforms.diffuse.value = this.borderSelected.color;\n\n    this.borderSelected.mesh = new THREE.Mesh( this.borderSelected.geometry, [this.borderSelected.edge_material, this.borderSelected.corner_material] );\n    this.widget.userData.selected.add(this.borderSelected.mesh);\n\n    //---------------//\n    // Selected Fill\n    //---------------//\n    \n    this.borderSelected.fill.material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.borderSelected.fill.material.defines.USE_MAP = '';\n    this.borderSelected.fill.material.uniforms.diffuse.value = new THREE.Color(0xFFFFFF);\n    this.borderSelected.fill.geometry = new THREE.PlaneGeometry( 1, 1, 1 );\n    this.borderSelected.fill.mesh = new THREE.Mesh( this.borderSelected.fill.geometry, this.borderSelected.fill.material );\n\n    this.widget.userData.selected.add( this.borderSelected.fill.mesh );\n\n    //--------------------//\n    // Highlight Selected\n    //--------------------//\n\n    this.highlightSelected = {\n      color: new THREE.Color(0, 0.658824, 0.980392),\n      corner: '',\n      corner_material: {} as THREE.ShaderMaterial,\n      edge: '',\n      edge_material: {} as THREE.ShaderMaterial,\n      fill: {\n        texture: '',\n        material: {} as THREE.ShaderMaterial,\n        mesh: {} as THREE.Mesh,\n        geometry: {} as THREE.BufferGeometry,\n      },\n      mesh: {} as THREE.Mesh,\n      geometry: {} as THREE.BufferGeometry,\n      fillstyle: -1,\n      dimension: 0,\n      inneroffset: 0,\n      inneroffsety: 0,\n      pulsing: 0\n    };\n\n    this.highlightSelected.geometry = new THREE.BufferGeometry();\n    \n    this.highlightSelected.edge_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    this.highlightSelected.edge_material.defines.USE_MAP = '';\n    this.highlightSelected.edge_material.uniforms.diffuse.value = this.highlightSelected.color;\n\n    this.highlightSelected.corner_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.highlightSelected.corner_material.defines.USE_MAP = '';\n    this.highlightSelected.corner_material.uniforms.diffuse.value = this.highlightSelected.color;\n\n    this.highlightSelected.mesh = new THREE.Mesh( this.highlightSelected.geometry, [this.highlightSelected.edge_material, this.highlightSelected.corner_material] );\n    this.widget.userData.highlightSelected.add(this.highlightSelected.mesh);\n\n    //-------------------------//\n    // Highlight Selected Fill\n    //-------------------------//\n    \n    this.highlightSelected.fill.material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.highlightSelected.fill.material.defines.USE_MAP = '';\n    this.highlightSelected.fill.material.uniforms.diffuse.value = new THREE.Color(0xFFFFFF);\n    this.highlightSelected.fill.geometry = new THREE.PlaneGeometry( 1, 1, 1 );\n    this.highlightSelected.fill.mesh = new THREE.Mesh( this.highlightSelected.fill.geometry, this.highlightSelected.fill.material );\n\n    this.widget.userData.highlightSelected.add( this.highlightSelected.fill.mesh );\n\n    if(this.control instanceof GFFStruct){\n      \n      //Selected\n      this.hasSelected = control.hasField('SELECTED');\n      if(this.hasSelected){\n        const selected = control.getFieldByLabel('SELECTED').getChildStructs()[0];\n\n        if(selected.hasField('COLOR')){\n          const color = selected.getFieldByLabel('COLOR').getVector();\n          this.borderSelected.color.setRGB(color.x, color.y, color.z)\n        }\n\n        if(typeof this.borderSelected.color === 'undefined'){\n          this.borderSelected.color = new THREE.Color(1, 1, 1); //this.defaultColor;\n        }\n\n        this.borderSelected.dimension = selected.getFieldByLabel('DIMENSION').getValue() || 0;\n        this.borderSelected.corner = selected.getFieldByLabel('CORNER').getValue();\n        this.borderSelected.edge = selected.getFieldByLabel('EDGE').getValue();\n        this.borderSelected.fill.texture = selected.getFieldByLabel('FILL').getValue();\n        this.borderSelected.fillstyle = selected.getFieldByLabel('FILLSTYLE').getValue() || 0;\n        this.borderSelected.inneroffset = this.borderSelected.inneroffsety = selected.getFieldByLabel('INNEROFFSET').getValue() || 0;\n\n        if(selected.hasField('INNEROFFSETY'))\n          this.borderSelected.inneroffsety = selected.getFieldByLabel('INNEROFFSETY').getValue();\n\n        this.borderSelected.pulsing = selected.getFieldByLabel('PULSING').getValue() || 0;\n      }\n      \n      //Highlight Selected\n      this.hashighlightSelected = control.hasField('HILIGHTSELECTED');\n      if(this.hashighlightSelected){\n        const highlightSelected = control.getFieldByLabel('HILIGHTSELECTED').getChildStructs()[0];\n\n        if(highlightSelected.hasField('COLOR')){\n          const color = highlightSelected.getFieldByLabel('COLOR').getVector();\n          this.highlightSelected.color.setRGB(color.x, color.y, color.z)\n        }\n\n        if(typeof this.highlightSelected.color === 'undefined'){\n          this.highlightSelected.color = new THREE.Color(1, 1, 1); //this.defaultColor;\n        }\n\n        this.highlightSelected.dimension = highlightSelected.getFieldByLabel('DIMENSION').getValue() || 0;\n        this.highlightSelected.corner = highlightSelected.getFieldByLabel('CORNER').getValue();\n        this.highlightSelected.edge = highlightSelected.getFieldByLabel('EDGE').getValue();\n        this.highlightSelected.fill.texture = highlightSelected.getFieldByLabel('FILL').getValue();\n        this.highlightSelected.fillstyle = highlightSelected.getFieldByLabel('FILLSTYLE').getValue() || 0;\n        this.highlightSelected.inneroffset = this.highlightSelected.inneroffsety = highlightSelected.getFieldByLabel('INNEROFFSET').getValue() || 0;\n\n        if(highlightSelected.hasField('INNEROFFSETY'))\n          this.highlightSelected.inneroffsety = highlightSelected.getFieldByLabel('INNEROFFSETY').getValue();\n\n        this.highlightSelected.pulsing = highlightSelected.getFieldByLabel('PULSING').getValue() || 0;\n      }\n\n    }\n\n    //Control Textures\n\n    //----------//\n    // Selected\n    //----------//\n\n    if(this.borderSelected.edge != ''){\n      TextureLoader.enQueue(this.borderSelected.edge, this.borderSelected.edge_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture){\n          log.debug('initTextures', this.borderSelected.edge, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        const cbSize = this.getCBScale();\n        this.border.fill.mesh.scale.set(cbSize, cbSize, 1);\n        this.borderSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n      });\n    }\n\n    if(this.borderSelected.corner != ''){\n      TextureLoader.enQueue(this.borderSelected.corner, this.borderSelected.corner_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture){\n          log.debug('initTextures', this.borderSelected.corner, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n      });\n    }\n\n    if(this.borderSelected.fill.texture != ''){\n      this.borderSelected.fill.material.transparent = true;\n      TextureLoader.enQueue(this.borderSelected.fill.texture, this.borderSelected.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(texture == null){\n          this.borderSelected.fill.material.uniforms.opacity.value = 0.01;\n        }\n      });\n    }else{\n      this.borderSelected.fill.material.visible = false;\n    }\n\n    //--------------------//\n    // Highlight Selected\n    //--------------------//\n\n    if(this.highlightSelected.edge != ''){\n      TextureLoader.enQueue(this.highlightSelected.edge, this.highlightSelected.edge_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture){\n          log.debug('initTextures', this.highlightSelected.edge, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n      });\n    }\n\n    if(this.highlightSelected.corner != ''){\n      TextureLoader.enQueue(this.highlightSelected.corner, this.highlightSelected.corner_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture){\n          log.debug('initTextures', this.highlightSelected.corner, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n      });\n    }\n\n    if(this.highlightSelected.fill.texture != ''){\n      this.highlightSelected.fill.material.transparent = true;\n      TextureLoader.enQueue(this.highlightSelected.fill.texture, this.highlightSelected.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(texture == null){\n          this.highlightSelected.fill.material.uniforms.opacity.value = 0.01;\n        }\n        const cbSize = this.getCBScale();\n        this.highlight.fill.mesh.scale.set(cbSize, cbSize, 1);\n        this.highlightSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n      });\n    }else{\n      this.highlightSelected.fill.material.visible = false;\n    }\n\n    //Control Input Events\n\n    //Selected\n    this.attachEventListenters( this.borderSelected.mesh );\n\n    //Highlight Selected\n    this.attachEventListenters( this.highlightSelected.mesh );\n\n    this.addEventListener( 'mouseMove', (_e) => { });\n\n    this.addEventListener( 'click', () =>{\n      log.debug('click', this);\n      this.setValue(!this.value);\n    });\n\n    this.addEventListener( 'mouseDown', (e) => {\n      e.stopPropagation();\n    });\n\n    this.addEventListener( 'mouseUp', () => { });\n\n    const cbSize = this.getCBScale();\n    this.border.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.borderSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.highlight.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.highlightSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n    \n    this.borderSelected.fill.mesh.position.set(-(this.extent.width/2 - cbSize/2), 0, this.zOffset);\n    this.highlightSelected.fill.mesh.position.set(-(this.extent.width/2 - cbSize/2), 0, this.zOffset);\n\n    this.borderSelected.fill.material.uniforms.diffuse.value.set(this.defaultColor);\n    this.highlightSelected.fill.material.uniforms.diffuse.value.set(this.defaultHighlightColor);\n\n    this.updateCBVisualState();\n  }\n\n  getCBScale(){\n    // return this.guiFont?.bsline || this.extent.height/2;\n    return 24;\n  }\n\n  buildFill(){\n    super.buildFill();\n    const cbSize = this.getCBScale();\n    this.border.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.border.fill.mesh.position.set(-(this.extent.width/2 - cbSize/2), 0, this.zOffset);\n    this.border.fill.material.uniforms.diffuse.value.set(this.defaultColor);\n  }\n\n  buildHighlightFill(){\n    super.buildHighlightFill();\n    const cbSize = this.getCBScale();\n    this.highlight.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.highlight.fill.mesh.position.set(-(this.extent.width/2 - cbSize/2), 0, this.zOffset);\n    this.highlight.fill.material.uniforms.diffuse.value.set(this.defaultHighlightColor);\n  }\n\n  hideHighlight(){}\n  hideBorder(){}\n  hideFill(){}\n  hideHighlightFill(){}\n\n  updateCBVisualState(){\n    this.border.fill.mesh.visible = false;\n    this.borderSelected.fill.mesh.visible = false;\n    this.highlight.fill.mesh.visible = false;\n    this.highlightSelected.fill.mesh.visible = false;\n\n    const cbSize = this.getCBScale();\n    this.border.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.borderSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.highlight.fill.mesh.scale.set(cbSize, cbSize, 1);\n    this.highlightSelected.fill.mesh.scale.set(cbSize, cbSize, 1);\n\n    if(this.hover){\n      if(this.value){\n        this.highlightSelected.fill.mesh.visible = true;\n      }else{\n        this.highlight.fill.mesh.visible = true;\n      }\n    }else{\n      if(this.value){\n        this.borderSelected.fill.mesh.visible = true;\n      }else{\n        this.border.fill.mesh.visible = true;\n      }\n    }\n\n  }\n\n  onHoverOut(){\n    this.hover = false;\n    this.pulsing = false;\n\n    this.text.material.uniforms.diffuse.value.set(this.defaultColor);\n\n    if(typeof this.onMouseOut === 'function')\n      this.onMouseOut();\n\n    this.updateCBVisualState();\n    this.processEventListener('mouseOut');\n  }\n\n  onHoverIn(){\n    if(!this.hover && typeof this.onHover === 'function')\n      this.onHover();\n\n    this.hover = true;\n    this.pulsing = true;\n\n    this.text.material.uniforms.diffuse.value.set(this.defaultHighlightColor);\n\n    if(typeof this.onMouseIn === 'function')\n      this.onMouseIn();\n\n    this.updateCBVisualState();\n\n    if(this.isClickable()){\n      GameState.guiAudioEmitter.playSoundFireAndForget('gui_scroll');\n    }\n    \n    this.processEventListener('hover');\n    this.processEventListener('mouseIn');\n  }\n\n  onINIPropertyAttached(){\n    if(this.iniProperty)\n      this.setValue(GameState.iniConfig.getProperty(this.iniProperty));\n  }\n\n  setValue(value: boolean){\n    this.value = value ? 1 : 0;\n\n    if(this.iniProperty){\n      GameState.iniConfig.setProperty(this.iniProperty, this.value);\n    }\n    \n    if(typeof this.onValueChanged === 'function')\n      this.onValueChanged(this.value);\n\n    this.processEventListener('valueChanged', [this.value]);\n\n    this.updateCBVisualState();\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUIControl.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":226,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":226,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":227,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":227,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":228,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":228,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":229,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":229,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":289,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":289,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":289,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":289,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":303,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":303,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":303,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":303,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":306,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":306,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":306,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":306,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":324,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":324,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":328,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":328,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":328,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":328,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":368,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":368,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":368,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":368,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":381,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":381,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":381,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":381,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":384,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":384,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":384,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":384,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":401,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":401,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":405,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":405,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":405,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":405,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":476,"column":24,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":476,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":477,"column":24,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":477,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":478,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":478,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":486,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":486,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":487,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":487,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":495,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":495,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":496,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":496,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":497,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":497,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":505,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":505,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":506,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":506,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":588,"column":17,"nodeType":"MemberExpression","messageId":"errorCall","endLine":588,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":588,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":588,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":589,"column":17,"nodeType":"MemberExpression","messageId":"errorCall","endLine":589,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":589,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":589,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":651,"column":17,"nodeType":"MemberExpression","messageId":"errorCall","endLine":651,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":651,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":651,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":652,"column":17,"nodeType":"MemberExpression","messageId":"errorCall","endLine":652,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":652,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":652,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":734,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":734,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":734,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":734,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":735,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":735,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":735,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":735,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":770,"column":47,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":770,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":770,"column":60,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":770,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":770,"column":73,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":770,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":782,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":782,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":782,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":782,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":783,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":783,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":783,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":783,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":819,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":819,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":820,"column":47,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":820,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":831,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":831,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":832,"column":28,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":832,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":835,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":835,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":840,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":840,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":845,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":845,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":846,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":846,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":857,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":857,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":858,"column":28,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":858,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":861,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":861,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":866,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":866,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":871,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":871,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":872,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":872,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":873,"column":55,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":873,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":875,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":875,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":882,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":882,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":883,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":883,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":886,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":886,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":891,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":891,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":900,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":900,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":901,"column":50,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":901,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":912,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":912,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":913,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":913,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":916,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":916,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":921,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":921,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":926,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":926,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":927,"column":52,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":927,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":938,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":938,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":939,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":939,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":942,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":942,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":947,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":947,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":953,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":953,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":954,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":954,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":955,"column":60,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":955,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":958,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":958,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":963,"column":77,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":963,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .renderOrder on a type that cannot be resolved.","line":964,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":964,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":967,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":967,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":973,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":973,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1195,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1195,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1199,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1199,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1203,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1203,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1210,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1210,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1214,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1214,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1218,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1218,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1233,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1233,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1234,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1234,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1238,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1238,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1239,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1239,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1243,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1243,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1247,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1247,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1265,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1265,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1269,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1269,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1273,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1273,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1277,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1277,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1286,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1286,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1298,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1298,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1303,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1303,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1308,"column":25,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1308,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1313,"column":25,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1313,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1314,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1314,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1314,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1314,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1315,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1315,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1315,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1315,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1320,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1320,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1324,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1324,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1328,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1328,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1332,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1332,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1336,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1336,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1336,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1336,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1337,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1337,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1337,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1337,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1341,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1341,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1341,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1341,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1342,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1342,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1342,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1342,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":1360,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":1360,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":1364,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":1364,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1372,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1372,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1376,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1376,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1377,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1377,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1378,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":1378,"endColumn":119},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1378,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1378,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1378,"column":94,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1378,"endColumn":102},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1379,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1379,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1379,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1379,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":1380,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1380,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":1381,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1381,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1383,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1383,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":1386,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1386,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniformsNeedUpdate on a type that cannot be resolved.","line":1387,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1387,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1388,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1388,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1395,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1395,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on an `any` value.","line":1395,"column":80,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1395,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":1400,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":1400,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1400,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1400,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1409,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1409,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1413,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1413,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1414,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1414,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1415,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":1415,"endColumn":113},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1415,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1415,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1415,"column":88,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1415,"endColumn":96},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1416,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1416,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1416,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1416,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":1417,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1417,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":1418,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1418,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1420,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1420,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":1423,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1423,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniformsNeedUpdate on a type that cannot be resolved.","line":1424,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1424,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":1425,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1425,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":1440,"column":53,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1440,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1461,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":1461,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .matrix on an `any` value.","line":1461,"column":73,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1461,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1462,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1462,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updateMatrix on an `any` value.","line":1462,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1462,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1484,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1484,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1484,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1484,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1491,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":1491,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":1491,"column":44,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1491,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":2031,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2031,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2032,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2032,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2033,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2033,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":2034,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2034,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":2037,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2037,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2104,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2104,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2104,"column":28,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2104,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2105,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2105,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .computeBoundingBox on a type that cannot be resolved.","line":2105,"column":26,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2105,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2108,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2108,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .addGroup on a type that cannot be resolved.","line":2108,"column":26,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2108,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2110,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2110,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .addGroup on a type that cannot be resolved.","line":2110,"column":26,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2110,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2113,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2113,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .geometry on a type that cannot be resolved.","line":2113,"column":24,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2113,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2189,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2189,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2189,"column":31,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2189,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2190,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2190,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .computeBoundingBox on a type that cannot be resolved.","line":2190,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2190,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2193,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2193,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .addGroup on a type that cannot be resolved.","line":2193,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2193,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2195,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2195,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .addGroup on a type that cannot be resolved.","line":2195,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2195,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2198,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2198,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .geometry on a type that cannot be resolved.","line":2198,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2198,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on a type that cannot be resolved.","line":2214,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2214,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2215,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2215,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2216,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2216,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":2217,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2217,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2228,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2228,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":2228,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2228,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2240,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2274,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .boundingSphere on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2241,"column":16,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2241,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .boundingSphere on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2242,"column":14,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2242,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2245,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignmentThis","endLine":2245,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attributes on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2245,"column":30,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2245,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2246,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignmentThis","endLine":2246,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attributes on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2246,"column":29,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2246,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":2247,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2247,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .boundingSphere on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2248,"column":14,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2248,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value. `this` is typed as an `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2249,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCallThis","endLine":2249,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .boundingSphere on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2249,"column":14,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2249,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":2253,"column":17,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":2253,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .boundingSphere on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":2253,"column":22,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":2253,"endColumn":36},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":2260,"column":5,"nodeType":"FunctionExpression","messageId":"function","endLine":2260,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":2307,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2307,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":2313,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2313,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":2318,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2318,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":2321,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2321,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":2324,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2324,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":2411,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":2411,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":2411,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":2411,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2459,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2459,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2460,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2460,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2467,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2467,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":2468,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":2468,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2478,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2478,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2478,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2478,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2479,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2479,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2480,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2480,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2483,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2483,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2483,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2483,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2484,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2484,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2485,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2485,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2488,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2488,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2488,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2488,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2489,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2489,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2490,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2490,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2493,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2493,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2493,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2493,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2494,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2494,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2495,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2495,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2507,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2507,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2507,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2507,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2508,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2508,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2509,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2509,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2512,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2512,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2512,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2512,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2513,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2513,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2514,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2514,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2517,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2517,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2517,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2517,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2518,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2518,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2519,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2519,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":2522,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":2522,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2522,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2522,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2523,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2523,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on an `any` value.","line":2524,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":2524,"endColumn":45}],"suppressedMessages":[],"errorCount":259,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\nimport * as BufferGeometryUtils from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\n\nimport { KeyMapper, Mouse } from \"@/controls\";\nimport { KeyMapAction } from \"@/enums/controls/KeyMapAction\";\nimport { GameEngineType } from \"@/enums/engine\";\nimport { Anchor } from \"@/enums/gui/Anchor\";\nimport { GUIControlAlignment } from \"@/enums/gui/GUIControlAlignment\";\nimport { GUIControlType } from \"@/enums/gui/GUIControlType\";\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { GameState } from \"@/GameState\";\nimport type { GameMenu } from \"@/gui/GameMenu\";\nimport { GUIControlEvent, type GUIControlEventData } from \"@/gui/GUIControlEvent\";\nimport { GUIControlEventFactory } from \"@/gui/GUIControlEventFactory\";\nimport { GUIFont } from \"@/gui/GUIFont\";\nimport { GUIListBox } from \"@/gui/GUIListBox\";\nimport { IDPadTarget } from \"@/interface/gui/IDPadTarget\";\nimport { IGUIControlBorder } from \"@/interface/gui/IGUIControlBorder\";\nimport { IGUIControlColors } from \"@/interface/gui/IGUIControlColors\";\nimport { IGUIControlEventListeners } from \"@/interface/gui/IGUIControlEventListeners\";\nimport { IGUIControlExtent } from \"@/interface/gui/IGUIControlExtent\";\nimport type { IGUIControlListNode } from \"@/interface/gui/IGUIControlListNode\";\nimport { IGUIControlMoveTo } from \"@/interface/gui/IGUIControlMoveTo\";\nimport { IGUIControlText } from \"@/interface/gui/IGUIControlText\";\nimport { TextureLoader } from \"@/loaders\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/** Duck-typed source for control init (GFFStruct or plain object with same shape). */\ninterface IGUIControlInitSource {\n  hasField?(label: string): boolean;\n  getFieldByLabel?(label: string): unknown;\n  [key: string]: unknown;\n}\ninterface IGUIControlFieldLike { getValue(): unknown }\ninterface IGUIControlVectorLike { getVector(): THREE.Vector3 }\ninterface IGUIControlStructLike { hasField?(label: string): boolean; getFieldByLabel?(label: string): unknown; getChildStructs?(): unknown[] }\n\nconst itemSize = 2\nconst box = { min: [0, 0], max: [0, 0] }\n\n/**\n * GUIControl class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file GUIControl.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GUIControl {\n  objectType: number = GUIControlTypeMask.GUIControl;\n  position: THREE.Vector3 = new THREE.Vector3();\n  list: GUIListBox;\n  isProtoItem: boolean;\n  /** List item payload (e.g. ModuleItem or string); set by GUIListBox. */\n  node: IGUIControlListNode | string | undefined;\n  visible: boolean = true;\n  keymapAction: KeyMapAction;\n\n  calculateBox() {\n    return;\n  }\n\n  static COLORS: IGUIControlColors = {\n    BORDER: new THREE.Color(1, 1, 1),\n    BORDER_HOVER: new THREE.Color(1, 1, 1),\n    BORDER_HIGHLIGHT: new THREE.Color(1, 1, 1),\n    BORDER_HIGHLIGHT_HOVER: new THREE.Color(1, 1, 1),\n    TEXT: new THREE.Color(1, 1, 1),\n    TEXT_HIGHLIGHT: new THREE.Color(1, 1, 1),\n  };\n\n  id: number = 0;\n  name: string;\n  menu: GameMenu;\n  control: GFFStruct;\n  parent: GUIControl;\n  scale: boolean;\n  iniProperty: string = \"\";\n  autoCalculatePosition: boolean = true;\n  guiFont: GUIFont;\n\n  dPadTarget: IDPadTarget = {\n    up: undefined,\n    down: undefined,\n    left: undefined,\n    right: undefined\n  };\n\n  anchor: Anchor = Anchor.None;\n\n  offset: THREE.Vector2;\n  worldPosition: THREE.Vector3;\n  widget: THREE.Group;\n  box: THREE.Box2;\n  children: GUIControl[] = [];\n  zOffset: number = 1;\n  zIndex: number = 0;\n\n  eventListeners: IGUIControlEventListeners = {\n    click: [],\n    mouseIn: [],\n    mouseOut: [],\n    mouseDown: [],\n    mouseMove: [],\n    mouseUp: [],\n    hover: []\n  };\n\n  defaultColor: THREE.Color;\n  defaultHighlightColor: THREE.Color;\n\n  allowClick: boolean = true;\n  disableSelection: boolean = false;\n\n  onClick?: (e: GUIControlEvent) => void;\n  onMouseMove?: (e: GUIControlEvent) => void;\n  onMouseDown?: (e: GUIControlEvent) => void;\n  onMouseUp?: (e: GUIControlEvent) => void;\n  onMouseIn?: (e: GUIControlEvent) => void;\n  onMouseOut?: (e: GUIControlEvent) => void;\n  onDrag?: (e: GUIControlEvent) => void;\n  onDragEnd?: (e: GUIControlEvent) => void;\n  onHover?: (e: GUIControlEvent) => void;\n\n  onKeyUp?: (e: KeyboardEvent) => void;\n  onKeyDown?: (e: KeyboardEvent) => void;\n\n  pulsing: boolean = false;\n  pulse: number = 1;\n  opacity: number = 1;\n  hover: boolean;\n  swapBorderAndHighliteOnHover = true;\n\n  extent: IGUIControlExtent = {\n    top: 0,\n    left: 0,\n    width: 0,\n    height: 0\n  };\n\n  moveTo: IGUIControlMoveTo = {\n    up: 0,\n    down: 0,\n    left: 0,\n    right: 0\n  }\n\n  border: IGUIControlBorder;\n  highlight: IGUIControlBorder;\n  text: IGUIControlText;\n  hasText: boolean;\n  hasBorder: boolean;\n  hasExtent: boolean;\n  padding: number;\n  objectParentId: number;\n  objectParent: number;\n  objectLocked: number;\n  type: number;\n  hasHighlight: boolean;\n  hasMoveTo: boolean;\n  borderEnabled: boolean;\n  borderFillEnabled: boolean;\n  highlightEnabled: boolean;\n  highlightFillEnabled: boolean;\n  hovering: boolean;\n  anchorOffset: THREE.Vector2 = new THREE.Vector2(0, 0);\n  editable: boolean;\n  selected: boolean;\n  onSelect?: () => void;\n\n  userData: Record<string, unknown> = {};\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl | undefined, scale: boolean = false) {\n\n    this.menu = menu;\n    this.control = control;\n    this.parent = parent;\n    this.scale = scale;\n\n    this.offset = new THREE.Vector2();\n\n    this.widget = new THREE.Group();\n    this.widget.userData.control = this;\n\n    this.worldPosition = new THREE.Vector3();\n    this.box = new THREE.Box2(\n      new THREE.Vector2(\n        0,\n        0\n      ),\n      new THREE.Vector2(\n        0,\n        0\n      )\n    );\n\n    this.defaultColor = new THREE.Color(0.0, 0.658824, 0.980392);\n    this.defaultHighlightColor = new THREE.Color(1, 1, 0);\n\n    if (GameState.GameKey == GameEngineType.TSL) {\n      this.defaultColor = new THREE.Color(0.10196078568697, 0.69803923368454, 0.549019634723663);\n      this.defaultHighlightColor = new THREE.Color(0.800000011920929, 0.800000011920929, 0.6980392336845398);\n    }\n\n    this.allowClick = true;\n\n    this.pulsing = false;\n    this.pulse = 1;\n    this.opacity = 1;\n    this.hover = false;\n\n    this.widget.userData.border = new THREE.Group();\n    this.widget.userData.highlight = new THREE.Group();\n    this.widget.userData.fill = new THREE.Group();\n    this.widget.userData.text = new THREE.Group();\n\n    this.widget.add(this.widget.userData.border);\n    this.widget.add(this.widget.userData.highlight);\n    this.widget.add(this.widget.userData.fill);\n    this.widget.add(this.widget.userData.text);\n\n    this.initObjects();\n    this.initInputListeners();\n    this.initProperties();\n    this.initTextures();\n\n  }\n\n  initObjects() {\n    //--------//\n    // Extent\n    //--------//\n\n    this.extent = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0\n    };\n\n    //--------//\n    // Border\n    //--------//\n\n    this.border = {\n      color: new THREE.Color(this.defaultColor),\n      corner: '',\n      corner_material: {} as THREE.ShaderMaterial,\n      edge: '',\n      edge_material: {} as THREE.ShaderMaterial,\n      fill: {\n        geometry: {} as THREE.BufferGeometry,\n        material: {} as THREE.ShaderMaterial,\n        mesh: {} as THREE.Mesh,\n        texture: '',\n      },\n      geometry: {} as THREE.BufferGeometry,\n      mesh: {} as THREE.Mesh,\n      fillstyle: -1,\n      dimension: 0,\n      inneroffset: 0,\n      inneroffsety: 0,\n      pulsing: 0\n    };\n\n    this.border.geometry = new THREE.BufferGeometry();\n\n    this.border.edge_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.border.edge_material.defines.USE_UV = '';\n    //this.border.edge_material.defines.USE_MAP = '';\n    this.border.edge_material.uniforms.diffuse.value = this.border.color;\n\n    this.border.corner_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.border.corner_material.defines.USE_UV = '';\n    //this.border.corner_material.defines.USE_MAP = '';\n    this.border.corner_material.uniforms.diffuse.value = this.border.color;\n\n    this.border.mesh = new THREE.Mesh(this.border.geometry, [this.border.edge_material, this.border.corner_material]);\n    this.widget.userData.border.add(this.border.mesh);\n\n    //-------------//\n    // Border Fill\n    //-------------//\n\n    this.border.fill.material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.border.fill.material.defines.USE_UV = '';\n    //this.border.fill.material.defines.USE_MAP = '';\n    this.border.fill.material.uniforms.diffuse.value = new THREE.Color(0xFFFFFF);\n    this.border.fill.geometry = new THREE.PlaneGeometry(1, 1, 1) as THREE.BufferGeometry;\n    this.border.fill.mesh = new THREE.Mesh(this.border.fill.geometry, this.border.fill.material);\n\n    this.widget.userData.border.add(this.border.fill.mesh);\n\n    //-----------//\n    // Highlight\n    //-----------//\n\n    this.highlight = {\n      color: new THREE.Color(this.defaultHighlightColor),\n      corner: '',\n      corner_material: {} as THREE.ShaderMaterial,\n      edge: '',\n      edge_material: {} as THREE.ShaderMaterial,\n      fill: {\n        geometry: {} as THREE.BufferGeometry,\n        material: {} as THREE.ShaderMaterial,\n        mesh: {} as THREE.Mesh,\n        texture: '',\n      },\n      geometry: {} as THREE.BufferGeometry,\n      mesh: {} as THREE.Mesh,\n      fillstyle: -1,\n      dimension: 0,\n      inneroffset: 0,\n      inneroffsety: 0,\n      pulsing: 0\n    };\n\n    this.highlight.geometry = new THREE.BufferGeometry();\n\n    this.highlight.edge_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.highlight.edge_material.defines.USE_MAP = '';\n    this.highlight.edge_material.uniforms.diffuse.value = this.highlight.color;\n\n    this.highlight.corner_material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.highlight.corner_material.defines.USE_MAP = '';\n    this.highlight.corner_material.uniforms.diffuse.value = this.highlight.color;\n\n    this.highlight.mesh = new THREE.Mesh(this.highlight.geometry, [this.highlight.edge_material, this.highlight.corner_material]);\n    this.widget.userData.highlight.add(this.highlight.mesh);\n\n    //----------------//\n    // Highlight Fill\n    //----------------//\n\n    this.highlight.fill.material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.highlight.fill.material.defines.USE_MAP = '';\n    this.highlight.fill.material.uniforms.diffuse.value = new THREE.Color(0xFFFFFF);\n    this.highlight.fill.geometry = new THREE.PlaneGeometry(1, 1, 1);\n    this.highlight.fill.mesh = new THREE.Mesh(this.highlight.fill.geometry, this.highlight.fill.material);\n\n    this.widget.userData.highlight.add(this.highlight.fill.mesh);\n\n    //------//\n    // Text\n    //------//\n\n    this.text = {\n      color: new THREE.Color(this.defaultColor),\n      font: '', //fnt_d16x16b\n      strref: -1,\n      text: '',\n      alignment: 9, //9 //18 //17\n      pulsing: 0,\n      geometry: {} as THREE.BufferGeometry,\n      mesh: {} as THREE.Mesh,\n      material: {} as THREE.ShaderMaterial,\n      texture: {} as OdysseyTexture,\n    };\n\n    this.text.geometry = new THREE.BufferGeometry();\n    this.text.geometry.index = new THREE.BufferAttribute(new Uint16Array(), 1).setUsage(THREE.StaticDrawUsage);\n\n    const posAttribute = new THREE.BufferAttribute(new Float32Array(), 2).setUsage(THREE.StaticDrawUsage);\n    const uvAttribute = new THREE.BufferAttribute(new Float32Array(), 2).setUsage(THREE.StaticDrawUsage);\n    this.text.geometry.setAttribute('position', posAttribute);\n    this.text.geometry.setAttribute('uv', uvAttribute);\n\n    this.text.geometry.index.needsUpdate = true;\n    this.text.geometry.attributes.position.needsUpdate = true;\n    this.text.geometry.attributes.uv.needsUpdate = true;\n\n    this.text.material = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-gui').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.DoubleSide,\n      transparent: true,\n      fog: false,\n      visible: true\n    });\n    //this.text.material.defines.USE_MAP = '';\n    this.text.material.uniforms.diffuse.value = this.text.color;\n    //new THREE.MeshBasicMaterial({color: this.text.color, side: THREE.DoubleSide, transparent: true});\n    this.text.mesh = new THREE.Mesh(this.text.geometry, this.text.material);\n    this.text.mesh.frustumCulled = false;\n    //this.widget.userData.text.add(this.text.mesh);\n\n    //--------//\n    // MoveTo\n    //--------//\n\n    this.moveTo = {\n      up: 0,\n      down: 0,\n      left: 0,\n      right: 0\n    };\n  }\n\n  setList(list: GUIListBox) {\n    this.list = list;\n  }\n\n  initInputListeners() {\n    //---------//\n    //  Border\n    //---------//\n\n    if (this.border.mesh) {\n      this.border.mesh.name = 'GUIBorder';\n      this.border.mesh.position.z = this.zOffset;\n      this.attachEventListenters(this.border.mesh);\n    }\n\n    //-------------//\n    // Border Fill\n    //-------------//\n\n    if (this.border.fill.mesh) {\n      this.border.fill.mesh.renderOrder = this.id;\n      this.attachEventListenters(this.border.fill.mesh);\n    }\n\n    //-----------//\n    // Highlight\n    //-----------//\n\n    if (this.highlight.mesh) {\n      this.highlight.mesh.name = 'GUIHighlight';\n      this.highlight.mesh.position.z = this.zOffset;\n      this.attachEventListenters(this.highlight.mesh);\n    }\n\n    //----------------//\n    // Highlight Fill\n    //----------------//\n\n    if (this.highlight.fill.mesh) {\n      this.highlight.fill.mesh.renderOrder = this.id;\n      this.attachEventListenters(this.highlight.fill.mesh);\n    }\n\n    //------//\n    // Text\n    //------//\n\n    if (this.text.mesh) {\n      this.text.mesh.name = 'GUIText';\n      this.text.mesh.position.z = this.zOffset;\n      this.text.mesh.renderOrder = 5;\n      this.attachEventListenters(this.text.mesh);\n    }\n\n  }\n\n  attachEventListenters(object: THREE.Object3D) {\n    if (object instanceof THREE.Object3D) {\n      object.userData.isClickable = (_e: GUIControlEvent) => {\n        return this.isClickable();\n      };\n\n      object.userData.onClick = (e: GUIControlEvent) => {\n        this.processEventListener('click', [e]);\n      };\n\n      object.userData.onMouseMove = (e: GUIControlEvent) => {\n        this.processEventListener('mouseMove', [e]);\n      }\n\n      object.userData.onMouseDown = (e: GUIControlEvent) => {\n        this.processEventListener('mouseDown', [e]);\n      };\n\n      object.userData.onMouseUp = (e: GUIControlEvent) => {\n        this.processEventListener('mouseUp', [e]);\n      };\n\n      object.userData.onHover = (e: GUIControlEvent) => {\n        this.processEventListener('hover', [e]);\n      };\n\n      object.userData.getControl = () => {\n        return this;\n      }\n    }\n  }\n\n  initProperties() {\n    if (this.control instanceof GFFStruct) {\n      const control = this.control;\n\n      this.type = (control.hasField('CONTROLTYPE') ? control.getFieldByLabel('CONTROLTYPE')?.getValue() : -1);\n      this.widget.name = this.name = (control.hasField('TAG') ? control.getFieldByLabel('TAG')?.getValue() : -1);\n      this.id = (control.hasField('ID') ? control.getFieldByLabel('ID')?.getValue() : -1);\n      this.objectLocked = (control.hasField('Obj_Locked') ? control.getFieldByLabel('Obj_Locked')?.getValue() : -1);\n      this.objectParent = (control.hasField('Obj_Parent') ? control.getFieldByLabel('Obj_Parent')?.getValue() : -1);\n      this.objectParentId = (control.hasField('Obj_ParentID') ? control.getFieldByLabel('Obj_ParentID')?.getValue() : -1);\n\n      this.padding = (control.hasField('PADDING') ? control.getFieldByLabel('PADDING')?.getValue() : 0);\n\n      //Extent\n      this.hasExtent = control.hasField('EXTENT');\n      if (this.hasExtent) {\n        const extent = control.getFieldByLabel('EXTENT')?.getChildStructs()[0];\n        if (extent) {\n          this.extent.top = extent.getFieldByLabel('TOP')?.getValue();\n          this.extent.left = extent.getFieldByLabel('LEFT')?.getValue();\n          this.extent.width = extent.getFieldByLabel('WIDTH')?.getValue();\n          this.extent.height = extent.getFieldByLabel('HEIGHT')?.getValue();\n        }\n      }\n\n      //Border\n      this.hasBorder = control.hasField('BORDER');\n      if (this.hasBorder) {\n        const border = control.getFieldByLabel('BORDER')?.getChildStructs()[0];\n        if (border) {\n          if (border.hasField('COLOR')) {\n            const color = border.getFieldByLabel('COLOR')?.getVector();\n            if (color && (color.x * color.y * color.z) < 1) {\n              if (this.border.color && this.border.fill.material) {\n                this.border.color.setRGB(color.x, color.y, color.z);\n                this.border.fill.material.uniforms.diffuse.value.set(this.border.color);\n              }\n            }\n          }\n\n          if (typeof this.border.color === 'undefined') {\n            this.border.color = new THREE.Color(1, 1, 1); //this.defaultColor;\n          }\n\n          this.border.dimension = border.getFieldByLabel('DIMENSION')?.getValue() || 0;\n          this.border.corner = border.getFieldByLabel('CORNER')?.getValue();\n          this.border.edge = border.getFieldByLabel('EDGE')?.getValue();\n          this.border.fill.texture = border.getFieldByLabel('FILL')?.getValue();\n          this.border.fillstyle = border.getFieldByLabel('FILLSTYLE')?.getValue() || 0;\n          this.border.inneroffset = this.border.inneroffsety = border.getFieldByLabel('INNEROFFSET')?.getValue() || 0;\n\n          if (border.hasField('INNEROFFSETY'))\n            this.border.inneroffsety = border.getFieldByLabel('INNEROFFSETY')?.getValue();\n\n          this.border.pulsing = border.getFieldByLabel('PULSING')?.getValue() || 0;\n        }\n\n      }\n\n      //Text\n      this.hasText = control.hasField('TEXT');\n      if (this.hasText) {\n        const text = control.getFieldByLabel('TEXT')?.getChildStructs()[0];\n        if (text) {\n          this.text.font = text.getFieldByLabel('FONT')?.getValue();\n          this.text.strref = text.getFieldByLabel('STRREF')?.getValue();\n          this.text.text = (text.hasField('TEXT') ? this.menu.gameStringParse(text.getFieldByLabel('TEXT')?.getValue()) : '');\n          if (this.text.text == '') {\n            this.text.text = this.menu.gameStringParse(GameState.TLKManager.TLKStrings[this.text.strref]?.Value || '');\n          }\n          this.text.alignment = text.getFieldByLabel('ALIGNMENT')?.getValue();\n          this.text.pulsing = text.getFieldByLabel('PULSING')?.getValue();\n\n          if (this.text.font == 'fnt_d16x16') {\n            this.text.font = 'fnt_d16x16b';\n          }\n\n          if (text.hasField('COLOR')) {\n            const color = text.getFieldByLabel('COLOR')?.getVector();\n            if (color) this.text.color.setRGB(color.x, color.y, color.z)\n          }\n\n          if (typeof this.text.color === 'undefined') {\n            this.text.color = this.defaultColor.clone();\n          }\n        }\n      }\n\n      //Highlight\n      this.hasHighlight = control.hasField('HILIGHT');\n      if (this.hasHighlight) {\n        const highlight = control.getFieldByLabel('HILIGHT')?.getChildStructs()[0];\n        if (highlight) {\n          if (highlight.hasField('COLOR')) {\n            const color = highlight.getFieldByLabel('COLOR')?.getVector();\n            if (color && (color.x * color.y * color.z) < 1) {\n              if (this.highlight.color && this.highlight.fill.material) {\n                this.highlight.color.setRGB(color.x, color.y, color.z);\n                this.highlight.fill.material.uniforms.diffuse.value.set(this.highlight.color);\n              }\n            }\n          }\n\n          if (typeof this.highlight.color === 'undefined') {\n            this.highlight.color = new THREE.Color(1, 1, 1); //this.defaultColor;\n          }\n\n          this.highlight.dimension = highlight.getFieldByLabel('DIMENSION')?.getValue() || 0;\n          this.highlight.corner = highlight.getFieldByLabel('CORNER')?.getValue() || '';\n          this.highlight.edge = highlight.getFieldByLabel('EDGE')?.getValue() || '';\n          this.highlight.fill.texture = highlight.getFieldByLabel('FILL')?.getValue() || '';\n          this.highlight.fillstyle = highlight.getFieldByLabel('FILLSTYLE')?.getValue() || 0;\n          this.highlight.inneroffset = this.highlight.inneroffsety = highlight.getFieldByLabel('INNEROFFSET')?.getValue() || 0;\n\n          if (highlight.hasField('INNEROFFSETY'))\n            this.highlight.inneroffsety = highlight.getFieldByLabel('INNEROFFSETY')?.getValue();\n\n          this.highlight.pulsing = highlight.getFieldByLabel('PULSING')?.getValue() || 0;\n        }\n      }\n\n      //Moveto\n      this.hasMoveTo = control.hasField('MOVETO');\n      if (this.hasMoveTo) {\n        const moveTo = control.getFieldByLabel('MOVETO')?.getChildStructs()[0];\n        if (moveTo) {\n          this.moveTo.down = moveTo.getFieldByLabel('DOWN')?.getValue();\n          this.moveTo.left = moveTo.getFieldByLabel('LEFT')?.getValue();\n          this.moveTo.right = moveTo.getFieldByLabel('RIGHT')?.getValue();\n          this.moveTo.up = moveTo.getFieldByLabel('UP')?.getValue();\n        }\n      }\n    } else if (this.control != null && typeof this.control === 'object') {\n      const c = this.control as IGUIControlInitSource;\n      const has = (label: string) => (typeof c.hasField === 'function' ? c.hasField(label) : label in c);\n      const get = (label: string) => (typeof c.getFieldByLabel === 'function' ? c.getFieldByLabel(label) : (c as Record<string, unknown>)[label]);\n      const val = (f: IGUIControlFieldLike | unknown) => (f != null && typeof (f as IGUIControlFieldLike).getValue === 'function' ? (f as IGUIControlFieldLike).getValue() : f);\n      const vec = (f: IGUIControlVectorLike | undefined) => (f != null && typeof (f as IGUIControlVectorLike).getVector === 'function' ? (f as IGUIControlVectorLike).getVector() : f);\n      const child = (f: IGUIControlStructLike | null | undefined): IGUIControlStructLike | undefined => {\n        if (f == null) return undefined;\n        if (typeof (f as IGUIControlStructLike).getChildStructs === 'function') {\n          const arr = (f as IGUIControlStructLike).getChildStructs();\n          return Array.isArray(arr) && arr.length > 0 ? arr[0] : undefined;\n        }\n        return f as IGUIControlStructLike;\n      };\n      const childVal = (ch: IGUIControlStructLike | null | undefined, label: string) => {\n        if (ch == null) return undefined;\n        const f = typeof ch.getFieldByLabel === 'function' ? ch.getFieldByLabel(label) : (ch as Record<string, unknown>)[label];\n        return val(f);\n      };\n      const childVec = (ch: IGUIControlStructLike | null | undefined, label: string) => {\n        if (ch == null) return undefined;\n        const f = typeof ch.getFieldByLabel === 'function' ? ch.getFieldByLabel(label) : (ch as Record<string, unknown>)[label];\n        return vec(f);\n      };\n\n      this.type = has('CONTROLTYPE') ? val(get('CONTROLTYPE')) : -1;\n      this.widget.name = this.name = has('TAG') ? (val(get('TAG')) ?? '') : '';\n      this.id = has('ID') ? val(get('ID')) : -1;\n      this.objectLocked = has('Obj_Locked') ? val(get('Obj_Locked')) : -1;\n      this.objectParent = has('Obj_Parent') ? val(get('Obj_Parent')) : -1;\n      this.objectParentId = has('Obj_ParentID') ? val(get('Obj_ParentID')) : -1;\n      this.padding = has('PADDING') ? (val(get('PADDING')) ?? 0) : 0;\n\n      const extentStruct = child(get('EXTENT'));\n      this.hasExtent = has('EXTENT') && extentStruct != null;\n      if (this.hasExtent && extentStruct) {\n        this.extent.top = childVal(extentStruct, 'TOP');\n        this.extent.left = childVal(extentStruct, 'LEFT');\n        this.extent.width = childVal(extentStruct, 'WIDTH');\n        this.extent.height = childVal(extentStruct, 'HEIGHT');\n      }\n\n      const borderStruct = child(get('BORDER'));\n      this.hasBorder = has('BORDER') && borderStruct != null;\n      if (this.hasBorder && borderStruct) {\n        const color = childVec(borderStruct, 'COLOR');\n        if (color && (color.x * color.y * color.z) < 1) {\n          if (this.border.color && this.border.fill.material) {\n            this.border.color.setRGB(color.x, color.y, color.z);\n            this.border.fill.material.uniforms.diffuse.value.set(this.border.color);\n          }\n        }\n        if (typeof this.border.color === 'undefined') {\n          this.border.color = new THREE.Color(1, 1, 1);\n        }\n        this.border.dimension = childVal(borderStruct, 'DIMENSION') ?? 0;\n        this.border.corner = childVal(borderStruct, 'CORNER');\n        this.border.edge = childVal(borderStruct, 'EDGE');\n        this.border.fill.texture = childVal(borderStruct, 'FILL');\n        this.border.fillstyle = childVal(borderStruct, 'FILLSTYLE') ?? 0;\n        this.border.inneroffset = this.border.inneroffsety = childVal(borderStruct, 'INNEROFFSET') ?? 0;\n        if (borderStruct != null && (typeof borderStruct.hasField === 'function' ? borderStruct.hasField('INNEROFFSETY') : 'INNEROFFSETY' in borderStruct)) {\n          this.border.inneroffsety = childVal(borderStruct, 'INNEROFFSETY');\n        }\n        this.border.pulsing = childVal(borderStruct, 'PULSING') ?? 0;\n      }\n\n      const textStruct = child(get('TEXT'));\n      this.hasText = has('TEXT') && textStruct != null;\n      if (this.hasText && textStruct) {\n        this.text.font = childVal(textStruct, 'FONT');\n        this.text.strref = childVal(textStruct, 'STRREF');\n        this.text.text = (textStruct != null && (typeof textStruct.hasField === 'function' ? textStruct.hasField('TEXT') : 'TEXT' in textStruct))\n          ? this.menu.gameStringParse(childVal(textStruct, 'TEXT') ?? '')\n          : '';\n        if (this.text.text === '') {\n          this.text.text = this.menu.gameStringParse(GameState.TLKManager.TLKStrings[this.text.strref]?.Value ?? '');\n        }\n        this.text.alignment = childVal(textStruct, 'ALIGNMENT');\n        this.text.pulsing = childVal(textStruct, 'PULSING');\n        if (this.text.font === 'fnt_d16x16') {\n          this.text.font = 'fnt_d16x16b';\n        }\n        const textColor = childVec(textStruct, 'COLOR');\n        if (textColor) this.text.color.setRGB(textColor.x, textColor.y, textColor.z);\n        if (typeof this.text.color === 'undefined') {\n          this.text.color = this.defaultColor.clone();\n        }\n      }\n\n      const highlightStruct = child(get('HILIGHT'));\n      this.hasHighlight = has('HILIGHT') && highlightStruct != null;\n      if (this.hasHighlight && highlightStruct) {\n        const hlColor = childVec(highlightStruct, 'COLOR');\n        if (hlColor && (hlColor.x * hlColor.y * hlColor.z) < 1) {\n          if (this.highlight.color && this.highlight.fill.material) {\n            this.highlight.color.setRGB(hlColor.x, hlColor.y, hlColor.z);\n            this.highlight.fill.material.uniforms.diffuse.value.set(this.highlight.color);\n          }\n        }\n        if (typeof this.highlight.color === 'undefined') {\n          this.highlight.color = new THREE.Color(1, 1, 1);\n        }\n        this.highlight.dimension = childVal(highlightStruct, 'DIMENSION') ?? 0;\n        this.highlight.corner = (childVal(highlightStruct, 'CORNER') ?? '') as string;\n        this.highlight.edge = (childVal(highlightStruct, 'EDGE') ?? '') as string;\n        this.highlight.fill.texture = (childVal(highlightStruct, 'FILL') ?? '') as string;\n        this.highlight.fillstyle = childVal(highlightStruct, 'FILLSTYLE') ?? 0;\n        this.highlight.inneroffset = this.highlight.inneroffsety = childVal(highlightStruct, 'INNEROFFSET') ?? 0;\n        if (highlightStruct != null && (typeof highlightStruct.hasField === 'function' ? highlightStruct.hasField('INNEROFFSETY') : 'INNEROFFSETY' in highlightStruct)) {\n          this.highlight.inneroffsety = childVal(highlightStruct, 'INNEROFFSETY');\n        }\n        this.highlight.pulsing = childVal(highlightStruct, 'PULSING') ?? 0;\n      }\n\n      const moveToStruct = child(get('MOVETO'));\n      this.hasMoveTo = has('MOVETO') && moveToStruct != null;\n      if (this.hasMoveTo && moveToStruct) {\n        this.moveTo.down = childVal(moveToStruct, 'DOWN');\n        this.moveTo.left = childVal(moveToStruct, 'LEFT');\n        this.moveTo.right = childVal(moveToStruct, 'RIGHT');\n        this.moveTo.up = childVal(moveToStruct, 'UP');\n      }\n    }\n  }\n\n  initTextures() {\n\n    //--------//\n    // Border\n    //--------//\n\n    if (this.border.edge != '') {\n      this.border.edge_material.visible = false;\n      TextureLoader.enQueue(this.border.edge, this.border.edge_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!texture) {\n          log.debug('initTextures', this.border.edge, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        if (!this.border.edge_material.transparent) {\n          this.border.mesh.renderOrder = 0;\n        }\n        texture.needsUpdate = true;\n        this.border.edge_material.visible = true;\n        if (typeof this.borderEnabled == 'undefined')\n          this.borderEnabled = true;\n      });\n    } else {\n      this.border.edge_material.visible = false;\n      this.borderEnabled = false;\n    }\n\n    if (this.border.corner != '') {\n      this.border.corner_material.visible = false;\n      TextureLoader.enQueue(this.border.corner, this.border.corner_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!texture) {\n          log.debug('initTextures', this.border.corner, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        if (!this.border.corner_material.transparent) {\n          this.border.mesh.renderOrder = 0;\n        }\n        texture.needsUpdate = true;\n        this.border.corner_material.visible = true;\n        if (typeof this.borderEnabled == 'undefined')\n          this.borderEnabled = true;\n      });\n    } else {\n      this.border.corner_material.visible = false;\n      this.borderEnabled = false;\n    }\n\n    if (this.border.fill.texture != '') {\n      this.border.fill.material.transparent = true;\n      this.border.fill.material.visible = false;\n      TextureLoader.enQueue(this.border.fill.texture, this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!(texture)) {\n          this.border.fill.material.visible = false;\n          return;\n        }\n\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        if (!this.border.fill.material.transparent) {\n          this.border.fill.mesh.renderOrder = 0;\n        }\n        texture.needsUpdate = true;\n        this.border.fill.material.visible = true;\n        if (typeof this.borderFillEnabled == 'undefined')\n          this.borderFillEnabled = true;\n      });\n    } else {\n      this.border.fill.material.visible = false;\n      this.borderFillEnabled = false;\n    }\n\n    //-----------//\n    // Highlight\n    //-----------//\n\n    if (this.highlight.edge != '') {\n      this.highlight.edge_material.visible = false;\n      TextureLoader.enQueue(this.highlight.edge, this.highlight.edge_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!texture) {\n          log.debug('initTextures', this.highlight.edge, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        if (!this.highlight.edge_material.transparent) {\n          this.highlight.mesh.renderOrder = 0;\n        }\n        texture.needsUpdate = true;\n        this.highlight.edge_material.visible = true;\n        if (typeof this.highlightEnabled == 'undefined')\n          this.highlightEnabled = true;\n      });\n    } else {\n      this.highlight.edge_material.visible = false;\n      this.highlightEnabled = false;\n    }\n\n    if (this.highlight.corner != '') {\n      this.highlight.corner_material.visible = false;\n      TextureLoader.enQueue(this.highlight.corner, this.highlight.corner_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!texture) {\n          log.debug('initTextures', this.highlight.corner, texture);\n          return;\n        }\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        if (!this.highlight.corner_material.transparent) {\n          this.highlight.mesh.renderOrder = 0;\n        }\n        texture.needsUpdate = true;\n        this.highlight.corner_material.visible = true;\n        if (typeof this.highlightEnabled == 'undefined')\n          this.highlightEnabled = true;\n      });\n    } else {\n      this.highlight.corner_material.visible = false;\n      this.highlightEnabled = false;\n    }\n\n    if (this.highlight.fill.material) {\n      if (this.highlight.fill.texture != '') {\n        this.highlight.fill.material.transparent = true;\n        this.highlight.fill.material.visible = false;\n        TextureLoader.enQueue(this.highlight.fill.texture, this.highlight.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n          if (this.highlight.fill.material) {\n            if (!(texture)) {\n              this.highlight.fill.material.visible = false;\n            } else {\n              texture.anisotropy = 1;\n              texture.minFilter = THREE.LinearFilter;\n              texture.magFilter = THREE.LinearFilter;\n              if (this.highlight.fill.mesh && !this.highlight.fill.material.transparent) {\n                this.highlight.fill.mesh.renderOrder = 0;\n              }\n              texture.needsUpdate = true;\n              this.highlight.fill.material.visible = true;\n              this.highlightFillEnabled = true;\n            }\n          }\n        });\n      } else {\n        this.highlight.fill.material.visible = false;\n        this.highlightFillEnabled = false;\n      }\n    }\n\n    //------//\n    // Text\n    //------//\n\n    if (this.text.font != '') {\n      this.text.material.visible = false;\n      TextureLoader.enQueue(this.text.font, this.text.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if (!texture) {\n          log.debug('initTextures', this.text.font, texture);\n          return;\n        }\n\n        this.text.texture = texture;\n        this.text.material.uniforms.map.value = texture;\n        this.text.material.uniforms.diffuse = { value: this.text.color };\n        this.text.material.alphaTest = 0;\n        this.text.material.transparent = true;\n        this.text.material.needsUpdate = true;\n        texture.anisotropy = 1;\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        texture.needsUpdate = true;\n        this.guiFont = new GUIFont(texture);\n        this.onFontTextureLoaded();\n        this.text.material.visible = true;\n      });\n    } else {\n      this.text.material.visible = false;\n    }\n\n  }\n\n  isClickable() {\n    return (this.eventListeners['click'].length || this.onClick) && this.isVisible() && !this.disableSelection;\n  }\n\n  isVisible() {\n    return this.widget.visible;\n  }\n\n  mouseOver: boolean = false;\n  onHoverOut() {\n    this.hover = false;\n    this.mouseOver = false;\n    if (this.disableSelection) {\n      return;\n    }\n\n    if (typeof this.onMouseOut === 'function')\n      this.onMouseOut();\n\n    if (this.swapBorderAndHighliteOnHover) {\n      this.hideHighlight();\n\n      if (this.border.edge != '')\n        this.showBorder();\n    } else {\n      this.showBorder();\n      this.hideHighlight();\n    }\n\n    this.processEventListener('mouseOut');\n    this.setTooltipVisible(false);\n  }\n\n  onHoverIn() {\n    this.mouseOver = true;\n    if (this.disableSelection) {\n      this.hover = false;\n      return;\n    }\n\n    if (!this.hover && typeof this.onHover === 'function')\n      this.onHover();\n\n    this.hover = true;\n\n    if (typeof this.onMouseIn === 'function')\n      this.onMouseIn();\n\n    if (this.swapBorderAndHighliteOnHover) {\n      if (this.highlight.edge != '' || this.highlight.fill.texture != '')\n        this.showHighlight();\n\n      if (this.highlight.edge != '')\n        this.hideBorder();\n    } else {\n      this.showBorder();\n      this.showHighlight();\n    }\n\n    if (this.isClickable()) {\n      GameState.guiAudioEmitter.playSoundFireAndForget('gui_scroll');\n    }\n\n    this.processEventListener('hover');\n    this.processEventListener('mouseIn');\n\n    // this.setTooltipVisible(true);\n  }\n\n  onFontTextureLoaded() {\n    this.buildText();\n  }\n\n  resizeControl() {\n\n    try {\n      if (this.hasBorder) {\n        this.buildBorder();\n      }\n      if (this.hasHighlight) {\n        this.buildHighlight();\n      }\n    } catch (_e: unknown) {\n      //Must not have a border\n    }\n\n    this.resizeFill();\n    if (this.hasHighlight) {\n      this.resizeHighlightFill();\n    }\n\n  }\n\n  createControl() {\n\n    if (this.widget instanceof THREE.Object3D && this.widget.parent) {\n      this.widget.parent.remove(this.widget);\n    }\n\n    //if(this.parent === undefined){\n    //  this.widget.add(this.menu.backgroundSprite);\n    //}\n\n    this.buildBorder();\n    this.buildFill();\n\n    this.buildHighlight();\n    this.buildHighlightFill();\n\n    this.hideHighlight();\n\n    this._onCreate();\n    //Calculate the widget screen position\n    this.calculatePosition();\n    this.buildChildren();\n\n    //Load any textures in the queue\n    TextureLoader.LoadQueue();\n    return this.widget;\n\n  }\n\n  buildChildren() {\n\n    if (!(this.menu))\n      return false;\n\n    if (!(this.menu.tGuiPanel.control instanceof GFFStruct))\n      return false;\n\n    if (this.menu.tGuiPanel.control.hasField('CONTROLS')) {\n      const children = this.menu.tGuiPanel.control.getFieldByLabel('CONTROLS')?.getChildStructs() || [];\n\n      for (let i = 0; i < children.length; i++) {\n        const childParent = (children[i].hasField('Obj_Parent') ? children[i].getFieldByLabel('Obj_Parent')?.getValue() : '');\n        if (childParent == this.name) {\n\n          const control: GUIControl = this.menu.factory.FromStruct(children[i], this.menu, this, this.scale);\n\n          control.zIndex = this.zIndex + 1;\n\n          this.children.push(control);\n\n          const _cWidget = control.createControl();\n          _cWidget.position.z = control.zIndex;\n\n          //this.widget.add(_cWidget);\n          this.menu.tGuiPanel.widget.add(_cWidget);\n\n        }\n      }\n\n    }\n  }\n\n  reattach(parent: GUIControl) {\n    if (typeof this.parent != 'undefined') {\n      this.parent.widget.remove(this.widget);\n    }\n\n    this.parent = parent;\n    this.parent.widget.add(this.widget);\n  }\n\n  getControl() {\n    return this.widget;\n  }\n\n  hide() {\n    this.widget.visible = false;\n  }\n\n  show() {\n    this.updateWorldPosition();\n    this.widget.visible = true;\n  }\n\n  update(delta: number) {\n    const opacity = this.disableSelection ? 0.5 : 1;\n    if (this.pulsing || (this.hover && this.isClickable()) || this.selected) {\n      const pulseOpacity = 1 - (0.5 * GameState.MenuManager.pulseOpacity) * opacity;\n      /**\n       * Border\n       */\n      if (this.border.edge_material) {\n        this.border.edge_material.uniforms.opacity.value = this.hover ? 1 : pulseOpacity;\n      }\n\n      if (this.border.corner_material) {\n        this.border.corner_material.uniforms.opacity.value = this.hover ? 1 : pulseOpacity;\n      }\n\n      if (this.border.fill.material) {\n        this.border.fill.material.uniforms.opacity.value = this.hover ? 1 : pulseOpacity;\n      }\n\n      /**\n       * Highlight\n       */\n      if (this.highlight.edge_material) {\n        this.highlight.edge_material.uniforms.opacity.value = pulseOpacity;\n      }\n\n      if (this.highlight.corner_material) {\n        this.highlight.corner_material.uniforms.opacity.value = pulseOpacity;\n      }\n\n      if (this.highlight.fill.material) {\n        this.highlight.fill.material.uniforms.opacity.value = pulseOpacity;\n      }\n\n      /**\n       * Text\n       */\n      if (this.text.material) {\n        this.text.material.uniforms.opacity.value = !this.hover ? 1 : pulseOpacity;\n        this.setTextColor(this.defaultHighlightColor.r, this.defaultHighlightColor.g, this.defaultHighlightColor.b);\n      }\n    } else {\n      this.resetPulse();\n    }\n\n    if (this.border.edge_material && this.border.corner_material) {\n      this.border.edge_material.visible = this.borderEnabled ? true : false;\n      this.border.corner_material.visible = this.borderEnabled ? true : false;\n    }\n\n    if (this.highlight.edge_material && this.highlight.corner_material) {\n      this.highlight.edge_material.visible = this.highlightEnabled ? true : false;\n      this.highlight.corner_material.visible = this.highlightEnabled ? true : false;\n    }\n\n    if (this.border.fill.material) {\n      this.border.fill.material.visible = this.borderFillEnabled;\n    }\n\n    if (this.highlight.fill.material) {\n      this.highlight.fill.material.visible = this.highlightFillEnabled;\n    }\n\n    const len = this.children.length;\n    for (let i = 0; i < len; i++) {\n      this.children[i].update(delta);\n    }\n\n    //Tooltip timer\n    this.tooltipTimer = (this.mouseOver ? this.tooltipTimer + (1000 * delta) : 0);\n    if (this.tooltipTimer > 3000 && this.tooltipText != '') {\n      this.setTooltipVisible(true);\n    }\n  }\n\n  resetPulse() {\n    const opacity = this.disableSelection ? 0.5 : 1;\n    if (this.border.edge_material) {\n      this.border.edge_material.uniforms.opacity.value = 1 * opacity;\n    }\n\n    if (this.border.corner_material) {\n      this.border.corner_material.uniforms.opacity.value = 1 * opacity;\n    }\n\n    if (this.highlight.edge_material) {\n      this.highlight.edge_material.uniforms.opacity.value = 1 * opacity;\n    }\n\n    if (this.highlight.corner_material) {\n      this.highlight.corner_material.uniforms.opacity.value = 1 * opacity;\n    }\n\n    if (this.text.material) {\n      this.text.material.uniforms.opacity.value = 1 * opacity;\n      this.setTextColor(this.text.color.r, this.text.color.g, this.text.color.b);\n    }\n\n    if (this.border.fill.material)\n      this.border.fill.material.uniforms.opacity.value = 1 * opacity;\n\n    if (this.disableSelection) {\n      this.hideHighlight();\n    }\n  }\n\n  setHovering(bState: boolean = false) {\n    this.hovering = bState;\n  }\n\n  hideBorder() {\n    this.border.mesh.visible = false;\n    this.hideFill();\n  }\n\n  showBorder() {\n    this.border.mesh.visible = true;\n    this.showFill();\n  }\n\n  hideHighlight() {\n    this.highlight.mesh.visible = false;\n    this.hideHighlightFill();\n  }\n\n  showHighlight() {\n    this.highlight.mesh.visible = true;\n    this.highlight.corner_material.uniforms.diffuse.value.set(this.defaultHighlightColor);\n    this.highlight.edge_material.uniforms.diffuse.value.set(this.defaultHighlightColor);\n    this.showHighlightFill();\n  }\n\n  hideFill() {\n    this.border.fill.mesh.visible = false;\n  }\n\n  showFill() {\n    this.border.fill.mesh.visible = true;\n  }\n\n  hideHighlightFill() {\n    this.highlight.fill.mesh.visible = false;\n  }\n\n  showHighlightFill() {\n    this.highlight.fill.mesh.visible = true;\n  }\n\n  setBorderColor(r = 1, g = 1, b = 1) {\n    this.border.edge_material.uniforms.diffuse.value.setRGB(r, g, b);\n    this.border.corner_material.uniforms.diffuse.value.setRGB(r, g, b);\n  }\n\n  setHighlightColor(r = 1, g = 1, b = 1) {\n    this.highlight.edge_material.uniforms.diffuse.value.setRGB(r, g, b);\n    this.highlight.corner_material.uniforms.diffuse.value.setRGB(r, g, b);\n  }\n\n  setTextColor(r = 1, g = 1, b = 1) {\n    //0.0, 0.658824, 0.980392\n    this.text.color.setRGB(r, g, b);\n    this.text.material.uniforms.diffuse.value = this.text.color;\n    this.text.material.needsUpdate = true;\n  }\n\n  /*setText(text = '', renderOrder){\n    //0.0, 0.658824, 0.980392\n    if(typeof this.text.geometry != 'undefined'){\n      this.text.geometry.update(text);\n    }\n  }*/\n\n  getFill(): THREE.Mesh {\n    return this.border.fill.mesh;\n  }\n\n  getHighlightFill() {\n    return this.highlight.fill.mesh;\n  }\n\n  setHighlightFillTexture(map: THREE.Texture) {\n    if (!(map instanceof THREE.Texture)) {\n      map = TextureLoader.textures.get('fx_static');\n    }\n\n    this.highlight.fill.material.uniforms.map.value = map;\n    (this.highlight.fill.material as THREE.ShaderMaterial & { map?: THREE.Texture }).map = map;\n\n    if (map instanceof THREE.Texture) {\n      this.highlight.fill.material.visible = true;\n      this.highlight.fill.material.uniforms.opacity.value = 1;\n      this.highlight.fill.material.uniforms.uvTransform.value = this.highlight.fill.material.uniforms.map.value.matrix;\n      this.highlight.fill.material.uniforms.map.value.updateMatrix();\n      this.highlight.fill.material.defines.USE_UV = '';\n      this.highlight.fill.material.defines.USE_MAP = '';\n    } else {\n      this.highlight.fill.material.visible = false;\n    }\n\n    this.highlight.fill.material.needsUpdate = true;\n    this.highlight.fill.material.uniformsNeedUpdate = true;\n    this.highlight.fill.material.visible = (map instanceof THREE.Texture);\n    this.highlightFillEnabled = true;\n  }\n\n  setFillColor(r = 1, g = 1, b = 1) {\n    //0.0, 0.658824, 0.980392\n    if (typeof this.getFill() != 'undefined') {\n      (this.getFill().material as THREE.ShaderMaterial).uniforms.diffuse.value.setRGB(r, g, b);\n    }\n  }\n\n  getFillTexture() {\n    return this.border.fill.material.uniforms.map.value;\n  }\n\n  setFillTexture(map: THREE.Texture) {\n\n    if (!(map instanceof THREE.Texture)) {\n      map = TextureLoader.textures.get('fx_static');\n    }\n\n    this.border.fill.material.uniforms.map.value = map;\n    (this.border.fill.material as THREE.ShaderMaterial & { map?: THREE.Texture }).map = map;\n\n    if (map instanceof THREE.Texture) {\n      this.border.fill.material.visible = true;\n      this.border.fill.material.uniforms.opacity.value = 1;\n      this.border.fill.material.uniforms.uvTransform.value = this.border.fill.material.uniforms.map.value.matrix;\n      this.border.fill.material.uniforms.map.value.updateMatrix();\n      this.border.fill.material.defines.USE_UV = '';\n      this.border.fill.material.defines.USE_MAP = '';\n    } else {\n      this.border.fill.material.visible = false;\n    }\n\n    this.border.fill.material.needsUpdate = true;\n    this.border.fill.material.uniformsNeedUpdate = true;\n    this.border.fill.material.visible = (map instanceof THREE.Texture);\n    this.borderFillEnabled = true;\n  }\n\n  getFillTextureName() {\n    return this.border.fill.texture;\n  }\n\n  async setFillTextureName(name = '', bUpdateHighlight = true): Promise<OdysseyTexture> {\n    this.border.fill.texture = name;\n    this.borderFillEnabled = true;\n    if (!name.length) { return; }\n\n    if (bUpdateHighlight) this.highlightFillEnabled = true;\n    if (bUpdateHighlight) this.highlight.fill.texture = name;\n    TextureLoader.enQueue(this.border.fill.texture, this.border.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n      this.setFillTexture(texture)\n      if (bUpdateHighlight) this.setHighlightFillTexture(texture);\n      return texture;\n    });\n    return;\n  }\n\n  setMaterialTexture(material: THREE.ShaderMaterial, texture: THREE.Texture | null) {\n    if (!(material instanceof THREE.ShaderMaterial))\n      return false;\n\n    if (texture == undefined)\n      texture = null;\n\n    material.uniforms.map.value = texture;\n    (material as THREE.ShaderMaterial & { map?: THREE.Texture }).map = texture;\n\n    if (texture instanceof THREE.Texture) {\n      material.visible = true;\n      material.uniforms.opacity.value = 1;\n      material.uniforms.uvTransform.value = material.uniforms.map.value.matrix;\n      material.uniforms.map.value.updateMatrix();\n      material.defines.USE_UV = '';\n      material.defines.USE_MAP = '';\n    } else {\n      material.visible = false;\n    }\n\n    material.needsUpdate = true;\n    material.uniformsNeedUpdate = true;\n    material.visible = (texture instanceof THREE.Texture);\n\n    if (material == this.border.fill.material) {\n      this.borderFillEnabled = true;\n    }\n\n    if (material == this.highlight.fill.material) {\n      this.highlightFillEnabled = true;\n    }\n\n  }\n\n  flipY(flip = true) {\n    let texture = this.border.fill.material.uniforms.map.value;\n    if (texture instanceof THREE.Texture) {\n      texture.repeat.y = flip ? -1 : 1;\n      texture.updateMatrix();\n      texture.needsUpdate = true;\n    }\n\n    texture = this.highlight.fill.material.uniforms.map.value;\n    if (texture instanceof THREE.Texture) {\n      texture.repeat.y = flip ? -1 : 1;\n      texture.updateMatrix();\n      texture.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Panel positioning: adjusts screen-space position from extent and bit_flags (centering).\n   * THREE.js: orthographic camera center=(0,0), X-right, Y-up; game coords top-left=(0,0),\n   * X-right, Y-down. Root panel at screen center; children relative to parent group.\n   */\n  calculatePosition() {\n    if (!this.autoCalculatePosition || this.list)\n      return;\n\n    const vw = GameState.ResolutionManager.getViewportWidth();\n    const vh = GameState.ResolutionManager.getViewportHeight();\n\n    const isRootPanel = this === this.menu.tGuiPanel;\n\n    if (isRootPanel) {\n      const flags = this.menu.panelBitFlags;\n      let screenLeft = this.extent.left;\n      let screenTop = this.extent.top;\n\n      if ((flags & 0x08) !== 0) {\n        screenLeft += Math.trunc((vw - this.extent.width) / 2);\n        screenTop += Math.trunc((vh - this.extent.height) / 2);\n      } else {\n        if ((flags & 0x20) !== 0) {\n          screenLeft += Math.trunc((vw - 640) / 2);\n        }\n        if ((flags & 0x40) !== 0) {\n          screenTop += Math.trunc((vh - 480) / 2);\n        }\n      }\n\n      // Convert screen-space top-left to THREE.js orthographic center coords.\n      // THREE.js: center=(0,0), X-right, Y-up\n      // Screen:   origin=(0,0) at top-left, X-right, Y-down\n      // Control center in screen space: (screenLeft + width/2, screenTop + height/2)\n      // THREE.js x = screenCenterX - viewportWidth/2\n      // THREE.js y = viewportHeight/2 - screenCenterY\n      //\n      // Apply this.offset so child-menu panels (e.g. CharGenQuickPanel,\n      // CharGenCustomPanel) that set tGuiPanel.offset in their\n      // menuControlInitializer can shift the root panel position and have\n      // children's hit-test bounds recalculated correctly via recalculatePosition().\n      this.widget.position.x = screenLeft + this.extent.width / 2 - vw / 2 + this.offset.x;\n      this.widget.position.y = vh / 2 - screenTop - this.extent.height / 2 + this.offset.y;\n      this.widget.position.z = 0;\n      this.widget.scale.set(1, 1, 1);\n      this.anchorOffset.set(this.widget.position.x, this.widget.position.y);\n      this.updateBounds();\n      return;\n    }\n\n    // ==========================================\n    // Child control positioning\n    // ==========================================\n    // In the original game, AurGUISetupViewport creates a local coordinate\n    // system for the panel. Controls' extents (left, top, width, height) are\n    // in this local space, with origin at the panel's top-left corner.\n    //\n    // In THREE.js, the root panel's group is at the panel's CENTER.\n    // So we convert from panel-local (top-left origin, Y-down) to\n    // THREE.js local (center origin, Y-up):\n    //   localX = extent.left + width/2 - panelWidth/2\n    //   localY = panelHeight/2 - extent.top - height/2\n    //\n    // This is equivalent to:\n    //   localX = extent.left - (panelWidth - width) / 2\n    //   localY = -(extent.top - (panelHeight - height) / 2)\n\n    const panelW = this.menu.width;\n    const panelH = this.menu.height;\n\n    // When enablePositionScaling is set, anchor controls to viewport edges (used by\n    // menus that use a fixed-resolution layout at a different resolution).\n    if (this.scale) {\n      // Auto-detect anchor region based on position in the design-space panel\n      if (this.anchor === Anchor.None) {\n        const halfX = panelW / 2;\n        const halfY = panelH / 2;\n        const quatX = 25;\n\n        if (this.extent.left === 0 && this.extent.top === 0) {\n          // Screen centered - no anchor\n        } else {\n          // Determine vertical zone\n          const isTop = this.extent.top < halfY;\n          const isBottom = this.extent.top >= halfY;\n\n          // Determine horizontal zone\n          const isLeft = this.extent.left < (halfX / 2);\n          const isRight = this.extent.left >= (halfX / 2);\n          const isCenter = this.extent.left > quatX && this.extent.left < (halfX + quatX);\n\n          if (isBottom) {\n            if (isCenter) this.anchor = Anchor.BottomCenter;\n            else if (isLeft) this.anchor = Anchor.BottomLeft;\n            else if (isRight) this.anchor = Anchor.BottomRight;\n          }\n          if (isTop) {\n            if (isCenter) this.anchor = Anchor.TopCenter;\n            else if (isLeft) this.anchor = Anchor.TopLeft;\n            else if (isRight) this.anchor = Anchor.TopRight;\n          }\n        }\n      }\n\n      // Position control relative to viewport edges.\n      // This maps to how the main interface uses\n      // resolution-specific layouts where controls maintain fixed distances\n      // from screen edges.\n      const edgeRight = panelW - this.extent.left - this.extent.width;\n      const edgeBottom = panelH - this.extent.top - this.extent.height;\n\n      switch (this.anchor) {\n        case Anchor.TopLeft:\n          this.anchorOffset.x = -(vw / 2) + this.extent.left + this.extent.width / 2;\n          this.anchorOffset.y = (vh / 2) - this.extent.top - this.extent.height / 2;\n          break;\n        case Anchor.TopCenter:\n          this.anchorOffset.x = this.extent.left + this.extent.width / 2 - panelW / 2;\n          this.anchorOffset.y = (vh / 2) - this.extent.top - this.extent.height / 2;\n          break;\n        case Anchor.TopRight:\n          this.anchorOffset.x = (vw / 2) - edgeRight - this.extent.width / 2;\n          this.anchorOffset.y = (vh / 2) - this.extent.top - this.extent.height / 2;\n          break;\n        case Anchor.BottomLeft:\n          this.anchorOffset.x = -(vw / 2) + this.extent.left + this.extent.width / 2;\n          this.anchorOffset.y = -(vh / 2) + edgeBottom + this.extent.height / 2;\n          break;\n        case Anchor.BottomCenter:\n          this.anchorOffset.x = this.extent.left + this.extent.width / 2 - panelW / 2;\n          this.anchorOffset.y = -(vh / 2) + edgeBottom + this.extent.height / 2;\n          break;\n        case Anchor.BottomRight:\n          this.anchorOffset.x = (vw / 2) - edgeRight - this.extent.width / 2;\n          this.anchorOffset.y = -(vh / 2) + edgeBottom + this.extent.height / 2;\n          break;\n        default:\n          // No anchor - standard panel-center-relative positioning\n          this.anchorOffset.x = this.extent.left + this.extent.width / 2 - panelW / 2;\n          this.anchorOffset.y = panelH / 2 - this.extent.top - this.extent.height / 2;\n          break;\n      }\n    } else {\n      // Standard child control positioning (non-scaled).\n      // Convert from panel-local (top-left origin, Y-down) to\n      // THREE.js group-local (center origin, Y-up).\n      this.anchorOffset.x = this.extent.left + this.extent.width / 2 - panelW / 2;\n      this.anchorOffset.y = panelH / 2 - this.extent.top - this.extent.height / 2;\n    }\n\n    this.widget.position.x = this.anchorOffset.x + this.offset.x;\n    this.widget.position.y = this.anchorOffset.y + this.offset.y;\n    this.widget.scale.set(1, 1, 1);\n\n    this.updateBounds();\n\n  }\n\n  getActiveControls() {\n\n    if (!this.widget.visible)\n      return [];\n\n    let controls: GUIControl[] = [];\n    for (let i = 0; i < this.children.length; i++) {\n      const control = this.children[i];\n      if (control.box && control.box.containsPoint(Mouse.positionUI) && (control.allowClick || control.editable)) {\n        controls.push(control);\n      } else {\n        this.menu.setWidgetHoverActive(control, false);\n      }\n      if (control.box && control.box.containsPoint(Mouse.positionUI)) {\n        controls = controls.concat(control.getActiveControls());\n      }\n    }\n\n    return controls;\n  }\n\n  /**\n   * Updates the hit-test bounding box for this control.\n   * Tests local coords against extent (left, top, width, height) directly; no scaling.\n   * In THREE.js we compute world-space bounding box from widget position and extent.\n   */\n  updateBounds() {\n    // Use raw extent dimensions for 1:1 pixel rendering.\n    // menu.scale is only applied by setScale() for rare zoom effects (default = 1).\n    const w = this.extent.width * this.menu.scale;\n    const h = this.extent.height * this.menu.scale;\n\n    if (this.list) {\n      // List items: compute world position from parent offset\n      const px = this.parent.widget.position.x;\n      const py = this.parent.widget.position.y;\n      this.box.min.x = this.widget.position.x - w / 2 + px;\n      this.box.min.y = this.widget.position.y - h / 2 + py;\n      this.box.max.x = this.widget.position.x + w / 2 + px;\n      this.box.max.y = this.widget.position.y + h / 2 + py;\n\n      for (let i = 0; i < this.children.length; i++) {\n        this.children[i].updateBounds();\n      }\n    } else {\n      // Compute world position from the flat hierarchy. All child widgets are\n      // placed in tGuiPanel.widget (flat THREE.js group),\n      // so world position = rootPanel.position + localPosition * menuScale.\n      //\n      // We avoid THREE.js getWorldPosition() here because during initial creation\n      // in buildChildren(), the widget is not yet added to the root panel's group\n      // when updateBounds() first runs (called from calculatePosition() inside\n      // createControl(), before the widget.add() call). getWorldPosition() would\n      // then return just the local position  missing the root panel's offset and\n      // producing an incorrect hit-test box.\n      const isRoot = this === this.menu.tGuiPanel;\n      let wx: number, wy: number;\n      if (isRoot) {\n        wx = this.widget.position.x;\n        wy = this.widget.position.y;\n      } else {\n        const s = this.menu.scale;\n        wx = this.menu.tGuiPanel.widget.position.x + this.widget.position.x * s;\n        wy = this.menu.tGuiPanel.widget.position.y + this.widget.position.y * s;\n      }\n      this.worldPosition.set(wx, wy, this.widget.position.z);\n      this.box.min.x = wx - w / 2;\n      this.box.min.y = wy - h / 2;\n      this.box.max.x = wx + w / 2;\n      this.box.max.y = wy + h / 2;\n    }\n  }\n\n  updateScale() {\n    this.updateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i] instanceof GUIControl)\n        this.children[i].updateScale();\n    }\n  }\n\n  recalculate() {\n    this.calculatePosition();\n    this.updateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].recalculate();\n    }\n  }\n\n  /**\n   * Recursively update hit-test Box2 bounds for this control and all children\n   * WITHOUT recalculating widget positions.  Use this when the root panel's\n   * widget.position has been changed externally (e.g. by a direct assignment in\n   * a click handler) and only the bounding boxes need to catch up.\n   */\n  updateBoundsRecursive() {\n    this.updateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].updateBoundsRecursive();\n    }\n  }\n\n  /**\n   * Returns the control's position and size in THREE.js local coordinates\n   * (relative to the parent group's center, Y-up).\n   * Used internally for border/fill/highlight geometry layout.\n   */\n  getControlExtent() {\n    const panelW = this.menu.width;\n    const panelH = this.menu.height;\n\n    // Convert from panel-local (top-left, Y-down) to THREE.js group-local (center, Y-up)\n    let left = this.extent.left + this.extent.width / 2 - panelW / 2;\n    const top = panelH / 2 - this.extent.top - this.extent.height / 2;\n\n    const shrinkWidth = this.getShrinkWidth();\n    left += shrinkWidth;\n\n    return {\n      top: top,\n      left: left,\n      width: this.extent.width,\n      height: this.extent.height,\n    };\n\n  }\n\n  getInnerSize() {\n    let width = this.extent.width - this.border.dimension;\n    if (width < this.border.dimension) width = this.border.dimension;\n\n    let height = this.extent.height - this.border.dimension;\n    if (height < this.border.dimension) height = this.border.dimension;\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n\n  getOuterSize() {\n    const extent = this.getControlExtent();\n    return {\n      top: extent.top,\n      left: extent.left,\n      width: extent.width,\n      height: extent.height\n    };\n  }\n\n  flipLeft(): boolean {\n    if (BitWise.InstanceOfObject(this, GUIControlTypeMask.GUIListBox) && (this as GUIListBox).isScrollBarLeft()) {\n      return true;\n    }\n    return false;\n  }\n\n  getFillExtent() {\n    const extent = this.getControlExtent();\n    const inner = this.getInnerSize();\n    //log.info('size', extent, inner);\n\n    const shrinkWidth = this.getShrinkWidth();\n\n    let width = inner.width - this.border.dimension - shrinkWidth;\n    let height = inner.height - this.border.dimension;\n\n    if (width < 0) {\n      width = 0.00001;\n    }\n\n    if (height < 0) {\n      height = 0.00001;\n    }\n\n    return {\n      top: extent.top,\n      left: extent.left,\n      width: width,\n      height: height\n    };\n  }\n\n  getBorderSize() {\n    if (GameState.GameKey == GameEngineType.TSL) {\n      return this.border.dimension || 0;\n    } else {\n      return this.border.dimension || 0;\n    }\n  }\n\n  getHightlightSize() {\n    if (GameState.GameKey == GameEngineType.TSL) {\n      return this.highlight.dimension || 0;\n    } else {\n      return this.highlight.dimension || 0;\n    }\n  }\n\n  getShrinkWidth() {\n    let shrinkWidth = 0;\n    if (BitWise.InstanceOfObject(this, GUIControlTypeMask.GUIListBox)) {\n      const listBox = this as GUIListBox;\n      shrinkWidth = (listBox.scrollbar.extent.width) + (listBox.scrollbar.border.dimension * 2);\n    }\n    return shrinkWidth;\n  }\n\n  getBorderExtent(side: string) {\n    // let extent = this.getControlExtent();\n    const inner = this.getInnerSize();\n\n    if (BitWise.InstanceOfObject(this, GUIControlTypeMask.GUIProtoItem)) {\n      inner.width += this.parent.border.inneroffset * 2;\n      inner.width = Math.min(this.extent.width, inner.width);\n    }\n\n    let top = 0, left = 0, width = 0, height = 0;\n\n    const shrinkWidth = this.getShrinkWidth();\n\n    switch (side) {\n      case 'top':\n        top = -(inner.height / 2);\n        left = -shrinkWidth / 2;\n        width = inner.width - (this.getBorderSize()) - shrinkWidth;\n        height = this.getBorderSize();\n        break;\n      case 'bottom':\n        top = (inner.height / 2);\n        left = -shrinkWidth / 2;\n        width = inner.width - (this.getBorderSize()) - shrinkWidth;\n        height = this.getBorderSize();\n        break;\n      case 'left':\n        top = 0\n        left = -(inner.width / 2);\n        width = inner.height - (this.getBorderSize()) < 0 ? 0.000001 : inner.height - (this.getBorderSize());\n        height = this.getBorderSize();\n        break;\n      case 'right':\n        top = 0;\n        left = (inner.width / 2) - shrinkWidth;\n        width = inner.height - (this.getBorderSize()) < 0 ? 0.000001 : inner.height - (this.getBorderSize());\n        height = this.getBorderSize();\n        break;\n      case 'topLeft':\n        top = ((inner.height / 2));\n        left = -((inner.width / 2));\n        width = this.getBorderSize();\n        height = this.getBorderSize();\n        break;\n      case 'topRight':\n        top = (inner.height / 2);\n        left = (inner.width / 2) - shrinkWidth;\n        width = this.getBorderSize();\n        height = this.getBorderSize();\n        break;\n      case 'bottomLeft':\n        top = -((inner.height / 2));\n        left = -((inner.width / 2));\n        width = this.getBorderSize();\n        height = this.getBorderSize();\n        break;\n      case 'bottomRight':\n        top = -((inner.height / 2));\n        left = ((inner.width / 2)) - shrinkWidth;\n        width = this.getBorderSize();\n        height = this.getBorderSize();\n        break;\n    }\n\n    if (width < 0) {\n      width = 0.00001;\n    }\n\n    if (height < 0) {\n      height = 0.00001;\n    }\n\n    return {\n      top: top,\n      left: left + (this.flipLeft() ? shrinkWidth : 0),\n      width: width,\n      height: height\n    };\n\n  }\n\n  getHighlightExtent(side: string) {\n    const extent = this.getControlExtent();\n    const inner = this.getInnerSize();\n\n    let top = 0, left = 0, width = 0, height = 0;\n\n    if (BitWise.InstanceOfObject(this, GUIControlTypeMask.GUIProtoItem)) {\n      inner.width += this.parent.border.inneroffset * 2;\n      inner.width = Math.min(this.extent.width, inner.width);\n    }\n\n    const shrinkWidth = this.getShrinkWidth();\n\n    switch (side) {\n      case 'top':\n        top = -((inner.height / 2));\n        left = -shrinkWidth / 2;\n        width = inner.width - (this.getHightlightSize()) - shrinkWidth;\n        height = this.getHightlightSize();\n        break;\n      case 'bottom':\n        top = (inner.height / 2);\n        left = -shrinkWidth / 2;\n        width = inner.width - (this.getHightlightSize()) - shrinkWidth;\n        height = this.getHightlightSize();\n        break;\n      case 'left':\n        top = 0;\n        left = -(inner.width / 2);\n        width = inner.height - (this.getHightlightSize());\n        height = this.getHightlightSize();\n        break;\n      case 'right':\n        top = 0;\n        left = (inner.width / 2);\n        width = inner.height - (this.getHightlightSize());\n        height = this.getHightlightSize();\n        break;\n      case 'topLeft':\n        top = ((inner.height / 2));\n        left = -((inner.width / 2));\n        width = this.getHightlightSize();\n        height = this.getHightlightSize();\n        break;\n      case 'topRight':\n        top = (inner.height / 2);\n        left = (inner.width / 2) - shrinkWidth;\n        width = this.getHightlightSize();\n        height = this.getHightlightSize();\n        break;\n      case 'bottomLeft':\n        top = -((inner.height / 2));\n        left = -((inner.width / 2));\n        width = this.getHightlightSize();\n        height = this.getHightlightSize();\n        break;\n      case 'bottomRight':\n        top = -((inner.height / 2));\n        left = ((inner.width / 2)) - shrinkWidth;\n        width = this.getHightlightSize();\n        height = this.getHightlightSize();\n        break;\n    }\n\n    if (width < 0) {\n      width = 0.00001;\n    }\n\n    if (height < 0) {\n      height = 0.00001;\n    }\n\n    return {\n      top: top,\n      left: left + (this.flipLeft() ? shrinkWidth : 0),\n      width: width,\n      height: height\n    };\n  }\n\n  buildFill() {\n    const extent = this.getFillExtent();\n\n    if (this.border.fill.mesh) {\n      this.border.fill.mesh.name = this.widget.name + ' center fill';\n      this.border.fill.mesh.scale.x = extent.width || 0.000001;\n      this.border.fill.mesh.scale.y = extent.height || 0.000001;\n      this.border.fill.mesh.position.z = this.zOffset;\n\n      const shrinkWidth = this.getShrinkWidth();\n      this.border.fill.mesh.position.x = (this.flipLeft() ? shrinkWidth / 2 : -shrinkWidth / 2);\n    }\n  }\n\n  buildBorder() {\n\n    const edgeGeometries = 4;\n    const cornerGeometries = 4;\n    const geomCount = edgeGeometries + cornerGeometries;\n\n    const planes: THREE.BufferGeometry[] = [];\n    let extent;\n\n    for (let i = 0; i < geomCount; i++) {\n      switch (i) {\n        case 0: //top-border\n          extent = this.getBorderExtent('top');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 1: //right-border\n          extent = this.getBorderExtent('right');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(-Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 2: //bottom-border\n          extent = this.getBorderExtent('bottom');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 3: //left-border\n          extent = this.getBorderExtent('left');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 4: //top-left-corner\n          extent = this.getBorderExtent('topLeft');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 5: //top-right-corner\n          extent = this.getBorderExtent('topRight');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(-Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 6: //bottom-right-corner\n          extent = this.getBorderExtent('bottomRight');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 7: //bottom-left-corner\n          extent = this.getBorderExtent('bottomLeft');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n      }\n    }\n\n    if (this.border.geometry instanceof THREE.BufferGeometry)\n      this.border.geometry.dispose();\n\n    this.border.geometry = BufferGeometryUtils.mergeBufferGeometries(planes, false);\n    this.border.geometry.computeBoundingBox();\n\n    //Edge Group\n    this.border.geometry.addGroup(0, 24, 0);\n    //Corner Group\n    this.border.geometry.addGroup(24, 24, 1);\n\n    if (this.border.mesh)\n      this.border.mesh.geometry = this.border.geometry;\n\n    //Clean up the temporary plane geometries\n    let _plane: THREE.BufferGeometry | undefined;\n    while (planes.length) {\n      _plane = planes.shift();\n      if (_plane) {\n        _plane.dispose();\n      }\n    }\n\n  }\n\n  buildHighlight() {\n\n    const edgeGeometries = 4;\n    const cornerGeometries = 4;\n    const geomCount = edgeGeometries + cornerGeometries;\n\n    const planes: THREE.BufferGeometry[] = [];\n    let extent;\n\n    for (let i = 0; i < geomCount; i++) {\n      switch (i) {\n        case 0: //top-border\n          extent = this.getHighlightExtent('top');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 1: //right-border\n          extent = this.getHighlightExtent('right');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(-Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 2: //bottom-border\n          extent = this.getHighlightExtent('bottom');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 3: //left-border\n          extent = this.getHighlightExtent('left');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 4: //top-left-corner\n          extent = this.getHighlightExtent('topLeft');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 5: //top-right-corner\n          extent = this.getHighlightExtent('topRight');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(-Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 6: //bottom-right-corner\n          extent = this.getHighlightExtent('bottomRight');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n        case 7: //bottom-left-corner\n          extent = this.getHighlightExtent('bottomLeft');\n          planes[i] = new THREE.PlaneGeometry(extent.width, extent.height, 1, 1);\n          planes[i].rotateZ(Math.PI / 2);\n          planes[i].translate(extent.left, extent.top, 0);\n          break;\n      }\n    }\n\n    if (this.highlight.geometry instanceof THREE.BufferGeometry)\n      this.highlight.geometry.dispose();\n\n    this.highlight.geometry = BufferGeometryUtils.mergeBufferGeometries(planes, false);\n    this.highlight.geometry.computeBoundingBox();\n\n    //Edge Group\n    this.highlight.geometry.addGroup(0, 24, 0);\n    //Corner Group\n    this.highlight.geometry.addGroup(24, 24, 1);\n\n    if (this.highlight.mesh)\n      this.highlight.mesh.geometry = this.highlight.geometry;\n\n    //Clean up the temporary plane geometries\n    let _plane: THREE.BufferGeometry | undefined;\n    while (planes.length) {\n      _plane = planes.shift();\n      if (_plane) {\n        _plane.dispose();\n      }\n    }\n\n  }\n\n  buildHighlightFill() {\n    const extent = this.getFillExtent();\n    if (this.highlight.fill.mesh) {\n      this.highlight.fill.mesh.name = this.widget.name + ' center fill';\n      this.highlight.fill.mesh.scale.x = extent.width || 0.000001;\n      this.highlight.fill.mesh.scale.y = extent.height || 0.000001;\n      this.highlight.fill.mesh.position.z = this.zOffset;\n    }\n  }\n\n  buildText() {\n    if (!this.text.texture)\n      return;\n\n    if (this.text.mesh.parent)\n      this.text.mesh.parent.remove(this.text.mesh);\n\n    this.widget.userData.text.add(this.text.mesh);\n\n    const texture = this.text.texture;\n    texture.flipY = false;\n    texture.anisotropy = 1;\n    texture.minFilter = THREE.LinearFilter;\n    texture.magFilter = THREE.LinearFilter;\n    texture.needsUpdate = true;\n\n    if (this.text.text != '' || (this.text.strref != 0 && typeof GameState.TLKManager.TLKStrings[this.text.strref] != 'undefined'))\n      this.updateTextGeometry(this.text.text != '' ? this.menu.gameStringParse(this.text.text) : this.menu.gameStringParse(GameState.TLKManager.TLKStrings[this.text.strref].Value));\n\n    this.text.geometry.computeBoundingSphere = function () {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere()\n      }\n\n      const positions = this.attributes.position.array\n      const itemSize = this.attributes.position.itemSize\n      if (!positions || !itemSize || positions.length < 2) {\n        this.boundingSphere.radius = 0\n        this.boundingSphere.center.set(0, 0, 0)\n        return\n      }\n      // this.computeSphere(positions, this.boundingSphere)\n      if (isNaN(this.boundingSphere.radius)) {\n        log.error('THREE.BufferGeometry.computeBoundingSphere(): ' +\n          'Computed radius is NaN. The ' +\n          '\"position\" attribute is likely to have NaN values.')\n      }\n    }\n\n    ((ctrl: GUIControl) => {\n      this.text.geometry.computeBoundingBox = function (this: THREE.BufferGeometry) {\n        if (this.boundingBox === null) {\n          this.boundingBox = new THREE.Box3();\n        }\n        const bbox = this.boundingBox;\n        const positions = this.attributes.position.array;\n        const itemSize = this.attributes.position.itemSize;\n        if (!positions || !itemSize || positions.length < 2) {\n          bbox.makeEmpty();\n          return;\n        }\n        ctrl.computeBox(positions, bbox);\n      };\n    })(this);\n\n  }\n\n  getCharPositions(char: number) {\n    return {\n      ul: this.text.texture.txi.upperleftcoords[char],\n      lr: this.text.texture.txi.lowerrightcoords[char]\n    }\n  }\n\n  updateTextGeometry(text: string) {\n\n    if (!(this.text.texture instanceof THREE.Texture))\n      return;\n\n    if (this.guiFont) {\n      this.guiFont.buildGeometry(this.text.geometry, this.text.text, this.text.alignment, this.getOuterSize().width);\n      this.alignText();\n    }\n\n    if (this.text.geometry && this.text.geometry.boundingBox) {\n      this.text.geometry.boundingBox.getSize(this.textSize);\n    }\n\n  }\n\n  textSize: THREE.Vector3 = new THREE.Vector3(0, 0, 0);\n\n  alignText() {\n    if (this.text.geometry && this.text.geometry.boundingBox) {\n      this.text.geometry.boundingBox.getSize(this.textSize);\n    }\n    this.widget.userData.text.position.z = this.zOffset;\n\n    const innerSize = this.getInnerSize()\n\n    //Horizontal Alignment moved to GUIFont\n    // const horizontal = this.text.alignment & GUIControlAlignment.HorizontalMask;\n    this.widget.userData.text.position.x = -(innerSize.width / 2 - this.textSize.x / 2) - this.textSize.x / 2;\n\n    const vertical = this.text.alignment & GUIControlAlignment.VerticalMask;\n    switch (vertical) {\n      case GUIControlAlignment.VerticalTop:\n        this.widget.userData.text.position.y = (innerSize.height / 2 - this.textSize.y / 2) + this.textSize.y / 2;\n        break;\n      case GUIControlAlignment.VerticalCenter:\n        this.widget.userData.text.position.y = this.textSize.y / 2;\n        break;\n      case GUIControlAlignment.VerticalBottom:\n        this.widget.userData.text.position.y = -(innerSize.height / 2 - this.textSize.y / 2) + this.textSize.y / 2;\n        break;\n    }\n\n    if (BitWise.InstanceOfObject(this.parent, GUIControlTypeMask.GUIListBox) && this.type == GUIControlType.Label) {\n      // this.widget.userData.text.position.x -= (this.parent.scrollbar.extent.width) + (this.parent.scrollbar.border.dimension * 2);\n      this.extent.height = this.textSize.y;\n      this.resizeControl();\n      this.list.updateList();\n    }\n\n  }\n\n  disableBorder() {\n    this.borderEnabled = false;\n  }\n\n  disableBorderFill() {\n    this.borderFillEnabled = false;\n  }\n\n  disableHighlight() {\n    this.highlightEnabled = false;\n  }\n\n  disableHighlightFill() {\n    this.highlightFillEnabled = false;\n  }\n\n  enableBorder() {\n    this.borderEnabled = true;\n  }\n\n  enableBorderFill() {\n    this.borderFillEnabled = true;\n  }\n\n  enableHighlight() {\n    this.highlightEnabled = true;\n  }\n\n  enableHighlightFill() {\n    this.highlightFillEnabled = true;\n  }\n\n  disableTextAlignment() {\n    this.text.alignment = 0;\n  }\n\n  getRendererSize() {\n    return { width: GameState.ResolutionManager.getViewportWidth(), height: GameState.ResolutionManager.getViewportHeight() };\n  }\n\n  setKeymapAction(action: KeyMapAction) {\n    this.keymapAction = action;\n    return this;\n  }\n\n  tooltipText: string = '';\n  tooltipTimer: number = 3000;\n  tooltipVisible: boolean = false;\n  setTooltipText(text: string) {\n    if (this.keymapAction) {\n      const action = KeyMapper.Actions[this.keymapAction];\n      if (action) {\n        text += ` | ${action.character}`;\n      }\n    }\n    this.tooltipText = text;\n    return this;\n  }\n\n  setTooltipVisible(visible: boolean) {\n    const isChanged = this.tooltipVisible != visible;\n    this.tooltipVisible = visible;\n    if (this.tooltipVisible && isChanged) {\n      GameState.MenuManager.MenuToolTip.showToolTip(this.tooltipText, Mouse.positionViewport.x, Mouse.positionViewport.y, this);\n    } else if (!this.tooltipVisible && isChanged) {\n      GameState.MenuManager.MenuToolTip.hide();\n    }\n    return this;\n  }\n\n  setText(str: string | { toString(): string } = '', renderOrder = 5) {\n    if (typeof str !== 'string')\n      str = str.toString();\n\n    str = str.trim();\n\n    const oldText = this.text.text;\n    this.text.text = this.menu.gameStringParse(str);\n\n    if (typeof this.text.geometry !== 'object')\n      this.buildText();\n\n    if (this.text.mesh) {\n      this.text.mesh.renderOrder = undefined;//renderOrder;\n    }\n\n    if (oldText != this.text.text && typeof this.text.geometry === 'object') {\n      //log.info('updateText', this.text.text);\n      this.updateTextGeometry(this.text.text);\n    }\n\n    if (this.text.geometry && this.text.geometry.boundingBox) {\n      this.text.geometry.boundingBox.getSize(this.textSize);\n    }\n\n  }\n\n  getText() {\n    return this.text.text;\n  }\n\n  getTextSize() {\n    this.text.geometry.computeBoundingBox();\n    this.text.geometry.boundingBox.getSize(this.textSize);\n    return this.textSize;\n  }\n\n  _onCreate() {\n    //Dummy Method\n  }\n\n  getHintText() {\n    if (this.text.strref != 0 && typeof GameState.TLKManager.TLKStrings[this.text.strref + 1] != 'undefined') {\n      return GameState.TLKManager.TLKStrings[this.text.strref].Value;\n    } else {\n      return '';\n    }\n  }\n\n  resizeFill() {\n    if (this.border.fill.mesh) {\n      const extent = this.getFillExtent();\n      this.border.fill.mesh.scale.x = extent.width || 0.000001;\n      this.border.fill.mesh.scale.y = extent.height || 0.000001;\n    }\n  }\n\n  resizeHighlightFill() {\n    if (this.highlight.fill.mesh) {\n      const extent = this.getFillExtent();\n      this.highlight.fill.mesh.scale.x = extent.width || 0.000001;\n      this.highlight.fill.mesh.scale.y = extent.height || 0.000001;\n    }\n  }\n\n  resizeBorder(side: string) {\n\n    const extent = this.getBorderExtent(side);\n\n    switch (side) {\n      case 'top':\n        this.widget.userData.border.children[0].position.set(extent.left, extent.top, 1); // top\n        this.widget.userData.border.children[0].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[0].scale.y = extent.height || 0.000001;\n        break;\n      case 'left':\n        this.widget.userData.border.children[1].position.set(extent.left, extent.top, 1); // left\n        this.widget.userData.border.children[1].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[1].scale.y = extent.height || 0.000001;\n        break;\n      case 'right':\n        this.widget.userData.border.children[2].position.set(extent.left, extent.top, 1); // right\n        this.widget.userData.border.children[2].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[2].scale.y = extent.height || 0.000001;\n        break;\n      case 'bottom':\n        this.widget.userData.border.children[3].position.set(extent.left, extent.top, 1); // bottom\n        this.widget.userData.border.children[3].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[3].scale.y = extent.height || 0.000001;\n        break;\n    }\n\n  }\n\n  resizeCorner(side: string) {\n\n    const extent = this.getBorderExtent(side);\n\n    switch (side) {\n      case 'topLeft':\n        this.widget.userData.border.children[4].position.set(extent.left, extent.top, 1); // top\n        this.widget.userData.border.children[4].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[4].scale.y = extent.height || 0.000001;\n        break;\n      case 'topRight':\n        this.widget.userData.border.children[5].position.set(extent.left, extent.top, 1); // left\n        this.widget.userData.border.children[5].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[5].scale.y = extent.height || 0.000001;\n        break;\n      case 'bottomLeft':\n        this.widget.userData.border.children[6].position.set(extent.left, extent.top, 1); // right\n        this.widget.userData.border.children[6].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[6].scale.y = extent.height || 0.000001;\n        break;\n      case 'bottomRight':\n        this.widget.userData.border.children[7].position.set(extent.left, extent.top, 1); // bottom\n        this.widget.userData.border.children[7].scale.x = extent.width || 0.000001;\n        this.widget.userData.border.children[7].scale.y = extent.height || 0.000001;\n        break;\n    }\n\n  }\n\n  resizeHighlight(side: string) {\n\n    /*let extent = this.getHighlightExtent(side);\n\n    let geometry = new THREE.PlaneGeometry( extent.width, extent.height, 1 );\n    let material = new THREE.MeshBasicMaterial( {color: new THREE.Color(0xFFFFFF), side: THREE.DoubleSide} );\n    let sprite = new THREE.Mesh( geometry, material );\n\n    if(this.highlight.edge != ''){\n      TextureLoader.enQueue(this.highlight.edge, material, TextureType.TEXTURE);\n    }\n    sprite.position.set( extent.left, extent.top, 1 ); // top left\n\n    switch(side){\n      case 'top':\n        sprite.rotation.z = Math.PI;\n      break;\n      case 'bottom':\n      break;\n      case 'left':\n        sprite.rotation.z = Math.PI/2;\n      break;\n      case 'right':\n        sprite.rotation.z = -Math.PI/2;\n      break;\n    }\n\n    sprite.name = side+' edge';\n    this.widget.highlight.add(sprite);\n\n    sprite.isClickable = (_e: GUIControlEvent) => {\n      return this.isClickable();\n    };\n\n    sprite.onClick = (e: GUIControlEvent) => {\n      if (typeof this.onClick === 'function')\n        this.onClick(e);\n    };\n\n    sprite.onMouseMove = (e: GUIControlEvent) => {\n      if (typeof this.onMouseMove === 'function')\n        this.onMouseMove(e);\n    }\n\n    sprite.onMouseDown = (e: GUIControlEvent) => {\n      if (typeof this.onMouseDown === 'function')\n        this.onMouseDown(e);\n    };\n\n    sprite.onMouseUp = (e: GUIControlEvent) => {\n      if (typeof this.onMouseUp === 'function')\n        this.onMouseUp(e);\n    };\n\n    sprite.onHover = (e: GUIControlEvent) => {\n      if (typeof this.onMouseIn === 'function')\n        this.onMouseIn(e);\n    };\n\n    sprite.getControl = () => {\n      return this;\n    }*/\n\n  }\n\n  resizeHighlightCorner(side: string) {\n\n    /*let extent = this.getHighlightExtent(side);\n\n    let geometry = new THREE.PlaneGeometry( extent.width, extent.height, 1 );\n    let material = new THREE.MeshBasicMaterial( {color: new THREE.Color(0xFFFFFF), side: THREE.DoubleSide} );\n    let sprite = new THREE.Mesh( geometry, material );\n\n    if(this.highlight.corner != ''){\n      TextureLoader.enQueue(this.highlight.corner, material, TextureType.TEXTURE);\n    }\n\n    switch(side){\n      case 'topRight':\n        sprite.rotation.z = - (Math.PI / 2);\n      break;\n      case 'bottomRight':\n        sprite.rotation.z = - Math.PI;\n      break;\n      case 'bottomLeft':\n        sprite.rotation.z = (Math.PI / 2);\n      break;\n    }\n\n    sprite.position.set( extent.left, extent.top, 0 ); // top left\n    sprite.name = side+' corner';\n    this.widget.highlight.add(sprite);*/\n\n  }\n\n  //Add an event listener\n  addEventListener(name: string = '', callback?: (event: GUIControlEvent, ...args: GUIControlEventData[]) => void) {\n    if (typeof callback === 'function') {\n      if (Object.prototype.hasOwnProperty.call(this.eventListeners, name)) {\n        (this.eventListeners as Record<string, Array<(event: GUIControlEvent, ...args: GUIControlEventData[]) => void>>)[name].push(callback);\n      }\n    }\n    return this;\n  }\n\n  //Remove an event listener\n  removeEventListener(name: string = '', callback?: (event: GUIControlEvent, ...args: GUIControlEventData[]) => void) {\n\n    if (Object.prototype.hasOwnProperty.call(this.eventListeners, name)) {\n      const arr = (this.eventListeners as Record<string, Array<(event: GUIControlEvent, ...args: GUIControlEventData[]) => void>>)[name];\n      if (typeof callback === 'function') {\n        const cbIndex = arr.indexOf(callback);\n        if (cbIndex > -1) {\n          arr.splice(cbIndex, 1);\n        }\n      } else {\n        arr.length = 0;\n      }\n    }\n    return this;\n\n  }\n\n  //Process an event listener\n  processEventListener(name = '', args: GUIControlEventData[] = []) {\n    let processed = false;\n\n    const event = GUIControlEventFactory.generateEventObject();\n    event.data = args;\n\n    let invokeArgs: [GUIControlEvent, ...GUIControlEventData[]];\n    if (!args.length) {\n      invokeArgs = [event];\n    } else {\n      invokeArgs = [event, ...args];\n    }\n\n    if (Object.prototype.hasOwnProperty.call(this.eventListeners, name)) {\n      const arr = (this.eventListeners as Record<string, Array<(event: GUIControlEvent, ...args: GUIControlEventData[]) => void>>)[name];\n      for (let i = 0; i < arr.length; i++) {\n        const fn = arr[i];\n        if (typeof fn === 'function') {\n          processed = true;\n          fn(...invokeArgs);\n        }\n      }\n    }\n    return processed;\n  }\n\n  click() {\n    if (this.disableSelection) {\n      return;\n    }\n\n    this.processEventListener('click');\n  }\n\n  setDPadTarget(direction = '', control: GUIControl) {\n    if (typeof direction == 'string') {\n      direction = direction.toLowerCase();\n    }\n\n    if (control instanceof GUIControl) {\n      switch (direction) {\n        case 'up':\n          this.dPadTarget.up = control;\n          break;\n        case 'down':\n          this.dPadTarget.down = control;\n          break;\n        case 'left':\n          this.dPadTarget.left = control;\n          break;\n        case 'right':\n          this.dPadTarget.right = control;\n          break;\n      }\n    }\n  }\n\n  directionalNavigate(direction = '') {\n    switch (direction) {\n      case 'up':\n\n        break;\n      case 'down':\n\n        break;\n      case 'left':\n\n        break;\n      case 'right':\n\n        break;\n    }\n  }\n\n  onINIPropertyAttached() {\n    //Stub\n  }\n\n  attachINIProperty(key = '') {\n    const property = key;\n    if (property) {\n      this.iniProperty = property;\n      this.onINIPropertyAttached();\n    }\n  }\n\n  updateWorldPosition() {\n\n    const pos = this.widget.position.clone();\n    let parent = this.parent;\n    while (parent instanceof GUIControl) {\n      pos.add(parent.widget.position);\n      parent = parent.parent;\n    }\n    this.worldPosition = pos;\n    return pos;\n\n  }\n\n  bounds(positions: number[] = []) {\n    const count = positions.length / itemSize\n    box.min[0] = positions[0]\n    box.min[1] = positions[1]\n    box.max[0] = positions[0]\n    box.max[1] = positions[1]\n\n    for (let i = 0; i < count; i++) {\n      const x = positions[i * itemSize + 0]\n      const y = positions[i * itemSize + 1]\n      box.min[0] = Math.min(x, box.min[0])\n      box.min[1] = Math.min(y, box.min[1])\n      box.max[0] = Math.max(x, box.max[0])\n      box.max[1] = Math.max(y, box.max[1])\n    }\n  }\n\n  computeBox(positions: number[] = [], output: THREE.Box3) {\n    this.bounds(positions)\n    output.min.set(box.min[0], box.min[1], 0)\n    output.max.set(box.max[0], box.max[1], 0)\n  }\n\n  computeSphere(positions: number[] = [], output: THREE.Sphere) {\n    this.bounds(positions)\n    const minX = box.min[0]\n    const minY = box.min[1]\n    const maxX = box.max[0]\n    const maxY = box.max[1]\n    const width = maxX - minX\n    const height = maxY - minY\n    const length = Math.sqrt(width * width + height * height)\n    output.center.set(minX + width / 2, minY + height / 2, 0)\n    output.radius = length / 2\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUIListBox.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":262,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":262,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":287,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":287,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":327,"column":26,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":327,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":327,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":327,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":503,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":503,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":504,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":504,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":504,"column":23,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":504,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updateWorldPosition on an `any` value.","line":504,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":504,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .y on an `any` value.","line":505,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":505,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .extent on an `any` value.","line":505,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":505,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .y on an `any` value.","line":506,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":506,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .extent on an `any` value.","line":506,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":506,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":622,"column":8,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":622,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .containsPoint on an `any` value.","line":622,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":622,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":627,"column":8,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":627,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .containsPoint on an `any` value.","line":627,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":627,"endColumn":59}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { Mouse } from \"@/controls/Mouse\";\nimport { GameEngineType } from \"@/enums/engine\";\nimport { GUIControlType } from \"@/enums/gui/GUIControlType\";\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\nimport { GameState } from \"@/GameState\";\nimport type { GameMenu } from \"@/gui/GameMenu\";\nimport { GUIControl } from \"@/gui/GUIControl\";\nimport { GUIControlEvent } from \"@/gui/GUIControlEvent\";\nimport { GUIProtoItem } from \"@/gui/GUIProtoItem\";\nimport type { GUIScrollBar } from \"@/gui/GUIScrollBar\";\nimport type { IGUIControlListNode } from \"@/interface/gui/IGUIControlListNode\";\nimport { TextureLoader } from \"@/loaders/TextureLoader\";\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\ninterface GUIListItemCallbacks {\n  onClick?: (node: IGUIControlListNode | string, control: GUIControl) => void;\n  onValueChanged?: (node: IGUIControlListNode | string, control: GUIControl) => void;\n  onHover?: (node: IGUIControlListNode | string, control: GUIControl) => void;\n}\n\n/**\n * GUIListBox class.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file GUIListBox.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n * \n * Features:\n * - Automatic scrollbar visibility based on content height\n * - Scrollbar is hidden when all items fit within the listbox height\n * - Scrollbar is shown when content exceeds the visible area\n */\nexport class GUIListBox extends GUIControl {\n  listItems: (IGUIControlListNode | string)[];\n  scroll: number;\n  maxScroll: number;\n  GUIProtoItemClass: typeof GUIProtoItem;\n  onSelected: (node: IGUIControlListNode | string | undefined, control: GUIControl, index: number) => void;\n  hasProtoItem: boolean;\n  protoItem: GUIControl;\n  hasScrollBar: boolean;\n  _scrollbar: GFFStruct;\n  itemGroup: THREE.Group;\n  scene: THREE.Scene;\n  scrollbar: GUIScrollBar;\n  scrollWrapper: THREE.Group;\n  width: number;\n  height: number;\n  camera: THREE.OrthographicCamera;\n  texture: THREE.WebGLRenderTarget;\n  clearColor: THREE.Color;\n  targetMaterial: THREE.MeshBasicMaterial;\n  targetGeometry: THREE.PlaneGeometry;\n  targetMesh: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;\n  selectedItem: GUIControl;\n  minY: number;\n  maxY: number;\n  \n  // Height caching for performance\n  private itemHeightCache = new Map<number, number>();\n  private cacheDirty = true;\n  \n  static hexTextures: Map<string, OdysseyTexture>;\n  static InitTextures: () => void;\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\n    super(menu, control, parent, scale);\n    this.objectType |= GUIControlTypeMask.GUIListBox;\n\n    this.listItems = [];\n    this.scroll = 0;\n    this.maxScroll = 0;\n    this.offset = new THREE.Vector2(0, 0);\n    this.scene = new THREE.Scene();\n\n    //ProtoItem\n    this.hasProtoItem = control.hasField('PROTOITEM');\n    if(this.hasProtoItem){\n      //log.info(control.getFieldByLabel('PROTOITEM'))\n      this.protoItem = this.menu.factory.FromStruct(control.getFieldByLabel('PROTOITEM').getChildStructs()[0], this.menu, this, this.scale);\n    }\n\n    //ScrollBar\n    this.hasScrollBar = control.hasField('SCROLLBAR');\n    if(this.hasScrollBar){\n      //log.info(control.getFieldByLabel('SCROLLBAR'))\n      this._scrollbar = control.getFieldByLabel('SCROLLBAR').getChildStructs()[0];\n    }\n\n    if(this.hasScrollBar){\n      this.scrollbar = new this.menu.factory.GUIScrollBar(this.menu, this._scrollbar, this, this.scale);\n      this.scrollbar.setList( this );\n      //this.widget.add(this.scrollbar.createControl());\n      this.scrollWrapper = new THREE.Group();\n      this.scrollWrapper.add(this.scrollbar.createControl())\n      this.scene.add(this.scrollWrapper);\n    }\n\n    this.itemGroup = new THREE.Group();\n    this.itemGroup.name = 'ListItems';\n    this.itemGroup.position.set(0, 0, 0);\n\n    const shrinkWidth = this.scrollbar ? this.scrollbar.extent.width/2 : 0;\n    this.itemGroup.position.x += this.isScrollBarLeft() ? shrinkWidth : shrinkWidth * -1;\n\n    const extent = this.getOuterSize();\n    this.width = extent.width;\n    this.height = extent.height;\n\n    this.camera = new THREE.OrthographicCamera(\n      this.width / -2, this.width / 2,\n      this.height / 2, this.height / -2,\n      1, 500\n    );\n    this.camera.position.z = 100;\n\n    this.texture = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });\n\t\t//this.tDepth = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\n    this.clearColor = new THREE.Color(0x000000);\n\n    this.targetMaterial = new THREE.MeshBasicMaterial()\n    this.targetMaterial.blending = THREE.CustomBlending;\n\n    this.targetMaterial.blendEquation = THREE.AddEquation;\n    this.targetMaterial.blendSrc = THREE.OneFactor;\n    this.targetMaterial.blendDst = THREE.OneMinusSrcColorFactor;\n    //this.targetMaterial.blendSrcAlpha = THREE.OneFactor;\n    //this.targetMaterial.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n\n    this.targetGeometry = new THREE.PlaneGeometry(1, 1, 1, 1);\n    this.targetMesh = new THREE.Mesh(this.targetGeometry, this.targetMaterial);\n    this.targetMaterial.map = this.texture.texture;\n    this.targetMesh.position.x = 0;\n    this.targetMesh.position.y = 0;\n    this.targetMesh.position.z = 4;\n    this.targetMesh.renderOrder = 5;\n    this.targetMesh.scale.set(this.width, this.height, 1);\n    this.widget.add(this.targetMesh);\n\n    this.scene.add(this.itemGroup);\n\n  }\n\n  resizeControl(): void {\n    super.resizeControl();\n    this.width = this.extent.width;\n    this.height = this.extent.height;\n    this.texture.setSize(this.width, this.height);\n    this.targetMesh.scale.set(this.width, this.height, 1);\n    this.updateCamera();\n    this.invalidateHeightCache();\n    this.updateList();\n    if(this.scrollbar) {\n      this.scrollbar.update();\n    }\n    // Update scrollbar visibility after resize\n    this.updateScrollbarVisibility();\n  }\n\n  update(delta: number = 0){\n    super.update(delta);\n\n    if(!this.isVisible())\n      return;\n\n    this.render();\n  }\n\n  render(){\n    const oldClearColor = new THREE.Color()\n    this.menu.context.renderer.getClearColor(oldClearColor);\n    this.menu.context.renderer.setClearColor(this.clearColor, 1);\n    this.menu.context.renderer.setRenderTarget(this.texture);\n    this.menu.context.renderer.clear(true);\n    this.menu.context.renderer.render(this.scene, this.camera);\n    (this.texture as THREE.WebGLRenderTarget & { needsUpdate?: boolean }).needsUpdate = true;\n    this.menu.context.renderer.setRenderTarget(null);\n    this.targetMaterial.transparent = true;\n    this.targetMaterial.needsUpdate = true;\n    this.menu.context.renderer.setClearColor(oldClearColor, 1);\n  }\n\n  calculatePosition(){\n    super.calculatePosition();\n    for(let i = 0; i < this.children.length; i++){\n      this.children[i].calculatePosition();\n    }\n\n    if(this.scrollbar){\n      this.scrollbar.calculatePosition();\n      this.scrollbar.update();\n    }\n\n  }\n\n  clearItems(){\n    for (let i = this.itemGroup.children.length - 1; i >= 0; i--) {\n      this.itemGroup.remove(this.itemGroup.children[i]);\n    }\n    this.listItems = [];\n    this.children = [];\n    this.invalidateHeightCache();\n    this.updateScrollbarVisibility();\n    this.render();\n  }\n\n  removeItemByIndex(index = -1){\n    if(index >= 0 && this.children.length > index){\n      const node = this.children.splice(index, 1)[0];\n      node.widget.parent.remove(node.widget);\n\n      //Select a new item if the one removed was selected\n      if(this.selectedItem == node){\n        //new select index\n        index = index--;\n        if(index < 0)\n          index = 0;\n\n        this.select(this.children[index]);\n      }\n\n      this.invalidateHeightCache();\n      this.updateList();\n      this.updateScrollbarVisibility();\n    }\n  }\n\n  getProtoItemType(){\n    return this.protoItem.type;\n  }\n\n  addItem(node: IGUIControlListNode | string, options: GUIListItemCallbacks = {} as GUIListItemCallbacks): GUIControl {\n    const control = this.protoItem;\n    const type = control.type;\n    \n    let ctrl: GUIControl;\n    let widget: THREE.Object3D;\n\n    let idx = this.listItems.indexOf(node);\n    if(idx == -1 || typeof node === 'string'){\n      this.listItems.push(node);\n    }else{\n      return this.children[idx];\n    }\n\n    if(typeof this.GUIProtoItemClass === 'undefined'){\n      switch(type){\n        case GUIControlType.Label:\n        case GUIControlType.ProtoItem:\n          ctrl = new this.menu.factory.GUIProtoItem(this.menu, control.control, this, this.scale);\n          ctrl.guiFont = this.protoItem.guiFont;\n          ctrl.text.texture = this.protoItem.text.texture;\n          ctrl.text.material.uniforms.map.value = this.protoItem.text.material.uniforms.map.value;\n          ctrl.isProtoItem = false;\n          ctrl.offset = this.offset;\n          ctrl.node = node;\n          ctrl.setList( this );\n          idx = this.children.push(ctrl) - 1;\n\n          widget = ctrl.createControl();\n          ctrl.setText(node);\n          ctrl.buildText();\n\n          this.itemGroup.add(widget);\n          \n          if(typeof options.onClick === 'function'){\n            ctrl.addEventListener('click', (e) => {\n              e.stopPropagation();\n              this.select(ctrl);\n              options.onClick(node, ctrl);\n            });\n          }\n        break;\n        case GUIControlType.CheckBox:\n          ctrl = new this.menu.factory.GUICheckBox(this.menu, control.control, this, this.scale);\n          ctrl.guiFont = this.protoItem.guiFont;\n          ctrl.text.texture = this.protoItem.text.texture;\n          ctrl.text.material.uniforms.map.value = this.protoItem.text.material.uniforms.map.value;\n          ctrl.isProtoItem = false;\n          ctrl.offset = this.offset;\n          ctrl.node = node;\n          ctrl.setList( this );\n          idx = this.children.push(ctrl) - 1;\n\n          widget = ctrl.createControl();\n          ctrl.setText(node);\n          this.itemGroup.add(widget);\n          \n          if(typeof options.onClick === 'function'){\n            ctrl.addEventListener('click', (e) => {\n              e.stopPropagation();\n              this.select(ctrl);\n              options.onClick(node, ctrl);\n            });\n          }\n          \n          if(typeof options.onValueChanged === 'function'){\n            ctrl.addEventListener('valueChanged', (e) => {\n              e.stopPropagation();\n              options.onValueChanged(node, ctrl);\n            });\n          }\n        break;\n        case GUIControlType.Button:\n          try{\n            ctrl = new this.menu.factory.GUIButton(this.menu, control.control, this, this.scale);\n            ctrl.guiFont = this.protoItem.guiFont;\n            ctrl.isProtoItem = false;\n            ctrl.offset = this.offset;\n            ctrl.node = node;\n            ctrl.setList( this );\n            idx = this.children.push(ctrl) - 1;\n\n            ctrl.highlight.color = new THREE.Color(0.83203125, 1, 0.83203125);\n            ctrl.border.color = new THREE.Color(0, 0.658823549747467, 0.9803921580314636);\n\n            widget = ctrl.createControl();\n            ctrl.setText(node.getName());\n\n            this.itemGroup.add(widget);\n          \n            if(typeof options.onClick === 'function'){\n              ctrl.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.select(ctrl);\n                options.onClick(node, ctrl);\n              });\n            }\n          }catch(e){\n            log.error('GUIListBox.add', e);\n          }\n        break;\n        default:\n          log.error('GUIListBox.add', 'Unknown ControlType', type);\n        break;\n      }\n    }else{\n      ctrl = new this.GUIProtoItemClass(this.menu, control.control, this, this.scale);\n      ctrl.guiFont = this.protoItem.guiFont;\n      ctrl.isProtoItem = true;\n      ctrl.offset = this.offset;\n      ctrl.node = node;\n      ctrl.setList( this );\n      idx = this.children.push(ctrl) - 1;\n\n      ctrl.highlight.color = ctrl.defaultHighlightColor.clone();\n      ctrl.border.color = ctrl.defaultColor.clone();\n      \n      widget = ctrl.createControl();\n\n      this.itemGroup.add(widget);\n          \n      if(typeof options.onClick === 'function' && !ctrl.disableSelection){\n        ctrl.addEventListener('click', (e) => {\n          e.stopPropagation();\n          this.select(ctrl);\n\n          options.onClick(node, ctrl);\n        });\n      }\n    }\n\n    if(ctrl){\n      ctrl.addEventListener('click', (e) => {\n        this.select(ctrl);\n      });\n    }\n\n    this.invalidateHeightCache();\n    this.updateList();\n    if(this.scrollbar) {\n      this.scrollbar.update();\n    }\n    // Update scrollbar visibility after adding item\n    this.updateScrollbarVisibility();\n\n    return this.children[idx];\n  }\n\n  setSelectedIndex(index: number = 0){\n    if(index >= 0 && index < this.children.length){\n      let lastSelectedIndex = 0;\n      for(let i = 0, len = this.children.length; i < len; i++){\n        if(this.children[i].selected == true) lastSelectedIndex = i;\n        this.children[i].selected = false;\n      }\n\n      this.children[index].selected = true;\n      if(index != lastSelectedIndex && typeof this.children[index].onSelect === 'function'){\n        this.children[index].onSelect.call(this);\n      }\n    }\n  }\n\n  select(control: GUIControl){\n    try{\n      const len = this.children.length;\n      let bWasSelected = false;\n      let bWasItemSelected = false;\n\n      //deselect all \n      for(let i = 0; i < len; i++){\n        bWasSelected = this.children[i].selected;\n        if(this.children[i] == control){\n          bWasItemSelected = this.children[i].selected;\n          continue; \n        }\n\n        this.children[i].selected = false;\n        if(bWasSelected && typeof this.children[i].onSelect === 'function'){\n          this.children[i].onSelect.call(this);\n        }\n      }\n\n      if(control instanceof GUIControl && this.selectedItem != control){\n        control.selected = true;\n        this.selectedItem = control;\n        if(!bWasItemSelected && typeof control.onSelect === 'function'){\n          control.onSelect.call(this);\n          // item.processEventListener('select');\n        }\n        if(!bWasItemSelected && typeof this.onSelected === 'function')\n          this.onSelected(control.node, control, this.children.indexOf(control));\n      }\n    }catch(e){\n      log.error('GUIListBox.select', e);\n    }\n  }\n\n  clearSelection(){\n    this.select(undefined);\n  }\n\n  selectItem(item: IGUIControlListNode | string){\n    const idx = this.listItems.indexOf(item);\n    if(idx >= 0){\n      this.select(this.children[idx]);\n      this.setSelectedIndex(idx);\n    }\n  }\n\n  listMarginTop = 0;\n  listMarginBottom = 0;\n  listItemMarginTop = 0;\n  listItemMarginBottom = 0;\n\n  updateList(){\n    if(!this.children.length) return;\n    \n    // Calculate visible area bounds\n    const visibleTop = this.extent.height / 2 - this.border.inneroffsety;\n    const visibleBottom = -this.extent.height / 2 + this.border.inneroffsety;\n    const visibleHeight = visibleTop - visibleBottom;\n    \n    // Calculate scroll bounds using consistent height calculation\n    const itemHeight = this.getItemHeight(this.children[0]);\n    this.maxScroll = Math.max(0, this.children.length - Math.floor(visibleHeight / itemHeight));\n    \n    if(this.scroll > this.maxScroll){\n      this.scroll = this.maxScroll;\n    }\n\n    // Position items consistently\n    const currentY = visibleTop - this.listMarginTop;\n    \n    for (let i = 0; i < this.children.length; i++) {\n      const node = this.children[i];\n      const height = this.getItemHeight(node);\n      \n      // Calculate item position\n      const itemY = currentY - (i - this.scroll) * itemHeight - height / 2 - this.listItemMarginTop;\n      node.widget.position.y = itemY;\n      node.updateBounds();\n      // currentY -= this.listItemMarginBottom;\n      // currentY -= this.listItemMarginTop;\n    }\n    \n    this.updateScrollbarVisibility();\n    this.updateScrollbarThumb();\n    this.calculateBox();\n    this.cullOffscreen();\n  }\n\n  cullOffscreen(){\n    return;\n    const parentPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3())\n    this.minY = parentPos.y + this.extent.height/2;\n    this.maxY = parentPos.y - this.extent.height/2;\n\n    const nodePadding = 0;//(this.getNodeHeight()/2);\n\n    const nodes = this.itemGroup.children;\n    for(let i = 0; i < nodes.length; i++){\n      const control = nodes[i].userData.control;\n      const nodePos = control.updateWorldPosition(); //getWorldPosition(nodes[i].control.worldPosition);\n      const nodeTop = nodePos.y + control.extent.height/2 - nodePadding;\n      const nodeBottom = nodePos.y - control.extent.height/2 + nodePadding;\n      const height = nodeBottom - nodeTop;\n      const nodeCenter = nodeTop + height/2;\n      const inside = ( (nodeTop < this.minY && nodeBottom > this.maxY) || (nodeCenter < this.minY && nodeCenter > this.maxY) );\n      nodes[i].visible = inside;\n    }\n  }\n\n  isScrollBarLeft(){\n    if(this.control.hasField('LEFTSCROLLBAR')){\n      return this.control.getFieldByLabel('LEFTSCROLLBAR').getValue() == 1;\n    }\n    return false;\n  }\n\n  getNodeHeight(node?: GUIControl): number {\n    let height = 0;\n    \n    if(!node){\n      if(this.hasProtoItem && this.protoItem.control.hasField('EXTENT')){\n        const extent = this.protoItem.control.getFieldByLabel('EXTENT').getChildStructs()[0];\n        height += extent.getFieldByLabel('HEIGHT').getValue() || 0;\n      }\n\n      if(this.hasProtoItem && this.protoItem.control.hasField('BORDER')){\n        const border = this.protoItem.control.getFieldByLabel('BORDER').getChildStructs()[0];\n        height += (border.getFieldByLabel('DIMENSION').getValue() || 0) / 2;\n      }\n\n      if(!this.hasProtoItem){\n        log.warn('GUIListBox.getNodeHeight', 'No proto item found', `${this.menu.gui_resref}.gui`, this.name);\n      }\n    } else {\n      const control = node;\n      let cHeight = (node.extent.height + (node.getBorderSize()/2));\n\n      if(control.text.geometry){\n        control.text.geometry.computeBoundingBox();\n        const tSize = new THREE.Vector3();\n        control.text.geometry.boundingBox.getSize(tSize);\n        if(tSize.y > cHeight){\n          cHeight = tSize.y;\n        }\n      }\n      height = cHeight + this.padding; // FIX: Use the calculated height!\n    }\n\n    return height;\n  }\n\n  getContentHeight(){\n    let height = this.border.inneroffsety * 2;//this.padding * 2;\n    for(let i = 0; i < this.children.length; i++){\n      const control = this.children[i];\n      // let node = this.listItems[i];\n\n      // let cHeight = (control.extent.height + (control.getBorderSize()/2));\n\n      // if(control.text.geometry){\n      //   control.text.geometry.computeBoundingBox();\n      //   //let tSize = new THREE.Box3();\n      //   let tSize = control.text.geometry.boundingBox.getSize(new THREE.Vector3());\n      //   if(tSize.y > cHeight){\n      //     cHeight = tSize.y;\n      //   }\n      // }\n      height += control.extent.height + this.padding;\n    }\n    return height;\n  }\n\n  scrollUp(){\n    this.scroll -= 1;\n    if(this.scroll <= 0)\n      this.scroll = 0;\n\n    this.updateScrollbarThumb();\n    this.updateList();\n  }\n\n  scrollDown(){    \n    this.scroll += 1;\n    if(this.scroll >= this.maxScroll)\n      this.scroll = this.maxScroll;\n\n    this.updateScrollbarThumb();\n    this.updateList();\n  }\n\n  getActiveControls(){\n\n    if(!this.widget.visible)\n      return [];\n\n    let controls: GUIControl[] = [];\n    for(let i = 0; i < this.children.length; i++){\n      const control = this.children[i];\n      //Check to see if the control is onscreen\n      if(control.widget.visible){\n        //check to see if the mouse is inside the control\n        if(control.box.containsPoint(Mouse.positionUI)){\n          controls.push(control);\n          controls = controls.concat( control.getActiveControls() );\n        }else{\n          this.menu.setWidgetHoverActive(control, false);\n        }\n      }else{\n        this.menu.setWidgetHoverActive(control, false);\n      }\n    }\n\n    if(this.scrollbar.box.containsPoint(Mouse.positionUI)){\n      controls.push(this.scrollbar);\n      //controls = controls.concat( this.scrollbar.getActiveControls() );\n    }\n\n    if(this.scrollbar.upArrow.userData.box.containsPoint(Mouse.positionUI)){\n      controls.push(this.scrollbar);\n      //controls = controls.concat( this.scrollbar.getActiveControls() );\n    }\n\n    if(this.scrollbar.downArrow.userData.box.containsPoint(Mouse.positionUI)){\n      controls.push(this.scrollbar);\n      //controls = controls.concat( this.scrollbar.getActiveControls() );\n    }\n\n    controls = controls.concat( this.scrollbar.getActiveControls() );\n    \n    return controls;\n  }\n\n  calculateBox(){\n    const worldPosition = this.parent.widget.position.clone();\n    //log.info('worldPos', worldPosition);\n\n    this.box.min.x = this.widget.position.x - this.extent.width/2 + worldPosition.x;\n    this.box.min.y = this.widget.position.y - this.extent.height/2 + worldPosition.y;\n    this.box.max.x = this.widget.position.x + this.extent.width/2 + worldPosition.x;\n    this.box.max.y = this.widget.position.y + this.extent.height/2 + worldPosition.y;\n\n    /*this.box = new THREE.Box2(\n      new THREE.Vector2(\n        this.widget.position.x - this.extent.width/2 + worldPosition.x,\n        this.widget.position.y - this.extent.height/2 + worldPosition.y\n      ),\n      new THREE.Vector2(\n        this.widget.position.x + this.extent.width/2 + worldPosition.x,\n        this.widget.position.y + this.extent.height/2 + worldPosition.y\n      )\n    );*/\n\n    for(let i = 0; i < this.children.length; i++){\n      this.children[i].calculateBox();\n    }\n\n    if(this.scrollbar){\n      this.scrollbar.calculatePosition();\n    }\n\n\n  }\n\n  _onCreate(){\n    super._onCreate();\n\n    //let extent = this.getFillExtent();\n    //let sprite = this.getFill();\n    //sprite.material.color = new THREE.Color(0.0, 0.658824, 0.980392);\n\n    //this.setProgress(this.curValue);\n    \n  }\n\n  directionalNavigate(direction = ''){\n    const maxItems = this.children.length;\n    let index = this.children.indexOf(this.selectedItem);\n    switch(direction){\n      case 'up':\n        index--;\n        if(index < 0){\n          index = 0;\n        }\n        this.select(this.children[index]);\n        this.scrollUp();\n      return;\n      case 'down':\n        index++;\n        if(index >= maxItems){\n          index = maxItems-1;\n        }\n        this.select(this.children[index]);\n        this.scrollDown();\n      return;\n    }\n    super.directionalNavigate(direction);\n  }\n\n  // Unified height calculation method\n  private getItemHeight(node: GUIControl): number {\n    const nodeIndex = this.children.indexOf(node);\n    \n    if (!this.cacheDirty && this.itemHeightCache.has(nodeIndex)) {\n      return this.itemHeightCache.get(nodeIndex);\n    }\n    \n    let height = 0;\n    \n    if (node instanceof GUIProtoItem) {\n      height = node.getItemHeight();\n    } else {\n      height = this.getNodeHeight(node);\n    }\n    \n    this.itemHeightCache.set(nodeIndex, height);\n    return height;\n  }\n\n  // Invalidate height cache when items change\n  private invalidateHeightCache() {\n    this.cacheDirty = true;\n    this.itemHeightCache.clear();\n  }\n\n  // Update scrollbar visibility based on content height\n  private updateScrollbarVisibility(){\n    if(!this.scrollbar || !this.hasScrollBar) return;\n    \n    // Calculate if scrolling is needed\n    // maxScroll > 0 means there are more items than can fit in the visible area\n    const needsScrolling = this.maxScroll > 0;\n    \n    // Show/hide scrollbar based on whether scrolling is needed\n    this.scrollWrapper.visible = needsScrolling;\n    \n    // Also update the scrollbar's internal visibility state if it has one\n    if(this.scrollbar.widget) {\n      this.scrollbar.widget.visible = needsScrolling;\n    }\n  }\n\n  // Public method to manually update scrollbar visibility\n  public refreshScrollbarVisibility(){\n    this.updateScrollbarVisibility();\n  }\n\n  // Update scrollbar thumb position\n  private updateScrollbarThumb(){\n    if(!this.scrollbar || this.maxScroll <= 0) return;\n    \n    const scrollThumbOffset = (this.scrollbar.extent.height - this.scrollbar.thumb.scale.y);\n    const scrollPercent = this.scroll / this.maxScroll;\n    const maxThumbY = scrollThumbOffset / 2;\n    const minThumbY = -maxThumbY;\n    \n    this.scrollbar.thumb.position.y = maxThumbY - (scrollThumbOffset * scrollPercent);\n    \n    // Clamp to bounds\n    this.scrollbar.thumb.position.y = Math.max(minThumbY, Math.min(maxThumbY, this.scrollbar.thumb.position.y));\n    \n    // Handle NaN\n    if(isNaN(this.scrollbar.thumb.position.y)){\n      this.scrollbar.thumb.position.y = 0;\n    }\n  }\n\n  // Update camera to match coordinate system\n  private updateCamera() {\n    this.camera.left = -this.width / 2;\n    this.camera.right = this.width / 2;\n    this.camera.top = this.height / 2;\n    this.camera.bottom = -this.height / 2;\n    this.camera.updateProjectionMatrix();\n  }\n\n}\n\nGUIListBox.hexTextures = new Map();\n\nGUIListBox.InitTextures = function(){\n  if(GameState.GameKey != GameEngineType.TSL){\n    for(let i = 0; i < 7; i++){\n      let name = '';\n      if(!i){\n        name = 'lbl_hex';\n      }else{\n        name = 'lbl_hex_'+(i+1);\n      }\n      TextureLoader.Load(name).then((texture: OdysseyTexture) => {\n        GUIListBox.hexTextures.set(texture?.name, texture);\n      });\n    }\n  }else{\n    TextureLoader.Load('uibit_eqp_itm1').then((texture: OdysseyTexture) => {\n      GUIListBox.hexTextures.set(texture?.name, texture);\n    });\n    TextureLoader.Load('uibit_eqp_itm2').then((texture: OdysseyTexture) => {\n      GUIListBox.hexTextures.set(texture?.name, texture);\n    });\n    TextureLoader.Load('uibit_eqp_itm3').then((texture: OdysseyTexture) => {\n      GUIListBox.hexTextures.set(texture?.name, texture);\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUIProgressBar.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":43,"column":21,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":43,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":84,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":84,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":85,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":85,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":85,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":85,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":96,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":96,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":96,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":96,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":99,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":99,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":99,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":114,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":114,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":114,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":114,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":117,"column":29,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":117,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":119,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":119,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":119,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":119,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":131,"column":15,"nodeType":"MemberExpression","messageId":"errorCall","endLine":131,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on a type that cannot be resolved.","line":131,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":131,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":163,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":163,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":173,"column":51,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":173,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on a type that cannot be resolved.","line":183,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":183,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":184,"column":57,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":184,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":186,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":186,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":190,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":190,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":203,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":203,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":206,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":206,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":206,"column":14,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":206,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":209,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":209,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":211,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":211,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":213,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":213,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on a type that cannot be resolved.","line":213,"column":14,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":213,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":216,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":216,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":218,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":218,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attributes on a type that cannot be resolved.","line":221,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":221,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .attributes on a type that cannot be resolved.","line":222,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":222,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on a type that cannot be resolved.","line":224,"column":13,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":224,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on a type that cannot be resolved.","line":225,"column":13,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":225,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Material`.","line":236,"column":57,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":236,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":245,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":245,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":249,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":249,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":250,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":250,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":251,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":251,"endColumn":117},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":251,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":251,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":251,"column":92,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":251,"endColumn":100},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":252,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":252,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniforms on a type that cannot be resolved.","line":252,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":252,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":253,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":253,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .defines on a type that cannot be resolved.","line":254,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":254,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":256,"column":35,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":256,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on a type that cannot be resolved.","line":259,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":259,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uniformsNeedUpdate on a type that cannot be resolved.","line":260,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":260,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":261,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":261,"endColumn":40}],"suppressedMessages":[],"errorCount":49,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport type { GameMenu } from \"@/gui/GameMenu\";\nimport { GUIControl } from \"@/gui/GUIControl\";\nimport { IGUIControlBorder } from \"@/interface/gui/IGUIControlBorder\";\nimport { TextureLoader } from \"@/loaders\";\nimport { ShaderManager } from \"@/managers/ShaderManager\";\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\n\n/**\n * GUIProgressBar class.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file GUIProgressBar.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GUIProgressBar extends GUIControl {\n  curValue: number;\n  startFromLeft: boolean;\n  maxValue: number;\n\n  progress: IGUIControlBorder;\n  hasProgress: boolean;\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\n    super(menu, control, parent, scale);\n    this.objectType |= GUIControlTypeMask.GUIProgressBar;\n\n    this.startFromLeft = control.hasField('STARTFROMLEFT') ? (control.getNumberByLabel('STARTFROMLEFT') !== 0) : false;\n    this.curValue = control.hasField('CURVALUE') ? control.getNumberByLabel('CURVALUE') : 0;\n    this.maxValue = control.hasField('MAXVALUE') ? control.getNumberByLabel('MAXVALUE') : 0;\n\n    this.widget.userData.progress = new THREE.Group();\n    this.widget.add(this.widget.userData.progress);\n\n    //----------//\n    // Progress\n    //----------//\n\n    this.progress = {\n      color: new THREE.Color(0, 0.658824, 0.980392),\n      corner: '',\n      corner_material: {} as THREE.ShaderMaterial,\n      edge: '',\n      edge_material: {} as THREE.ShaderMaterial,\n      mesh: {} as THREE.Mesh,\n      geometry: {} as THREE.BufferGeometry,\n      fill: {\n        texture: '',\n        material: {} as THREE.ShaderMaterial,\n        mesh: {} as THREE.Mesh,\n        geometry: {} as THREE.BufferGeometry\n      },\n      fillstyle: -1,\n      dimension: 0,\n      inneroffset: 0,\n      inneroffsety: 0,\n      pulsing: 0\n    };\n\n    this.progress.geometry = new THREE.BufferGeometry();\n    \n    const odysseyGuiU = ShaderManager.Shaders.get('odyssey-gui').getUniforms();\n    const odysseyGuiUniforms = Array.isArray(odysseyGuiU)\n      ? THREE.UniformsUtils.merge(odysseyGuiU)\n      : THREE.UniformsUtils.merge([odysseyGuiU]);\n    this.progress.edge_material = new THREE.ShaderMaterial({\n      uniforms: odysseyGuiUniforms,\n      vertexShader: ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    this.progress.edge_material.defines.USE_MAP = '';\n    this.progress.edge_material.uniforms.diffuse.value = this.progress.color;\n\n    this.progress.corner_material = new THREE.ShaderMaterial({\n      uniforms: odysseyGuiUniforms,\n      vertexShader: ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.progress.corner_material.defines.USE_MAP = '';\n    this.progress.corner_material.uniforms.diffuse.value = this.progress.color;\n\n    this.progress.mesh = new THREE.Mesh( this.progress.geometry, [this.progress.edge_material, this.progress.corner_material] );\n    this.widget.userData.progress.add(this.progress.mesh);\n\n    //---------------//\n    // Progress Fill\n    //---------------//\n    \n    this.progress.fill.material = new THREE.ShaderMaterial({\n      uniforms: odysseyGuiUniforms,\n      vertexShader: ShaderManager.Shaders.get('odyssey-gui').getVertex(),\n      fragmentShader: ShaderManager.Shaders.get('odyssey-gui').getFragment(),\n      side: THREE.FrontSide,\n      fog: false,\n      visible: true\n    });\n    //this.progress.fill.material.defines.USE_MAP = '';\n    this.progress.fill.material.uniforms.diffuse.value = this.progress.color;\n    this.progress.fill.geometry = new THREE.PlaneGeometry( 1, 1, 1 );\n    this.progress.fill.mesh = new THREE.Mesh( this.progress.fill.geometry, this.progress.fill.material );\n    this.progress.fill.mesh.position.z = this.zOffset + 1;\n\n    this.widget.userData.progress.add( this.progress.fill.mesh );\n\n    if(this.control){\n      \n      //Progress\n      this.hasProgress = control.hasField('PROGRESS');\n      if(this.hasProgress){\n        const progress = control.getFieldByLabel('PROGRESS')?.getChildStructs()[0];\n        if(progress){\n          if(progress.hasField('COLOR')){\n            const color = progress.getFieldByLabel('COLOR')?.getVector();\n            if(color){\n              this.progress.color.setRGB(color.x, color.y, color.z)\n            }\n          }\n\n          if(typeof this.progress.color === 'undefined'){\n            this.progress.color = new THREE.Color(1, 1, 1); //this.defaultColor;\n          }\n\n          const gffVal = (v: ReturnType<GFFStruct['getFieldByLabel']>) => (v?.getValue() ?? undefined);\n          const gffNum = (v: ReturnType<GFFStruct['getFieldByLabel']>) => Number(gffVal(v)) || 0;\n          const gffStr = (v: ReturnType<GFFStruct['getFieldByLabel']>) => String(gffVal(v) ?? '');\n          this.progress.dimension = gffNum(progress.getFieldByLabel('DIMENSION'));\n          this.progress.corner = gffStr(progress.getFieldByLabel('CORNER'));\n          this.progress.edge = gffStr(progress.getFieldByLabel('EDGE'));\n          this.progress.fill.texture = gffStr(progress.getFieldByLabel('FILL'));\n          this.progress.fillstyle = gffNum(progress.getFieldByLabel('FILLSTYLE'));\n          this.progress.inneroffset = this.progress.inneroffsety = gffNum(progress.getFieldByLabel('INNEROFFSET'));\n\n          if(progress.hasField('INNEROFFSETY'))\n            this.progress.inneroffsety = gffNum(progress.getFieldByLabel('INNEROFFSETY'));\n\n          this.progress.pulsing = gffNum(progress.getFieldByLabel('PULSING'));\n        }\n      }\n\n    }\n\n    //----------//\n    // Progress\n    //----------//\n\n    if(this.progress.edge != ''){\n      TextureLoader.enQueue(this.progress.edge, this.progress.edge_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture)\n          log.debug('initTextures', this.progress.edge, texture);\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n      });\n    }\n\n    if(this.progress.corner != ''){\n      TextureLoader.enQueue(this.progress.corner, this.progress.corner_material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(!texture)\n          log.debug('initTextures', this.progress.corner, texture);\n\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n      });\n    }\n\n    if(this.progress.fill.texture != ''){\n      this.progress.fill.material.transparent = true;\n      TextureLoader.enQueue(this.progress.fill.texture, this.progress.fill.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n        if(texture == null){\n          this.progress.fill.material.uniforms.opacity.value = 0.01;\n        }\n      });\n    }else{\n      this.progress.fill.material.visible = false;\n    }\n\n  }\n\n  setProgress(val: number = 100){\n\n    this.curValue = val < 0 ? 0 : val;\n    this.curValue = !this.curValue ? 0.000000000000001 : this.curValue;\n    \n    const value = Math.min(this.curValue / this.maxValue, 1);\n\n    const extent = this.getFillExtent();\n    const sprite = this.progress.fill.mesh;\n\n    if(extent.width > extent.height){\n      sprite.scale.set( extent.width * value, extent.height, 1.0 );\n      const offsetX = (extent.width -(extent.width * value))/2;\n      if(this.startFromLeft)\n        sprite.position.x = -offsetX;\n      else\n        sprite.position.x = +offsetX;\n    }else{\n      sprite.scale.set( extent.width, extent.height * value, 1.0 );\n      const offsetY = (extent.height -(extent.height * value))/2;\n      if(this.startFromLeft)\n        sprite.position.y = +offsetY;\n      else\n        sprite.position.y = -offsetY;\n    }\n\n    (this.progress.fill.geometry.attributes.uv as THREE.BufferAttribute).setY(1, value);\n    this.progress.fill.geometry.attributes.uv.needsUpdate = true;\n    \n    (sprite.material as THREE.ShaderMaterial).uniforms.opacity.value = 1;\n    (sprite.material as THREE.Material & { transparent?: boolean }).transparent = true;\n\n  }\n\n  getFillTextureName(){\n    return this.progress.fill.texture;\n  }\n\n  setFillTextureName(name = ''){\n    this.progress.fill.texture = name;\n    return new Promise<OdysseyTexture>( (resolve, _reject) => {\n      TextureLoader.enQueue(this.progress.fill.texture, this.progress.fill.material, TextureType.TEXTURE, resolve);\n    })\n  }\n\n  setFillTexture(map: THREE.Texture){\n    if(!(map instanceof THREE.Texture)){\n      map = TextureLoader.textures.get('fx_static');\n    }\n\n    this.progress.fill.material.uniforms.map.value = map;\n    (this.progress.fill.material as THREE.ShaderMaterial & { map?: THREE.Texture }).map = map;\n\n    if(map instanceof THREE.Texture){\n      this.progress.fill.material.visible = true;\n      this.progress.fill.material.uniforms.opacity.value = 1;\n      this.progress.fill.material.uniforms.uvTransform.value = this.progress.fill.material.uniforms.map.value.matrix;\n      this.progress.fill.material.uniforms.map.value.updateMatrix();\n      this.progress.fill.material.defines.USE_UV = '';\n      this.progress.fill.material.defines.USE_MAP = '';\n    }else{\n      this.progress.fill.material.visible = false;\n    }\n\n    this.progress.fill.material.needsUpdate = true;\n    this.progress.fill.material.uniformsNeedUpdate = true;\n    this.progress.fill.material.visible = (map instanceof THREE.Texture);\n  }\n\n  _onCreate(){\n    super._onCreate();\n    this.setProgress(this.curValue);\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUIScrollBar.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Vector3`.","line":88,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":88,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":99,"column":13,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":99,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .translate on an `any` value.","line":99,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":101,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":101,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Vector3`.","line":123,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":123,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":134,"column":13,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":134,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .translate on an `any` value.","line":134,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":134,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":136,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":136,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":221,"column":10,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":221,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .containsPoint on an `any` value.","line":221,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":221,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":223,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":223,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .containsPoint on an `any` value.","line":223,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":223,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":236,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":236,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":237,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":237,"endColumn":40},{"ruleId":"no-global-assign","severity":2,"message":"Read-only global 'scrollY' should not be modified.","line":289,"column":7,"nodeType":"Identifier","messageId":"globalShouldNotBeModified","endLine":289,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":422,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":422,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":426,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":426,"endColumn":40}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport * as THREE from \"three\";\n\nimport { Mouse } from \"@/controls/Mouse\";\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport type { GameMenu } from \"@/gui/GameMenu\";\nimport { GUIControl } from \"@/gui/GUIControl\";\nimport type { GUIControlEvent } from \"@/gui/GUIControlEvent\";\nimport type { GUIListBox } from \"@/gui/GUIListBox\";\nimport { TextureLoader } from \"@/loaders\";\nimport { ResolutionManager } from \"@/managers/ResolutionManager\";\nimport type { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * GUIScrollBar class.\n * \n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n * \n * @file GUIScrollBar.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GUIScrollBar extends GUIControl{\n  _dir: GFFStruct | undefined;\n  arrowTex: THREE.Texture;\n  upArrowGeometry: THREE.PlaneGeometry;\n  upArrowMaterial: THREE.MeshBasicMaterial;\n  scrollPos: number;\n  scrollMax: number;\n  mouseOffset: { x: number; y: number; };\n  upArrow: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;\n  downArrowGeometry: THREE.PlaneGeometry;\n  downArrowMaterial: THREE.MeshBasicMaterial;\n  downArrow: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;\n  _thumb: GFFStruct;\n  geometry: THREE.PlaneGeometry;\n  thumbMaterial: THREE.MeshBasicMaterial;\n  thumb: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;\n  inner_box: THREE.Box2 | undefined;\n\n  arrowSize: number = 16;\n\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\n    super(menu, control, parent, scale);\n    this.objectType |= GUIControlTypeMask.GUIScrollBar;\n\n    this.scrollPos = 0;\n    this.scrollMax = 1;\n    this.mouseOffset = {x: 0, y: 0};\n    this.arrowSize = this.extent.width;\n\n    this.extent.height -= (this.arrowSize + this.border.dimension) * 2;\n\n    this.arrowTex = undefined;\n\n    if(this.control.hasField('DIR')){\n      this._dir = this.control.getFieldByLabel('DIR')?.getChildStructs()[0];\n      if(this._dir?.hasField('IMAGE')){\n        TextureLoader.tpcLoader.fetch(this._dir.getFieldByLabel('IMAGE')?.getValue()).then((texture: OdysseyTexture) => {\n          this.arrowTex = texture;\n          \n          //Up Arrow\n          this.upArrowGeometry = new THREE.PlaneGeometry( 1, 1, 1 );\n          this.upArrowMaterial = new THREE.MeshBasicMaterial( {color: new THREE.Color(0xFFFFFF), map: this.arrowTex, side: THREE.DoubleSide} );\n          this.upArrow = new THREE.Mesh( this.upArrowGeometry, this.upArrowMaterial );\n\n          this.widget.add(this.upArrow);\n          this.upArrow.name = 'SCROLLBAR up arrow';\n          this.upArrow.scale.x = this.arrowSize;\n          this.upArrow.scale.y = this.arrowSize;\n          this.upArrow.position.z = 5;\n\n          this.upArrow.position.y = this.extent.height/2 + this.arrowSize/2;\n          this.upArrow.userData.worldPosition = new THREE.Vector3();\n\n          this.upArrowMaterial.transparent = true;\n          this.upArrowMaterial.needsUpdate = true;\n\n          let parentPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3());\n\n          this.upArrow.userData.updateBox = () => {\n            this.upArrow.getWorldPosition(this.upArrow.userData.worldPosition);\n            this.upArrow.userData.box = new THREE.Box2(\n              new THREE.Vector2(\n                -this.extent.width/2,\n                -this.extent.width/2\n              ),\n              new THREE.Vector2(\n                this.extent.width/2,\n                this.extent.width/2\n              )\n            );\n            this.upArrow.userData.box.translate(this.upArrow.userData.worldPosition);\n          };\n          this.upArrow.userData.updateBox();\n\n          //Down Arrow\n          this.downArrowGeometry = new THREE.PlaneGeometry( 1, 1, 1 );\n          this.downArrowMaterial = new THREE.MeshBasicMaterial( {color: new THREE.Color(0xFFFFFF), map: this.arrowTex, side: THREE.DoubleSide} );\n          this.downArrow = new THREE.Mesh( this.downArrowGeometry, this.downArrowMaterial );\n\n          this.widget.add(this.downArrow);\n          this.downArrow.name = 'SCROLLBAR up arrow';\n          this.downArrow.scale.x = this.arrowSize;\n          this.downArrow.scale.y = this.arrowSize;\n          this.downArrow.position.z = 5;\n          this.downArrow.position.y = -(this.extent.height/2 + this.arrowSize/2);\n          this.downArrow.rotation.z = Math.PI;\n          this.downArrow.userData.worldPosition = new THREE.Vector3();\n\n          parentPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3());\n\n          this.downArrowMaterial.transparent = true;\n          this.downArrowMaterial.needsUpdate = true;\n\n          this.downArrow.userData.updateBox = () => {\n            this.downArrow.getWorldPosition(this.downArrow.userData.worldPosition);\n            this.downArrow.userData.box = new THREE.Box2(\n              new THREE.Vector2(\n                -this.extent.width/2,\n                -this.extent.width/2\n              ),\n              new THREE.Vector2(\n                this.extent.width/2,\n                this.extent.width/2\n              )\n            );\n            this.downArrow.userData.box.translate(this.downArrow.userData.worldPosition)\n          };\n          this.downArrow.userData.updateBox();\n\n          this.upArrow.userData.onClick = (_e: GUIControlEvent) => {\n            this.scrollUp();\n          };\n\n          this.downArrow.userData.onClick = (_e: GUIControlEvent) => {\n            this.scrollDown();\n          };\n\n        });\n      }\n    }\n\n    if(this.control.hasField('THUMB')){\n      this._thumb = this.control.getFieldByLabel('THUMB').getChildStructs()[0];\n      this.geometry = new THREE.PlaneGeometry( 1, 1, 1 );\n      this.thumbMaterial = new THREE.MeshBasicMaterial( {color: new THREE.Color(0xFFFFFF), side: THREE.DoubleSide} );\n      this.thumb = new THREE.Mesh( this.geometry, this.thumbMaterial );\n\n      this.widget.add(this.thumb);\n      this.thumb.name = 'SCROLLBAR thumb';\n      this.thumb.scale.x = this.extent.width/2;\n      this.thumb.scale.y = this.extent.height/2;\n      this.thumb.position.z = 5;\n\n      const parentPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3());\n\n      this.thumb.userData.box = new THREE.Box2(\n        new THREE.Vector2(\n          (parentPos.x - this.extent.width/2),\n          (parentPos.y - this.extent.height/2)\n        ),\n        new THREE.Vector2(\n          (parentPos.x + this.extent.width/2),\n          (parentPos.y + this.extent.height/2)\n        )\n      )\n\n      this.thumb.userData.onClick = (e: GUIControlEvent) => {\n        this.processEventListener('click', [e]);\n      };\n\n      this.thumb.userData.onMouseMove = (e: GUIControlEvent) =>{\n        this.processEventListener('mouseMove', [e]);\n      }\n\n      this.thumb.userData.onMouseDown = (e: GUIControlEvent) => {\n        this.processEventListener('mouseDown', [e]);\n      };\n\n      this.thumb.userData.onMouseUp = (e: GUIControlEvent) => {\n        this.processEventListener('mouseUp', [e]);\n      };\n\n      this.thumb.userData.onHover = (e: GUIControlEvent) => {\n        this.processEventListener('hover', [e]);\n      };\n\n      this.thumb.userData.getControl = (_e: GUIControlEvent) => {\n        return this;\n      };\n\n      // this.thumb.click = (e: GUIControlEvent) => {\n      //   log.info('scroll thumb')\n      // };\n\n      if(this._thumb.hasField('IMAGE')){\n        TextureLoader.enQueue(this._thumb.getFieldByLabel('IMAGE').getValue(), this.thumbMaterial, TextureType.TEXTURE);\n        TextureLoader.LoadQueue();\n      }\n    }\n\n    this.addEventListener('mouseMove', () => {\n      //if(this.inner_box.containsPoint(Mouse.positionUI)){\n        this.mouseInside();\n      //}\n    });\n\n    this.addEventListener('click', () =>{\n      const mouseX = Mouse.positionViewport.x - (ResolutionManager.getViewportWidthScaled() / 2);\n      const mouseY = Mouse.positionViewport.y - (ResolutionManager.getViewportHeightScaled() / 2);\n\n      const scrollTop = ( this.thumb.position.y + (this.thumb.scale.y / 2) ) + mouseY;\n      this.mouseOffset.y = scrollTop;\n      if(this.upArrow.userData.box.containsPoint(Mouse.positionUI)){\n        this.list.scrollUp();\n      }else if(this.downArrow.userData.box.containsPoint(Mouse.positionUI)){\n        this.list.scrollDown();\n      }else if(this.inner_box?.containsPoint(Mouse.positionUI)){\n        this.mouseInside();\n      }\n    })\n\n    this.addEventListener('mouseDown', (e) => {\n      e.stopPropagation();\n      const mouseX = Mouse.positionViewport.x - (ResolutionManager.getViewportWidthScaled() / 2);\n      const mouseY = Mouse.positionViewport.y - (ResolutionManager.getViewportHeightScaled() / 2);\n      const scrollTop = ( this.thumb.position.y + (this.thumb.scale.y / 2) ) + mouseY;\n      this.mouseOffset.y = scrollTop;\n      this.upArrow.userData.updateBox();\n      this.downArrow.userData.updateBox();\n    });\n\n    this.addEventListener('mouseUp', () => {\n      const mouseX = Mouse.positionViewport.x - (ResolutionManager.getViewportWidthScaled() / 2);\n      const mouseY = Mouse.positionViewport.y - (ResolutionManager.getViewportHeightScaled() / 2);\n      //let scrollTop = ( this.thumb.position.y + (this.thumb.scale.y / 2) ) + mouseY;\n      //this.mouseOffset.y = scrollTop;\n      //log.info('GUIScrollBar', 'blah');\n      /*if(this.upArrow.box.containsPoint(Mouse.Mouse.positionUI)){\n        log.info('GUIScrollBar', 'up');\n        this.list.scrollUp();\n      }else if(this.downArrow.box.containsPoint(Mouse.Mouse.positionUI)){\n        log.info('GUIScrollBar', 'down');\n        this.list.scrollDown();\n      }else */if(this.inner_box?.containsPoint(Mouse.positionUI)){\n        //log.info('GUIScrollBar', 'scroll');\n        this.mouseInside();\n      }\n    });\n\n  }\n  \n  scrollUp() {\n    // throw new Error(\"Method not implemented.\");\n  }\n  scrollDown() {\n    // throw new Error(\"Method not implemented.\");\n  }\n\n  mouseInside(){\n\n    const mouseX = Mouse.positionViewport.x - (ResolutionManager.getViewportWidthScaled() / 2);\n    const mouseY = Mouse.positionViewport.y - (ResolutionManager.getViewportHeightScaled() / 2);\n    //log.info(mouseY);\n    //if(this.inner_box.containsPoint({x: mouseX, y: mouseY})){\n\n      const centerPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3());\n\n      const scrollBarHeight = this.extent.height;\n\n      this.thumb.position.y = -(mouseY) || 0;\n\n      if(this.thumb.position.y < -((scrollBarHeight - this.thumb.scale.y))/2 ){\n        this.thumb.position.y = -((scrollBarHeight - this.thumb.scale.y))/2 || 0\n      }\n\n      if(this.thumb.position.y > ((scrollBarHeight - this.thumb.scale.y))/2 ){\n        this.thumb.position.y = ((scrollBarHeight - this.thumb.scale.y))/2 || 0\n      }\n\n      const maxScroll = ((scrollBarHeight - this.thumb.scale.y)/2);\n      scrollY = (this.thumb.position.y + maxScroll) / (maxScroll*2);\n      this.scrollPos = 1.0 - scrollY;\n      this.update();\n\n    //}\n\n  }\n\n  setList(list: GUIListBox){\n    this.list = list;\n    this.calculatePosition();\n    this.update();\n  }\n\n  update(){\n\n    if(this.list){\n\n      const contentHeight = this.list.getContentHeight();\n\n      let scaleY = this.list.extent.height / contentHeight;\n      if(scaleY > 1){\n        scaleY = 1;\n        this.thumb.scale.y = this.extent.height * scaleY;\n      }else{\n        if(scaleY < 0.01)\n          scaleY = 0.01;\n        this.thumb.scale.y = this.extent.height * scaleY;\n      }\n\n      let offsetY = contentHeight*this.scrollPos;\n      const offsetYMax = contentHeight - this.extent.height;\n      const nodeHeight = this.list.getNodeHeight();\n      if(offsetY > offsetYMax){\n        offsetY = offsetYMax;//Math.floor(offsetYMax / nodeHeight) * nodeHeight;\n      }\n\n      //log.info((Math.floor(offsetY / nodeHeight)) * nodeHeight);\n      /*offsetY = (Math.ceil(offsetY / nodeHeight)) * nodeHeight;\n\n      for(let i = 0; i < this.list.itemGroup.children.length; i++){\n        let node = this.list.itemGroup.children[i];\n        let control = node.control;\n        node.position.y = control.startY + offsetY;\n        control.calculateBox();\n        //node.box.translate(new THREE.Vector2( offsetY))\n      }\n      this.list.cullOffscreen();*/\n\n      this.list.scroll = Math.floor(this.list.maxScroll * this.scrollPos) || 0;\n      this.list.updateList();\n\n      const scrollThumbOffset = (this.extent.height - this.thumb.scale.y) - (this.border.dimension*2);\n      this.thumb.position.y = scrollThumbOffset/2 - (scrollThumbOffset * this.list.scroll / this.list.maxScroll) || 0;\n\n    }\n\n  }\n\n  calculatePosition(){\n    let parentExtent = { width: this.menu.width, height: this.menu.height };\n    let parentOffsetX, parentOffsetY;\n    if(!(this.parent.widget instanceof THREE.Scene)){\n      parentExtent = this.menu.tGuiPanel.extent;\n      //log.info(this.parent)\n      //parentOffsetX = this.menu.tGuiPanel.widget.getWorldPosition(new THREE.Vector3()).x + this.offset.x;\n      //parentOffsetY = this.menu.tGuiPanel.widget.getWorldPosition(new THREE.Vector3()).y + this.offset.y;\n      parentOffsetX = this.menu.tGuiPanel.worldPosition.x + this.offset.x;\n      parentOffsetY = this.menu.tGuiPanel.worldPosition.y + this.offset.y;\n\n    }else{\n      parentOffsetX = parentOffsetY = 0;\n    }\n\n    // let wRatio = ResolutionManager.getViewportWidth() / this.menu.tGuiPanel.extent.width;\n    // let hRatio = ResolutionManager.getViewportHeight() / this.menu.tGuiPanel.extent.height;\n\n    if(this.list){\n      if(this.list.isScrollBarLeft()){\n        this.anchorOffset.set(-(this.list.extent.width/2 - this.extent.width/2 - this.list.border.inneroffset/2), 0);\n      }else{\n        this.anchorOffset.set((this.list.extent.width/2 - this.extent.width/2 - this.list.border.inneroffset/2), 0);\n      }      \n    }else{\n      this.anchorOffset.set(0, 0);\n    }\n\n    this.widget.position.x = this.anchorOffset.x;\n    this.widget.position.y = this.anchorOffset.y;\n\n    let worldPosition = new THREE.Vector3();\n    try{\n      worldPosition = this.parent.widget.position.clone();\n    }catch(e){\n      log.error(e);\n    }\n    const parentPos = this.worldPosition; //this.widget.getWorldPosition(new THREE.Vector3());\n    //log.info('worldPos', worldPosition);\n    this.box = new THREE.Box2(\n      new THREE.Vector2(\n        this.anchorOffset.x - this.extent.width/2 + worldPosition.x,\n        this.anchorOffset.y - (this.extent.height + 64)/2 + worldPosition.y\n      ),\n      new THREE.Vector2(\n        this.anchorOffset.x + this.extent.width/2 + worldPosition.x,\n        this.anchorOffset.y + (this.extent.height + 64)/2 + worldPosition.y\n      )\n    );\n\n    this.inner_box = new THREE.Box2(\n      new THREE.Vector2(\n        this.anchorOffset.x - this.extent.width/2 + worldPosition.x,\n        this.anchorOffset.y - (this.extent.height)/2 + worldPosition.y\n      ),\n      new THREE.Vector2(\n        this.anchorOffset.x + this.extent.width/2 + worldPosition.x,\n        this.anchorOffset.y + (this.extent.height)/2 + worldPosition.y\n      )\n    );\n    if(this.thumb){\n      this.thumb.userData.box = new THREE.Box2(\n        new THREE.Vector2(\n          (parentPos.x - this.extent.width/2),\n          (parentPos.y - this.extent.height/2)\n        ),\n        new THREE.Vector2(\n          (parentPos.x + this.extent.width/2),\n          (parentPos.y + this.extent.height/2)\n        )\n      );\n    }\n\n    if(this.upArrow){\n      this.upArrow.userData.updateBox();\n    }\n\n    if(this.downArrow){\n      this.downArrow.userData.updateBox();\n    }\n\n  }\n\n  directionalNavigate(direction = ''){\n    if(this.list){\n      this.list.directionalNavigate(direction);\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GUISlider.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":28,"column":19,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":28,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a `Function` typed value.","line":203,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":203,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a `Function` typed value.","line":232,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":232,"endColumn":26}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { Mouse } from \"@/controls/Mouse\";\r\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\r\nimport { GUISliderDirection } from \"@/enums/gui/GUISliderDirection\";\r\nimport { TextureType } from \"@/enums/loaders/TextureType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport type { GameMenu } from \"@/gui/GameMenu\";\r\nimport { GUIControl } from \"@/gui/GUIControl\";\r\nimport { TextureLoader } from \"@/loaders\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\r\n/**\r\n * GUISlider class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUISlider.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUISlider extends GUIControl{\r\n\r\n  onValueChanged: Function;\r\n\r\n  thumbStruct: GFFStruct;\r\n  scrollPos: number;\r\n  scrollMax: number;\r\n  mouseOffset: { x: number; y: number; };\r\n  value: number;\r\n  thumb: { texture: string; material: THREE.SpriteMaterial; mesh: THREE.Sprite; geometry: THREE.BufferGeometry; width: number; height: number; };\r\n  direction: GUISliderDirection = GUISliderDirection.Horizontal;\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n    this.objectType |= GUIControlTypeMask.GUISlider;\r\n\r\n    this.scrollPos = 0.5;\r\n    this.scrollMax = 1;\r\n    this.mouseOffset = {x: 0, y: 0};\r\n    this.value = 0.50;\r\n\r\n    this.thumb = {\r\n      texture: '',\r\n      material: undefined,\r\n      mesh: undefined,\r\n      geometry: undefined,\r\n      width: 8,\r\n      height: 32,\r\n    };\r\n\r\n    this.thumb.material = new THREE.SpriteMaterial( { map: null, color: new THREE.Color(0xFFFFFF) } );\r\n    this.thumb.material.transparent = true;\r\n    this.thumb.mesh = new THREE.Sprite( this.thumb.material );\r\n    this.widget.add(this.thumb.mesh);\r\n\r\n    this.thumb.mesh.addEventListener('click', (e) => {\r\n      log.info('hello');\r\n      this.mouseInside();\r\n    });\r\n\r\n    if(this.control.hasField('THUMB')){\r\n      this.thumbStruct = this.control.getFieldByLabel('THUMB').getChildStructs()[0];\r\n\r\n      this.thumb.mesh.position.z = 2;\r\n      this.thumb.mesh.name = 'SCROLLBAR thumb';\r\n      this.thumb.mesh.scale.x = this.thumb.width;\r\n      this.thumb.mesh.scale.y = this.thumb.height;\r\n\r\n      const parentPos = this.widget.getWorldPosition(new THREE.Vector3());\r\n\r\n      this.thumb.mesh.userData.box = new THREE.Box2(\r\n        new THREE.Vector2(\r\n          (parentPos.x - this.extent.width/2),\r\n          (parentPos.y - this.extent.height/2)\r\n        ),\r\n        new THREE.Vector2(\r\n          (parentPos.x + this.extent.width/2),\r\n          (parentPos.y + this.extent.height/2)\r\n        )\r\n      )\r\n\r\n      if(this.thumbStruct.hasField('IMAGE')){\r\n        TextureLoader.enQueue(this.thumbStruct.getFieldByLabel('IMAGE').getValue(), this.thumb.material, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n          this.thumb.material.transparent = false;\r\n          this.thumb.material.alphaTest = 0.5;\r\n          this.thumb.material.needsUpdate = true;\r\n          if(texture.header){\r\n            this.thumb.width = texture.header.width;\r\n            this.thumb.height = texture.header.height;\r\n            this.thumb.mesh.scale.set(texture.header.width, texture.header.height, 1);\r\n          }\r\n        });\r\n        TextureLoader.LoadQueue();\r\n      }\r\n    }\r\n\r\n    this.addEventListener('mouseMove', () => {\r\n      this.mouseInside();\r\n    })\r\n\r\n    this.addEventListener('click', (e) =>{\r\n      e.stopPropagation();\r\n      const mouseX = Mouse.positionViewport.x - (GameState.ResolutionManager.getViewportWidthScaled() / 2);\r\n      const mouseY = Mouse.positionViewport.y - (GameState.ResolutionManager.getViewportHeightScaled() / 2);\r\n      const scrollLeft = ( this.thumb.mesh.position.x + (this.thumb.mesh.scale.x / 2) ) + mouseX;\r\n      const scrollTop = ( this.thumb.mesh.position.y + (this.thumb.mesh.scale.y / 2) ) + mouseY;\r\n\r\n      this.mouseOffset.x = scrollLeft;\r\n      this.mouseOffset.y = scrollTop;\r\n\r\n      this.mouseInside();\r\n    });\r\n\r\n    this.addEventListener('mouseDown', (e) => {\r\n      e.stopPropagation();\r\n      const mouseX = Mouse.positionViewport.x - (GameState.ResolutionManager.getViewportWidthScaled() / 2);\r\n      const mouseY = Mouse.positionViewport.y - (GameState.ResolutionManager.getViewportHeightScaled() / 2);\r\n      const scrollLeft = ( this.thumb.mesh.position.x + (this.thumb.mesh.scale.x / 2) ) + mouseX;\r\n      const scrollTop = ( this.thumb.mesh.position.y + (this.thumb.mesh.scale.y / 2) ) + mouseY;\r\n\r\n      this.mouseOffset.x = scrollLeft;\r\n      this.mouseOffset.y = scrollTop;\r\n    });\r\n\r\n    this.addEventListener('mouseUp', () => {\r\n      this.mouseInside();\r\n    });\r\n\r\n    this.setValue(this.value);\r\n\r\n  }\r\n\r\n  onINIPropertyAttached(){\r\n    if(this.iniProperty)\r\n      this.setValue(GameState.iniConfig.getProperty(this.iniProperty) * .01);\r\n  }\r\n\r\n  mouseInside(){\r\n    if(this.disableSelection) return;\r\n\r\n    // const mouseX = Mouse.positionViewport.x - (GameState.ResolutionManager.getViewportWidthScaled() / 2);\r\n    const mouseY = -(Mouse.positionViewport.y - (GameState.ResolutionManager.getViewportHeightScaled() / 2));\r\n    const scrollBarWidth = this.extent.width;\r\n    const scrollBarHeight = this.extent.height;\r\n\r\n    let value = this.value;\r\n    let valueChanged = false;\r\n\r\n    if(this.direction == GUISliderDirection.Horizontal){\r\n      const maxWidth = (this.extent.width - this.thumb.width);\r\n      const minX = this.widget.position.x - maxWidth/2;\r\n      const maxX = this.widget.position.x + maxWidth/2;\r\n\r\n      let mouseX = Mouse.positionUI.x;\r\n\r\n      if(mouseX < minX){\r\n        mouseX = minX;\r\n      }\r\n\r\n      if(mouseX > maxX){\r\n        mouseX = maxX\r\n      }\r\n\r\n      const scrollX = ((mouseX - minX) / (maxX - minX));\r\n      this.thumb.mesh.position.x = maxWidth * (scrollX - 0.5);\r\n      this.thumb.mesh.position.y = 0;\r\n      valueChanged = (scrollX != this.value);\r\n      value = scrollX;\r\n    }else{\r\n      const maxHeight = (this.extent.height - this.thumb.height);\r\n      const minY = this.widget.position.y - maxHeight/2;\r\n      const maxY = this.widget.position.y + maxHeight/2;\r\n\r\n      let mouseY = Mouse.positionUI.y;\r\n\r\n      if(mouseY < minY){\r\n        mouseY = minY;\r\n      }\r\n\r\n      if(mouseY > maxY){\r\n        mouseY = maxY\r\n      }\r\n\r\n      const scrollY = ((mouseY - minY) / (maxY - minY));\r\n      this.thumb.mesh.position.x = 0;\r\n      this.thumb.mesh.position.y = maxHeight * (scrollY - 0.5);\r\n      valueChanged = (scrollY != this.value);\r\n      value = scrollY;\r\n    }\r\n\r\n    this.value = value;\r\n\r\n    if(this.iniProperty){\r\n      GameState.iniConfig.setProperty(this.iniProperty, (this.value * 100) | 0);\r\n    }\r\n\r\n    if(valueChanged && typeof this.onValueChanged === 'function')\r\n      this.onValueChanged(this.value);\r\n\r\n  }\r\n\r\n  setValue(value = 0){\r\n\r\n    this.value = value;\r\n\r\n    if(this.direction == GUISliderDirection.Horizontal){\r\n      const maxWidth = (this.extent.width - this.thumb.width);\r\n      const threshold = maxWidth/2;\r\n      const thumbX = (maxWidth * value) - threshold;\r\n\r\n      this.thumb.mesh.position.x = thumbX;\r\n      this.thumb.mesh.position.y = 0;\r\n    }else{\r\n      const maxHeight = (this.extent.height - this.thumb.height);\r\n      const threshold = maxHeight/2;\r\n      const thumbY = (maxHeight * value) - threshold;\r\n\r\n      this.thumb.mesh.position.y = thumbY;\r\n      this.thumb.mesh.position.x = 0;\r\n    }\r\n\r\n    if(this.iniProperty){\r\n      GameState.iniConfig.setProperty(this.iniProperty, (this.value * 100) | 0);\r\n    }\r\n    \r\n    if(typeof this.onValueChanged === 'function')\r\n      this.onValueChanged(this.value);\r\n\r\n  }\r\n\r\n  setVertical(){\r\n    this.direction = GUISliderDirection.Vertical;\r\n  }\r\n\r\n  setHorizontal(){\r\n    this.direction = GUISliderDirection.Horizontal;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\GameMenu.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":183,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":183,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on an `any` value.","line":183,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":183,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":290,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":290,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":290,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":290,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":296,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":296,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":296,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":296,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":507,"column":55,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":507,"endColumn":57}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { KeyMapper } from \"@/controls\";\nimport { Mouse } from \"@/controls/Mouse\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { GUIControlType } from \"@/enums/gui/GUIControlType\";\nimport { GUIControlTypeMask } from \"@/enums/gui/GUIControlTypeMask\";\nimport { GameState } from \"@/GameState\";\nimport { GUIControl } from \"@/gui/GUIControl\";\nimport { GUIControlFactory } from \"@/gui/GUIControlFactory\";\nimport type { GUIProtoItem } from \"@/gui/GUIProtoItem\";\nimport { ResourceLoader, TextureLoader } from \"@/loaders\";\nimport type { MenuManager } from \"@/managers/MenuManager\";\nimport { ResolutionManager } from \"@/managers/ResolutionManager\";\nimport { ShaderManager } from \"@/managers/ShaderManager\"\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n * GameMenu class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file GameMenu.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class GameMenu {\n  gui_resref: string;\n  menuGFF: GFFObject;\n  manager: typeof MenuManager;\n  factory: typeof GUIControlFactory = GUIControlFactory;\n\n  //This is for MenuTop\n  childMenu: GameMenu = undefined;\n\n  tGuiPanel: GUIControl;\n  _button_a: GUIControl = undefined;\n  _button_b: GUIControl = undefined;\n  _button_x: GUIControl = undefined;\n  _button_y: GUIControl = undefined;\n  selectedControl: GUIControl;\n\n  //Used for hoverstate tracking\n  activeControls: GUIControl[] = [];\n\n  bVisible: boolean = false;\n  scale: number = 1;\n  enablePositionScaling: boolean = false;\n  isOverlayGUI: boolean = false;\n  textNeedsUpdate: boolean = false;\n\n  userCanClose: boolean = true;\n  width: number = 640;\n  height: number = 480;\n\n  /**\n   * Panel bit_flags for layout and centering.\n   *\n   * Bit layout: visible (bit 7), initial (bit 2), loaded (bit 1), hit-test (bit 0).\n   * Centering: bit 3 = center on screen; bits 5/6 = horizontal/vertical offset relative to 640x480.\n   * KotOR.js default adds centering for arbitrary resolutions.\n   */\n  panelBitFlags: number = 0x8F;\n\n  background: string;\n  backgroundSprite: THREE.Mesh;\n  backgroundMaterial: THREE.ShaderMaterial;\n\n  voidFill: boolean = false;\n  backgroundVoidSprite: THREE.Mesh;\n  backgroundVoidMaterial: THREE.ShaderMaterial;\n\n  engineMode: EngineMode = EngineMode.GUI;\n\n  eventListenters: Map<string, ((...args: (string | number | boolean | object)[]) => void)[]> = new Map();\n  context: typeof GameState = GameState;\n\n  constructor() {\n    this._button_a = undefined;\n    this._button_b = undefined;\n    this._button_x = undefined;\n    this._button_y = undefined;\n  }\n\n  async load(): Promise<GameMenu> {\n    GameState.PerformanceMonitor.start(this.constructor.name + '.load');\n    await this.loadMenu();\n    GameState.PerformanceMonitor.stop(this.constructor.name + '.load');\n    return this;\n  }\n\n  async loadMenu(): Promise<GameMenu> {\n    this.tGuiPanel = null;\n\n    //mainmenu16x12\n    await this.loadBackground();\n    try {\n      const buffer = await ResourceLoader.loadResource(ResourceTypes.gui, this.gui_resref);\n      this.menuGFF = new GFFObject(buffer);\n      await this.buildMenu(this.menuGFF);\n    } catch (e) {\n      log.error(e);\n    }\n    return this;\n  }\n\n  async buildMenu(gff: GFFObject) {\n    GameState.PerformanceMonitor.start(this.constructor.name + '.buildMenu');\n    this.tGuiPanel = new GUIControl(this, gff.RootNode, undefined, this.enablePositionScaling);\n    this.tGuiPanel.allowClick = false;\n\n    const extent = this.tGuiPanel.extent;\n    this.width = extent.width;\n    this.height = extent.height;\n\n    const panelControl = this.tGuiPanel.createControl();\n\n    if (this.voidFill) {\n      this.tGuiPanel.widget.add(this.backgroundVoidSprite);\n    }\n\n    if (this.backgroundSprite) {\n      this.tGuiPanel.widget.add(this.backgroundSprite);\n    }\n\n    // Root panel position is set by calculatePosition() during createControl().\n    // Do NOT override it here  that would cause an inconsistency between initial\n    // load and resize (recalculatePosition sets the correct position on resize).\n\n    //This auto assigns references for the controls to the menu object.\n    //It is no longer required to use this.getControlByName('CONTROL_NAME') when initializing a menu\n    //You can just use this.CONTROL_NAME\n    this.assignChildControlsToMenu(this.tGuiPanel);\n\n    await this.menuControlInitializer();\n\n    await TextureLoader.LoadQueue();\n    GameState.PerformanceMonitor.stop(this.constructor.name + '.buildMenu');\n    return this;\n  }\n\n  async menuControlInitializer(_skipInit: boolean = false): Promise<void> {\n    return;\n  }\n\n  assignChildControlsToMenu(object: GUIControl) {\n    if (!object) { return; }\n\n    for (let i = 0, len = object.children.length; i < len; i++) {\n      const ctrl = object.children[i];\n      if (!!ctrl && !isNaN(parseInt(ctrl.name[0]))) ctrl.name = '_' + ctrl.name;\n      (this as GameMenu & Record<string, GUIControl | undefined>)[ctrl.name] = ctrl;\n      this.assignChildControlsToMenu(ctrl);\n    }\n  }\n\n  async loadBackground() {\n    /**\n     * Background black void to fill the screen behind the menu\n     */\n    if (this.voidFill) {\n      const geometry = new THREE.PlaneGeometry(1, 1, 1);\n      this.backgroundVoidMaterial = new THREE.ShaderMaterial({\n        uniforms: THREE.UniformsUtils.merge([\n          ShaderManager.Shaders.get('void-gui').getUniforms()\n        ]),\n        vertexShader: ShaderManager.Shaders.get('void-gui').getVertex(),\n        fragmentShader: ShaderManager.Shaders.get('void-gui').getFragment(),\n      })\n      this.backgroundVoidSprite = new THREE.Mesh(geometry, this.backgroundVoidMaterial);\n      this.backgroundVoidSprite.position.z = -6;\n      this.backgroundVoidSprite.renderOrder = -6;\n\n      // this.backgroundVoidMaterial.uniforms.u_color.value.setRGB(0.0, 0.658824, 0.980392);\n      this.backgroundVoidMaterial.uniforms.u_color.value.setRGB(0.10196078568697, 0.69803923368454, 0.549019634723663);\n      // this.backgroundVoidMaterial.uniforms.u_color.value.setRGB(1.0, 1.0, 1.0);\n    }\n\n    /**\n     * Background texture of the menu\n     */\n    if (this.background) {\n      const texture: OdysseyTexture = await TextureLoader.tpcLoader.fetch(this.background);\n      const geometry = new THREE.PlaneGeometry(1600, 1200, 1);\n      this.backgroundMaterial = new THREE.ShaderMaterial({\n        uniforms: THREE.UniformsUtils.merge([\n          ShaderManager.Shaders.get('background-gui').getUniforms()\n        ]),\n        vertexShader: ShaderManager.Shaders.get('background-gui').getVertex(),\n        fragmentShader: ShaderManager.Shaders.get('background-gui').getFragment(),\n      });\n      this.backgroundMaterial.transparent = true;\n      this.backgroundSprite = new THREE.Mesh(geometry, this.backgroundMaterial);\n      this.backgroundSprite.position.z = -5;\n      this.backgroundSprite.renderOrder = -5;\n      this.backgroundMaterial.uniforms.map.value = texture;\n    }\n  }\n\n  async loadTexture(resRef: string): Promise<OdysseyTexture> {\n    return await TextureLoader.Load(resRef);\n  }\n\n  /**\n   * Get a control by its GFF/layout name (e.g. BTN_QUIT, LBL_TITLE).\n   * Controls are assigned to the menu instance during buildMenu.\n   */\n  getControlByName(name: string): GUIControl | undefined {\n    const ctrl = (this as GameMenu & Record<string, GUIControl | undefined>)[name];\n    if (ctrl === undefined) {\n      log.error('getControlByName', 'Control not found', name);\n      return undefined;\n    }\n    return ctrl as GUIControl;\n  }\n\n  hide(): void {\n    this.bVisible = false;\n    if (this.tGuiPanel?.getControl()) {\n      GameState.scene_gui.remove(this.tGuiPanel.getControl());\n    }\n    if (this.childMenu instanceof GameMenu) {\n      this.childMenu.hide();\n    }\n  }\n\n  show(): void {\n    if (!this.tGuiPanel?.getControl()) {\n      return;\n    }\n    if (!this.isOverlayGUI) {\n      GameState.SetEngineMode(this.engineMode);\n    }\n    this.bVisible = true;\n    GameState.scene_gui.add(this.tGuiPanel.getControl());\n    if (this.childMenu instanceof GameMenu) {\n      this.childMenu.show();\n      this.childMenu.tGuiPanel?.updateBoundsRecursive?.();\n    }\n  }\n\n  /**\n   * Close this menu: hide it and remove it from the manager stack.\n   * Restores the menu below (if any) as current.\n   */\n  close(): void {\n    this.hide();\n    if (this.manager?.Remove) {\n      this.manager.Remove(this);\n    }\n  }\n\n  /**\n   * Open this menu: add it to the manager stack and show it.\n   */\n  open(): void {\n    if (this.manager?.Add) {\n      this.manager.Add(this);\n    }\n    this.show();\n  }\n\n  /**\n   * Remove this menu from the manager stack and hide it.\n   * Same effect as close(); provided for API clarity (e.g. \"remove\" from stack).\n   */\n  remove(): void {\n    this.close();\n  }\n\n  isVisible() {\n    return this.bVisible;\n  }\n\n  update(delta: number = 0) {\n    //Only update if the Menu is visible\n    if (!this.bVisible)\n      return;\n\n    if (this.voidFill) {\n      this.backgroundVoidMaterial.uniforms.u_time.value = this.context.deltaTimeFixed;\n      this.backgroundVoidMaterial.uniforms.u_resolution.value.set(ResolutionManager.getViewportWidth(), ResolutionManager.getViewportHeight());\n      this.backgroundVoidSprite.scale.set(ResolutionManager.getViewportWidth(), ResolutionManager.getViewportHeight(), 1);\n    }\n\n    if (this.background) {\n      this.backgroundMaterial.uniforms.u_time.value = this.context.deltaTimeFixed;\n      this.backgroundMaterial.uniforms.u_resolution.value.set(1600, 1200);\n    }\n\n    if (this.activeControls.length) {\n      for (let i = this.activeControls.length; i--;) {\n        const control = this.activeControls[i];\n        if (!control.box.containsPoint(Mouse.positionUI)) {\n          control.onHoverOut();\n          this.activeControls.splice(i, 1);\n        }\n      }\n    }\n\n    if (this.tGuiPanel && this.tGuiPanel.children) {\n      const len = this.tGuiPanel.children.length;\n      for (let i = 0; i < len; i++) {\n        this.tGuiPanel.children[i].update(delta);\n      }\n    }\n  }\n\n  recalculatePosition() {\n    try {\n      this.tGuiPanel.recalculate();\n    } catch (e) { log.error(e); }\n  }\n\n  setWidgetHoverActive(control: GUIControl, bActive: boolean = false) {\n\n    if (!BitWise.InstanceOfObject(control, GUIControlTypeMask.GUIControl))\n      return false;\n\n    if (BitWise.InstanceOfObject(control, GUIControlTypeMask.GUIProtoItem) && (\n      typeof (control as GUIProtoItem).list.GUIProtoItemClass !== 'undefined' &&\n      control.type !== GUIControlType.Label && control.type !== GUIControlType.ProtoItem\n    )) {\n      return false;\n    }\n\n    const idx = this.activeControls.indexOf(control);\n\n    if (bActive) {\n      if (idx == -1) {\n        this.activeControls.push(control);\n        if (control) {\n          control.onHoverIn();\n        }\n      }\n    } else {\n      if (idx > -1) {\n        if (control) {\n          control.onHoverOut();\n        }\n        this.activeControls.splice(idx, 1);\n      }\n    }\n\n  }\n\n  getActiveControls() {\n    let controls: GUIControl[] = [];\n    if (this.tGuiPanel) {\n      controls = this.tGuiPanel.getActiveControls();\n    }\n    if (this.childMenu) {\n      controls = controls.concat(this.childMenu.getActiveControls());\n    }\n    return controls;\n  }\n\n  setScale(scale = 1.0) {\n\n    this.scale = scale;\n    this.tGuiPanel.widget.scale.set(this.scale, this.scale, 1.0);\n\n    for (let i = 0; i < this.tGuiPanel.children.length; i++) {\n      if (this.tGuiPanel.children[i])\n        this.tGuiPanel.children[i].updateScale();\n    }\n\n  }\n\n  resize() {\n    if (this.tGuiPanel) {\n      this.recalculatePosition();\n    }\n  }\n\n  triggerControllerAPress() {\n    if (this._button_a) {\n      this._button_a.click();\n    } else if (this.manager.activeGUIElement) {\n      this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerBPress() {\n    if (this._button_b) {\n      this._button_b.click();\n    }\n  }\n\n  triggerControllerXPress() {\n    if (this._button_x) {\n      this._button_x.click();\n    }\n  }\n\n  triggerControllerYPress() {\n    if (this._button_y) {\n      this._button_y.click();\n    }\n  }\n\n  triggerControllerDUpPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerDDownPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerDLeftPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerDRightPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerBumperLPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerBumperRPress() {\n    if (this.manager.activeGUIElement) {\n      //this.manager.activeGUIElement.click();\n    }\n  }\n\n  triggerControllerLStickXPress(positive = false) {\n\n  }\n\n  triggerControllerLStickYPress(positive = false) {\n\n  }\n\n  triggerControllerRStickXPress(positive = false) {\n\n  }\n\n  triggerControllerRStickYPress(positive = false) {\n\n  }\n\n  addEventListener(name: string, callback: (...args: (string | number | boolean | object)[]) => void) {\n    if (typeof callback !== 'function') { return; }\n\n    name = name.toUpperCase().trim();\n    let listeners = this.eventListenters.get(name);\n    if (!Array.isArray(listeners)) {\n      listeners = [callback];\n      this.eventListenters.set(name, listeners);\n    } else if (listeners.indexOf(callback) == -1) {\n      listeners.push(callback);\n    }\n  }\n\n  removeEventListener(name: string, callback: (...args: (string | number | boolean | object)[]) => void) {\n    if (typeof callback !== 'function') { return; }\n\n    name = name.toUpperCase().trim();\n    const listeners = this.eventListenters.get(name);\n    if (Array.isArray(listeners)) {\n      const idx = listeners.indexOf(callback);\n      if (idx >= 0) { listeners.splice(idx, 1); }\n    }\n  }\n\n  triggerEventListener(name: string, ...args: Array<string | number | boolean | object>) {\n    name = name.toUpperCase().trim();\n    const listeners = this.eventListenters.get(name);\n    if (Array.isArray(listeners)) {\n      for (let i = 0; i < listeners.length; i++) {\n        listeners[i](...args);\n      }\n    }\n  }\n\n  gameStringParse(text: string) {\n    text = text.split('##')[0].replaceAll(/\\{.*\\}/ig, '').trim();\n    text = text.replace(/<FullName>/gm, GameState.PartyManager.ActualPlayerTemplate?.getFieldByLabel('FirstName')?.getValue());\n    text = text.replace(/<FirstName>/gm, GameState.PartyManager.ActualPlayerTemplate?.getFieldByLabel('FirstName')?.getValue());\n    text = text.replace(/<LastName>/gm, GameState.PartyManager.ActualPlayerTemplate?.getFieldByLabel('LastName')?.getValue());\n\n    KeyMapper.ACTIONS_ALL.forEach((keymap) => {\n      text = text.replace(keymap.tokenRegEx, keymap.character);\n    });\n\n    text = text.replace(/<CUSTOM(\\d+)>/gm, function (match, p1, offset, string) {\n      return GameState.module.getCustomToken(parseInt(p1));\n    });\n\n    return text;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\LBL_3DView.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":92,"column":5,"nodeType":"MemberExpression","messageId":"errorCall","endLine":92,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .diffuse on a type that cannot be resolved.","line":92,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":92,"endColumn":53}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { GameState } from \"@/GameState\";\r\nimport type { GUIControl } from \"@/gui/GUIControl\";\r\nimport type { LightManager } from \"@/managers\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\n\r\n\r\n/**\r\n * LBL_3DView class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file LBL_3DView.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class LBL_3DView {\r\n  width: number;\r\n  height: number;\r\n  visible: boolean;\r\n  scene: THREE.Scene;\r\n  camera: THREE.PerspectiveCamera;\r\n  texture: THREE.WebGLRenderTarget;\r\n  tDepth: THREE.WebGLRenderTarget;\r\n  clearColor: THREE.Color;\r\n  currentCamera: THREE.Camera;\r\n  globalLight: THREE.AmbientLight;\r\n  lightManager: LightManager = new GameState.LightManager();\r\n  emitters: Record<string, { tick: (delta: number) => void }> = {};\r\n  _emitters: Record<string, { tick: (delta: number) => void }> = {};\r\n  group: { \r\n    emitters: THREE.Group; \r\n    lights: THREE.Group; \r\n    light_helpers: THREE.Group; \r\n    shadow_lights: THREE.Group; \r\n    creatures: THREE.Group; \r\n  };\r\n  control: GUIControl | undefined;\r\n  frustumMat4: THREE.Matrix4;\r\n  viewportFrustum: THREE.Frustum;\r\n\r\n  constructor(width: number = 800, height: number = 600){\r\n\r\n    this.width = width;//window.innerWidth;\r\n    this.height = height;//window.innerHeight;\r\n    this.visible = false;\r\n    this.frustumMat4 = new THREE.Matrix4();\r\n    this.viewportFrustum = new THREE.Frustum();\r\n\r\n    this.scene = new THREE.Scene();\r\n    this.camera = new THREE.PerspectiveCamera( 22.5, this.width/this.height, 0.1, 15000 );\r\n    this.texture = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});\r\n\t\tthis.tDepth = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\r\n    this.clearColor = new THREE.Color(0x000000);\r\n\r\n    this.currentCamera = this.camera;\r\n\r\n    this.globalLight = new THREE.AmbientLight(0x7F7F7F);\r\n    this.globalLight.position.x = 0;\r\n    this.globalLight.position.y = 0;\r\n    this.globalLight.position.z = 0;\r\n    this.globalLight.intensity  = 1;\r\n\r\n    //this.scene.add(this.globalLight);\r\n    this.camera.up = new THREE.Vector3( 0, 0, 1 );\r\n    this.camera.updateProjectionMatrix();\r\n\r\n    this.emitters = {};\r\n    this._emitters = {};\r\n    this.group = {\r\n      emitters: new THREE.Group(),\r\n      lights: new THREE.Group(),\r\n      light_helpers: new THREE.Group(),\r\n      shadow_lights: new THREE.Group(),\r\n      creatures: new THREE.Group()\r\n    }\r\n\r\n    this.scene.add(this.group.emitters);\r\n    this.scene.add(this.group.lights);\r\n    this.scene.add(this.group.shadow_lights);\r\n    this.scene.add(this.group.creatures);\r\n\r\n    this.lightManager.init(this);\r\n  }\r\n\r\n  setControl(control: GUIControl){\r\n    this.control = control;\r\n    \r\n    this.control.setFillTexture(this.texture.texture);\r\n    // this.control.getFill().material.uniforms.map.value = this.texture.texture;\r\n    this.control.getFill().material.uniforms.diffuse.value.setHex(0xFFFFFF);\r\n  }\r\n\r\n  getCamera(){\r\n    return this.camera;\r\n  }\r\n\r\n  getTexture(){\r\n    return this.texture.texture;\r\n  }\r\n\r\n  addModel(model: THREE.Object3D){\r\n    if(model instanceof THREE.Object3D){\r\n      this.scene.add(model);\r\n    }\r\n  }\r\n\r\n  removeModel(model: THREE.Object3D){\r\n    if(model instanceof THREE.Object3D){\r\n      this.scene.remove(model);\r\n    }\r\n  }\r\n\r\n  setVisible(bVisible: boolean){\r\n    this.visible = bVisible;\r\n  }\r\n\r\n  setSize(width = 0, height = 0){\r\n    this.width = width;\r\n    this.height = height;\r\n    this.tDepth.setSize(this.width, this.height);\r\n    this.updateRatio();\r\n  }\r\n\r\n  updateRatio(){\r\n    this.texture.setSize(this.width, this.height);\r\n    this.camera.aspect = this.width / this.height;\r\n    this.camera.updateProjectionMatrix();\r\n  }\r\n\r\n  render(delta = 0){\r\n\r\n    if(!this.visible)\r\n      return;\r\n\r\n    for(const emitter in this.emitters){\r\n      this.emitters[emitter].tick(delta);\r\n    }\r\n\r\n    for(let i = 0; i < this.scene.children.length; i++){\r\n      const element = this.scene.children[i];\r\n      if(element instanceof OdysseyModel3D){\r\n        element.update(delta);\r\n      }\r\n    }\r\n\r\n    if(this.currentCamera){\r\n      this.frustumMat4.multiplyMatrices( this.currentCamera.projectionMatrix, this.currentCamera.matrixWorldInverse )\r\n      this.viewportFrustum.setFromProjectionMatrix(this.frustumMat4);\r\n      this.lightManager.update(delta, this.currentCamera);\r\n    }\r\n\r\n    const oldClearColor = new THREE.Color()\r\n    GameState.renderer.getClearColor(oldClearColor);\r\n    //GameState.renderer.setClearColor(this.clearColor, 1);\r\n    GameState.renderer.setRenderTarget(this.texture);\r\n    GameState.renderer.clear();\r\n    GameState.renderer.render(this.scene, this.currentCamera);\r\n    (this.texture as THREE.WebGLRenderTarget & { needsUpdate?: boolean }).needsUpdate = true;\r\n    GameState.renderer.setRenderTarget(null);\r\n    //GameState.renderer.setClearColor(oldClearColor, 1);\r\n\r\n    if(this.control){\r\n      const material = this.control.getFill().material;\r\n      if(material instanceof THREE.ShaderMaterial){\r\n        material.uniforms.map.value = this.texture.texture;\r\n        material.transparent = true;\r\n        material.needsUpdate = true;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\LBL_MapView.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":193,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":193,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setHex on an `any` value.","line":193,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":193,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":249,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":249,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":249,"column":76,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":249,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":298,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":298,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":299,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":299,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":299,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":299,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":299,"column":62,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":299,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":299,"column":67,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":299,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":303,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":303,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":304,"column":11,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":304,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":392,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":392,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":393,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":393,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .mapNoteEnabled on an `any` value.","line":393,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":393,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":394,"column":47,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":394,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":394,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":394,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":394,"column":64,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":394,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":394,"column":69,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":394,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":459,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":459,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":460,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":460,"endColumn":53}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport type { GUIControl, GUILabel } from \".\";\n\nimport { GameEngineType } from \"@/enums/engine\";\nimport { MapMode } from \"@/enums/engine/MapMode\";\nimport { MapNorthAxis } from \"@/enums/engine/MapNorthAxis\";\nimport { GameState } from \"@/GameState\";\nimport { TextureLoader } from \"@/loaders\";\nimport { AreaMap, ModuleWaypoint } from \"@/module\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\n\n\n\n// import { ShaderManager, MenuManager, PartyManager } from \"@/managers\";\n\nconst FOG_SIZE = 64;\nconst FOG_SIZE_HALF = FOG_SIZE/2;\n\nconst planeGeometry = new THREE.PlaneGeometry(1, 1, 1, 1);\n\n/**\n * LBL_MapView class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file LBL_MapView.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class LBL_MapView {\n  LBL_MAPVIEW: GUILabel;\n  control: GUIControl;\n\n  width: number = 120;\n  height: number = 120;\n\n  arrowSize: number = 32;\n\n  mode: MapMode = MapMode.MINIMAP;\n\n  scene: THREE.Scene;\n  camera: THREE.OrthographicCamera;\n  texture: THREE.WebGLRenderTarget;\n  tDepth: THREE.WebGLRenderTarget;\n  clearColor: THREE.Color;\n  currentCamera: THREE.Camera;\n  frustumMat4: THREE.Matrix4;\n  viewportFrustum: THREE.Frustum;\n\n  mapGroup: THREE.Group = new THREE.Group();\n  mapPlane: THREE.Mesh;\n  fogPlane: THREE.Mesh;\n  arrowPlane: THREE.Mesh;\n  mapNotes: THREE.Mesh[] = [];\n  fogGroup: THREE.Group = new THREE.Group();\n  partyGroup: THREE.Group = new THREE.Group();\n\n  mapTexture: OdysseyTexture;\n  fogTexture: OdysseyTexture;\n  noteTexture: OdysseyTexture;\n  pmTexture: OdysseyTexture;\n\n  arrowTexture: OdysseyTexture;\n\n  areaMap: AreaMap;\n  visible: boolean;\n\n  position: THREE.Vector3 = new THREE.Vector3(0, 0, 0);\n  arrowAngle: number = 0;\n\n  mapNoteSize = 32;\n  mapNodeHoverScale = 0.75;\n  mapNoteDefaultScale = 0.5;\n  mapNoteSelected: ModuleWaypoint;\n  bounds: THREE.Box2 = new THREE.Box2();\n\n  _mapCoordinates: THREE.Vector2 = new THREE.Vector2(0, 0);\n  mousePosition: THREE.Vector2 = new THREE.Vector2(0, 0);\n  globalLight: THREE.AmbientLight;\n\n  constructor(\n    LBL_MAPVIEW: GUILabel,\n  ) {\n    this.LBL_MAPVIEW = LBL_MAPVIEW;\n\n    this.visible = true;\n    this.frustumMat4 = new THREE.Matrix4();\n    this.viewportFrustum = new THREE.Frustum();\n\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.OrthographicCamera(\n      this.width / -2,\n      this.width / 2,\n      this.height / 2,\n      this.height / -2,\n      1, 1000\n    );\n\n    this.texture = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});\n    this.tDepth = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\n    this.clearColor = new THREE.Color(0x000000);\n\n    this.currentCamera = this.camera;\n    this.camera.position.z = 100;\n\n    this.globalLight = new THREE.AmbientLight(0x7F7F7F);\n    this.globalLight.position.x = 0;\n    this.globalLight.position.y = 0;\n    this.globalLight.position.z = 0;\n    this.globalLight.intensity  = 1;\n    this.scene.add(this.globalLight);\n\n    //MAP\n    const mapPlaneMaterial = new THREE.MeshBasicMaterial({\n      color: 0xFFFFFF\n    });\n\n    this.mapPlane = new THREE.Mesh(planeGeometry, mapPlaneMaterial);\n    this.mapPlane.position.set(0, 0, 0);\n    this.mapGroup.add(this.mapPlane);\n\n    //FOG\n    const fogPlaneMaterial = new THREE.ShaderMaterial({\n      uniforms: THREE.UniformsUtils.merge([\n        GameState.ShaderManager.Shaders.get('odyssey-fow').getUniforms()\n      ]),\n      vertexShader: GameState.ShaderManager.Shaders.get('odyssey-fow').getVertex(),\n      fragmentShader: GameState.ShaderManager.Shaders.get('odyssey-fow').getFragment(),\n    });\n    fogPlaneMaterial.defines.USE_MAP = '';\n    fogPlaneMaterial.defines.USE_UV = '';\n    fogPlaneMaterial.defines.USE_ALPHAMAP = '';\n    fogPlaneMaterial.transparent = true;\n\n    this.fogPlane = new THREE.Mesh(planeGeometry, fogPlaneMaterial);\n    this.fogPlane.position.set(0, 0, 0);\n    this.scene.add(this.fogPlane);\n\n    //ARROW\n    const arrowPlaneMaterial = new THREE.MeshBasicMaterial({\n      color: 0xFFFFFF,\n      transparent: true,\n    });\n\n    this.arrowPlane = new THREE.Mesh(planeGeometry, arrowPlaneMaterial);\n    this.arrowPlane.position.set(0, 0, 0);\n    this.arrowPlane.scale.set(this.arrowSize, this.arrowSize, 0);\n    this.scene.add(this.arrowPlane);\n\n    const pmCircleMaterial = new THREE.MeshBasicMaterial({\n      color: 0xFF7F50,\n      transparent: true,\n    });\n\n    for(let i = 0; i < 2; i++){\n      const pmCircle = new THREE.Mesh(planeGeometry, pmCircleMaterial);\n      pmCircle.scale.set(16, 16, 1);\n      this.partyGroup.add(pmCircle);\n    }\n    this.scene.add(this.partyGroup);\n\n    this.scene.add(this.mapGroup);\n    this.scene.add(this.fogGroup);\n\n    TextureLoader.Load('blackdot').then((texture: OdysseyTexture) => {\n      fogPlaneMaterial.uniforms.map.value = texture;\n      this.fogTexture = texture;\n    });\n\n    TextureLoader.Load('mm_barrow').then((texture: OdysseyTexture) => {\n      this.arrowTexture = texture;\n      (this.arrowPlane.material as THREE.MeshBasicMaterial).map = texture;\n    });\n\n    TextureLoader.Load('whitetarget').then((texture: OdysseyTexture) => {\n      this.noteTexture = texture;\n    });\n\n    TextureLoader.Load('lbl_mapcircle').then((texture: OdysseyTexture) => {\n      this.pmTexture = pmCircleMaterial.map = texture;\n    });\n  }\n\n  setControl(control: GUIControl){\n    this.control = control;\n    if(!this.control) return;\n\n    this.control.setFillTexture(this.texture.texture);\n\n    const material = this.control.getFill().material;\n    if(material instanceof THREE.ShaderMaterial){\n      material.uniforms.diffuse.value.setHex(0xFFFFFF);\n    }\n  }\n\n  setVisible(bVisible: boolean){\n    this.visible = bVisible;\n  }\n\n  setMode(mode: MapMode){\n    this.mode = mode;\n  }\n\n  setSize(width = 0, height = 0){\n    this.width = width;\n    this.height = height;\n    this.texture.setSize(this.width, this.height);\n    this.tDepth.setSize(this.width, this.height);\n    this.updateRatio();\n  }\n\n  updateRatio(){\n    this.texture.setSize(this.width, this.height);\n    this.camera.left = this.width / -2;\n    this.camera.right = this.width / 2;\n    this.camera.top = this.height / 2;\n    this.camera.bottom = this.height / -2;\n    this.camera.updateProjectionMatrix();\n  }\n\n  setTexture(texture: OdysseyTexture){\n    this.mapTexture = texture;\n    if(!this.mapTexture) return;\n\n    this.mapTexture.wrapS = THREE.RepeatWrapping;\n    this.mapTexture.wrapT = THREE.RepeatWrapping;\n    const material = this.mapPlane.material as THREE.MeshBasicMaterial;\n    material.map = this.mapTexture;\n\n    const textureSize = this.getMapTextureSize();\n    this.mapPlane.scale.set(textureSize.width, textureSize.height, 1);\n\n    const scaleSize = this.getMapTextureScaleSize();\n    this.mapGroup.position.x = textureSize.width/2;\n    this.mapGroup.position.y = textureSize.height/2;\n\n    this.fogPlane.scale.set(scaleSize.width, scaleSize.height, 1);\n    this.fogPlane.position.z = 5;\n    this.fogPlane.position.x = scaleSize.width/2;\n    this.fogPlane.position.y = scaleSize.height/2;\n  }\n\n  setAreaMap(areaMap: AreaMap){\n    this.areaMap = areaMap;\n    if(!this.areaMap) return;\n\n    (this.fogPlane.material as THREE.ShaderMaterial).uniforms.alphaMap.value = this.areaMap.fogAlphaTexture;\n    (this.fogPlane.material as THREE.ShaderMaterial).uniforms.mapRes.value.set(this.areaMap.mapResX+1, this.areaMap.mapResY+1);\n\n    if(this.mode == MapMode.FULLMAP){\n      this.areaMap.addEventListener('mapNoteAdded', (note: ModuleWaypoint) => {\n        const noteMaterial = new THREE.MeshBasicMaterial({\n          map: this.noteTexture,\n          transparent: true,\n          color: this.LBL_MAPVIEW.defaultColor\n        });\n\n        const noteMesh = new THREE.Mesh(planeGeometry, noteMaterial);\n        this.mapNotes.push(noteMesh);\n        this.scene.add(noteMesh);\n        noteMesh.userData.moduleObject = note;\n\n        const scaleSize = this.getMapTextureScaleSize();\n        const mapPos = this.areaMap.toMapCoordinates(note.position.x, note.position.y);\n        noteMesh.position.set(\n          (scaleSize.width * mapPos.x) + 4,\n          (scaleSize.height * mapPos.y) + 4,\n          10\n        );\n        noteMesh.scale.set(this.mapNoteSize * this.mapNoteDefaultScale, this.mapNoteSize * this.mapNoteDefaultScale, 1);\n        if(!this.mapNoteSelected) this.mapNoteSelected = note;\n      });\n\n      this.areaMap.addEventListener('mapNoteRemoved', (note: ModuleWaypoint) => {\n        let i = this.mapNotes.length;\n        while(i--){\n          const mesh = this.mapNotes[i];\n          if(!mesh) continue;\n\n          if(mesh.userData.moduleObject == note){\n            mesh.removeFromParent();\n            (mesh.material as THREE.MeshBasicMaterial).dispose();\n            this.mapNotes.splice(i, 1);\n          }\n        }\n      });\n    }\n  }\n\n  updateMousePosition(x: number = 0, y: number = 0){\n    this.mousePosition.set(x, y);\n  }\n\n  onClick(){\n    for(let i = 0, len = this.mapNotes.length; i < len; i++){\n      const mesh = this.mapNotes[i];\n      const note = mesh.userData.moduleObject;\n      if(this.areaMap.isMapPositionExplored(note.position.x, note.position.y)){\n        this.bounds.min.set(mesh.position.x - (this.mapNoteDefaultScale*this.mapNoteSize/2), mesh.position.y - (this.mapNoteDefaultScale*this.mapNoteSize/2));\n        this.bounds.max.set(mesh.position.x + (this.mapNoteDefaultScale*this.mapNoteSize/2), mesh.position.y + (this.mapNoteDefaultScale*this.mapNoteSize/2));\n        if(this.bounds.containsPoint(this.mousePosition)){\n          this.mapNoteSelected = note;\n          return note;\n        }\n      }\n    }\n  }\n\n  updateFog(){\n    if(!this.areaMap) return;\n  }\n\n  render(delta: number = 0){\n    if(!this.visible || !this.control)\n      return;\n\n    if(!this.currentCamera) this.currentCamera = this.camera;\n\n    if(this.currentCamera){\n      this.frustumMat4.multiplyMatrices( this.currentCamera.projectionMatrix, this.currentCamera.matrixWorldInverse )\n      this.viewportFrustum.setFromProjectionMatrix(this.frustumMat4);\n    }\n\n    this.updateFog();\n\n    const scaleSize = this.getMapTextureScaleSize();\n\n    this.areaMap.revealPosition(this.position.x, this.position.y);\n    const mapPos = this.areaMap.toMapCoordinates(this.position.x, this.position.y);\n    this.currentCamera.position.x = (scaleSize.width * mapPos.x);\n    this.currentCamera.position.y = (scaleSize.height * mapPos.y);\n    const minX = this.width/2;\n    const maxX = Math.max(this.width/2, 440 - this.width/2)\n\n    if(this.currentCamera.position.x < minX){\n      this.currentCamera.position.x = minX;\n    }\n\n    if(this.currentCamera.position.x > maxX){\n      this.currentCamera.position.x = maxX;\n    }\n\n    const maxY = Math.max(this.height/2, 256 - this.height/2);\n    const minY = this.height/2;\n\n    if(this.currentCamera.position.y < minY){\n      this.currentCamera.position.y = minY;\n    }\n\n    if(this.currentCamera.position.y > maxY){\n      this.currentCamera.position.y = maxY;\n    }\n\n    if(this.arrowPlane){\n      this.arrowPlane.position.set(\n        (scaleSize.width * mapPos.x) + 4,\n        (scaleSize.height * mapPos.y) + 4,\n        10\n      );\n      this.arrowPlane.rotation.set(0, 0, this.arrowAngle);\n      if(this.mode == MapMode.FULLMAP){\n        (this.arrowPlane.material as THREE.MeshBasicMaterial).opacity = 1 - (0.5 *GameState.MenuManager.pulseOpacity);\n      }\n    }\n\n    for(let i = 0; i < 2; i++){\n      const pm = GameState.PartyManager.party[i+1];\n      const mesh = this.partyGroup.children[i];\n      if(this.mode == MapMode.MINIMAP){\n        mesh.visible = false;\n        continue;\n      }\n\n      if(pm){\n        mesh.visible = true;\n        const pos = this.areaMap.toMapCoordinates(pm.position.x, pm.position.y);\n        mesh.position.set(\n          (scaleSize.width * pos.x) + 4,\n          (scaleSize.height * pos.y) + 4,\n          9\n        );\n      }else{\n        mesh.visible = false;\n      }\n    }\n\n    if(this.mode == MapMode.FULLMAP){\n      for(let i = 0, len = this.mapNotes.length; i < len; i++){\n        const mesh = this.mapNotes[i];\n        const material = mesh.material as THREE.MeshBasicMaterial;\n        const note = mesh.userData.moduleObject;\n        mesh.visible = note.mapNoteEnabled;\n        if(this.areaMap.isMapPositionExplored(note.position.x, note.position.y)){\n          this.bounds.min.set(mesh.position.x - (this.mapNoteDefaultScale*this.mapNoteSize/2), mesh.position.y - (this.mapNoteDefaultScale*this.mapNoteSize/2));\n          this.bounds.max.set(mesh.position.x + (this.mapNoteDefaultScale*this.mapNoteSize/2), mesh.position.y + (this.mapNoteDefaultScale*this.mapNoteSize/2));\n\n          if(this.mapNoteSelected == note){\n            material.color.copy(this.LBL_MAPVIEW.defaultHighlightColor);\n            mesh.scale.set(this.mapNoteSize*this.mapNodeHoverScale, this.mapNoteSize*this.mapNodeHoverScale, 1);\n          }else if(this.bounds.containsPoint(this.mousePosition)){\n            material.color.copy(this.LBL_MAPVIEW.defaultHighlightColor);\n            mesh.scale.set(this.mapNoteSize*this.mapNoteDefaultScale, this.mapNoteSize*this.mapNoteDefaultScale, 1);\n          }else{\n            material.color.copy(this.LBL_MAPVIEW.defaultColor);\n            mesh.scale.set(this.mapNoteSize*this.mapNoteDefaultScale, this.mapNoteSize*this.mapNoteDefaultScale, 1);\n          }\n        }else{\n          mesh.visible = false;\n        }\n      }\n    }\n\n    const oldClearColor = new THREE.Color();\n    GameState.renderer.getClearColor(oldClearColor);\n    GameState.renderer.setClearColor(this.clearColor, 1);\n    GameState.renderer.setRenderTarget(this.texture);\n    GameState.renderer.clear();\n    GameState.renderer.render(this.scene, this.currentCamera);\n    (this.texture as unknown as THREE.WebGLRenderTarget & { needsUpdate?: boolean }).needsUpdate = true;\n    GameState.renderer.setRenderTarget(null);\n    GameState.renderer.setClearColor(oldClearColor, 1);\n\n    if(this.control){\n      const material = this.control.getFill().material;\n      if(material instanceof THREE.Material){\n        if(material instanceof THREE.ShaderMaterial){\n          material.uniforms.map.value = this.texture.texture;\n        }else if(material instanceof THREE.MeshBasicMaterial){\n          material.map = this.texture.texture;\n        }\n        material.transparent = true;\n        material.needsUpdate = true;\n      }\n    }\n\n  }\n\n  getMapTextureScaleSize(): { width: number, height: number } {\n    let width = 440;\n    let height = 256;\n\n    if(GameState.GameKey == GameEngineType.TSL){\n      width = 512;\n      height = 256;\n    }\n\n    return { width: width, height: height };\n  }\n\n  getMapTextureSize(): { width: number, height: number } {\n    let texWidth = 512;\n    let texHeight = 256;\n\n    if(this.mapTexture.mipmaps.length){\n      texWidth = this.mapTexture.mipmaps[0].width;\n      texHeight = this.mapTexture.mipmaps[0].height;\n    }else if(this.mapTexture.source.data){\n      texWidth = this.mapTexture.source.data.width;\n      texHeight = this.mapTexture.source.data.height;\n    }\n\n    return { width: texWidth, height: texHeight };\n  }\n\n  setPosition(x: number, y: number){\n    this.position.set(x, y, 0);\n  }\n\n  setRotation(angle: number = 0){\n    this.arrowAngle = angle;\n    switch(this.areaMap.northAxis){\n      case MapNorthAxis.NORTH:\n        {\n          this.arrowAngle = angle;\n        }\n      break;\n      case MapNorthAxis.SOUTH:\n        {\n          this.arrowAngle = angle + (Math.PI / 2);\n        }\n      break;\n      case MapNorthAxis.EAST:\n        {\n          this.arrowAngle = angle + (Math.PI / 2);\n        }\n      break;\n      case MapNorthAxis.WEST:\n        {\n          this.arrowAngle = angle - (Math.PI / 2);\n        }\n      break;\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\protoitem\\GUIEquipmentItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":44,"column":22,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":44,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":44,"column":22,"nodeType":"MemberExpression","messageId":"errorCall","endLine":44,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":55,"column":26,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":55,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":55,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":55,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":55,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":55,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":55,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":55,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on a type that cannot be resolved.","line":55,"column":82,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":55,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":73,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":73,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":74,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":74,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":74,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":74,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":75,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":75,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":76,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":76,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":76,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":76,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":78,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":78,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":78,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":78,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":84,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":84,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":85,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":86,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":86,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | string[]`.","line":88,"column":29,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":88,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":88,"column":29,"nodeType":"MemberExpression","messageId":"errorCall","endLine":88,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":88,"column":50,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":88,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on an `any` value.","line":89,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":95,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":95,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":96,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":97,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":100,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":101,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":101,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":102,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":102,"column":79,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":103,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":103,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":106,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":106,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":106,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":108,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":108,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":108,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":110,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":110,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":111,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":112,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":113,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":113,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":114,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":115,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":117,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":118,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":118,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":132,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":132,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":132,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":132,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":150,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":150,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":150,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":150,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":163,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":163,"endColumn":61}],"suppressedMessages":[],"errorCount":47,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GUIButton, GUIListBox, GUIProtoItem } from \"..\";\n\r\nimport { GameEngineType } from \"@/enums/engine\";\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { GameState } from \"@/GameState\";\r\nimport { GameMenu } from \"@/gui/GameMenu\";\r\nimport { GUIControl } from \"@/gui/GUIControl\";\r\nimport { TextureLoader } from \"@/loaders\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\nconst log = createScopedLogger(LogScope.Game);\nimport * as THREE from \"three\";\r\n\r\n/**\r\n * GUIEquipmentItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIEquipmentItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIEquipmentItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n      const button = new GUIButton(this.menu, this.control, this, this.scale);\r\n      button.extent.width = 190;\r\n      button.setText(this.node.getName());\r\n      button.autoCalculatePosition = false;\r\n      this.children.push(button);\r\n\r\n      const _buttonWidget = button.createControl();\r\n      _buttonWidget.position.x = (this.extent.width - button.extent.width) / 2;\r\n      _buttonWidget.position.y = 0;\r\n      _buttonWidget.position.z = this.zIndex + 1;\r\n      this.widget.add(_buttonWidget);\r\n\r\n      const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonIcon.setText(this.node.getStackSize() > 1 ? this.node.getStackSize().toString() : '');\r\n      buttonIcon.disableTextAlignment();\r\n      buttonIcon.extent.width = 55;\r\n      buttonIcon.extent.height = 55;\r\n      buttonIcon.extent.top = 0;\r\n      buttonIcon.extent.left = 0;\r\n      buttonIcon.disableBorder();\r\n      buttonIcon.disableHighlight();\r\n      buttonIcon.hasText = true;\r\n      buttonIcon.autoCalculatePosition = false;\r\n      this.children.push(buttonIcon);\r\n\r\n      const _buttonIconWidget = buttonIcon.createControl();\r\n      _buttonIconWidget.position.x = -(this.extent.width/2 - buttonIcon.extent.width/2);\r\n      _buttonIconWidget.position.y = 0;\r\n      _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n      //Stack Count Text Position\r\n      if(this.node.getStackSize() >= 100){\r\n        buttonIcon.widget.userData.text.position.set(6, -10, 5);\r\n      }else if(this.node.getStackSize() >= 10){\r\n        buttonIcon.widget.userData.text.position.set(10, -10, 5);\r\n      }else{\r\n        buttonIcon.widget.userData.text.position.set(14, -10, 5);\r\n      }\r\n\r\n      this.widget.add(_buttonIconWidget);\r\n\r\n      this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.iconMaterial.transparent = true;\r\n      this.widget.userData.iconMaterial.visible = false;\r\n      this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n      //log.info(this.node.getIcon());\r\n      TextureLoader.enQueue(this.node.getIcon(), this.widget.userData.iconMaterial, TextureType.TEXTURE, (texture: OdysseyTexture) => {\r\n        this.widget.userData.iconMaterial.visible = true;\r\n      });\r\n      \r\n      this.widget.userData.spriteGroup = new THREE.Group();\r\n      //this.widget.spriteGroup.position.x = -(this.extent.width/2)-(52/2); //HACK\r\n      //this.widget.spriteGroup.position.y -= 4;\r\n      this.widget.userData.iconSprite.scale.x = 52;\r\n      this.widget.userData.iconSprite.scale.y = 52;\r\n      this.widget.userData.iconSprite.position.z = 1;\r\n\r\n      this.widget.userData.hexMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.hexMaterial.transparent = true;\r\n      this.widget.userData.hexSprite = new THREE.Sprite( this.widget.userData.hexMaterial );\r\n      this.widget.userData.hexSprite.scale.x = this.widget.userData.hexSprite.scale.y = 64;\r\n      this.widget.userData.hexSprite.position.z = 1;\r\n\r\n      if(GameState.GameKey != GameEngineType.TSL)\r\n        this.widget.userData.spriteGroup.add(this.widget.userData.hexSprite);\r\n        \r\n      this.widget.userData.spriteGroup.add(this.widget.userData.iconSprite);\r\n\r\n      if(this.node.getStackSize() >= 100){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex_7');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else if(this.node.getStackSize() > 1){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex_6');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else{\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get('lbl_hex_3');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }\r\n\r\n      this.onSelect = () => {\r\n        if(this.selected){\r\n          this.showHighlight();\r\n          this.hideBorder();\r\n          this.pulsing = true;\r\n          this.text.color.setRGB(1, 1, 0);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          button.showHighlight();\r\n          button.hideBorder();\r\n          this.widget.userData.hexMaterial.color.setRGB(1, 1, 0);\r\n          button.setHighlightColor(1, 1, 0);\r\n          button.pulsing = true;\r\n          buttonIcon.pulsing = true;\r\n\r\n          button.text.color.setRGB(1, 1, 0);\r\n          button.text.material.uniforms.diffuse.value = button.text.color;\r\n          button.text.material.needsUpdate = true;\r\n        }else{\r\n          this.hideHighlight();\r\n          this.showBorder();\r\n          this.pulsing = false;\r\n          this.text.color.setRGB(0, 0.658824, 0.980392);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          button.hideHighlight();\r\n          button.showBorder();\r\n          this.widget.userData.hexMaterial.color.setRGB(0, 0.658823549747467, 0.9803921580314636);\r\n          button.setBorderColor(0, 0.658823549747467, 0.9803921580314636);\r\n          button.pulsing = false;\r\n          buttonIcon.pulsing = false;\r\n\r\n          button.text.color.setRGB(0, 0.658824, 0.980392);\r\n          button.text.material.uniforms.diffuse.value = button.text.color;\r\n          button.text.material.needsUpdate = true;\r\n        }\r\n      };\r\n      this.onSelect.call(this);\r\n\r\n      //StackCount Text\r\n      _buttonIconWidget.add(this.widget.userData.spriteGroup);\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\protoitem\\GUIInventoryItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":52,"column":27,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":52,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":52,"column":27,"nodeType":"MemberExpression","messageId":"errorCall","endLine":52,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | { toString(): string; }`.","line":64,"column":26,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":64,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":64,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":64,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":64,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":64,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":64,"column":57,"nodeType":"MemberExpression","messageId":"errorCall","endLine":64,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on a type that cannot be resolved.","line":64,"column":82,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":64,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":82,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":82,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":83,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":83,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":83,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":83,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":84,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":84,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":85,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":85,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":85,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":87,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":87,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":87,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":87,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":93,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":93,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":94,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":94,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":96,"column":26,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":96,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":96,"column":26,"nodeType":"MemberExpression","messageId":"errorCall","endLine":96,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":98,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":99,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":106,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":107,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":107,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":108,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transparent on an `any` value.","line":111,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `SpriteMaterial`.","line":112,"column":58,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":112,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":113,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scale on an `any` value.","line":114,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on an `any` value.","line":115,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":117,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":117,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":117,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":118,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":118,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on an `any` value.","line":118,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":118,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":120,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":120,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":121,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":122,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":123,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":123,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":124,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":124,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":125,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":125,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":127,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":127,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":128,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":128,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":142,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":142,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":142,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":142,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":160,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":160,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .color on an `any` value.","line":160,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":160,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":173,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":173,"endColumn":61}],"suppressedMessages":[],"errorCount":46,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameMenu, GUIButton, GUIControl, GUIListBox, GUIProtoItem } from \"..\";\n\r\nimport { GameEngineType } from \"@/enums/engine\";\nimport { GameState } from \"@/GameState\";\r\nimport { TextureLoader } from \"@/loaders\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\r\n\nconst log = createScopedLogger(LogScope.Game);\nimport * as THREE from \"three\";\r\n\r\n/**\r\n * GUIInventoryItem class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIInventoryItem.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIInventoryItem extends GUIProtoItem {\r\n\r\n  constructor(menu: GameMenu, control: GFFStruct, parent: GUIControl, scale: boolean = false){\r\n    super(menu, control, parent, scale);\r\n  }\r\n\r\n  buildFill(){}\r\n  buildBorder(){}\r\n  buildHighlight(){}\r\n  buildText(){}\r\n\r\n  createControl(){\r\n    try{\r\n      super.createControl();\r\n      //Create the actual control elements below\r\n\r\n      const spacing = 5;\r\n      const protoWidth = this.extent.width;\r\n      const protoHeight = this.extent.height;\r\n      const iconWidth = this.extent.height;\r\n      const iconHeight = this.extent.height;\r\n\r\n      const labelWidth = protoWidth - iconWidth - this.parent.border.inneroffset;\r\n\r\n      //Label\r\n      const buttonLabel = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonLabel.extent.left = 0;\r\n      buttonLabel.extent.width = labelWidth;\r\n      buttonLabel.setText(this.node.getName());\r\n      buttonLabel.autoCalculatePosition = false;\r\n      this.children.push(buttonLabel);\r\n\r\n      const _buttonWidget = buttonLabel.createControl();\r\n      _buttonWidget.position.x = (protoWidth - buttonLabel.extent.width) / 2;\r\n      _buttonWidget.position.y = 0;\r\n      _buttonWidget.position.z = this.zIndex + 1;\r\n      this.widget.add(_buttonWidget);\r\n\r\n      //Icon\r\n      const buttonIcon = new GUIButton(this.menu, this.control, this, this.scale);\r\n      buttonIcon.setText(this.node.getStackSize() > 1 ? this.node.getStackSize().toString() : '');\r\n      buttonIcon.disableTextAlignment();\r\n      buttonIcon.extent.width = iconWidth;\r\n      buttonIcon.extent.height = iconHeight;\r\n      buttonIcon.extent.top = 0;\r\n      buttonIcon.extent.left = 0;\r\n      buttonIcon.disableBorder();\r\n      buttonIcon.disableHighlight();\r\n      buttonIcon.hasText = true;\r\n      buttonIcon.autoCalculatePosition = false;\r\n      this.children.push(buttonIcon);\r\n\r\n      const _buttonIconWidget = buttonIcon.createControl();\r\n      _buttonIconWidget.position.x = -(protoWidth/2 - buttonIcon.extent.width/2);\r\n      _buttonIconWidget.position.y = 0;\r\n      _buttonIconWidget.position.z = this.zIndex + 1;\r\n\r\n      //Stack Count Text Position\r\n      if(this.node.getStackSize() >= 100){\r\n        buttonIcon.widget.userData.text.position.set(6, -10, 5);\r\n      }else if(this.node.getStackSize() >= 10){\r\n        buttonIcon.widget.userData.text.position.set(10, -10, 5);\r\n      }else{\r\n        buttonIcon.widget.userData.text.position.set(14, -10, 5);\r\n      }\r\n\r\n      this.widget.add(_buttonIconWidget);\r\n\r\n      this.widget.userData.iconMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.iconMaterial.transparent = true;\r\n      this.widget.userData.iconSprite = new THREE.Sprite( this.widget.userData.iconMaterial );\r\n      //log.info(this.node.getIcon());\r\n      TextureLoader.Load(this.node.getIcon()).then((texture: OdysseyTexture) => {\r\n        if(texture){\r\n          this.widget.userData.iconMaterial.map = texture;\r\n          this.widget.userData.iconMaterial.needsUpdate = true;\r\n        }\r\n      });\r\n      \r\n      this.widget.userData.spriteGroup = new THREE.Group();\r\n      //this.widget.spriteGroup.position.x = -(protoWidth/2)-(52/2); //HACK\r\n      //this.widget.spriteGroup.position.y -= 4;\r\n      this.widget.userData.iconSprite.scale.x = iconWidth * 0.95;\r\n      this.widget.userData.iconSprite.scale.y = iconHeight * 0.95;\r\n      this.widget.userData.iconSprite.position.z = 2;\r\n\r\n      this.widget.userData.hexMaterial = new THREE.SpriteMaterial( { map: null, color: 0xffffff } );\r\n      this.widget.userData.hexMaterial.transparent = true;\r\n      this.widget.userData.hexSprite = new THREE.Sprite( this.widget.userData.hexMaterial );\r\n      this.widget.userData.hexSprite.scale.x = \r\n        this.widget.userData.hexSprite.scale.y = iconWidth;\r\n      this.widget.userData.hexSprite.position.z = 1;\r\n\r\n      this.widget.userData.spriteGroup.add(this.widget.userData.hexSprite);  \r\n      this.widget.userData.spriteGroup.add(this.widget.userData.iconSprite);\r\n\r\n      if(this.node.getStackSize() >= 100){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_7' : 'uibit_eqp_itm3');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else if(this.node.getStackSize() > 1){\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_6' : 'uibit_eqp_itm2');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }else{\r\n        this.widget.userData.hexMaterial.map = GUIListBox.hexTextures.get(GameState.GameKey == GameEngineType.KOTOR ? 'lbl_hex_3' : 'uibit_eqp_itm1');\r\n        this.widget.userData.hexMaterial.needsUpdate = true;\r\n      }\r\n\r\n      this.onSelect = () => {\r\n        if(this.selected){\r\n          this.showHighlight();\r\n          this.hideBorder();\r\n          this.pulsing = true;\r\n          this.text.color.setRGB(1, 1, 0);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.showHighlight();\r\n          buttonLabel.hideBorder();\r\n          this.widget.userData.hexMaterial.color.setRGB(1, 1, 0);\r\n          buttonLabel.setHighlightColor(1, 1, 0);\r\n          buttonLabel.pulsing = true;\r\n          buttonIcon.pulsing = true;\r\n\r\n          buttonLabel.text.color.setRGB(1, 1, 0);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }else{\r\n          this.hideHighlight();\r\n          this.showBorder();\r\n          this.pulsing = false;\r\n          this.text.color.setRGB(0, 0.658824, 0.980392);\r\n          this.text.material.uniforms.diffuse.value = this.text.color;\r\n          this.text.material.needsUpdate = true;\r\n  \r\n          buttonLabel.hideHighlight();\r\n          buttonLabel.showBorder();\r\n          this.widget.userData.hexMaterial.color.setRGB(0, 0.658823549747467, 0.9803921580314636);\r\n          buttonLabel.setBorderColor(0, 0.658823549747467, 0.9803921580314636);\r\n          buttonLabel.pulsing = false;\r\n          buttonIcon.pulsing = false;\r\n\r\n          buttonLabel.text.color.setRGB(0, 0.658824, 0.980392);\r\n          buttonLabel.text.material.uniforms.diffuse.value = buttonLabel.text.color;\r\n          buttonLabel.text.material.needsUpdate = true;\r\n        }\r\n      };\r\n      this.onSelect.call(this);\r\n\r\n      //StackCount Text\r\n      _buttonIconWidget.add(this.widget.userData.spriteGroup);\r\n      return this.widget;\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n    return this.widget;\r\n\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\gui\\protoitem\\GUIItemNone.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":15,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":17,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameState } from \"@/GameState\";\r\n\r\nconst STR_NONE = 363;\r\n\r\n/**\r\n * GUIItemNone class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GUIItemNone.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GUIItemNone {\r\n  constructor(){\r\n    // super()\r\n  }\r\n\r\n  getIcon(){\r\n    return 'inone';\r\n  }\r\n\r\n  getStackSize(){\r\n    return 1;\r\n  }\r\n\r\n  getName(){\r\n    //None String\r\n    return GameState.TLKManager.GetStringById(STR_NONE).Value;\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\interface\\odyssey\\IOdysseyModelAnimationData.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":11,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":11,"endColumn":44,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[322,367],"text":"type IOdysseyModelAnimationData = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[322,367],"text":"type IOdysseyModelAnimationData = unknown"},"desc":"Replace empty interface with `unknown`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * IOdysseyModelAnimationData interface.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file IOdysseyModelAnimationData.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n * @interface\r\n */\r\nexport interface IOdysseyModelAnimationData {\r\n  \r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\CheatConsoleManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":37,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":37,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ExperienceType } from \"@/enums/engine/ExperienceType\";\r\nimport { GameState } from \"@/GameState\";\nimport { ResourceLoader } from \"@/loaders\";\r\nimport { InventoryManager } from \"@/managers/InventoryManager\";\r\nimport { KEYManager } from \"@/managers/KEYManager\";\r\nimport { ModuleItem } from \"@/module\";\r\nimport { GFFObject } from \"@/resource/GFFObject\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\n\r\n\r\n/**\r\n * CheatConsoleManager class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file CheatConsoleManager.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class CheatConsoleManager {\r\n\r\n  //Gives your character the amount of Dark Side points you want\r\n  static addDarkSide(points: number = 0){\r\n    points = Math.abs(points);\r\n    const player = GameState.getCurrentPlayer();\r\n    if(player){\r\n      player.goodEvil -= points;\r\n      if(player.goodEvil < 0) player.goodEvil = 0;\r\n    }\r\n  }\r\n\r\n  //Gives your character the amount of experience points you want\r\n  static addEXP(points: number = 0){\r\n    points = Math.abs(points);\r\n    const player = GameState.getCurrentPlayer();\r\n    if(player){\r\n      player.addXP(points, ExperienceType.PLOT);\r\n    }\r\n  }\r\n\r\n  //Increases your character's level to the number you want\r\n  static addLevel(points: number = 0){\r\n    points = Math.abs(points);\r\n    const player = GameState.getCurrentPlayer();\r\n    if(player){\r\n      \r\n    }\r\n  }\r\n\r\n  //Gives your character the amount of Light Side points you want\r\n  static addLightSide(points: number = 0){\r\n    points = Math.abs(points);\r\n    const player = GameState.getCurrentPlayer();\r\n    if(player){\r\n      player.goodEvil += points;\r\n      if(player.goodEvil > 100) player.goodEvil = 100;\r\n    }\r\n  }\r\n\r\n  //Increases the brightness in the game\r\n  static bright(){\r\n\r\n  }\r\n\r\n  //Receive (n) computer spikes\r\n  static giveComputerSpikes (amount: number = 100){\r\n    amount = Math.abs(amount);\r\n\r\n  }\r\n\r\n  //Receive the amount of credits you want\r\n  static giveCredits (amount: number = 0){\r\n    amount = Math.abs(amount);\r\n\r\n  }\r\n\r\n  static giveItem(resref: string = '', amount: number = 1){\r\n    amount = Math.abs(amount);\r\n    const buffer = ResourceLoader.loadCachedResource(ResourceTypes['uti'], resref);\r\n    if(buffer){\r\n      const item = new ModuleItem(new GFFObject(buffer));\r\n      item.initProperties();\r\n      item.setStackSize(amount);\r\n      InventoryManager.addItem(item);\r\n      return item;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  //Receive (n) medkits\r\n  static giveMedPacks (amount: number = 100){\r\n    amount = Math.abs(amount);\r\n\r\n  }\r\n\r\n  //Refills your character's health and Force points\r\n  static heal (){\r\n    const player = GameState.getCurrentPlayer();\r\n    if(player){\r\n      \r\n    }\r\n  }\r\n\r\n  //Reveals the entire map for the area you're in\r\n  static revealmap() {\r\n    if(GameState?.module?.area){\r\n      //todo\r\n    }\r\n  }\r\n\r\n  //Teleports your characters to a specific location\r\n  static warp (name: string = ''){\r\n    if(name){\r\n      GameState.LoadModule(name)\r\n    }\r\n  }\r\n\r\n  //Will display your character's current coordinates\r\n  static whereami (){\r\n    //todo\r\n  }\r\n\r\n  static giveRandomLoot(amount: number = 1) {\r\n    const items = KEYManager.Key.keys.filter( (k) => k.resType == ResourceTypes.uti );\r\n    for(let i = 0; i < amount; i++){\r\n      const item = items[Math.floor(Math.random()*items.length)];\r\n      if(item){\r\n        CheatConsoleManager.giveItem(item.resRef, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  static processCommand(command: string){\r\n    const args = command.trim().toLowerCase().split(' ');\r\n    const cmd = args.shift();\r\n    const params = args;\r\n    switch(cmd){  \r\n      case 'adddark':\r\n        CheatConsoleManager.addDarkSide(parseInt(params[0]));\r\n        break;\r\n      case 'addlight':\r\n        CheatConsoleManager.addLightSide(parseInt(params[0]));\r\n        break;\r\n      case 'addlevel':\r\n        CheatConsoleManager.addLevel(parseInt(params[0]));\r\n        break;\r\n      case 'addxp':\r\n        CheatConsoleManager.addEXP(parseInt(params[0]));\r\n        break;  \r\n      case 'giveitem':\r\n        CheatConsoleManager.giveItem(params[0], parseInt(params[1]));\r\n        break;\r\n      case 'givecredits':\r\n        CheatConsoleManager.giveCredits(parseInt(params[0]));\r\n        break;  \r\n      case 'heal':\r\n        CheatConsoleManager.heal();\r\n        break;\r\n      case 'revealmap':\r\n        CheatConsoleManager.revealmap();\r\n        break;  \r\n      case 'warp':\r\n        CheatConsoleManager.warp(params[0]);\r\n        break;\r\n      case 'whereami':\r\n        CheatConsoleManager.whereami();\r\n        break;  \r\n      case 'giverandomloot':\r\n        CheatConsoleManager.giveRandomLoot(parseInt(params[0]));\r\n        break;\r\n    }\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\CutsceneManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":461,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":461,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":463,"column":53,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":463,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":467,"column":60,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":467,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":477,"column":68,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":477,"endColumn":91},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":481,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":481,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":489,"column":48,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":489,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":525,"column":66,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":525,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":528,"column":57,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":528,"endColumn":78}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AudioEmitter } from \"@/audio/AudioEmitter\";\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { CameraMode } from \"@/enums/dialog/CameraMode\";\nimport { ConversationState } from \"@/enums/dialog/ConversationState\";\nimport { CutsceneMode } from \"@/enums/dialog/CutsceneMode\";\nimport { DLGCameraAngle } from \"@/enums/dialog/DLGCameraAngle\";\nimport { DLGConversationType } from \"@/enums/dialog/DLGConversationType\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { ModuleCreatureAnimState } from \"@/enums/module/ModuleCreatureAnimState\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { GameState } from \"@/GameState\";\nimport { ICameraParticipant } from \"@/interface/dialog/ICameraParticipant\";\nimport { ICameraState } from \"@/interface/dialog/ICameraState\";\nimport type { ModuleCreature, ModuleObject } from \"@/module\";\nimport { DLGNode } from \"@/resource/DLGNode\";\nimport { DLGObject } from \"@/resource/DLGObject\";\nimport { OdysseyModel3D } from \"@/three/odyssey/OdysseyModel3D\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\n\nconst ENTRY_DELAY = 3000;\nconst HALF_PI = Math.PI / 2;\n\nconst SINGLE_SHOT_ANGLE_OFFSET = 0.5;\n\n/** Listener signature for CutsceneManager events (conversation ended, etc.). */\ntype CutsceneEventListener = (...args: (string | number | boolean | object)[]) => void;\n\n/** Dialog/cutscene controller. Static namespace by design (see GameState.CutsceneManager). */\n/* eslint-disable-next-line @typescript-eslint/no-extraneous-class -- Static namespace; not a constructible service. */\nexport class CutsceneManager {\n\n  static active: boolean = false;\n  static cutsceneMode: CutsceneMode = CutsceneMode.DIALOG;\n\n  static conversation_name: string;\n  static dialog: DLGObject;\n  static startingEntry: DLGNode | null;\n  static currentEntry: DLGNode | null;\n  static currentReplies: DLGNode[] = [];\n\n  static lastSpokenString: string = '';\n\n  static listener: ModuleObject;\n  static owner: ModuleObject;\n\n  static ended: boolean;\n  static state: ConversationState;\n  static unequipHeadItem: boolean;\n  static unequipItems: boolean;\n  static isListening: boolean;\n\n  static audioEmitter: AudioEmitter;\n\n  static paused: boolean = false;\n\n  static cameraState: ICameraState = {\n    mode: CameraMode.DIALOG,\n    cameraAngle: DLGCameraAngle.ANGLE_SPEAKER,\n    cameraID: -1,\n    cameraAnimation: -1,\n    currentCameraAnimation: undefined,\n    currentCameraAnimationElapsed: 0,\n    listener: {} as ICameraParticipant,\n    speaker: {} as ICameraParticipant,\n  }\n\n  static getCurrentListener(): ModuleObject {\n    if (this.currentEntry) {\n      return this.currentEntry.listener;\n    }\n    return this.listener;\n  }\n\n  static getCurrentOwner(): ModuleObject {\n    if (this.currentEntry) {\n      return this.currentEntry.owner;\n    }\n    return this.owner;\n  }\n\n  static startConversation(dialog: DLGObject, owner: ModuleObject, listener: ModuleObject = GameState.PartyManager.party[0]) {\n    log.debug('CutsceneManager.startConversation', String(dialog), owner, listener);\n    this.active = true;\n    this.cameraState.currentCameraAnimation = undefined;\n    this.owner = owner;\n    this.listener = listener;\n    this.paused = false;\n    this.ended = false;\n    this.currentEntry = null;\n    this.state = ConversationState.INVALID;\n    if (owner.isPlayer && !listener.isPlayer) {\n      this.listener = owner;\n      this.owner = listener;\n    }\n    this.unequipHeadItem = false;\n    this.unequipItems = false;\n    GameState.SetEngineMode(EngineMode.DIALOG);\n    this.isListening = true;\n    this.startingEntry = null;\n    this.currentEntry = null;\n    this.currentReplies = [];\n    this.lastSpokenString = '';\n    this.ended = false;\n\n    if (!dialog) {\n      dialog = this.owner.getConversation();\n    }\n\n    if (!(dialog instanceof DLGObject)) {\n      this.endConversation();\n    }\n\n    this.conversation_name = dialog.resref;\n    this.dialog = dialog;\n    this.dialog.owner = this.owner;\n    this.dialog.listener = this.listener;\n\n    //todo trigger updateTextPosition\n    this.isListening = true;\n    this.startingEntry = this.getNextEntry(this.dialog.startingList);\n    if(!this.startingEntry){\n      log.warn('CutsceneManager.startConversation: No starting entry found');\n      this.endConversation();\n      return;\n    }\n\n    //bark entry\n    const isBarkDialog = this.startingEntry.isBarkDialog();\n    if (isBarkDialog) {\n      this.cutsceneMode = CutsceneMode.BARK;\n      GameState.MenuManager.InGameBark.bark(this.startingEntry);\n      this.startingEntry.runScripts();\n      const reply = this.dialog.getReplyByIndex(this.startingEntry.replies[0]?.index);\n      if (reply) {\n        reply.runScripts();\n      }\n      this.endConversation();\n      return;\n    }\n\n    //normal dialog entry\n    this.cutsceneMode = (this.dialog.isAnimatedCutscene) ? CutsceneMode.ANIMATED : CutsceneMode.DIALOG;\n\n    if(this.listener.isPM){\n      GameState.PartyManager.MakePlayerLeader();\n      this.listener = this.dialog.listener = GameState.PartyManager.party[0];\n    }\n\n    if(this.dialog.getConversationType() == DLGConversationType.CONVERSATION){\n      GameState.MenuManager.InGameDialog.canLetterbox = true;\n    }\n\n    log.debug(`CutsceneManager.startConversation: ${this.dialog.getConversationType() ? 'Computer' : 'Conversation'}`);\n\n    GameState.holdWorldFadeInForDialog = (this.cutsceneMode == CutsceneMode.ANIMATED);\n    this.dialog.loadStuntCamera().then(() => {\n      log.debug('CutsceneManager.startConversation: loadStuntCamera');\n      this.dialog.loadStuntActors().then(() => {\n        log.debug('CutsceneManager.startConversation: loadStuntActors');\n        this.dialog.loadBackgroundMusic().then(() => {\n          log.debug('CutsceneManager.startConversation: loadBackgroundMusic');\n          switch (this.dialog.getConversationType()) {\n            case DLGConversationType.COMPUTER:\n              log.debug('CutsceneManager.startConversation: Computer');\n              GameState.MenuManager.InGameComputer.open();\n              break;\n            default:\n              log.debug('CutsceneManager.startConversation: Conversation');\n              GameState.MenuManager.InGameDialog.open();\n              break;\n          }\n          this.showEntry(this.startingEntry);\n        });\n      });\n    });\n  }\n\n  /**\n   * Get the next entry\n   * @param entryLinks - The entry links\n   * @returns The next entry\n   */\n  static getNextEntry(entryLinks: DLGNode[] = []/*, callback?: Function*/): DLGNode {\n    if (!entryLinks.length) { return; }\n    this.isListening = true;\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      // GameState.MenuManager.InGameComputer.updateTextPosition();\n    }else{\n      GameState.MenuManager.InGameDialog.updateTextPosition();\n    }\n    const entryIndex = this.dialog.getNextEntryIndex(entryLinks);\n    return this.dialog.getEntryByIndex(entryIndex);\n  }\n\n  /**\n   * Handle the player skipping a dialog entry\n   * @param _currentEntry - The entry to skip (unused; skip applies to this.currentEntry)\n   */\n  static playerSkipEntry(_currentEntry: DLGNode): void {\n    if(!this.currentEntry) { return; }\n    if(!this.currentEntry.skippable) { return; }\n    if(this.currentEntry.checkList.isSkipped){ return; }\n    if(this.currentEntry.repliesShown){ return; }\n    this.currentEntry.checkList.isSkipped = true;\n    this.audioEmitter.stop();\n    this.currentEntry.resetLIP();\n    this.showReplies(this.currentEntry);\n  }\n\n  /**\n   * Show a dialog entry\n   * @param entry - The entry to show\n   */\n  static showEntry(entry: DLGNode) {\n    this.currentEntry = entry;\n    this.currentEntry.repliesShown = false;\n    entry.initProperties();\n    const isComputerCameraEntry = this.dialog.getConversationType() == DLGConversationType.COMPUTER && entry.cameraAngle == DLGCameraAngle.ANGLE_PLACEABLE_CAMERA;\n    this.state = ConversationState.LISTENING_TO_SPEAKER;\n    if (GameState.Mode != EngineMode.DIALOG)\n      return;\n    GameState.VideoEffectManager.SetVideoEffect(entry.getVideoEffect());\n    this.lastSpokenString = entry.getCompiledString();\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      GameState.MenuManager.InGameComputer.setEntry(entry);\n      GameState.MenuManager.InGameComputer.setDialogMode(ConversationState.LISTENING_TO_SPEAKER);\n    }else{\n      GameState.MenuManager.InGameDialog.setDialogMode(ConversationState.LISTENING_TO_SPEAKER);\n    }\n\n    entry.updateJournal();\n\n    //participant animations\n    if (this.cutsceneMode == CutsceneMode.ANIMATED) {\n      this.setAnimatedEntryAnimations(entry);\n    } else {\n      this.setEntryAnimations(entry);\n    }\n\n    //participant facing\n    if (this.cutsceneMode == CutsceneMode.DIALOG) {\n      if (BitWise.InstanceOfObject(this.currentEntry.listener, ModuleObjectType.ModuleObject) && BitWise.InstanceOfObject(this.currentEntry.speaker, ModuleObjectType.ModuleObject)) {\n        if (!this.currentEntry.listener.lockDialogOrientation && BitWise.InstanceOfObject(this.currentEntry.listener, ModuleObjectType.ModuleCreature)) {\n          this.currentEntry.listener.FacePoint(this.currentEntry.speaker.position);\n        }\n        if (!this.currentEntry.speaker.lockDialogOrientation && BitWise.InstanceOfObject(this.currentEntry.speaker, ModuleObjectType.ModuleCreature)) {\n          this.currentEntry.speaker.FacePoint(this.currentEntry.listener.position);\n        }\n      }\n    }\n\n    //Node Delay\n    const nodeDelay = (this.cutsceneMode != CutsceneMode.ANIMATED && entry.delay > -1) ? entry.delay * 1000 : ENTRY_DELAY;\n    entry.setNodeDelay(nodeDelay);\n    if(isComputerCameraEntry){\n      entry.setNodeDelay(5000);\n    }\n    //Node camera\n    this.setEntryCamera(entry);\n\n    //scripts\n    entry.runScripts();\n\n    //replies\n    const replies = this.dialog.getAvailableReplies(entry);\n    this.currentReplies = replies;\n\n    //vo\n    entry.playVoiceOver(this.audioEmitter);\n\n\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      if(entry.isContinueDialog() && !isComputerCameraEntry){\n        this.onReplySelect(replies[0]);\n      }else{\n        GameState.MenuManager.InGameComputer.setReplies(replies);\n      }\n    }else{\n      GameState.MenuManager.InGameDialog.setReplies(replies);\n    }\n  }\n\n  /**\n   * Select a reply at an index\n   * @param index - The index of the reply to select\n   */\n  static selectReplyAtIndex(index: number) {\n    const reply = this.currentReplies[index];\n    if(!reply){\n      log.warn('CutsceneManager.selectReplyAtIndex: No reply found');\n      return;\n    }\n\n    if(this.state != ConversationState.WAITING_FOR_PC_CHOICE){\n      log.warn('CutsceneManager.selectReplyAtIndex: Not in waiting for pc choice state');\n      return;\n    }\n    this.onReplySelect(reply);\n  }\n\n  /**\n   * Handle the selection of a reply\n   * @param reply - The reply to handle\n   */\n  static onReplySelect(reply: DLGNode) {\n    if (!reply) {\n      this.endConversation();\n      return;\n    }\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      GameState.MenuManager.InGameComputer.setDialogMode(ConversationState.LISTENING_TO_SPEAKER);\n    }else{\n      GameState.MenuManager.InGameDialog.setDialogMode(ConversationState.LISTENING_TO_SPEAKER);\n    }\n    reply.updateJournal();\n    reply.runScripts();\n    const entry = this.getNextEntry(reply.entries);\n    if(entry){\n      this.showEntry(entry);\n    }else{\n      this.endConversation();\n    }\n  }\n\n  /**\n   * Show the replies for a dialog entry\n   * @param entry - The entry to show the replies for\n   */\n  static showReplies(entry: DLGNode) {\n    this.state = ConversationState.WAITING_FOR_PC_CHOICE;\n    this.currentEntry = undefined;\n    this.isListening = false;\n    if (GameState.Mode != EngineMode.DIALOG)\n      return;\n\n    //Get First Reply\n    const reply = this.dialog.getReplyByIndex(entry.replies[0]?.index);\n    if(!reply){\n      log.warn('CutsceneManager.showReplies: No reply found');\n      this.endConversation();\n      return;\n    }\n\n    const isContinueDialog = entry.replies.length == 1 && reply.isContinueDialog();\n    const isEndDialog = entry.replies.length == 1 && reply.isEndDialog();\n\n    //End Dialog\n    if (isEndDialog || !entry.replies.length) {\n      if(!entry.replies.length){\n        log.warn('CutsceneManager.showReplies: No replies found');\n      }\n\n      reply?.runScripts();\n      this.endConversation();\n      return;\n    }\n\n    //Continue Dialog\n    if (isContinueDialog) {\n      reply?.runScripts();\n      const nextEntry = this.getNextEntry(reply.entries);\n      if(nextEntry){\n        this.showEntry(nextEntry);\n      }else{\n        this.endConversation();\n      }\n      return;\n    }\n\n    //Update Speaker Animation State\n    try {\n      if(BitWise.InstanceOfObject(this.getCurrentOwner(), ModuleObjectType.ModuleCreature)){\n        const anim = this.getCurrentOwner().animationConstantToAnimation( ModuleCreatureAnimState.LISTEN )\n        if(anim){\n          this.getCurrentOwner().dialogPlayAnimation(anim);\n        }\n      }\n    } catch (e: unknown) {\n      log.error(e instanceof Error ? e : new Error(String(e)));\n    }\n\n    //Update Listener Animation State\n    try {\n      if(BitWise.InstanceOfObject(this.getCurrentListener(), ModuleObjectType.ModuleCreature)){\n        const anim = this.getCurrentListener().animationConstantToAnimation( ModuleCreatureAnimState.LISTEN )\n        if(anim){\n          this.getCurrentListener().dialogPlayAnimation(anim);\n        }\n      }\n    } catch (e: unknown) {\n      log.error(e instanceof Error ? e : new Error(String(e)));\n    }\n\n    this.setListenerCamera();\n\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      GameState.MenuManager.InGameComputer.setDialogMode(ConversationState.WAITING_FOR_PC_CHOICE);\n    }else{\n      GameState.MenuManager.InGameDialog.setDialogMode(ConversationState.WAITING_FOR_PC_CHOICE);\n    }\n  }\n\n  /**\n   * End the conversation\n   * @param aborted - Whether the conversation was aborted\n   */\n  static endConversation(aborted = false) {\n    this.active = false;\n    if (this.paused) {\n      this.ended = true;\n    }\n    this.audioEmitter.stop();\n    if(this.dialog?.getConversationType() == DLGConversationType.COMPUTER){\n      GameState.MenuManager.InGameComputer.close();\n      // GameState.MenuManager.InGameComputerCam.close();\n      GameState.MenuManager.InGameComputerCam.hide();\n    }else{\n      GameState.MenuManager.InGameDialog.close();\n    }\n    GameState.currentCamera = GameState.camera;\n    this.state = ConversationState.INVALID;\n\n    if(this.dialog){\n      if (this.dialog.animatedCamera instanceof OdysseyModel3D)\n        this.dialog.animatedCamera.animationManager.currentAnimation = undefined;\n      log.debug('CutsceneManager.endConversation: onEndConversation', String(this.dialog.scripts.onEndConversation));\n      if (!aborted) {\n        if(this.dialog.scripts.onEndConversation){\n          this.dialog.scripts.onEndConversation.run(this.owner, 0);\n        }\n      }else{\n        log.debug('CutsceneManager.endConversation: onEndConversationAbort', String(this.dialog.scripts.onEndConversationAbort));\n        if(this.dialog.scripts.onEndConversationAbort){\n          this.dialog.scripts.onEndConversationAbort.run(this.owner, 0);\n        }\n      }\n      this.dialog.releaseStuntActors();\n      if(this.cutsceneMode == CutsceneMode.ANIMATED){\n        GameState.FadeOverlayManager.FadeInFromCutscene();\n      }\n    }\n\n    this.dialog = undefined;\n    GameState.VideoEffectManager.SetVideoEffect(-1);\n    AudioEngine.GetAudioEngine().dialogMusicAudioEmitter.stop();\n  }\n\n  /**\n   * Set the participant animations for an animated cutscene dialog entry\n   * @param entry - The entry to set the participant animations for\n   */\n  static setAnimatedEntryAnimations(entry: DLGNode) {\n    for (let i = 0; i < entry.animations.length; i++) {\n      const participant = entry.animations[i];\n      log.debug('participant', participant);\n      if (this.dialog.stuntActors.has(participant.participant)) {\n        try {\n          const actor = this.dialog.stuntActors.get(participant.participant);\n          if(!actor){ continue; }\n          if(BitWise.InstanceOfObject(actor.moduleObject, ModuleObjectType.ModuleCreature)){\n            const creature = actor.moduleObject as ModuleCreature;\n            const animationName = this.getCUTAnimationName(participant.animation);\n            const odysseyAnimation = actor.animations ? actor.animations.find( a => a.name.toLocaleLowerCase() == animationName.toLocaleLowerCase()) : undefined;\n            if(odysseyAnimation){\n              creature.dialogPlayOdysseyAnimation(odysseyAnimation);\n            }\n          }\n        } catch (e: unknown) {\n          log.error(e instanceof Error ? e : new Error(String(e)));\n        }\n      } else {\n        const actor = GameState.ModuleObjectManager.GetObjectByTag(participant.participant);\n        if(!actor){ continue; }\n        log.debug('actor', actor);\n        if (participant.animation >= 10000) {\n          const anim = actor.animationConstantToAnimation(participant.animation);\n          log.debug('anim', anim);\n          if (anim) {\n            actor.dialogPlayAnimation(anim);\n          } else {\n            log.error('Anim', String(participant.animation));\n          }\n        }else{\n          const anim = this.getDialogAnimation(participant.animation);\n          log.debug('anim', anim);\n          if (anim) {\n            actor.dialogPlayAnimation(anim);\n          } else {\n            log.error('Anim', String(participant.animation));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the participant animations for a normal dialog entry\n   * @param entry - The entry to set the participant animations for\n   */\n  static setEntryAnimations(entry: DLGNode) {\n    //Speaker Animation\n    if (BitWise.InstanceOfObject(this.currentEntry.speaker, ModuleObjectType.ModuleCreature)) {\n      const anim = this.currentEntry.speaker.animationConstantToAnimation( ModuleCreatureAnimState.TALK_NORMAL )\n      if(anim){\n        this.currentEntry.speaker.dialogPlayAnimation(anim);\n      }\n    }\n\n    //Listener Animation\n    if (BitWise.InstanceOfObject(this.currentEntry.listener, ModuleObjectType.ModuleCreature)) {\n      const anim = this.currentEntry.listener.animationConstantToAnimation( ModuleCreatureAnimState.LISTEN )\n      if(anim){\n        this.currentEntry.listener.dialogPlayAnimation(anim);\n      }\n    }\n\n    for (let i = 0; i < entry.animations.length; i++) {\n      const participant = entry.animations[i];\n      if(!participant.participant){ continue; }\n      const actor = GameState.ModuleObjectManager.GetObjectByTag(participant.participant);\n      if(!actor){ continue; }\n      if (participant.animation >= 10000) {\n        const anim = actor.animationConstantToAnimation(participant.animation);\n        if (anim) {\n          actor.dialogPlayAnimation(anim);\n        } else {\n          log.error('Anim', String(participant.animation));\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the CUT animation name\n   * @param index - The index of the animation\n   * @returns The CUT animation name\n   */\n  static getCUTAnimationName(index = 0) {\n    return 'CUT' + ('000' + (index - 1200 + 1)).slice(-3) + 'W';\n  }\n\n  /**\n   * Get the dialog animation\n   * @param index - The index of the animation\n   * @returns The dialog animation\n   */\n  static getDialogAnimation(index = 0): { name: string; looping: string } | undefined {\n    log.debug('GetDialogAnimation', String(index));\n    if (index >= 1000 && index < 1400) {\n      const id = (index - 999);\n      return {\n        name: 'cut' + ('000' + id).slice(-3),\n        looping: '1'\n      };\n    } else if (index >= 1400 && index < 1500) {\n      const id = (index - 1399);\n      return {\n        name: 'cut' + ('000' + id).slice(-3) + 'L',\n        looping: '1'\n      };\n    } else if (index >= 10000) {\n      const animations2DA = GameState.TwoDAManager.datatables.get('animations');\n      if(!animations2DA){ return; }\n\n      switch (index - 10000) {\n        case 30:\n          return animations2DA.rows[18];\n        case 35:\n          return animations2DA.rows[24];\n        case 38:\n          return animations2DA.rows[25];\n        case 39:\n          return animations2DA.rows[27];\n        case 40:\n          return animations2DA.rows[26];\n        case 41:\n          return animations2DA.rows[29];\n        case 42:\n          return animations2DA.rows[28];\n        case 121:\n          return animations2DA.rows[44];\n        case 127:\n          return animations2DA.rows[38];\n        case 403:\n          return animations2DA.rows[462];\n        case 404:\n          return animations2DA.rows[463];\n        case 405:\n          return animations2DA.rows[464];\n        case 406:\n          return animations2DA.rows[465];\n        case 407:\n          return animations2DA.rows[466];\n        case 408:\n          return animations2DA.rows[467];\n        case 409:\n          return animations2DA.rows[468];\n        case 410:\n          return animations2DA.rows[469];\n        case 411:\n          return animations2DA.rows[470];\n        case 412:\n          return animations2DA.rows[471];\n        case 413:\n          return animations2DA.rows[472];\n        case 424:\n          return animations2DA.rows[316];\n        case 425:\n          return animations2DA.rows[317];\n        case 426:\n          return animations2DA.rows[318];\n        case 427:\n          return animations2DA.rows[319];\n        case 428:\n          return animations2DA.rows[320];\n        case 499:\n          return animations2DA.rows[557];\n        case 500:\n          return animations2DA.rows[558];\n        case 501:\n          return animations2DA.rows[559];\n        case 502:\n          return animations2DA.rows[560];\n        case 503:\n          return animations2DA.rows[561];\n        case 504:\n          return animations2DA.rows[562];\n        case 507:\n          return animations2DA.rows[565];\n        case 508:\n          return animations2DA.rows[566];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Set the camera for an entry\n   * @param entry - The entry to set the camera for\n   */\n  static setEntryCamera(entry: DLGNode){\n    const angle = entry.cameraAngle;\n    const cameraID = entry.cameraAnimation > -1 ? entry.cameraAnimation : entry.cameraID;\n    const fov = entry.camFieldOfView;\n    const cameraAnimation = entry.cameraAnimation;\n\n    if ( angle == DLGCameraAngle.ANGLE_ANIMATED_CAMERA || this.dialog.animatedCamera && cameraAnimation > -1 ) {\n      this.setAnimatedCamera(cameraAnimation, fov);\n    } else if (angle == DLGCameraAngle.ANGLE_PLACEABLE_CAMERA) {\n      this.setPlaceableCamera(cameraID);\n    } else {\n      this.setDialogCamera(angle);\n    }\n  }\n\n  /**\n   * Set the camera participants\n   * @param listener - The listener\n   * @param speaker - The speaker\n   */\n  static setCameraParticipants(listener: ModuleObject, speaker: ModuleObject){\n    if (listener != null) {\n      this.cameraState.listener.participant = listener;\n      this.cameraState.listener.position = undefined;\n      this.cameraState.listener.rotation = undefined;\n    }\n    if (speaker != null) {\n      this.cameraState.speaker.participant = speaker;\n      this.cameraState.speaker.position = undefined;\n      this.cameraState.speaker.rotation = undefined;\n    }\n  }\n\n  /**\n   * Set the listener camera\n   */\n  static setListenerCamera(){\n    this.setDialogCamera(DLGCameraAngle.ANGLE_FOCUS_PLAYER);\n    this.setCameraParticipants(this.owner, this.listener);\n  }\n\n  /**\n   * Set the dialog camera\n   * @param nAngle - The angle to set the camera to\n   */\n  static setDialogCamera(nAngle: DLGCameraAngle) {\n    GameState.currentCamera = GameState.camera_dialog;\n    this.cameraState.mode = CameraMode.DIALOG;\n    this.cameraState.cameraAngle =\n      (nAngle == DLGCameraAngle.ANGLE_RANDOM) ? Math.floor(Math.random() * 3) + 1 : nAngle;\n    if (this.currentEntry?.listener != null && this.currentEntry?.speaker != null) {\n      this.setCameraParticipants(this.currentEntry.listener, this.currentEntry.speaker);\n    } else {\n      this.setCameraParticipants(this.owner, this.listener);\n    }\n  }\n\n  /**\n   * Set the placeable camera\n   * @param nCamera - The camera to set\n   */\n  static setPlaceableCamera(nCamera: number) {\n    const cam = GameState.getCameraById(nCamera);\n    if (!cam) {\n      log.warn(`No placeable camera found for camera [${nCamera}] falling back to dialog camera`);\n      this.setDialogCamera(DLGCameraAngle.ANGLE_RANDOM);\n      return;\n    }\n\n    GameState.currentCamera = cam;\n    this.cameraState.mode = CameraMode.PLACEABLE;\n    this.cameraState.cameraID = nCamera;\n    if (this.currentEntry?.listener != null && this.currentEntry?.speaker != null) {\n      this.setCameraParticipants(this.currentEntry.listener, this.currentEntry.speaker);\n    } else {\n      this.setCameraParticipants(this.owner, this.listener);\n    }\n  }\n\n  /**\n   * Set the animated camera\n   * @param nCamera - The camera to set\n   * @param nFOV - The field of view to set\n   */\n  static setAnimatedCamera(nCamera: number, nFOV: number = -1) {\n    if (!this.dialog?.animatedCamera) {\n      log.warn('setAnimatedCamera: no animated camera model, falling back to dialog camera');\n      this.setDialogCamera(DLGCameraAngle.ANGLE_RANDOM);\n      return;\n    }\n    const animationState = this.dialog.animatedCamera.animationManager.createAnimationState();\n    if(nCamera == -1){\n      this.currentEntry.checkList.cameraAnimationComplete = true;\n      this.dialog.animatedCamera.animationManager.currentAnimationState = animationState;\n      log.warn(`No animation found for camera [${nCamera}] falling back to dialog camera`);\n      this.setDialogCamera(DLGCameraAngle.ANGLE_RANDOM);\n      return;\n    }\n\n    if (!(this.dialog.animatedCamera instanceof OdysseyModel3D)) {\n      log.warn(`No animated camera model found for camera [${nCamera}] falling back to dialog camera`);\n      this.setDialogCamera(DLGCameraAngle.ANGLE_RANDOM);\n      return;\n    }\n\n    const animationName = this.getCUTAnimationName(nCamera);\n    const animation = this.dialog.animatedCamera.odysseyAnimationMap.get(animationName.toLowerCase().trim());\n    this.cameraState.currentCameraAnimation = animation;\n    this.cameraState.currentCameraAnimationElapsed = 0;\n    this.dialog.animatedCamera.animationManager.currentAnimation = animation;\n    this.dialog.animatedCamera.animationManager.currentAnimationState = animationState;\n    this.currentEntry.checkList.cameraAnimationComplete = !this.cameraState.currentCameraAnimation;\n    this.cameraState.mode = CameraMode.ANIMATED;\n    GameState.currentCamera = GameState.camera_animated;\n    if (nFOV != -1) {\n      GameState.camera_animated.fov = nFOV;\n    }\n\n    if (this.currentEntry?.listener != null && this.currentEntry?.speaker != null) {\n      this.setCameraParticipants(this.currentEntry.listener, this.currentEntry.speaker);\n    } else {\n      this.setCameraParticipants(this.owner, this.listener);\n    }\n  }\n\n  /**\n   * Update the cutscene manager\n   * @param delta - The delta time\n   */\n  static update(delta: number = 0) {\n    if (!this.dialog)\n      return;\n\n    this.dialog.stuntActors.forEach( async (actor) => {\n      const moduleObject = actor.moduleObject;\n      if(moduleObject){\n        moduleObject.box.setFromObject(moduleObject.container);\n      }\n    });\n\n    this.updateCamera(delta);\n\n    if(this.paused) return;\n\n    if(this.currentEntry){\n      const updateComplete = this.currentEntry.update(delta);\n      if(updateComplete && !this.currentEntry.repliesShown){\n        this.currentEntry.repliesShown = true;\n        this.showReplies(this.currentEntry);\n      }\n    }\n  }\n\n  /**\n   * Update the camera\n   * @param delta - The delta time\n   */\n  static updateCamera(delta: number = 0) {\n    if (!this.dialog || this.cutsceneMode == CutsceneMode.BARK) return;\n\n    if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n      GameState.MenuManager.InGameComputer.show();\n      GameState.MenuManager.InGameComputerCam.hide();\n    }else{\n      GameState.MenuManager.InGameComputerCam.hide();\n    }\n\n    if (this.cameraState.mode == CameraMode.ANIMATED) {\n      this.updateAnimatedCamera(delta);\n      return;\n    }\n\n    if (this.cameraState.mode == CameraMode.PLACEABLE) {\n      this.setPlaceableCamera(this.currentEntry.cameraAnimation > -1 ? this.currentEntry.cameraAnimation : this.currentEntry.cameraID);\n      if(this.dialog.getConversationType() == DLGConversationType.COMPUTER){\n        GameState.MenuManager.InGameComputer.hide();\n        GameState.MenuManager.InGameComputerCam.show();\n      }\n      return;\n    }\n\n    if (this.cameraState.mode == CameraMode.DIALOG) {\n      const listener = this.cameraState.listener;\n      const speaker = this.cameraState.speaker;\n\n      if(!listener.participant || !speaker.participant){\n        return;\n      }\n\n      const listenerNeedsUpdate = (!listener.position || (listener.position.x != listener.participant.position.x && listener.position.y != listener.participant.position.y && listener.position.z != listener.participant.position.z));\n      const speakerNeedsUpdate = (!speaker.position || (speaker.position.x != speaker.participant.position.x && speaker.position.y != speaker.participant.position.y && speaker.position.z != speaker.participant.position.z));\n\n      if(!listenerNeedsUpdate && !speakerNeedsUpdate){\n        return;\n      }\n\n      if(listenerNeedsUpdate){\n        if(!listener.position){\n          listener.position = new THREE.Vector3();\n        }\n        if(!listener.rotation){\n          listener.rotation = new THREE.Vector3();\n        }\n        listener.position.x = listener.participant.position.x;\n        listener.position.y = listener.participant.position.y;\n        listener.position.z = listener.participant.position.z;\n        listener.rotation.x = listener.participant.rotation.x;\n        listener.rotation.y = listener.participant.rotation.y;\n        listener.rotation.z = listener.participant.rotation.z;\n      }\n\n      if(speakerNeedsUpdate){\n        if(!speaker.position){\n          speaker.position = new THREE.Vector3();\n        }\n        if(!speaker.rotation){\n          speaker.rotation = new THREE.Vector3();\n        }\n        speaker.position.x = speaker.participant.position.x;\n        speaker.position.y = speaker.participant.position.y;\n        speaker.position.z = speaker.participant.position.z;\n        speaker.rotation.x = speaker.participant.rotation.x;\n        speaker.rotation.y = speaker.participant.rotation.y;\n        speaker.rotation.z = speaker.participant.rotation.z;\n      }\n\n      switch (this.cameraState.cameraAngle) {\n        case DLGCameraAngle.ANGLE_SPEAKER:\n          this.updateCameraAngleSpeaker(delta);\n          break;\n        case DLGCameraAngle.ANGLE_SPEAKER_BEHIND_PLAYER:\n          this.updateCameraAngleSpeakerBehindPlayer(delta);\n          break;\n        case DLGCameraAngle.ANGLE_SPEAKER_AND_PLAYER_SIDE:\n          this.updateCameraAngleTwoShot(delta);\n          break;\n        case DLGCameraAngle.ANGLE_FOCUS_PLAYER:\n          this.updateListenerCamera(delta);\n          break;\n      }\n      return;\n    }\n  }\n\n  /**\n   * Validate the camera participants are in the same room\n   */\n  static validateCameraParticipants(){\n    const listener = this.cameraState.listener.participant;\n    const speaker = this.cameraState.speaker.participant;\n    if(!listener || !speaker){\n      return false;\n    }\n    if(!listener.room || !speaker.room || (listener?.room !== speaker?.room))\n      return false;\n    return true;\n  }\n\n  /**\n   * Update the animated camera\n   * @param delta - The delta time\n   */\n  static updateAnimatedCamera(delta: number = 0){\n    const cameraModel = this.dialog.animatedCamera;\n    if(!cameraModel){\n      return;\n    }\n\n    const manager = cameraModel.animationManager;\n    if(!manager){\n      return;\n    }\n\n    if(!manager.currentAnimation){\n      this.currentEntry.checkList.cameraAnimationComplete = true;\n      return;\n    }\n    GameState.currentCamera = GameState.camera_animated;\n    manager.update(delta);\n    cameraModel.camerahook.updateMatrixWorld();\n    cameraModel.camerahook.getWorldPosition(GameState.camera_animated.position);\n    GameState.camera_animated.quaternion.copy(cameraModel.camerahook.quaternion);\n    GameState.camera_animated.updateProjectionMatrix();\n    if(!manager.currentAnimation){\n      this.currentEntry.checkList.cameraAnimationComplete = true;\n    }\n  }\n\n  /**\n   * setCameraAngleSpeaker\n   * Speaker front: a standard head-and-shoulders shot of the current speaker.\n   */\n  static updateCameraAngleSpeaker(_delta: number = 0): void {\n    // Get camera positions for both speaker and listener (with camera hooks if available)\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n    const speakerCameraPosition = speaker.getCameraHookPosition();\n    const _listenerCameraPosition = listener.getCameraHookPosition();\n\n    // Fixed distance for close-up head-on shot - not dependent on listener distance\n    const closeUpDistance = 1.2; // Fixed distance for consistent close-up framing\n    const heightOffset = 0; // No height adjustment needed for head-on shot\n\n    // Position camera for head-on close-up speaker shot\n    // Camera positioned directly in front of the speaker based on their rotation\n    const speakerRotation = (speaker.rotation.z + HALF_PI) - SINGLE_SHOT_ANGLE_OFFSET;\n\n    // Calculate camera position based on speaker's facing direction\n    const cameraX = speakerCameraPosition.x + Math.cos(speakerRotation) * closeUpDistance;\n    const cameraY = speakerCameraPosition.y + Math.sin(speakerRotation) * closeUpDistance;\n    const cameraZ = speakerCameraPosition.z + heightOffset;\n\n    // Calculate final camera position - direct frontal shot based on speaker's rotation\n    const cameraPosition = new THREE.Vector3(cameraX, cameraY, cameraZ);\n\n    // Calculate lookAt target - at speaker's eye level for proper framing\n    const lookAtTarget = speakerCameraPosition.clone().add(new THREE.Vector3(0, 0, 0.1)); // Lower lookAt target\n\n    // Set camera position and look at the speaker\n    GameState.camera_dialog.position.copy(cameraPosition);\n    GameState.camera_dialog.lookAt(lookAtTarget);\n  }\n\n  /**\n   * setCameraAngleSpeakerBehindPlayer\n   * Over-the-shoulder: frames the speaker OTS from the listener's side (classic shot-reverse-shot style)\n   * Uses collision detection to prevent camera from clipping through walls\n   * Falls back to setCameraAngleSpeaker if camera would collide with walkmesh\n   */\n  static updateCameraAngleSpeakerBehindPlayer(_delta: number = 0): void {\n    // Get camera positions for both speaker and listener (with camera hooks if available)\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n    const speakerCameraPosition = speaker.getCameraHookPosition();\n    const listenerCameraPosition = listener.getCameraHookPosition();\n\n    // Calculate midpoint between speaker and listener for lookAt target\n    const midpoint = this.getCameraMidPoint(speakerCameraPosition, listenerCameraPosition, 0.5);\n\n    // Calculate distance between participants for adaptive camera positioning\n    const participantDistance = speakerCameraPosition.distanceTo(listenerCameraPosition);\n\n    // Get listener's rotation to position camera behind and to the left\n    const listenerRotation = listener.rotation.z;\n\n    // Adaptive distances to ensure both participants are framed equally\n    const baseBehindDistance = 1.0; // Base distance behind listener\n    const baseLeftDistance = 1.5;   // Base distance to the left of listener\n    const distanceMultiplier = Math.max(0.8, Math.min(1.5, participantDistance * 0.4)); // Scale with participant distance\n\n    let behindDistance = baseBehindDistance * distanceMultiplier;\n    let leftDistance = baseLeftDistance * distanceMultiplier;\n\n    // Calculate initial camera position behind and to the left of listener\n    let cameraX = listenerCameraPosition.x + Math.cos(listenerRotation + Math.PI) * behindDistance + Math.cos(listenerRotation - HALF_PI) * leftDistance;\n    let cameraY = listenerCameraPosition.y + Math.sin(listenerRotation + Math.PI) * behindDistance + Math.sin(listenerRotation - HALF_PI) * leftDistance;\n    const cameraZ = midpoint.z + 0.3; // Slightly above the midpoint for better framing\n\n    // Calculate initial camera position\n    const cameraPosition = new THREE.Vector3(cameraX, cameraY, cameraZ);\n\n    // Adjust camera distance based on collision detection (similar to FollowerCamera)\n    const adjustedDistance = this.adjustCameraDistanceForCollision(cameraPosition, listenerCameraPosition, behindDistance);\n\n    // Recalculate camera position with adjusted distance\n    if (adjustedDistance < behindDistance) {\n      this.cameraState.cameraAngle = DLGCameraAngle.ANGLE_SPEAKER;\n      this.updateCameraAngleSpeaker();\n      return;\n      const scaleFactor = adjustedDistance / behindDistance;\n      behindDistance = adjustedDistance;\n      leftDistance *= scaleFactor;\n\n      cameraX = listenerCameraPosition.x + Math.cos(listenerRotation + Math.PI) * behindDistance + Math.cos(listenerRotation - HALF_PI) * leftDistance;\n      cameraY = listenerCameraPosition.y + Math.sin(listenerRotation + Math.PI) * behindDistance + Math.sin(listenerRotation - HALF_PI) * leftDistance;\n      cameraPosition.set(cameraX, cameraY, cameraZ);\n    }\n\n    // Set camera position and look at the midpoint between speaker and listener\n    GameState.camera_dialog.position.copy(cameraPosition);\n    GameState.camera_dialog.lookAt(midpoint);\n  }\n\n  /**\n   * setCameraAngleTwoShot\n   * True two-shot: frames both speaker and listener in a wide conversational view\n   * Camera positioned to show both participants with proper framing and distance\n   * Falls back to setCameraAngleSpeakerBehindPlayer if camera would collide with walkmesh\n   */\n  static updateCameraAngleTwoShot(_delta: number = 0): void {\n    // Get speaker and listener positions with camera height\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n    const speakerPos = speaker.position.clone().add(new THREE.Vector3(0, 0, speaker.getCameraHeight()));\n    const listenerPos = listener.position.clone().add(new THREE.Vector3(0, 0, listener.getCameraHeight()));\n\n    // Calculate midpoint between speaker and listener\n    const midpoint = this.getCameraMidPoint(speakerPos, listenerPos, 0.5);\n\n    // Calculate direction from listener to speaker\n    const direction = speakerPos.clone().sub(listenerPos).normalize();\n\n    // Calculate perpendicular direction for camera positioning\n    const perpendicular = new THREE.Vector3(-direction.y, direction.x, 0).normalize();\n\n    // Calculate distance between participants\n    const participantDistance = speakerPos.distanceTo(listenerPos);\n\n    // Determine camera distance based on participant separation\n    // Minimum 2.5 units, maximum 10 units, or 1.2x their distance\n    const minDistance = 2.5;\n    const maxDistance = 10.0;\n    const multiplier = 1.2;\n    const cameraDistance = Math.max(minDistance, Math.min(maxDistance, participantDistance * multiplier));\n\n    // Position camera to the side of both participants\n    const cameraPosition = midpoint.clone()\n      .add(perpendicular.multiplyScalar(cameraDistance))\n      .add(new THREE.Vector3(0, 0, 0)); // Slightly elevated for better framing\n\n    // Check for walkmesh collision before setting camera position\n    if (!this.validateCameraParticipants() || this.checkCameraCollision(cameraPosition, speaker.position)) {\n      // Fall back to over-the-shoulder shot if collision detected\n      this.cameraState.cameraAngle = DLGCameraAngle.ANGLE_SPEAKER_BEHIND_PLAYER;\n      this.updateCameraAngleSpeakerBehindPlayer();\n      return;\n    }\n\n    // Calculate lookAt target - slightly biased toward the speaker\n    const speakerBias = 0.5; // 50% bias toward speaker\n    const lookAtTarget = this.getCameraMidPoint(listenerPos, speakerPos, speakerBias)\n      .add(new THREE.Vector3(0, 0, -0.5)); // Slightly above midpoint\n\n    // Set camera position and lookAt\n    GameState.camera_dialog.position.copy(cameraPosition);\n    GameState.camera_dialog.lookAt(lookAtTarget);\n  }\n\n  /**\n   * Update the listener camera\n   * @param delta - The delta time\n   */\n  static updateListenerCamera(_delta: number = 0): void {\n    // Get camera positions for both speaker and listener (with camera hooks if available)\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n    const speakerCameraPosition = speaker.getCameraHookPosition();\n    const _listenerCameraPosition = listener.getCameraHookPosition();\n\n    // Fixed distance for close-up head-on shot - not dependent on listener distance\n    const closeUpDistance = 1.2; // Fixed distance for consistent close-up framing\n    const heightOffset = 0; // No height adjustment needed for head-on shot\n\n    // Position camera for head-on close-up speaker shot\n    // Camera positioned directly in front of the speaker based on their rotation\n    const speakerRotation = (speaker.rotation.z + HALF_PI) + SINGLE_SHOT_ANGLE_OFFSET;\n\n    // Calculate camera position based on speaker's facing direction\n    const cameraX = speakerCameraPosition.x + Math.cos(speakerRotation) * closeUpDistance;\n    const cameraY = speakerCameraPosition.y + Math.sin(speakerRotation) * closeUpDistance;\n    const cameraZ = speakerCameraPosition.z + heightOffset;\n\n    // Calculate final camera position - direct frontal shot based on speaker's rotation\n    const cameraPosition = new THREE.Vector3(cameraX, cameraY, cameraZ);\n\n    // Calculate lookAt target - at speaker's eye level for proper framing\n    const lookAtTarget = speakerCameraPosition.clone().add(new THREE.Vector3(0, 0, 0.1)); // Lower lookAt target\n\n    // Set camera position and look at the speaker\n    GameState.camera_dialog.position.copy(cameraPosition);\n    GameState.camera_dialog.lookAt(lookAtTarget);\n  }\n\n  static #tmpMPVec3 = new THREE.Vector3();\n  /**\n   * Get the camera midpoint\n   * @param pointA - The first point\n   * @param pointB - The second point\n   * @param percentage - The percentage to use\n   * @returns The camera midpoint\n   */\n  static getCameraMidPoint(pointA: THREE.Vector3, pointB: THREE.Vector3, percentage = 0.5): THREE.Vector3 {\n    // Calculate midpoint without cloning - more efficient\n    this.#tmpMPVec3.x = pointA.x + (pointB.x - pointA.x) * percentage;\n    this.#tmpMPVec3.y = pointA.y + (pointB.y - pointA.y) * percentage;\n    this.#tmpMPVec3.z = pointA.z + (pointB.z - pointA.z) * percentage;\n\n    return this.#tmpMPVec3;\n  }\n\n  /**\n   * checkCameraCollision\n   * Checks if a camera position would collide with walkmesh geometry\n   * @param cameraPosition - The proposed camera position\n   * @param targetPosition - The target position to look at (for ray direction)\n   * @returns true if collision detected, false otherwise\n   */\n  static checkCameraCollision(cameraPosition: THREE.Vector3, targetPosition: THREE.Vector3): boolean {\n    if (!GameState.module?.area) {\n      return false;\n    }\n\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n\n    if(!speaker.room || !listener.room || (speaker.room !== listener.room)){\n      return false;\n    }\n\n    const area = GameState.module.area;\n    const raycaster = GameState.raycaster;\n\n    // Calculate direction from camera to target\n    const direction = targetPosition.clone().sub(cameraPosition).normalize();\n\n    // Set up raycaster for collision detection\n    raycaster.set(cameraPosition, direction);\n    raycaster.far = cameraPosition.distanceTo(targetPosition);\n\n    // Collect walkmesh faces for collision testing\n    type AabbFacesEntry = { object: { collisionManager: { walkmesh: { faces: unknown[]; raycast: (r: THREE.Raycaster, f: unknown[]) => { distance: number }[] } } }; faces: unknown[] };\n    const aabbFaces: AabbFacesEntry[] = [];\n\n    // Add room walkmesh faces\n    if (speaker.room?.collisionManager?.walkmesh?.aabbNodes?.length) {\n      aabbFaces.push({\n        object: speaker.room,\n        faces: speaker.room.collisionManager.walkmesh.faces\n      });\n    }\n\n    if (listener.room !== speaker.room) {\n      if (listener.room?.collisionManager?.walkmesh?.aabbNodes?.length) {\n        aabbFaces.push({\n          object: listener.room,\n          faces: listener.room.collisionManager.walkmesh.faces\n        });\n      }\n    }\n\n    // Add door walkmesh faces (closed doors only)\n    for (let j = 0, jl = area.doors.length; j < jl; j++) {\n      const door = area.doors[j];\n      if (door?.collisionManager?.walkmesh && !door.isOpen()) {\n        aabbFaces.push({\n          object: door,\n          faces: door.collisionManager.walkmesh.faces\n        });\n      }\n    }\n\n    // Test for collisions\n    for (let k = 0, kl = aabbFaces.length; k < kl; k++) {\n      const castableFaces = aabbFaces[k];\n      const intersects = castableFaces.object.collisionManager.walkmesh.raycast(raycaster, castableFaces.faces) || [];\n\n      if (intersects.length > 0) {\n        // Check if any intersection is close to the camera position\n        for (let i = 0; i < intersects.length; i++) {\n          const intersect = intersects[i];\n          // If intersection is very close to camera position, consider it a collision\n          if (intersect.distance < 0.5) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * adjustCameraDistanceForCollision\n   * Adjusts camera distance based on walkmesh collision detection (similar to FollowerCamera)\n   * @param cameraPosition - The proposed camera position\n   * @param targetPosition - The target position to look at\n   * @param maxDistance - The maximum desired distance\n   * @returns The adjusted distance (may be less than maxDistance if collision detected)\n   */\n  static adjustCameraDistanceForCollision(cameraPosition: THREE.Vector3, targetPosition: THREE.Vector3, maxDistance: number): number {\n    if (!GameState.module?.area) {\n      return maxDistance;\n    }\n\n    const speaker = this.cameraState.speaker.participant;\n    const listener = this.cameraState.listener.participant;\n\n    const area = GameState.module.area;\n    const raycaster = GameState.raycaster;\n\n    // Calculate direction from target to camera\n    const direction = cameraPosition.clone().sub(targetPosition).normalize();\n\n    // Set up raycaster for collision detection\n    raycaster.set(targetPosition, direction);\n    raycaster.far = maxDistance;\n\n    // Collect walkmesh faces for collision testing\n    type AabbFacesEntryAdj = { object: { collisionManager: { walkmesh: { faces: unknown[]; raycast: (r: THREE.Raycaster, f: unknown[]) => { distance: number }[] } } }; faces: unknown[] };\n    const aabbFaces: AabbFacesEntryAdj[] = [];\n\n    // Add room walkmesh faces\n    if (speaker.room?.collisionManager?.walkmesh?.aabbNodes?.length) {\n      aabbFaces.push({\n        object: speaker.room,\n        faces: speaker.room.collisionManager.walkmesh.faces\n      });\n    }\n\n    if (listener.room !== speaker.room) {\n      if (listener.room?.collisionManager?.walkmesh?.aabbNodes?.length) {\n        aabbFaces.push({\n          object: listener.room,\n          faces: listener.room.collisionManager.walkmesh.faces\n        });\n      }\n    }\n\n    // Add door walkmesh faces (closed doors only)\n    for (let j = 0, jl = area.doors.length; j < jl; j++) {\n      const door = area.doors[j];\n      if (door?.collisionManager?.walkmesh && !door.isOpen()) {\n        aabbFaces.push({\n          object: door,\n          faces: door.collisionManager.walkmesh.faces\n        });\n      }\n    }\n\n    // Test for collisions and adjust distance (similar to FollowerCamera logic)\n    let adjustedDistance = maxDistance;\n\n    for (let k = 0, kl = aabbFaces.length; k < kl; k++) {\n      const castableFaces = aabbFaces[k];\n      const intersects = castableFaces.object.collisionManager.walkmesh.raycast(raycaster, castableFaces.faces) || [];\n\n      if (intersects.length > 0) {\n        for (let i = 0; i < intersects.length; i++) {\n          const intersect = intersects[i];\n          // If intersection is closer than current distance, adjust it (with 0.75 multiplier like FollowerCamera)\n          if (intersect.distance < adjustedDistance) {\n            adjustedDistance = intersect.distance * 0.75;\n          }\n        }\n      }\n    }\n\n    return adjustedDistance;\n  }\n\n  static #eventListeners: Map<string, CutsceneEventListener[]> = new Map();\n  static addEventListener(type: string, listener: CutsceneEventListener): void {\n    let listeners = this.#eventListeners.get(type);\n    if(!listeners){\n      listeners = [];\n      this.#eventListeners.set(type, listeners);\n    }\n    if(listeners.indexOf(listener) !== -1){\n      return;\n    }\n    listeners.push(listener);\n  }\n\n  static removeEventListener(type: string, listener: CutsceneEventListener): void {\n    const listeners = this.#eventListeners.get(type);\n    if(!listeners || listeners.indexOf(listener) !== -1){\n      return;\n    }\n    if(listeners){\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n  }\n\n  static dispatchEvent(type: string, ...args: (string | number | boolean | object)[]): void {\n    const listeners = this.#eventListeners.get(type);\n    if(listeners){\n      listeners.forEach(listener => listener(...args));\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\GlobalVariableManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":31,"column":55,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":31,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":31,"column":55,"nodeType":"MemberExpression","messageId":"errorCall","endLine":31,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":34,"column":56,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":34,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":34,"column":56,"nodeType":"MemberExpression","messageId":"errorCall","endLine":34,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":37,"column":54,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":37,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":37,"column":54,"nodeType":"MemberExpression","messageId":"errorCall","endLine":37,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":40,"column":54,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":40,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":40,"column":54,"nodeType":"MemberExpression","messageId":"errorCall","endLine":40,"endColumn":79}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import EngineLocation from \"@/engine/EngineLocation\";\r\nimport { IEngineGlobals } from \"@/interface/engine/IEngineGlobals\";\nimport { TwoDAManager } from \"@/managers/TwoDAManager\";\r\n\r\n/**\r\n * GlobalVariableManager class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file GlobalVariableManager.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class GlobalVariableManager {\r\n\r\n  static Globals: IEngineGlobals = {\r\n    Boolean   : new Map(), \r\n    Number    : new Map(), \r\n    String    : new Map(), \r\n    Location  : new Map(), \r\n  };\r\n  \r\n  public static Init(){\r\n    const _initGlobals = TwoDAManager.datatables.get('globalcat').rows;\r\n    for (const key in _initGlobals) {\r\n      if (_initGlobals.hasOwnProperty(key)) {\r\n        const globItem = _initGlobals[key];\r\n\r\n        switch(globItem.type){\r\n          case 'Boolean':\r\n            GlobalVariableManager.Globals.Boolean.set(globItem.name.toLowerCase(), {name: globItem.name, value: false});\r\n          break;\r\n          case 'Location':\r\n            GlobalVariableManager.Globals.Location.set(globItem.name.toLowerCase(), {name: globItem.name, value: new EngineLocation()});\r\n          break;\r\n          case 'Number':\r\n            GlobalVariableManager.Globals.Number.set(globItem.name.toLowerCase(), {name: globItem.name, value: 0});\r\n          break;\r\n          case 'String':\r\n            GlobalVariableManager.Globals.String.set(globItem.name.toLowerCase(), {name: globItem.name, value: ''});\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  public static SetGlobalBoolean(name = '', value = false){\r\n    const key = GlobalVariableManager.Globals.Boolean.get(name.toLocaleLowerCase());\r\n    if(key){\r\n      key.value = value ? true : false;\r\n    }\r\n  }\r\n\r\n  public static GetGlobalBoolean(name = ''): boolean {\r\n    const key = GlobalVariableManager.Globals.Boolean.get(name.toLocaleLowerCase());\r\n    if(key){\r\n      return key.value ? true : false;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public static SetGlobalNumber(name:string = '', value:number = 0){\r\n    const key = GlobalVariableManager.Globals.Number.get(name.toLocaleLowerCase());\r\n    if(key){\r\n      key.value = Math.floor(value);\r\n    }\r\n  }\r\n\r\n  public static GetGlobalNumber(name:string = ''): number {\r\n    const key = GlobalVariableManager.Globals.Number.get(name.toLocaleLowerCase());\r\n    if(key) return key.value;\r\n\r\n    return 0;\r\n  }\r\n\r\n  public static SetGlobalString(name:string = '', value: string = ''){\r\n    const key = GlobalVariableManager.Globals.String.get(name.toLocaleLowerCase());\r\n    if(key){\r\n      key.value = value;\r\n    }\r\n  }\r\n\r\n  public static GetGlobalString(name:string = ''): string {\r\n    const key = GlobalVariableManager.Globals.String.get(name.toLocaleLowerCase());\r\n    if(key) return key.value;\r\n\r\n    return '';\r\n  }\r\n\r\n  public static SetGlobalLocation(name = '', value = new EngineLocation){\r\n    const key = GlobalVariableManager.Globals.Location.get(name.toLocaleLowerCase());\r\n    if(key && value instanceof EngineLocation)\r\n      key.value = value;\r\n  }\r\n\r\n  public static GetGlobalLocation(name = ''): EngineLocation {\r\n    const key = GlobalVariableManager.Globals.Location.get(name.toLocaleLowerCase());\r\n    if(key) return key.value;\r\n\r\n    return new EngineLocation;\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\LightManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":70,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":70,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":71,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":71,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .remove on a type that cannot be resolved.","line":71,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":71,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":71,"column":66,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":71,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":75,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":75,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":76,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":76,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .remove on a type that cannot be resolved.","line":76,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":76,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":76,"column":80,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":76,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":80,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":80,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":81,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":81,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .remove on a type that cannot be resolved.","line":81,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":81,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .children on a type that cannot be resolved.","line":81,"column":80,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":81,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":91,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":91,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on a type that cannot be resolved.","line":91,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":91,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":98,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":98,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on a type that cannot be resolved.","line":98,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":98,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":109,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":109,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on a type that cannot be resolved.","line":109,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":109,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":116,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":116,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .add on a type that cannot be resolved.","line":116,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":116,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":241,"column":100,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":241,"endColumn":136},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uuid on an `any` value.","line":241,"column":132,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":241,"endColumn":136},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":242,"column":30,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":242,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .uuid on an `any` value.","line":242,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":242,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":329,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":329,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Object3D<Object3DEventMap>`.","line":331,"column":27,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":331,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":349,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":349,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isAnimated on an `any` value.","line":350,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":350,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":353,"column":37,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":353,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":353,"column":37,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":353,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getRadius on an `any` value.","line":353,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":353,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":424,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":424,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":425,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":425,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":428,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":428,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":445,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":445,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":446,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":446,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":483,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":483,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":484,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":484,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":509,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":509,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":510,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":510,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":648,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":648,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":649,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":649,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":652,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":652,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":667,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":667,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":668,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":668,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":683,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":683,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":684,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":684,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":699,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":699,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":700,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":700,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":752,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":752,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":752,"column":82,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":752,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .visible on a type that cannot be resolved.","line":756,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":756,"endColumn":45}],"suppressedMessages":[],"errorCount":52,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { OdysseyLight3D } from \"@/three/odyssey\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Manager);\nimport type { ModuleObject } from \"@/module\";\r\n\r\ninterface IOdysseyAnimatedLightUniformStruct {\r\n  position: THREE.Vector3;\r\n  color: THREE.Color;\r\n  distance: number;\r\n  decay: number;\r\n}\r\n\r\n/**\r\n * LightManager class.\r\n * \r\n * The LightManager class is currently used for dynamic lighting on objects like doors, placeables, creatures, and more. \r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file LightManager.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class LightManager {\r\n  static MAXLIGHTS = 8; //NumDynamicLights row in videoquality.2da\r\n  static MAXSHADOWLIGHTS = 3; //NumShadowCastingLights row in videoquality.2da\r\n  static DECAY = 1;\r\n  spawned = 0;\r\n  spawned_shadow = 0;\r\n  light_pool: THREE.PointLight[] = [];\r\n  shadow_pool: THREE.PointLight[] = [];\r\n  modelLightCounter: Record<string, number> = {};\r\n  shadowLightCounter: Record<string, number> = {};\r\n  lights: OdysseyLight3D[] = [];\r\n  tmpLights: OdysseyLight3D[];\r\n  lightsShown: Set<string>;\r\n  new_lights: OdysseyLight3D[];\r\n  new_lights_uuids: string[];\r\n  new_lights_spawned: number;\r\n\r\n  animatedLights: IOdysseyAnimatedLightUniformStruct[] = [];\r\n  animatedLightsCacheID: number = 0;\r\n\r\n  context: Record<string, unknown>;\r\n\r\n  init(context: Record<string, unknown>): void {\r\n    this.context = context;\r\n    LightManager.MAXLIGHTS = 8; //NumDynamicLights row in videoquality.2da\r\n    LightManager.MAXSHADOWLIGHTS = 3; //NumShadowCastingLights row in videoquality.2da\r\n    this.spawned = 0;\r\n    this.light_pool = [];\r\n    this.clearLights();\r\n  }\r\n\r\n  clearLights(){\r\n    //Each loop this will hold a counter per model that is trying to display lights. \r\n    //When that model has shown a max of 3 lights the rest will be ignored for that loop\r\n    this.modelLightCounter = {};\r\n    this.shadowLightCounter = {};\r\n    this.lights = [];\r\n    this.spawned = 0;\r\n    this.spawned_shadow = 0;\r\n    this.light_pool = [];\r\n    this.shadow_pool = [];\r\n\r\n    //Clear lights\r\n    while (this.context.group.lights.children.length){\r\n      this.context.group.lights.remove(this.context.group.lights.children[0]);\r\n    }\r\n\r\n    //Clear light helpers\r\n    while (this.context.group.light_helpers.children.length){\r\n      this.context.group.light_helpers.remove(this.context.group.light_helpers.children[0]);\r\n    }\r\n\r\n    //Clear shadow lights\r\n    while (this.context.group.shadow_lights.children.length){\r\n      this.context.group.shadow_lights.remove(this.context.group.shadow_lights.children[0]);\r\n    }\r\n\r\n\r\n    //Point Lights\r\n    for(let i = 0; i < LightManager.MAXLIGHTS; i++){\r\n      \r\n      const light = new THREE.PointLight( 0xFFFFFF, 0, 0, 1 );\r\n      light.userData.animated = 0;\r\n      light.userData.reclaimed = true;\r\n      this.context.group.lights.add(light);\r\n      const helper = new THREE.PointLightHelper( light, 1 );\r\n      light.visible = light.userData.helper = true;\r\n      helper.color = light.color;\r\n      light.userData.helper = helper;\r\n\r\n      this.light_pool.push( light );\r\n      this.context.group.light_helpers.add( helper );\r\n\r\n    }\r\n\r\n    //Shadow Lights\r\n    for(let i = 0; i < LightManager.MAXSHADOWLIGHTS; i++){\r\n      \r\n      const light = new THREE.PointLight( 0xFFFFFF, 0, 0, 1 );\r\n      light.castShadow = true;\r\n      light.userData.animated = 0;\r\n      light.userData.reclaimed = true;\r\n      this.context.group.shadow_lights.add(light);\r\n      const helper = new THREE.PointLightHelper( light, 1 );\r\n      light.visible = light.userData.helper = true;\r\n      helper.color = light.color;\r\n      light.userData.helper = helper;\r\n\r\n      this.shadow_pool.push( light );\r\n      this.context.group.light_helpers.add( helper );\r\n\r\n    }\r\n\r\n    //Ambient Lights\r\n    /*for(let i = 0; i < LightManager.MAXLIGHTS; i++){\r\n      let amb_light = new THREE.AmbientLight( 0xFFFFFF );\r\n      amb_light.reclaimed = true;\r\n      this.context.group.lights.add(amb_light);\r\n      let helper = new THREE.PointLightHelper( amb_light, 1 );\r\n      amb_light.visible = amb_light.helper = true;\r\n\r\n      amb_light.helper = helper;\r\n\r\n      this.ambient_light_pool.push( amb_light );\r\n      this.context.group.light_helpers.add( helper );\r\n    }*/\r\n    \r\n  }\r\n\r\n  //Add a OdysseyLight3D to the LightManager\r\n  addLight(light: OdysseyLight3D){\r\n    //return;\r\n    if(light){\r\n      //this.lights[light.priority].push(light);\r\n      this.lights.push(light);\r\n      light.getWorldPosition(light.worldPosition);\r\n      //this.lights[0].push(light);\r\n    }\r\n  }\r\n\r\n  //Remove a OdysseyLight3D from the LightManager\r\n  removeLight(light: OdysseyLight3D){\r\n    if(light){\r\n      const idx = this.lights.indexOf(light);\r\n      if(idx >= 0){\r\n        this.lights.splice(idx, 1);\r\n        //If the light is currently attached to an active light, remove the reference so it will be reassigned\r\n        for(let i = 0; i < this.light_pool.length; i++){\r\n          if(this.light_pool[i].userData.odysseyLight == light)\r\n            this.light_pool[i].userData.odysseyLight = undefined;\r\n        }\r\n        //If the light is currently attached to an active shadow light, remove the reference so it will be reassigned\r\n        for(let i = 0; i < this.shadow_pool.length; i++){\r\n          if(this.shadow_pool[i].userData.odysseyLight == light)\r\n            this.shadow_pool[i].userData.odysseyLight = undefined;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getFrameLights(){\r\n\r\n\r\n\r\n  }\r\n\r\n  update(delta = 0, target: THREE.Camera|ModuleObject){\r\n    if(!target) return;\r\n    \r\n    for(let i = 0, il = this.lights.length; i < il; i++){\r\n      const light = this.lights[i];\r\n      light.getWorldPosition(light.worldPosition);\r\n      light.cameraDistance = target.position.distanceTo(light.worldPosition);\r\n    }\r\n\r\n    //This object is to store the amount of lights that have tried to spawn per parent object\r\n    //Since only 3 lights can be on at any given time per object only the first 3 that try to spawn will do so\r\n    //This is reset every tick like so \r\n    this.modelLightCounter = {};\r\n    this.updateDynamicLights(delta);\r\n\r\n    //This object is to store the amount of lights that have tried to spawn per parent object\r\n    //Since only 3 lights can be on at any given time per object only the first 3 that try to spawn will do so\r\n    //This is reset every tick like so \r\n    //this.modelLightCounter = {};\r\n    //this.updateShadowLights(delta);\r\n\r\n  }\r\n\r\n  updateDynamicLights(delta = 0){\r\n    this.animatedLights = [];\r\n    this.tmpLights = [];//this.lights.slice();\r\n    //let ambientLights = this.lights.filter(light => light.odysseyModel.visible && (light.isAmbient || (light.odysseyModelNode.radius*light.odysseyModelNode.multiplier) > 50));\r\n    //let shadowLights = this.lights.filter(light => light.odysseyModel.visible && light.castShadow);\r\n    const fadingLights = this.lights.filter(light => light.odysseyModel.visible);\r\n    \r\n    //ambientLights.sort(this.sortLights).reverse();\r\n    //shadowLights.sort(this.sortLights);\r\n    fadingLights.sort(this.sortLights);\r\n\r\n    //this.tmpLights = this.tmpLights.concat(ambientLights, fadingLights);\r\n    //this.tmpLights = this.tmpLights.concat(fadingLights);\r\n    \r\n    //Attempt to reclaim lights that are no longer used\r\n    this.lightsShown = new Set<string>();\r\n    this.reclaimLights(delta);\r\n    //log.info(this.lightsShown);\r\n    this.new_lights = [];\r\n    this.new_lights_uuids = [];\r\n    this.new_lights_spawned = 0;\r\n\r\n    //Get the lights that are trying to spawn this frame\r\n    for( let i = 0, il = fadingLights.length; i < il; i++ ){\r\n\r\n      const light = fadingLights[i];\r\n\r\n      if(!this.canShowLight(light))\r\n        continue;\r\n\r\n      if(this.new_lights_spawned >= LightManager.MAXLIGHTS)\r\n        break;\r\n      \r\n\r\n      if(this.new_lights_uuids.indexOf(light.uuid) == -1){\r\n        this.new_lights.push(light);\r\n        this.new_lights_uuids.push(light.uuid);\r\n        this.new_lights_spawned++;\r\n      }\r\n      \r\n    }\r\n\r\n    //Last ditch effort to make sure lights don't get duplicated\r\n    for(let i = 0, il = LightManager.MAXLIGHTS; i < il; i++){\r\n      const lightNode = this.light_pool[i];\r\n      if(!lightNode.userData.reclaimed && lightNode.userData.odysseyLight && !this.lightsShown.has(lightNode.userData.odysseyLight.uuid)){\r\n        this.lightsShown.add(lightNode.userData.odysseyLight.uuid);\r\n      }\r\n    }\r\n    \r\n    //log.info(this.new_lights_uuids, this.new_lights.length);\r\n    \r\n    //Try to update lights with the pool of reclaimed lights\r\n    for( let i = 0, il = this.new_lights.length; i < il; i++ ){\r\n\r\n      //Break the loop if we have already meet our maximum light count\r\n      if(this.spawned >= LightManager.MAXLIGHTS)\r\n        break;\r\n\r\n      const odysseyLight = this.new_lights[i];\r\n      let lightNode = undefined;//this.light_pool[this.spawned];\r\n      for(let i2 = 0, il2 = LightManager.MAXLIGHTS; i2 < il2; i2++){\r\n        if(this.light_pool[i2].userData.reclaimed == true){\r\n          lightNode = this.light_pool[i2];\r\n          break;\r\n        }\r\n      }\r\n\r\n\r\n      //The only way this wouldn't be true is if we have a different number of lights in our light_pool than the\r\n      //engine maximum light number which should be 8 most of the time.\r\n      //The number of allocated lights should always match MAXLIGHTS.\r\n      if(lightNode){\r\n        \r\n        //If the light isn't already being shown\r\n        if(!this.lightsShown.has(odysseyLight.uuid)){\r\n\r\n          /////////////////////////////////////\r\n          // LIGHT SHADOWS NEED OPTIMIZATION\r\n          // SEE COMMENT BELOW\r\n          /////////////////////////////////////\r\n\r\n          //Setting the castShadow property causes major frame drops in some cases.\r\n          //This will need to be investigated and optimized at some point in the future.\r\n          //For now I am disabling it.\r\n          //lightNode.castShadow = light.castShadow;\r\n          lightNode.castShadow = false;\r\n\r\n          //Set Light Properties By Type\r\n          // if(odysseyLight.isAmbient && odysseyLight.getRadius() > 150){\r\n          //   //Ambient light flags don't seem to reliably point to a usage of THREE.AmbientLight per se as some game modules seem to produce PointLight effects in the original game\r\n          //   //Like the red hangar lights in the Tatooine Docking Bay. The turret MiniGame uses this flag for one of the lights and seems to produce\r\n          //   //an AmbientLight effect in the original game. There must be another flag or property that differentiates the two cases that I am missing\r\n          //   lightNode.userData.isPointLight = false;\r\n          //   lightNode.userData.isAmbientLight = true;\r\n          //   lightNode.type = 'AmbientLight';\r\n          //   lightNode.intensity = 0.5;\r\n          //   lightNode.userData.helper.material.opacity = 1;\r\n          //   //lightNode.distance = Infinity;\r\n          // }else{\r\n            lightNode.userData.isPointLight = true;\r\n            lightNode.userData.isAmbientLight = false;\r\n            lightNode.type = 'PointLight';\r\n\r\n            if(odysseyLight.isFading){\r\n              lightNode.intensity = 0;\r\n            }else{\r\n              lightNode.intensity = 1;\r\n            }\r\n            \r\n            lightNode.distance = odysseyLight.getRadius();\r\n          // }\r\n\r\n          //Set Common Light Properties\r\n          odysseyLight.position.set(0, 0, 0)\r\n          odysseyLight.getWorldPosition(lightNode.position)\r\n          lightNode.color.r = odysseyLight.color.r;\r\n          lightNode.color.g = odysseyLight.color.g;\r\n          lightNode.color.b = odysseyLight.color.b;\r\n          lightNode.decay = LightManager.DECAY;\r\n          \r\n          lightNode.updateMatrix();\r\n          lightNode.userData.odysseyLight = odysseyLight;\r\n          lightNode.userData.animated = odysseyLight.isAnimated ? 1 : 0;\r\n          lightNode.userData.lightUUID = odysseyLight.uuid;\r\n          this.lightsShown.add(odysseyLight.uuid);\r\n\r\n          if(lightNode.userData.lensFlare != odysseyLight.userData.lensFlare){\r\n            while(lightNode.children.length){\r\n              lightNode.remove(lightNode.children[0]);\r\n            }\r\n          }\r\n          \r\n          lightNode.userData.lensFlare = odysseyLight.userData.lensFlare;\r\n          if(lightNode.userData.lensFlare){\r\n            lightNode.add(lightNode.userData.lensFlare);\r\n          }\r\n\r\n          //Increment the spawn count\r\n          this.spawned++;\r\n          lightNode.userData.reclaimed = false;\r\n        }\r\n\r\n      }\r\n      \r\n    }\r\n\t\t// artist-friendly light intensity scaling factor\r\n\t\tconst scaleFactor = ( this.context?.renderer?.physicallyCorrectLights !== true ) ? Math.PI : 1;\r\n\r\n    let animatedLightsNeedUpdate = false;\r\n    let animatedLightIndex = 0;\r\n    for( let i = 0, il = this.light_pool.length; i < il; i++ ){\r\n      const lightNode = this.light_pool[i];\r\n      const light = this.light_pool[i].userData.odysseyLight;\r\n      if(!light || !light.isAnimated){ continue; }\r\n\r\n      lightNode.decay = LightManager.DECAY;\r\n      lightNode.distance = Math.abs(light.getRadius());\r\n      //lightNode.intensity = 1;//light.getIntensity();// * ((lightNode.color.r + lightNode.color.g + lightNode.color.b) / 3);\r\n      //log.info(lightNode.distance);\r\n      \r\n      const animatedLight: IOdysseyAnimatedLightUniformStruct = {\r\n        position: lightNode.position,\r\n        color: lightNode.color.clone().copy(lightNode.color).multiplyScalar( lightNode.intensity * scaleFactor ),\r\n        distance: lightNode.distance,\r\n        decay: lightNode.decay\r\n      };\r\n\r\n      const currentAnimatedLight = this.animatedLights[animatedLightIndex];\r\n      if(currentAnimatedLight && currentAnimatedLight.position.equals(animatedLight.position) && currentAnimatedLight.color.equals(animatedLight.color) && currentAnimatedLight.distance === animatedLight.distance && currentAnimatedLight.decay === animatedLight.decay){\r\n        continue;\r\n      }\r\n      this.animatedLights[animatedLightIndex] = animatedLight;\r\n      animatedLightsNeedUpdate = true;\r\n      animatedLightIndex++;\r\n    }\r\n    const diffLightCount = !!(this.animatedLights.length - animatedLightIndex);\r\n    this.animatedLights.length = animatedLightIndex;\r\n    if(animatedLightsNeedUpdate || diffLightCount){\r\n      this.animatedLightsCacheID++;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Try to reclaim unused lights and update spawned fading lights\r\n   * @param delta \r\n   */\r\n  reclaimLights(delta = 0){\r\n\r\n    this.spawned = 0;\r\n\r\n    const lightsUsed: Set<string> = new Set<string>();\r\n\r\n    const maxLights = LightManager.MAXLIGHTS;\r\n    for(let i = 0; i < maxLights; i++){\r\n      \r\n      //Get the THREE Light Object from the light_pool\r\n      const lightNode = this.light_pool[i];\r\n      if(!lightNode){ continue; }\r\n      \r\n      //Get the assigned OdysseyLight3D\r\n      const odysseyLight = lightNode.userData.odysseyLight as OdysseyLight3D;\r\n      if(!odysseyLight){\r\n        if(!lightNode.userData.reclaimed){ \r\n          this.reclaimLight(lightNode); \r\n        }\r\n        continue;\r\n      }\r\n\r\n      if(odysseyLight.isFading){\r\n        //FADINGLIGHT\r\n        if(!lightsUsed.has(odysseyLight.uuid) && odysseyLight.isOnScreen(this.context.viewportFrustum)){\r\n          lightsUsed.add(odysseyLight.uuid);\r\n          //odysseyLight.getWorldPosition(lightNode.position);\r\n          //lightNode.distance = odysseyLight.getRadius();\r\n          //lightNode.color.r = odysseyLight.color.r;\r\n          //lightNode.color.g = odysseyLight.color.g;\r\n          //lightNode.color.b = odysseyLight.color.b;\r\n          //The light is still active so update as needed\r\n          if(lightNode.intensity < odysseyLight.maxIntensity){\r\n            lightNode.intensity += 2*delta;\r\n          }\r\n\r\n          if(lightNode.intensity > odysseyLight.maxIntensity){\r\n            lightNode.intensity = odysseyLight.maxIntensity;\r\n          }\r\n\r\n          //Animate the light helper properties (This gives a visual aid when debugging lights)\r\n          lightNode.userData.helper.material.opacity = lightNode.intensity/odysseyLight.maxIntensity;\r\n          lightNode.userData.helper.material.transparent = true;\r\n\r\n          lightNode.userData.reclaimed = false;\r\n          this.lightsShown.add(lightNode.userData.lightUUID);\r\n          //Move the light to the beginning of the array so it is skipped until it is reclaimed\r\n          //This may not be a very efficient way of managing the array. I belive the combo of unshift and splice[0] can be pretty slow\r\n          //this.light_pool.unshift(this.light_pool.splice(i, 1)[0]);\r\n          this.spawned++;\r\n          \r\n        }else{\r\n          lightNode.userData.reclaimed = false;\r\n          //The light is no longer active so fade out and reclaim so this light can be reused\r\n          lightNode.intensity -= 2*delta;\r\n\r\n          if(lightNode.intensity < 0 || !odysseyLight.isOnScreen(this.context.viewportFrustum)){\r\n            lightNode.intensity = 0;\r\n            lightNode.userData.reclaimed = true;\r\n          }\r\n\r\n          //Animate the light helper properties (This gives a visual aid when debugging lights)\r\n          lightNode.userData.helper.material.opacity = lightNode.intensity/odysseyLight.maxIntensity;\r\n          lightNode.userData.helper.material.transparent = true;\r\n\r\n          if(!lightsUsed.has(odysseyLight.uuid) && lightNode.intensity > 0){\r\n            lightsUsed.add(odysseyLight.uuid);\r\n            //The light hasn't completed it's fadeout yet\r\n\r\n            this.lightsShown.add(odysseyLight.uuid);\r\n            //Move the light to the beginning of the array so it is skipped until it is reclaimed\r\n            //This may not be a very efficient way of managing the array. I belive the combo of unshift and splice[0] can be pretty slow\r\n            //this.light_pool.unshift(this.light_pool.splice(i, 1)[0]);\r\n            this.spawned++;\r\n          }else{\r\n            this.reclaimLight(lightNode);\r\n          }\r\n\r\n        }\r\n        \r\n        lightNode.color.r = odysseyLight.color.r;\r\n        lightNode.color.g = odysseyLight.color.g;\r\n        lightNode.color.b = odysseyLight.color.b;\r\n        // odysseyLight.maxIntensity = 0.5;//odysseyLight.getIntensity();\r\n        \r\n      }else{\r\n        if(!lightsUsed.has(odysseyLight.uuid) && odysseyLight.isOnScreen(this.context.viewportFrustum)){\r\n          lightsUsed.add(odysseyLight.uuid);\r\n          //This light is not a fading light so it can be instantly turned off and reclaimed\r\n          // odysseyLight.getWorldPosition(lightNode.position)\r\n          // lightNode.color.r = odysseyLight.color.r;\r\n          // lightNode.color.g = odysseyLight.color.g;\r\n          // lightNode.color.b = odysseyLight.color.b;\r\n          // lightNode.decay = 1;\r\n          \r\n          // lightNode.updateMatrix();\r\n          // lightNode.userData.animated = odysseyLight.isAnimated ? 1 : 0;\r\n          lightNode.intensity = 1;\r\n          lightNode.distance = odysseyLight.getRadius();\r\n          //Reset the light helper properties\r\n          lightNode.userData.helper.material.opacity = 1;\r\n          lightNode.userData.helper.material.transparent = false;\r\n          this.light_pool.unshift(this.light_pool.splice(i, 1)[0]);\r\n          lightNode.userData.reclaimed = false;\r\n        }else{\r\n          this.reclaimLight(lightNode);\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * A helper method to reset a lights properties when it needs to be reclaimed\r\n   * @param lightNode\r\n   * @returns void\r\n   */\r\n  reclaimLight(lightNode: THREE.Light){\r\n    if(!lightNode){ return; }\r\n\r\n    //This light is not a fading light so it can be instantly turned off and reclaimed\r\n    lightNode.position.set(0,0,0);\r\n    lightNode.intensity = 0;\r\n    //Reset the light helper properties\r\n    lightNode.userData.lightUUID = undefined;\r\n    lightNode.userData.helper.material.opacity = 0;\r\n    lightNode.userData.helper.material.transparent = true;\r\n    lightNode.userData.reclaimed = true;\r\n    lightNode.userData.odysseyLight = undefined;\r\n    lightNode.userData.animated = 0;\r\n  }\r\n\r\n  updateShadowLights(delta = 0){\r\n    this.tmpLights = [];//this.lights.slice();\r\n    const shadowLights = this.lights.filter(light => light.odysseyModel.visible && light.castShadow);\r\n    shadowLights.sort(this.sortLights);\r\n\r\n    this.new_lights = [];\r\n    this.new_lights_uuids = [];\r\n    this.new_lights_spawned = 0;\r\n\r\n    //Get the lights that are trying to spawn this frame\r\n    for( let i = 0, il = shadowLights.length; i < il; i++ ){\r\n\r\n      const odysseyLight = shadowLights[i];\r\n\r\n      if(!this.canShowLight(odysseyLight))\r\n        continue;\r\n\r\n      if(this.new_lights_spawned >= LightManager.MAXSHADOWLIGHTS)\r\n        break;\r\n\r\n      if(this.new_lights_uuids.indexOf(odysseyLight.uuid) == -1){\r\n        this.new_lights.push(odysseyLight);\r\n        this.new_lights_uuids.push(odysseyLight.uuid);\r\n        this.new_lights_spawned++;\r\n      }\r\n      \r\n    }\r\n    \r\n    //Attempt to reclaim lights that are no longer used\r\n    this.lightsShown = new Set<string>();\r\n    this.reclaimShadowLights(delta);\r\n    \r\n    //Try to update lights with the pool of reclaimed lights\r\n    for( let i = 0, il = this.new_lights.length; i < il; i++ ){\r\n\r\n      //Break the loop if we have already meet our maximum light count\r\n      if(this.spawned_shadow >= LightManager.MAXSHADOWLIGHTS)\r\n        break;\r\n\r\n      const odysseyLight = this.new_lights[i];\r\n      const lightNode = this.shadow_pool[this.spawned_shadow];\r\n\r\n      //The only way this wouldn't be true is if we have a different number of lights in our shadow_pool than the\r\n      //engine maximum light number which should be 8 most of the time.\r\n      //The number of allocated lights should always match MAXLIGHTS.\r\n      if(lightNode){\r\n        \r\n        //If the light isn't already being shown\r\n        if(!this.lightsShown.has(odysseyLight.uuid)){\r\n\r\n          //Set Light Properties By Type\r\n          // if(odysseyLight.isAmbient && odysseyLight.getRadius() > 150){\r\n          //   //Ambient light flags don't seem to reliably point to a usage of THREE.AmbientLight per se as some game modules seem to produce PointLight effects in the original game\r\n          //   //Like the red hangar lights in the Tatooine Docking Bay. The turret MiniGame uses this flag for one of the lights and seems to produce\r\n          //   //an AmbientLight effect in the original game. There must be another flag or property that differentiates the two cases that I am missing\r\n          //   lightNode.userData.isPointLight = false;\r\n          //   lightNode.userData.isAmbientLight = true;\r\n          //   lightNode.type = 'AmbientLight';\r\n          //   lightNode.intensity = 0.5;\r\n          //   lightNode.userData.helper.material.opacity = 1;\r\n          //   //lightNode.distance = Infinity;\r\n          // }else{\r\n            lightNode.userData.isPointLight = true;\r\n            lightNode.userData.isAmbientLight = false;\r\n            lightNode.type = 'PointLight';\r\n\r\n            if(odysseyLight.isFading){\r\n              lightNode.intensity = 0;\r\n            }else{\r\n              lightNode.intensity = 1;//light.getIntensity();\r\n            }\r\n            \r\n            lightNode.distance = odysseyLight.getRadius();\r\n          // }\r\n\r\n          //Set Common Light Properties\r\n          odysseyLight.getWorldPosition(lightNode.position)\r\n          lightNode.color.r = odysseyLight.color.r;\r\n          lightNode.color.g = odysseyLight.color.g;\r\n          lightNode.color.b = odysseyLight.color.b;\r\n          lightNode.decay = LightManager.DECAY;\r\n          \r\n          lightNode.updateMatrix();\r\n          lightNode.userData.odysseyLight = odysseyLight;\r\n          lightNode.userData.animated = odysseyLight.isAnimated ? 1 : 0;\r\n          lightNode.userData.lightUUID = odysseyLight.uuid;\r\n          this.lightsShown.add(odysseyLight.uuid);\r\n\r\n          //Increment the spawn count\r\n          this.spawned_shadow++;\r\n        }\r\n\r\n      }\r\n      \r\n    }\r\n\r\n    for( let i = 0, il = this.shadow_pool.length; i < il; i++ ){\r\n      const lightNode = this.shadow_pool[i];\r\n      const light = this.shadow_pool[i].userData.odysseyLight as OdysseyLight3D;\r\n      if(light && light.isAnimated){\r\n        lightNode.decay = LightManager.DECAY;\r\n        lightNode.distance = Math.abs(light.getRadius() );\r\n        lightNode.intensity = 1;//light.getIntensity();// * ((lightNode.color.r + lightNode.color.g + lightNode.color.b) / 3);\r\n        //log.info(lightNode.distance);\r\n      }\r\n    }\r\n  }\r\n  \r\n  //Try to reclaim unused shadow lights and update spawned fading lights\r\n  reclaimShadowLights(delta = 0){\r\n\r\n    this.spawned_shadow = 0;\r\n\r\n    for(let i = 0, il = LightManager.MAXSHADOWLIGHTS; i < il; i++){\r\n      \r\n      //Get the THREE Light Object from the shadow_pool\r\n      const lightNode = this.shadow_pool[i];\r\n      const odysseyLight = lightNode.userData.odysseyLight as OdysseyLight3D;\r\n\r\n      if(odysseyLight && odysseyLight.isFading){\r\n        //FADINGLIGHT\r\n        if(this.new_lights_uuids.indexOf(odysseyLight.uuid) >= 0 && odysseyLight.isOnScreen(this.context.viewportFrustum)){\r\n          //The light is still active so update as needed\r\n          if(lightNode.intensity < odysseyLight.maxIntensity){\r\n            lightNode.intensity += 2*delta;\r\n          }\r\n\r\n          if(lightNode.intensity > odysseyLight.maxIntensity){\r\n            lightNode.intensity = odysseyLight.maxIntensity;\r\n          }\r\n\r\n          //Animate the light helper properties (This gives a visual aid when debugging lights)\r\n          lightNode.userData.helper.material.opacity = lightNode.intensity/odysseyLight.maxIntensity;\r\n          lightNode.userData.helper.material.transparent = true;\r\n\r\n          lightNode.userData.reclaimed = false;\r\n          this.lightsShown.add(lightNode.userData.lightUUID);\r\n          //Move the light to the beginning of the array so it is skipped until it is reclaimed\r\n          //This may not be a very efficient way of managing the array. I belive the combo of unshift and splice[0] can be pretty slow\r\n          this.shadow_pool.unshift(this.shadow_pool.splice(i, 1)[0]);\r\n          this.spawned_shadow++;\r\n          \r\n        }else{\r\n          //The light is no longer active so fade out and reclaim so this light can be reused\r\n          lightNode.intensity -= 2*delta;\r\n\r\n          if(lightNode.intensity < 0 || !odysseyLight.isOnScreen(this.context.viewportFrustum)){\r\n            lightNode.intensity = 0;\r\n          }\r\n\r\n          //Animate the light helper properties (This gives a visual aid when debugging lights)\r\n          lightNode.userData.helper.material.opacity = lightNode.intensity/odysseyLight.maxIntensity;\r\n          lightNode.userData.helper.material.transparent = true;\r\n\r\n          if(lightNode.intensity > 0){\r\n            //The light hasn't completed it's fadeout yet\r\n\r\n            this.lightsShown.add(odysseyLight.uuid);\r\n            //Move the light to the beginning of the array so it is skipped until it is reclaimed\r\n            //This may not be a very efficient way of managing the array. I belive the combo of unshift and splice[0] can be pretty slow\r\n            this.shadow_pool.unshift(this.shadow_pool.splice(i, 1)[0]);\r\n            this.spawned_shadow++;\r\n          }else{\r\n            //Reclaim the light\r\n            lightNode.position.set(0,0,0);\r\n            lightNode.intensity = 0;\r\n            //Reset the light helper properties\r\n            lightNode.userData.helper.material.opacity = 0;\r\n            lightNode.userData.helper.material.transparent = true;\r\n          }\r\n\r\n        }\r\n\r\n        lightNode.color.r = odysseyLight.color.r;\r\n        lightNode.color.g = odysseyLight.color.g;\r\n        lightNode.color.b = odysseyLight.color.b;\r\n        // odysseyLight.maxIntensity = 0.5;//lightNode.light.getIntensity();\r\n        \r\n      }else{\r\n        //This light is not a fading light so it can be instantly turned off and reclaimed\r\n        lightNode.position.set(0,0,0);\r\n        lightNode.intensity = 0;\r\n        //Reset the light helper properties\r\n        lightNode.userData.helper.material.opacity = 0;\r\n        lightNode.userData.helper.material.transparent = true;\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  //Sort lights by distance and priority\r\n  sortLights (a: OdysseyLight3D, b: OdysseyLight3D){\r\n    if (b.isAnimated < a.isAnimated) return -1;\r\n    if (b.isAnimated > a.isAnimated) return 1;\r\n\r\n    if (b.getRadius() < a.getRadius()) return -1;\r\n    if (b.getRadius() > a.getRadius()) return 1;\r\n\r\n    if (b.priority < a.priority) return -1;\r\n    if (b.priority > a.priority) return 1;\r\n\r\n    if (a.cameraDistance < b.cameraDistance) return -1;\r\n    if (a.cameraDistance > b.cameraDistance) return 1;\r\n    \r\n    return 0;\r\n  }\r\n\r\n  //Check to see if the model that owns the light has already met it's limit of three active lights\r\n  canShowLight(light: OdysseyLight3D){\r\n\r\n    if(this.lightsShown.has(light.uuid))\r\n      return false;\r\n\r\n    if(!light || !light.isOnScreen(this.context.viewportFrustum) || !light.odysseyModel.visible)\r\n      return false;\r\n\r\n    //if(light.isDynamic == 1)\r\n    //  return false;\r\n\r\n    if(typeof this.modelLightCounter[light.parentUUID] === 'undefined'){\r\n      this.modelLightCounter[light.parentUUID] = 1;\r\n      return true;\r\n    }else{\r\n      this.modelLightCounter[light.parentUUID]++;\r\n      if(this.modelLightCounter[light.parentUUID] < 3){\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  //Toggle the visbility of the light helpers ingame\r\n  toggleLightHelpers(){\r\n    this.context.group.light_helpers.visible = !this.context.group.light_helpers.visible;\r\n  }\r\n\r\n  setLightHelpersVisible(on = false){\r\n    this.context.group.light_helpers.visible = on ? true : false;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\ModuleObjectManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":122,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":122,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":130,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":130,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":138,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":138,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":146,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":146,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":154,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":154,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":162,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":162,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":170,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":170,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":178,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":178,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":186,"column":12,"nodeType":"MemberExpression","messageId":"errorCall","endLine":186,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":206,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":206,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":213,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":213,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":220,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":220,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":234,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":234,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":255,"column":10,"nodeType":"MemberExpression","messageId":"errorCall","endLine":255,"endColumn":57}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { PerceptionMask } from \"@/enums/engine/PerceptionMask\";\nimport { ModuleObjectConstant } from \"@/enums/module/ModuleObjectConstant\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { CreatureType } from \"@/enums/nwscript/CreatureType\";\nimport { NWModuleObjectType } from \"@/enums/nwscript/NWModuleObjectType\";\nimport { ReputationType } from \"@/enums/nwscript/ReputationType\";\nimport { PartyManager } from \"@/managers/PartyManager\";\nimport type { Module, ModuleCreature, ModuleObject } from \"@/module\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Manager);\n\n/**\n * ModuleObjectManager class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file ModuleObjectManager.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class ModuleObjectManager {\n\n  private constructor() {\n    // Static-only class.\n  }\n\n  static objSearchIndex: number;\n  static module: Module;\n\n  static ObjectList: Map<number, ModuleObject> = new Map();\n  static COUNT: number = 1;\n  static PLAYER_ID = ModuleObjectConstant.PLAYER_ID;\n\n  static GetObjectById(id: ModuleObject|number = -1){\n\n    if(id === ModuleObjectConstant.OBJECT_INVALID || (typeof id === 'number' && id === -1))\n      return undefined;\n\n    if(typeof id === 'object'){\n      if(id.id >= 1){\n        return id;\n      }\n    }\n\n    const numId = typeof id === 'object' ? (id?.id ?? -1) : id;\n    if(numId >= 1 && this.ObjectList.has(numId)){\n      return this.ObjectList.get(numId);\n    }\n    return undefined;\n\n  }\n\n  static GetNextObjectId(){\n    return this.COUNT++;\n  }\n\n  static ResetPlayerId(){\n    this.PLAYER_ID = ModuleObjectConstant.PLAYER_ID;\n  }\n\n  static GetNextPlayerId(){\n    log.trace('GetNextPlayerId PLAYER_ID=%s', String(this.PLAYER_ID));\n    return this.PLAYER_ID--;\n  }\n\n  static AddObjectById(object: ModuleObject){\n    if(!object.id){\n      object.id = this.GetNextObjectId();\n      while(this.ObjectList.has(object.id)){\n        object.id = this.GetNextObjectId();\n      }\n    }\n    this.ObjectList.set(object.id, object);\n  }\n\n  static RemoveObject(object: ModuleObject){\n    if(!object) return;\n    this.RemoveObjectById(object?.id);\n  }\n\n  static RemoveObjectById(id: number): boolean {\n    if(isNaN(id)) return false;\n    //Remove the object from the global list of objects\n    if(id >= 1 && this.ObjectList.has(id)){\n      return this.ObjectList.delete(id);\n    }\n    return false;\n  }\n\n  static Reset(){\n    this.COUNT = 1;\n    this.PLAYER_ID = ModuleObjectConstant.PLAYER_ID;\n    this.ObjectList.clear();\n  }\n\n  public static GetObjectByTag(sTag = '', iNum = 0, oType = NWModuleObjectType.ALL){\n\n    /*ModuleObjectType.CREATURE         = 1;\n    ModuleObjectType.ITEM             = 2;\n    ModuleObjectType.TRIGGER          = 4;\n    ModuleObjectType.DOOR             = 8;\n    ModuleObjectType.AOE   = 16;\n    ModuleObjectType.WAYPOINT         = 32;\n    ModuleObjectType.PLACEABLE        = 64;\n    ModuleObjectType.STORE            = 128;\n    ModuleObjectType.ENCOUNTER        = 256;\n    ModuleObjectType.SOUND            = 512;\n    OBJECT_TYPE_ALL              = 32767;*/\n\n    sTag = sTag.toLowerCase();\n    const results: ModuleObject[] = [];\n    let obj: ModuleObject | undefined = undefined;\n    if((oType & NWModuleObjectType.PLACEABLE) == NWModuleObjectType.PLACEABLE){\n      for(let i = 0, len = this.module.area.placeables.length; i < len; i++){\n        obj = this.module.area.placeables[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      for(let i = 0, len = this.module.area.creatures.length; i < len; i++){\n        obj = this.module.area.creatures[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      for(let i = 0, len = PartyManager.party.length; i < len; i++){\n        obj = PartyManager.party[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.STORE) == NWModuleObjectType.STORE){\n      for(let i = 0, len = this.module.area.stores.length; i < len; i++){\n        obj = this.module.area.stores[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.DOOR) == NWModuleObjectType.DOOR){\n      for(let i = 0, len = this.module.area.doors.length; i < len; i++){\n        obj = this.module.area.doors[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.TRIGGER) == NWModuleObjectType.TRIGGER){\n      for(let i = 0, len = this.module.area.triggers.length; i < len; i++){\n        obj = this.module.area.triggers[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.WAYPOINT) == NWModuleObjectType.WAYPOINT){\n      for(let i = 0, len = this.module.area.waypoints.length; i < len; i++){\n        obj = this.module.area.waypoints[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.SOUND) == NWModuleObjectType.SOUND){\n      for(let i = 0, len = this.module.area.sounds.length; i < len; i++){\n        obj = this.module.area.sounds[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if((oType & NWModuleObjectType.ITEM) == NWModuleObjectType.ITEM){\n      for(let i = 0, len = this.module.area.items.length; i < len; i++){\n        obj = this.module.area.items[i];\n        if(obj.getTag().toLowerCase() == sTag)\n          results.push(obj);\n      }\n    }\n\n    if(sTag == '' || sTag == 'player'){\n      return PartyManager.party[0];\n    }else if(results.length){\n      return results[iNum];\n    }\n\n    return undefined;\n\n  }\n\n  public static GetNearestObjectByTag(sTag = '', oObject: ModuleObject, iNum = 0){\n    sTag = sTag.toLowerCase();\n    const results: ModuleObject[] = [];\n    let len = this.module.area.placeables.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.placeables[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.placeables[i])\n          results.push(this.module.area.placeables[i]);\n    }\n\n    len = PartyManager.party.length;\n    for(let i = 0; i < len; i++){\n      if(PartyManager.party[i].getTag().toLowerCase() == sTag)\n        if(oObject != PartyManager.party[i])\n          results.push(PartyManager.party[i]);\n    }\n\n    len = this.module.area.creatures.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.creatures[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.creatures[i])\n          results.push(this.module.area.creatures[i]);\n    }\n\n    len = this.module.area.items.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.items[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.items[i])\n          results.push(this.module.area.items[i]);\n    }\n\n    len = this.module.area.doors.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.doors[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.doors[i])\n          results.push(this.module.area.doors[i]);\n    }\n\n    len = this.module.area.triggers.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.triggers[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.triggers[i])\n          results.push(this.module.area.triggers[i]);\n    }\n\n    len = this.module.area.waypoints.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.waypoints[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.waypoints[i])\n          results.push(this.module.area.waypoints[i]);\n    }\n\n    len = this.module.area.sounds.length;\n    for(let i = 0; i < len; i++){\n      if(this.module.area.sounds[i].getTag().toLowerCase() == sTag)\n        if(oObject != this.module.area.sounds[i])\n          results.push(this.module.area.sounds[i]);\n    }\n\n    results.sort(\n      function(a,b) {\n        try{\n          const distanceA = a.getModel().position.distanceTo(oObject.getModel().position);\n          const distanceB = b.getModel().position.distanceTo(oObject.getModel().position);\n          return (distanceB > distanceA) ? -1 : ((distanceA > distanceB) ? 1 : 0);\n        }catch(e){\n          return 0;\n        }\n      }\n    );\n\n    if(results.length){\n      return results[iNum];\n    }\n\n    return undefined;\n\n  }\n\n  public static GetNearestInteractableObject(oObject?: ModuleObject){\n    let results: ModuleObject[] = [];\n\n    results = results.concat(PartyManager.party);\n    results = results.concat(this.module.area.creatures);\n    results = results.concat(this.module.area.doors);\n    results = results.concat(this.module.area.placeables);\n\n    results.sort(\n      function(a,b) {\n        try{\n          const distanceA = a.position.distanceTo(oObject.position);\n          const distanceB = b.position.distanceTo(oObject.position);\n          return (distanceB > distanceA) ? -1 : ((distanceA > distanceB) ? 1 : 0);\n        }catch(e){\n          return 0;\n        }\n      }\n    );\n\n    let result: ModuleObject | undefined;\n    const count = results.length;\n\n    for(let i = 0; i < count; i++){\n      result = results[i];\n      if( result != PartyManager.party[0] && result.isOnScreen() && result.isUseable() ){\n        if( result.hasLineOfSight( PartyManager.party[0] ) ){\n          break;\n        }\n      }\n      result = undefined;\n    }\n\n    return result;\n\n  }\n\n  public static GetNearestObject(oType = 0, oObject: ModuleObject, iNum = 0){\n    let results: ModuleObject[] = [];\n\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      results = results.concat(this.module.area.creatures);\n    }\n    if((oType & NWModuleObjectType.ITEM) == NWModuleObjectType.ITEM){\n      results = results.concat(this.module.area.items);\n    }\n    if((oType & NWModuleObjectType.TRIGGER) == NWModuleObjectType.TRIGGER){\n      results = results.concat(this.module.area.triggers);\n    }\n    if((oType & NWModuleObjectType.DOOR) == NWModuleObjectType.DOOR){\n      results = results.concat(this.module.area.doors);\n    }\n    if((oType & NWModuleObjectType.AOE) == NWModuleObjectType.AOE){\n      //results = results.concat([]);\n    }\n    if((oType & NWModuleObjectType.WAYPOINT) == NWModuleObjectType.WAYPOINT){\n      results = results.concat(this.module.area.waypoints);\n    }\n    if((oType & NWModuleObjectType.PLACEABLE) == NWModuleObjectType.PLACEABLE){\n      results = results.concat(this.module.area.placeables);\n    }\n    if((oType & NWModuleObjectType.STORE) == NWModuleObjectType.STORE){\n      results = results.concat(this.module.area.stores);\n    }\n    if((oType & NWModuleObjectType.ENCOUNTER) == NWModuleObjectType.ENCOUNTER){\n      results = results.concat(this.module.area.encounters);\n    }\n    if((oType & NWModuleObjectType.SOUND) == NWModuleObjectType.SOUND){\n      results = results.concat(this.module.area.sounds);\n    }\n\n    results.sort(\n      function(a,b) {\n        try{\n          const distanceA = a.position.distanceTo(oObject.position);\n          const distanceB = b.position.distanceTo(oObject.position);\n          return (distanceB > distanceA) ? -1 : ((distanceA > distanceB) ? 1 : 0);\n        }catch(e){\n          return 0;\n        }\n      }\n    );\n\n    if(results.length){\n      return results[iNum];\n    }\n\n    return undefined;\n\n  }\n\n  public static GetFirstObjectInArea(oArea = this.module.area, oType = 0){\n\n    if(!(BitWise.InstanceOf(oArea?.objectType, ModuleObjectType.ModuleArea))){\n      log.warn('GetFirstObjectInArea: invalid oArea, using module.area', oArea);\n      oArea = this.module.area;\n    }\n\n    ModuleObjectManager.objSearchIndex = 0;\n\n    let results: ModuleObject[] = [];\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      results = results.concat(this.module.area.creatures);\n    }\n    if((oType & NWModuleObjectType.ITEM) == NWModuleObjectType.ITEM){\n      results = results.concat(this.module.area.items);\n    }\n    if((oType & NWModuleObjectType.TRIGGER) == NWModuleObjectType.TRIGGER){\n      results = results.concat(this.module.area.triggers);\n    }\n    if((oType & NWModuleObjectType.DOOR) == NWModuleObjectType.DOOR){\n      results = results.concat(this.module.area.doors);\n    }\n    if((oType & NWModuleObjectType.AOE) == NWModuleObjectType.AOE){\n      //results = results.concat([]);\n    }\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      results = results.concat(this.module.area.creatures);\n    }\n    if((oType & NWModuleObjectType.WAYPOINT) == NWModuleObjectType.WAYPOINT){\n      results = results.concat(this.module.area.waypoints);\n    }\n    if((oType & NWModuleObjectType.PLACEABLE) == NWModuleObjectType.PLACEABLE){\n      results = results.concat(this.module.area.placeables);\n    }\n    if((oType & NWModuleObjectType.STORE) == NWModuleObjectType.STORE){\n      results = results.concat(this.module.area.stores);\n    }\n    if((oType & NWModuleObjectType.ENCOUNTER) == NWModuleObjectType.ENCOUNTER){\n      results = results.concat(this.module.area.encounters);\n    }\n    if((oType & NWModuleObjectType.SOUND) == NWModuleObjectType.SOUND){\n      results = results.concat(this.module.area.sounds);\n    }\n\n    if(results.length){\n      return results[ModuleObjectManager.objSearchIndex];\n    }\n    return undefined;\n  }\n\n  public static GetNextObjectInArea(oArea = this.module.area, oType = 0){\n    if(!(BitWise.InstanceOf(oArea?.objectType, ModuleObjectType.ModuleArea))){\n      log.warn('GetNextObjectInArea: invalid oArea, using module.area', oArea);\n      oArea = this.module.area;\n    }\n    ++ModuleObjectManager.objSearchIndex;\n\n    let results: ModuleObject[] = [];\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      results = results.concat(this.module.area.creatures);\n    }\n    if((oType & NWModuleObjectType.ITEM) == NWModuleObjectType.ITEM){\n      results = results.concat(this.module.area.items);\n    }\n    if((oType & NWModuleObjectType.TRIGGER) == NWModuleObjectType.TRIGGER){\n      results = results.concat(this.module.area.triggers);\n    }\n    if((oType & NWModuleObjectType.DOOR) == NWModuleObjectType.DOOR){\n      results = results.concat(this.module.area.doors);\n    }\n    if((oType & NWModuleObjectType.AOE) == NWModuleObjectType.AOE){\n      //results = results.concat([]);\n    }\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){\n      results = results.concat(this.module.area.creatures);\n    }\n    if((oType & NWModuleObjectType.WAYPOINT) == NWModuleObjectType.WAYPOINT){\n      results = results.concat(this.module.area.waypoints);\n    }\n    if((oType & NWModuleObjectType.PLACEABLE) == NWModuleObjectType.PLACEABLE){\n      results = results.concat(this.module.area.placeables);\n    }\n    if((oType & NWModuleObjectType.STORE) == NWModuleObjectType.STORE){\n      results = results.concat(this.module.area.stores);\n    }\n    if((oType & NWModuleObjectType.ENCOUNTER) == NWModuleObjectType.ENCOUNTER){\n      results = results.concat(this.module.area.encounters);\n    }\n    if((oType & NWModuleObjectType.SOUND) == NWModuleObjectType.SOUND){\n      results = results.concat(this.module.area.sounds);\n    }\n\n    if(ModuleObjectManager.objSearchIndex < results.length-1){\n      return results[ModuleObjectManager.objSearchIndex];\n    }\n    return undefined;\n  }\n\n  public static GetNearestCreature(nFirstCriteriaType: CreatureType, nFirstCriteriaValue: number, oTarget: ModuleObject, nNth = 1, nSecondCriteriaType = -1, nSecondCriteriaValue = -1, nThirdCriteriaType = -1, nThirdCriteriaValue = -1, list?: ModuleCreature[]): ModuleCreature | undefined {\n\n    if(!list){\n      list = this.module.area.creatures;\n      list = list.concat(PartyManager.party);\n    }\n\n    const results: ModuleCreature[] = [];\n\n    switch(nFirstCriteriaType){\n      case CreatureType.RACIAL_TYPE:\n\n      break;\n      case CreatureType.PLAYER_CHAR:\n\n      break;\n      case CreatureType.CLASS:\n\n      break;\n      case CreatureType.REPUTATION:\n        switch(nFirstCriteriaValue){\n          case ReputationType.FRIEND:\n            for(let i = 0; i < list.length; i++){\n              if(list[i].isDead()){ continue; }\n              if(list[i].isFriendly(oTarget) && oTarget.hasLineOfSight(list[i])){\n                results.push(list[i]);\n              }\n            }\n          break;\n          case ReputationType.ENEMY:\n            for(let i = 0; i < list.length; i++){\n              if(list[i].isDead()){ continue; }\n              if(list[i].isHostile(oTarget) && oTarget.hasLineOfSight(list[i])){\n                results.push(list[i]);\n              }\n            }\n          break;\n          case ReputationType.NEUTRAL:\n            for(let i = 0; i < list.length; i++){\n              if(list[i].isDead()){ continue; }\n              if(list[i].isNeutral(oTarget) && oTarget.hasLineOfSight(list[i])){\n                results.push(list[i]);\n              }\n            }\n          break;\n        }\n      break;\n      case CreatureType.IS_ALIVE:\n        for(let i = 0; i < list.length; i++){\n          if(list[i].isDead()){ continue; }\n          results.push(list[i]);\n        }\n      break;\n      case CreatureType.HAS_SPELL_EFFECT:\n\n      break;\n      case CreatureType.DOES_NOT_HAVE_SPELL_EFFECT:\n\n      break;\n      case CreatureType.PERCEPTION:\n        for(let i = 0; i < list.length; i++){\n          switch(nFirstCriteriaValue){\n            case 0:// PERCEPTION_SEEN_AND_HEARD\t0\tBoth seen and heard (Spot beats Hide, Listen beats Move Silently).\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !!(o.data & PerceptionMask.SEEN_AND_HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 1:// PERCEPTION_NOT_SEEN_AND_NOT_HEARD\t1\tNeither seen nor heard (Hide beats Spot, Move Silently beats Listen).\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !(o.data & PerceptionMask.SEEN_AND_HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 2:// PERCEPTION_HEARD_AND_NOT_SEEN\t2\t Heard only (Hide beats Spot, Listen beats Move Silently). Usually arouses suspicion for a creature to take a closer look.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !(o.data & PerceptionMask.SEEN) && !!(o.data & PerceptionMask.HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 3:// PERCEPTION_SEEN_AND_NOT_HEARD\t3\tSeen only (Spot beats Hide, Move Silently beats Listen). Usually causes a creature to take instant notice.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !!(o.data & PerceptionMask.SEEN) && !(o.data & PerceptionMask.HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 4:// PERCEPTION_NOT_HEARD 4 Not heard (Move Silently beats Listen), no line of sight.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !(o.data & PerceptionMask.HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 5:// PERCEPTION_HEARD 5 Heard (Listen beats Move Silently), no line of sight.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !!(o.data & PerceptionMask.HEARD) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 6:// PERCEPTION_NOT_SEEN\t6\tNot seen (Hide beats Spot), too far away to heard or magically silcenced.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !(o.data & PerceptionMask.SEEN) ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n            case 7:// PERCEPTION_SEEN\t7\tSeen (Spot beats Hide), too far away to heard or magically silcenced.\n              if(oTarget.perceptionList.filter( (o) => o.object == list[i] && !!(o.data & PerceptionMask.SEEN)  ).length){\n                if(list[i].isDead()){ continue; }\n                results.push(list[i]);\n              }\n            break;\n          }\n\n        }\n      break;\n    }\n\n    if(nSecondCriteriaType >= 0){\n      return ModuleObjectManager.GetNearestCreature(nSecondCriteriaType, nSecondCriteriaValue, oTarget, nNth, nThirdCriteriaType, nThirdCriteriaValue, -1, -1, results);\n    }\n\n    if(results.length){\n      results.sort((a: ModuleCreature, b: ModuleCreature) => {\n        return oTarget.position.distanceTo(a.position) - oTarget.position.distanceTo(b.position);\n      });\n      return results[nNth-1];\n    }\n\n    return undefined;\n  }\n\n  public static GetObjectsInShape(shape = -1, size = 1, target: EngineLocation, lineOfSight = false, oType = -1, origin = new THREE.Vector3, idx = -1){\n\n    let object_pool: ModuleObject[] = [];\n    const results: ModuleObject[] = [];\n\n    /*\n    int    ModuleObjectType.CREATURE         = 1;\n    int    ModuleObjectType.ITEM             = 2;\n    int    ModuleObjectType.TRIGGER          = 4;\n    int    ModuleObjectType.DOOR             = 8;\n    int    ModuleObjectType.AOE   = 16;\n    int    ModuleObjectType.WAYPOINT         = 32;\n    int    ModuleObjectType.PLACEABLE        = 64;\n    int    ModuleObjectType.STORE            = 128;\n    int    ModuleObjectType.ENCOUNTER        = 256;\n    int    ModuleObjectType.SOUND            = 512;\n    int    OBJECT_TYPE_ALL              = 32767;\n    */\n\n    //log.info('GetObjectsInShape', objectFilter, shape);\n\n    if((oType & NWModuleObjectType.CREATURE) == NWModuleObjectType.CREATURE){ //CREATURE\n      object_pool = object_pool.concat(this.module.area.creatures);\n    }\n\n    if((oType & NWModuleObjectType.ITEM) == NWModuleObjectType.ITEM){ //ITEM\n      object_pool = object_pool.concat(this.module.area.items);\n    }\n\n    if((oType & NWModuleObjectType.TRIGGER) == NWModuleObjectType.TRIGGER){ //TRIGGER\n      object_pool = object_pool.concat(this.module.area.triggers);\n    }\n\n    if((oType & NWModuleObjectType.DOOR) == NWModuleObjectType.DOOR){ //DOOR\n      object_pool = object_pool.concat(this.module.area.doors);\n    }\n\n    if((oType & NWModuleObjectType.AOE) == NWModuleObjectType.AOE){ //AOE\n\n    }\n\n    if((oType & NWModuleObjectType.WAYPOINT) == NWModuleObjectType.WAYPOINT){ //WAYPOINTS\n      object_pool = object_pool.concat(this.module.area.waypoints);\n    }\n\n    if((oType & NWModuleObjectType.PLACEABLE) == NWModuleObjectType.PLACEABLE){ //PLACEABLE\n      object_pool = object_pool.concat(this.module.area.placeables);\n    }\n\n    if((oType & NWModuleObjectType.STORE) == NWModuleObjectType.STORE){ //STORE\n\n    }\n\n    if((oType & NWModuleObjectType.ENCOUNTER) == NWModuleObjectType.ENCOUNTER){ //ENCOUNTER\n\n    }\n\n    if((oType & NWModuleObjectType.SOUND) == NWModuleObjectType.SOUND){ //SOUND\n      object_pool = object_pool.concat(this.module.area.sounds);\n    }\n\n    for(let i = 0, len = object_pool.length; i < len; i++){\n      if(BitWise.InstanceOf(object_pool[i]?.objectType, ModuleObjectType.ModuleObject)){\n        if(object_pool[i].position.distanceTo(target.position) < size){\n          results.push(object_pool[i]);\n        }\n      }\n    }\n\n    if(idx == -1){\n      return results;\n    }else{\n      return results[idx];\n    }\n\n  }\n\n  public static GetAttackerByIndex(oTarget: ModuleObject, index: number = 0): ModuleObject {\n    const object_pool: ModuleObject[] = [];\n\n    object_pool.concat(\n      this.module.area.creatures.filter(\n        (\n          creature =>\n          {\n            return (\n              creature.combatData.lastAttackTarget == oTarget ||\n              creature.combatData.lastSpellTarget == oTarget\n            );\n          }\n        )\n      )\n    );\n\n    return object_pool[index];\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\PartyManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":723,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":723,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\r\n\r\nimport * as THREE from \"three\";\r\n\r\nimport { CurrentGame } from \"@/engine/CurrentGame\";\r\nimport { DialogMessageEntry } from \"@/engine/DialogMessageEntry\";\r\nimport EngineLocation from \"@/engine/EngineLocation\";\r\nimport { FeedbackMessageEntry } from \"@/engine/FeedbackMessageEntry\";\r\nimport { JournalEntry } from \"@/engine/JournalEntry\";\r\nimport { type SWPortrait } from \"@/engine/rules/SWPortrait\";\r\nimport { GameEngineType, UIIconTimerType } from \"@/enums/engine\";\r\nimport { PazaakCards } from \"@/enums/minigames/PazaakCards\";\r\nimport { PazaakSideDeckSlots } from \"@/enums/minigames/PazaakSideDeckSlots\";\r\nimport { ModuleCreatureArmorSlot } from \"@/enums/module/ModuleCreatureArmorSlot\";\r\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { ResourceLoader } from \"@/loaders\";\r\nimport { ModuleCreature } from \"@/module/ModuleCreature\";\r\nimport { ModulePlayer } from \"@/module/ModulePlayer\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFObject } from \"@/resource/GFFObject\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { PartyManagerEvent } from \"@/types/PartyManagerEvent\";\r\nimport { BitWise } from \"@/utility/BitWise\";\r\nimport { GameFileSystem } from \"@/utility/GameFileSystem\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.Manager);\r\n\r\nexport interface CurrentMember {\r\n  isLeader: boolean,\r\n  memberID: number\r\n}\r\n\r\nexport interface PartyNPC {\r\n  available: boolean;\r\n  canSelect: boolean;\r\n  spawned: boolean;\r\n  template?: GFFObject;\r\n  moduleObject?: ModuleCreature;\r\n}\r\n\r\nexport interface PartyNPCList {\r\n  [key: string]: PartyNPC;\r\n}\r\n\r\nexport interface PartyPuppet {\r\n  available: boolean;\r\n  select: boolean;\r\n}\r\n\r\nexport interface PartyPuppetList {\r\n  [key: string]: PartyPuppet;\r\n}\r\n\r\n/**\r\n * PartyManager class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file PartyManager.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class PartyManager {\r\n\r\n  static partyTableTemplate: GFFObject;\r\n\r\n  static party: ModuleCreature[] = [];\r\n  static aiStyle = 0;\r\n\r\n  /**\r\n   * Current Player Creature (Can be overridden by with an NPC)\r\n   * This object will be stored in the Module's PlayList on Save\r\n   */\r\n  static Player: ModuleCreature;\r\n  static PlayerTemplate: GFFObject;\r\n\r\n  /**\r\n   * Actual Player Creature (This is the player create that was created by the player)\r\n   * If Player is not Equal to ActualPlayer export pc.utc on Save\r\n   */\r\n  // static ActualPlayer: ModulePlayer;\r\n  static ActualPlayerTemplate: GFFObject;\r\n\r\n  static PortraitOrder: string[] = [];\r\n  static MaxSize = 3;\r\n  static MaxNPCCount = 2;\r\n  static MaxPartyCount = 12;\r\n  static NPCS: PartyNPCList = {};\r\n\r\n  static Puppets: PartyPuppetList = {};\r\n\r\n  static PuppetCount: number = 0;\r\n  static MaxPuppetCount = 3;\r\n\r\n  static Gold = 0;\r\n  static CurrentMembers: CurrentMember[] = [];\r\n\r\n  static InfluenceMap: Map<number, number> = new Map<number, number>();\r\n  static ChemicalCount: number = 0;\r\n  static ComponentCount: number = 0;\r\n\r\n  static SwoopUpgrade1: number = -1;\r\n  static SwoopUpgrade2: number = -1;\r\n  static SwoopUpgrade3: number = -1;\r\n\r\n  static #eventListeners: Map<PartyManagerEvent, ((...args: (string | number | boolean | object)[]) => void)[]> = new Map();\r\n\r\n  /**\r\n   * Initialize the party manager\r\n   * @returns void\r\n   */\r\n  static Initialize(){\r\n    PartyManager.MaxPartyCount = GameState.GameKey == GameEngineType.TSL ? 12 : 9;\r\n    PartyManager.MaxPuppetCount = GameState.GameKey == GameEngineType.TSL ? 3 : 0;\r\n\r\n    for(let i = 0; i < PartyManager.MaxPartyCount; i++){\r\n      GameState.PartyManager.InfluenceMap.set(i, -1);\r\n      GameState.PartyManager.NPCS[i] = {\r\n        available: false,\r\n        canSelect: false,\r\n        spawned: false\r\n      };\r\n    }\r\n\r\n    for(let i = 0; i < PartyManager.MaxPuppetCount; i++){\r\n      GameState.PartyManager.Puppets[i] = {\r\n        available: false,\r\n        select: true\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the party manager\r\n   * @param gff - The GFF object to load\r\n   * @returns void\r\n   */\r\n  static async Load(gff: GFFObject){\r\n    if(!(gff instanceof GFFObject)){\r\n      log.error('PartyManager.Load expected GFFObject', gff);\r\n      throw 'PartyManager expected gff to be of type GFFObject';\r\n    }\r\n\r\n    PartyManager.partyTableTemplate = gff;\r\n\r\n    PartyManager.MaxPartyCount = GameState.GameKey == GameEngineType.TSL ? 12 : 9;\r\n    PartyManager.MaxPuppetCount = GameState.GameKey == GameEngineType.TSL ? 3 : 0;\r\n    \r\n    for(let i = 0; i < PartyManager.MaxPartyCount; i++){\r\n      GameState.PartyManager.InfluenceMap.set(i, -1);\r\n      GameState.PartyManager.NPCS[i] = {\r\n        available: false,\r\n        canSelect: false,\r\n        spawned: false\r\n      };\r\n    }\r\n\r\n    for(let i = 0; i < PartyManager.MaxPuppetCount; i++){\r\n      GameState.PartyManager.Puppets[i] = {\r\n        available: false,\r\n        select: true\r\n      };\r\n    }\r\n\r\n    if(gff.RootNode.hasField('GlxyMap')){\r\n      const GlxyMap = gff.getFieldByLabel('GlxyMap').getChildStructs()[0];\r\n      \r\n      const planetCount = GlxyMap.getFieldByLabel('GlxyMapNumPnts').getValue();\r\n      const planetBits = GlxyMap.getFieldByLabel('GlxyMapPlntMsk').getValue(); //Max 32?\r\n      const currentPlanet = GlxyMap.getFieldByLabel('GlxyMapSelPnt').getValue();\r\n\r\n      for(let i = 0; i < planetCount; i++){\r\n        GameState.Planetary.SetPlanetAvailable(i,  !!((planetBits>>i) & 0x01));\r\n      }\r\n\r\n      GameState.Planetary.SetSelectedPlanet(currentPlanet);\r\n    }\r\n\r\n    //Init the TutorialWindowTracker      \r\n    const tutorial2DA = GameState.TwoDAManager.datatables.get('tutorial');\r\n    let bitCount = 0;\r\n    if(tutorial2DA){\r\n      bitCount = Math.ceil(tutorial2DA.RowCount / 8) * 8;\r\n      for(let i = 0; i < bitCount; i++){\r\n        GameState.TutorialWindowTracker[i] = 0;\r\n      }\r\n    }\r\n\r\n    if(gff.RootNode.hasField('PT_TUT_WND_SHOWN')){\r\n      const tutWindBytes = gff.RootNode.getFieldByLabel('PT_TUT_WND_SHOWN').getVoid();\r\n      const maxBits = tutWindBytes.length * 8;\r\n      for(let i = 0; i < maxBits; i++){\r\n        for(let j = 0; j < 8; j++){\r\n          const bit = (tutWindBytes[i] >> j) & 1;\r\n          GameState.TutorialWindowTracker[ (i * 8) + j ] = bit;\r\n        }\r\n      }\r\n    }\r\n  \r\n    if(gff.RootNode.hasField('PT_AVAIL_NPCS')){\r\n      const avail = gff.getFieldByLabel('PT_AVAIL_NPCS').getChildStructs();\r\n      for(let i = 0; i < avail.length; i++){\r\n        //log.debug(PartyManager.NPCS[i]);\r\n        GameState.PartyManager.NPCS[i].available = avail[i].getFieldByLabel('PT_NPC_AVAIL').getValue();\r\n        GameState.PartyManager.NPCS[i].canSelect = avail[i].getFieldByLabel('PT_NPC_SELECT').getValue();\r\n      }\r\n    }\r\n  \r\n    //TSL: PT_AVAIL_PUPS\r\n    if(gff.RootNode.hasField('PT_AVAIL_PUPS')){\r\n      const avail = gff.getFieldByLabel('PT_AVAIL_PUPS').getChildStructs();\r\n      for(let i = 0; i < avail.length; i++){\r\n        GameState.PartyManager.Puppets[i].available = !!avail[i].getFieldByLabel('PT_PUP_AVAIL').getValue();\r\n        GameState.PartyManager.Puppets[i].select = !!avail[i].getFieldByLabel('PT_PUP_SELECT').getValue();\r\n      }\r\n    }\r\n\r\n    //TSL: PT_ITEM_CHEMICAL\r\n    if(gff.RootNode.hasField('PT_ITEM_CHEMICAL')){\r\n      GameState.PartyManager.ChemicalCount = gff.RootNode.getFieldByLabel('PT_ITEM_CHEMICAL').getValue();\r\n    }\r\n\r\n    //TSL: PT_ITEM_COMPONEN\r\n    if(gff.RootNode.hasField('PT_ITEM_COMPONEN')){\r\n      GameState.PartyManager.ComponentCount = gff.RootNode.getFieldByLabel('PT_ITEM_COMPONEN').getValue();\r\n    }\r\n  \r\n    //TSL: PT_AVAIL_PUPS\r\n    if(gff.RootNode.hasField('PT_INFLUENCE')){\r\n      const list = gff.getFieldByLabel('PT_INFLUENCE').getChildStructs();\r\n      for(let i = 0; i < list.length; i++){\r\n        GameState.PartyManager.InfluenceMap.set(i, list[i].getFieldByLabel('PT_NPC_INFLUENCE').getValue());\r\n      }\r\n    }\r\n  \r\n    //TSL: PT_AVAIL_PUPS\r\n    if(gff.RootNode.hasField('PT_PUPPETS')){\r\n      const list = gff.getFieldByLabel('PT_PUPPETS').getChildStructs();\r\n      for(let i = 0; i < list.length; i++){\r\n        //todo\r\n      }\r\n    }\r\n\r\n    GameState.PartyManager.Gold = gff.RootNode.getFieldByLabel('PT_GOLD').getValue();\r\n\r\n    if(gff.RootNode.hasField('PT_CONTROLLED_NP')){\r\n      log.debug('PT_CONTROLLED_NP', gff.RootNode.getFieldByLabel('PT_CONTROLLED_NP').getValue());\r\n    }\r\n\r\n    if(gff.RootNode.hasField('PT_MEMBERS')){\r\n      const pms = gff.getFieldByLabel('PT_MEMBERS').getChildStructs();\r\n      const currentPartyInfo = [];\r\n      GameState.PartyManager.CurrentMembers = [];\r\n      for(let i = 0; i < pms.length; i++){\r\n        GameState.PartyManager.CurrentMembers.push({\r\n          isLeader: pms[i].getFieldByLabel('PT_IS_LEADER').getValue() ? true : false,\r\n          memberID: pms[i].getFieldByLabel('PT_MEMBER_ID').getValue()\r\n        })\r\n      }\r\n    }\r\n\r\n    if(gff.RootNode.hasField('JNL_Entries')){\r\n      const entries = gff.RootNode.getFieldByLabel('JNL_Entries').getChildStructs();\r\n      for(let i = 0; i < entries.length; i++){\r\n        GameState.JournalManager.AddEntry(JournalEntry.FromStruct(entries[i]));\r\n      }\r\n    }\r\n\r\n    if(gff.RootNode.hasField('PT_DLG_MSG_LIST')){\r\n      const entries = gff.RootNode.getFieldByLabel('PT_DLG_MSG_LIST').getChildStructs();\r\n      for(let i = 0; i < entries.length; i++){\r\n        GameState.DialogMessageManager.AddEntry(DialogMessageEntry.FromStruct(entries[i]));\r\n      }\r\n    }\r\n\r\n    if(gff.RootNode.hasField('PT_FB_MSG_LIST')){\r\n      const entries = gff.RootNode.getFieldByLabel('PT_FB_MSG_LIST').getChildStructs();\r\n      for(let i = 0; i < entries.length; i++){\r\n        GameState.FeedbackMessageManager.AddEntry(FeedbackMessageEntry.FromStruct(entries[i]));\r\n      }\r\n    }\r\n\r\n    for(let i = 0; i < PartyManager.MaxPartyCount; i++){\r\n      const id = i;\r\n      try{\r\n        const buffer = await GameFileSystem.readFile( path.join( CurrentGame.gameinprogress_dir, 'availnpc'+id+'.utc') );\r\n        GameState.PartyManager.NPCS[id].template = null;\r\n        if(buffer.length){\r\n          GameState.PartyManager.NPCS[id].template = new GFFObject(buffer);\r\n        }\r\n      }catch(e){\r\n        log.debug('LoadPartyMember availnpc load', e instanceof Error ? e : String(e));\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Pazaak Cards\r\n     * PT_PAZAAKCARDS contains the cards that the player has in their deck\r\n     * struct child index is the card enum value\r\n     * PT_PAZAAKCOUNT is the number of that card in the deck\r\n     * - max index is 17\r\n     * - unknown 18th index always contains a PT_PAZAAKCOUNT of 0 unlike the other 17 PT_PAZAAKCOUNT is a BYTE\r\n     * - where the other 17 are INTs\r\n     */\r\n    if(gff.RootNode.hasField('PT_PAZAAKCARDS')){\r\n      const list = gff.RootNode.getFieldByLabel('PT_PAZAAKCARDS').getChildStructs();\r\n      for(let i = 0; i < list.length; i++){\r\n        GameState.PazaakManager.Cards.set(i, {\r\n          card: i,\r\n          count: list[i].getFieldByLabel('PT_PAZAAKCOUNT').getValue()\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Pazaak Side Deck\r\n     * PT_PAZSIDELIST contains the cards that the player has equipped in their side deck\r\n     * struct child index is the card index in the side deck\r\n     * PT_PAZSIDECARD is the card enum value\r\n     * max index is 10\r\n     */\r\n    if(gff.RootNode.hasField('PT_PAZSIDELIST')){\r\n      const list = gff.RootNode.getFieldByLabel('PT_PAZSIDELIST').getChildStructs();\r\n      for(let i = 0; i < list.length; i++){\r\n        GameState.PazaakManager.PlayerSideDeck.set(i, list[i].getFieldByLabel('PT_PAZSIDECARD').getValue());\r\n      }\r\n    }\r\n    \r\n  }\r\n\r\n  /**\r\n   * Export the party manager\r\n   * @param directory - The directory to export to\r\n   * @returns void\r\n   */\r\n  static async Export(directory = ''){\r\n    return new Promise<void>( (resolve, reject) => {\r\n      //Export PARTYTABLE.res\r\n      const partytable = new GFFObject();\r\n      partytable.FileType = 'PT  ';\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.STRUCT, 'GlxyMap')).addChildStruct( GameState.Planetary.SaveStruct() );\r\n      const jnl_list = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'JNL_Entries'));\r\n\r\n      for(let i = 0; i <  GameState.JournalManager.Entries.length; i++){\r\n        jnl_list.addChildStruct(\r\n          GameState.JournalManager.Entries[i].toStruct()\r\n        );\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'JNL_SortOrder')).setValue(0);\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_AISTATE')).setValue(0);\r\n      const availNPCSList = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_AVAIL_NPCS'));\r\n\r\n      //TODO: Party Available NPCS\r\n      const maxPartyMembers = (GameState.GameKey == GameEngineType.KOTOR) ? 9 : 12;\r\n      for(let i = 0; i < maxPartyMembers; i++){\r\n        const pm = GameState.PartyManager.NPCS[i];\r\n        const availStruct = new GFFStruct();\r\n        availStruct.addField( new GFFField(GFFDataType.BYTE, 'PT_NPC_AVAIL') ).setValue(pm.available ? 1 : 0);\r\n        availStruct.addField( new GFFField(GFFDataType.BYTE, 'PT_NPC_SELECT') ).setValue(pm.canSelect ? 1 : 0);\r\n        availNPCSList.addChildStruct(availStruct);\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_CHEAT_USED')).setValue(0);\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_CONTROLLED_NP')).setValue( GameState.getCurrentPlayer() == GameState.PartyManager.Player ? -1 : GameState.PartyManager.party.indexOf(GameState.getCurrentPlayer()) );\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_COST_MULT_LIS'));\r\n\r\n      //TODO: COST MULT LIST\r\n\r\n      const dlg_list = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_DLG_MSG_LIST'));\r\n\r\n      for(let i = 0; i <  GameState.DialogMessageManager.Entries.length; i++){\r\n        dlg_list.addChildStruct(\r\n          GameState.DialogMessageManager.Entries[i].toStruct()\r\n        );\r\n      }\r\n\r\n      const fb_list = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_FB_MSG_LIST'));\r\n\r\n      for(let i = 0; i <  GameState.FeedbackMessageManager.Entries.length; i++){\r\n        fb_list.addChildStruct(\r\n          GameState.FeedbackMessageManager.Entries[i].toStruct()\r\n        );\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_FOLLOWSTATE')).setValue(0);\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.DWORD, 'PT_GOLD')).setValue(GameState.PartyManager.Gold);\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_LAST_GUI_PNL')).setValue(0);\r\n      const ptMembersList = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_MEMBERS'));\r\n\r\n      let numMembers = 0;\r\n      for(let i = 0; i < GameState.PartyManager.party.length; i++){\r\n        const member = GameState.PartyManager.party[i];\r\n        if(member != GameState.PartyManager.Player){\r\n          const memberStruct = new GFFStruct();\r\n          memberStruct.addField( new GFFField(GFFDataType.BYTE, 'PT_IS_LEADER') ).setValue( GameState.getCurrentPlayer() == member ? 1 : 0 );\r\n          memberStruct.addField( new GFFField(GFFDataType.INT, 'PT_MEMBER_ID') ).setValue( member.npcId );\r\n          ptMembersList.addChildStruct( memberStruct );\r\n          numMembers++;\r\n        }\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PT_NUM_MEMBERS')).setValue(numMembers);\r\n\r\n      /**\r\n       * Pazaak Cards\r\n       */\r\n      const pazaakCardsList = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_PAZAAKCARDS'));\r\n      for(let i = 0; i < PazaakCards.MAX_CARDS + 1; i++){\r\n        const cardStruct = new GFFStruct(0);\r\n        const card = GameState.PazaakManager.Cards.get(i);\r\n        const isUnusedCard = i == PazaakCards.UNUSED_CARD;\r\n        /**\r\n         * Pazaak Unused Card\r\n         * - index 0-17: set the card count\r\n         * - index 18, unknown card, not sure if it's used at all\r\n         */\r\n        cardStruct.addField(new GFFField( isUnusedCard ? GFFDataType.BYTE : GFFDataType.INT, 'PT_PAZAAKCOUNT'))\r\n          .setValue(isUnusedCard ? 0 : card.count);\r\n        pazaakCardsList.addChildStruct(cardStruct);\r\n      }\r\n\r\n      /**\r\n       * Pazaak Side Deck\r\n       */\r\n      const pazaakSideDeckList = partytable.RootNode.addField(new GFFField(GFFDataType.LIST, 'PT_PAZSIDELIST'));\r\n      for(let i = 0; i < PazaakSideDeckSlots.MAX_SLOTS; i++){\r\n        const sideDeckStruct = new GFFStruct(0);\r\n        const sideDeckCard = GameState.PazaakManager.PlayerSideDeck.get(i);\r\n        sideDeckStruct.addField(new GFFField(GFFDataType.INT, 'PT_PAZSIDECARD'))\r\n          .setValue(sideDeckCard);\r\n        pazaakSideDeckList.addChildStruct(sideDeckStruct);\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.DWORD, 'PT_PLAYEDSECONDS')).setValue(0);\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PT_SOLOMODE')).setValue(0);\r\n\r\n      const tutorial2DA = GameState.TwoDAManager.datatables.get('tutorial');\r\n      if(tutorial2DA){\r\n        const byteCount = Math.ceil(tutorial2DA.RowCount / 8);\r\n        const buffer = new Uint8Array(byteCount);\r\n        for(let i = 0; i < byteCount; i++){\r\n          let byte = 0;\r\n          for(let j = 0; j < 8; j++){\r\n            const offset = (8 * i) + j;\r\n            const bit = GameState.TutorialWindowTracker[offset];\r\n            if(bit){\r\n              byte |= 1 << j;\r\n            }\r\n          }\r\n          buffer[i] = byte;\r\n        }\r\n        partytable.RootNode.addField(new GFFField(GFFDataType.VOID, 'PT_TUT_WND_SHOWN')).setData(buffer);\r\n      }else{\r\n        partytable.RootNode.addField(new GFFField(GFFDataType.VOID, 'PT_TUT_WND_SHOWN')).setData(new Uint8Array(0));\r\n      }\r\n\r\n      partytable.RootNode.addField(new GFFField(GFFDataType.INT, 'PT_XP_POOL'));\r\n\r\n      partytable.FileType = 'PT  ';\r\n      partytable.export(path.join(directory, 'PARTYTABLE.res'), () => {\r\n        resolve();\r\n      }, () => {\r\n        reject();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add gold to the party manager\r\n   * @param amount - The amount of gold to add\r\n   * @returns void\r\n   */\r\n  static AddGold(amount: number){\r\n    if(!amount) return;\r\n    this.Gold += amount;\r\n    \r\n    if(this.Gold < 0){\r\n      this.Gold = 0;\r\n    }\r\n\r\n    GameState.UINotificationManager.EnableUINotificationIconType(amount > 0 ? UIIconTimerType.CREDITS_RECEIVED : UIIconTimerType.CREDITS_RECEIVED);\r\n  }\r\n\r\n  /**\r\n   * Switch the leader of the party at the index\r\n   * @param index - The index of the party member to switch the leader of\r\n   * @returns void\r\n   */\r\n  static SwitchLeaderAtIndex(index: number = 0){\r\n    index = Math.abs(index);\r\n\r\n    if(index >= PartyManager.party.length){\r\n      log.warn(`Index out of range: ${index}/${PartyManager.party.length}`);\r\n      return;\r\n    }\r\n\r\n    if(index == 0){\r\n      log.warn('Party Member at index 0 is already the party leader.');\r\n      return PartyManager.party[0];\r\n    }\r\n\r\n    const pm = PartyManager.party.splice(index, 1)[0];\r\n    PartyManager.party.unshift(pm);\r\n    PartyManager.ProcessEventListener('change', [pm]);\r\n    PartyManager.UpdateLeader();\r\n    return pm;\r\n  }\r\n\r\n  static async AddNPCById(npcId = 0){\r\n    if(PartyManager.IsNPCInParty(npcId)){\r\n      return;\r\n    }\r\n\r\n    const arrayLength = PartyManager.CurrentMembers.push({\r\n      isLeader: false,\r\n      memberID: npcId\r\n    });\r\n    PartyManager.RebuildPortraitOrder();\r\n\r\n    await PartyManager.LoadPartyMember(arrayLength - 1);\r\n  }\r\n\r\n  /**\r\n   * Remove the NPC by the ID\r\n   * @param npcId - The ID of the NPC to remove\r\n   * @param leaveInWorld - Whether to leave the NPC in the world\r\n   * @returns void\r\n   */\r\n  static RemoveNPCById(npcId = 0, leaveInWorld = false){\r\n    log.trace('RemoveNPCById', npcId, leaveInWorld);\r\n    const partyMember = PartyManager.GetPartyMemberByNPCId(npcId);\r\n    if(!partyMember){\r\n      return;\r\n    }\r\n\r\n    const pmIndex = PartyManager.party.indexOf(partyMember);\r\n    if(pmIndex == -1){\r\n      return;\r\n    }\r\n\r\n    //Remove the partymember from the module\r\n    partyMember.isPM = false;\r\n    PartyManager.party.splice(pmIndex, 1);\r\n    PartyManager.RebuildPortraitOrder();\r\n\r\n    if(!leaveInWorld){\r\n      log.debug('RemoveNPCById !leaveInWorld', partyMember);\r\n      partyMember.destroy();\r\n    }else{\r\n      log.debug('RemoveNPCById leaveInWorld', partyMember);\r\n      if(partyMember.container){\r\n        partyMember.container.removeFromParent();\r\n      }\r\n      GameState.group.creatures.add(partyMember.container);\r\n      GameState.module.area.attachObject(partyMember);\r\n    }\r\n    \r\n    PartyManager.RemoveCurrentMemberByNPCId(npcId);\r\n  }\r\n\r\n  static GetPartyMemberByNPCId(npcId = 0){\r\n    for(let i = 0; i < PartyManager.party.length; i++){\r\n      const pm = PartyManager.party[i];\r\n      if(pm.npcId == npcId){\r\n        return pm;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  static RemovePartyMemberByNPCId(npcId = 0){\r\n    const pm = PartyManager.GetPartyMemberByNPCId(npcId);\r\n    if(!pm){\r\n      return;\r\n    }\r\n    PartyManager.party.splice(PartyManager.party.indexOf(pm), 1);\r\n  }\r\n\r\n  static GetCurrentMemberByNPCId(npcId = 0){\r\n    for(let i = 0; i < PartyManager.CurrentMembers.length; i++){\r\n      const mem = PartyManager.CurrentMembers[i];\r\n      if(mem.memberID == npcId){\r\n        return mem;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  static RemoveCurrentMemberByNPCId(npcId = 0){\r\n    const mem = PartyManager.GetCurrentMemberByNPCId(npcId);\r\n    if(!mem){\r\n      return;\r\n    }\r\n    const cmIndex = PartyManager.CurrentMembers.indexOf(mem);\r\n    if(cmIndex == -1){\r\n      return;\r\n    }\r\n    PartyManager.CurrentMembers.splice(cmIndex, 1);\r\n  }\r\n\r\n  /**\r\n   * Get the portrait by the index\r\n   * @param nID - The index of the portrait to get\r\n   * @returns string\r\n   */\r\n  static GetPortraitByIndex(nID = 0){\r\n\r\n    let portraitId = 0;\r\n    let goodEvil = 50;\r\n    if(PartyManager.NPCS[nID].template instanceof GFFObject){\r\n      const pm = PartyManager.NPCS[nID].template;\r\n      if(pm.RootNode.hasField('PortraitId')){\r\n        portraitId = pm.RootNode.getFieldByLabel('PortraitId').getValue();\r\n        goodEvil = pm.RootNode.getFieldByLabel('GoodEvil').getValue();\r\n      }\r\n    }\r\n\r\n    const portrait = GameState.SWRuleSet.portraits[portraitId];\r\n    if(!portrait){\r\n      return;\r\n    }\r\n\r\n    return portrait.getPortraitGoodEvil(goodEvil);\r\n  }\r\n\r\n  /**\r\n   * Rebuild the portrait order\r\n   * @returns void\r\n   */\r\n  static RebuildPortraitOrder(){\r\n    PartyManager.PortraitOrder = [];\r\n    for(let i = 0; i < PartyManager.party.length; i++){\r\n      PartyManager.PortraitOrder[i] = PartyManager.party[i].getPortraitResRef().toLowerCase();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the portrait by the resref\r\n   * @param resref - The resref of the portrait to get\r\n   * @returns SWPortrait\r\n   */\r\n  static GetPortraitByResRef( resref = '' ): SWPortrait{\r\n    const portrait2DA = GameState.SWRuleSet.portraits;\r\n    if(!portrait2DA || !portrait2DA.length){\r\n      return null;\r\n    }\r\n    for(let i = 0, len = portrait2DA.length; i < len; i++){\r\n      if(portrait2DA[i].baseresref.toLowerCase() != resref.toLowerCase()){\r\n        continue;\r\n      }\r\n      return portrait2DA[i];    \r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Add the portrait to the order\r\n   * @param resref - The resref of the portrait to add\r\n   * @returns void\r\n   */\r\n  static AddPortraitToOrder( resref = '' ){\r\n    if(PartyManager.PortraitOrder.indexOf(resref) == -1 )\r\n      PartyManager.PortraitOrder.push( resref.toLowerCase() );\r\n  }\r\n\r\n  /**\r\n   * Set the selectable state of the NPC\r\n   * @param nID - The ID of the NPC to set the selectable state of\r\n   * @param state - The state to set the selectable state to\r\n   * @returns void\r\n   */\r\n  static SetSelectable(nID = 0, state = false){\r\n    PartyManager.NPCS[nID].canSelect = state ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Check if the NPC is selectable\r\n   * @param nID - The ID of the NPC to check if it is selectable\r\n   * @returns boolean\r\n   */\r\n  static IsSelectable(nID = 0){\r\n    return PartyManager.NPCS[nID]?.canSelect ? true : false;\r\n  }\r\n  \r\n  /**\r\n   * Check if the NPC is available\r\n   * @param nID - The ID of the NPC to check if it is available\r\n   * @returns boolean\r\n   */\r\n  static IsAvailable(nID = 0){\r\n    return PartyManager.NPCS[nID]?.available ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Check if the NPC is in the party\r\n   * @param npcId - The ID of the NPC to check if it is in the party\r\n   * @returns boolean\r\n   */\r\n  static IsNPCInParty(npcId: number){\r\n    for(let i = 0; i < PartyManager.CurrentMembers.length; i++){\r\n      const cpm = PartyManager.CurrentMembers[i];\r\n      if(cpm.memberID == npcId){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the PartyMember to unavailable\r\n   * @param npcId - The ID of the NPC to set to unavailable\r\n   * @returns void\r\n   */\r\n  static RemoveAvailableNPC(npcId = 0){\r\n    PartyManager.NPCS[npcId].available = false;\r\n    PartyManager.NPCS[npcId].canSelect = false;\r\n    PartyManager.NPCS[npcId].template;\r\n  }\r\n\r\n\r\n  /**\r\n   * Add a creature template to the list of available PartyMembers\r\n   * @param npcId - The ID of the NPC to add to the list of available PartyMembers\r\n   * @param template - The template to add to the list of available PartyMembers\r\n   * @returns boolean\r\n   */\r\n  static AddAvailableNPCByTemplate(npcId = 0, template: string|GFFObject = ''): boolean {\r\n    if(typeof template === 'string'){\r\n      //Load template and merge fields\r\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['utc'], template);\r\n      if(buffer){\r\n        PartyManager.NPCS[npcId].available = true;\r\n        PartyManager.NPCS[npcId].canSelect = true;\r\n        PartyManager.NPCS[npcId].template = new GFFObject(buffer);\r\n        return true;\r\n      }else{\r\n        log.error('Failed to load character template');\r\n      }\r\n    }else if(template instanceof GFFObject){\r\n      //We already have the template (From SAVEGAME)\r\n      PartyManager.NPCS[npcId].available = true;\r\n      PartyManager.NPCS[npcId].canSelect = true;\r\n      PartyManager.NPCS[npcId].template = template;\r\n      return true;\r\n    }else{\r\n      log.error('Failed to load character template');\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static AddAvailableNPCByObject(npcId = 0, object: ModuleCreature): boolean {\r\n    if(!BitWise.InstanceOfObject(object, ModuleObjectType.ModuleCreature)){\r\n      return false;\r\n    }\r\n    PartyManager.NPCS[npcId].available = true;\r\n    PartyManager.NPCS[npcId].canSelect = true;\r\n    PartyManager.NPCS[npcId].template = object.save();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Add a world creature to the list of Party Members and remove it from the creatures array\r\n   * @param slot - The slot to add the creature to\r\n   * @param creature - The creature to add to the list of Party Members\r\n   * @returns void\r\n   */\r\n  static AddCreatureToParty(slot = 1, creature: ModuleCreature){\r\n    if(!BitWise.InstanceOfObject(creature, ModuleObjectType.ModuleCreature)){\r\n      return;\r\n    }\r\n\r\n    creature = creature as ModuleCreature;\r\n    creature.isPM = true;\r\n    creature.clearAllActions();\r\n    PartyManager.NPCS[slot].available = true;\r\n    //PartyManager.NPCS[nID].canSelect = true;\r\n    PartyManager.NPCS[slot].template = creature.template;\r\n    PartyManager.NPCS[slot].moduleObject = creature;\r\n    //Add the creature to the party array\r\n    PartyManager.party.push(creature);\r\n    //Check to see if the creature needs to be removed from the creatures array\r\n    const cIdx = GameState.module.area.creatures.indexOf(creature);\r\n    if(cIdx > -1){\r\n      GameState.module.area.creatures.splice(cIdx, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switch the player character\r\n   * @param npcId - The ID of the NPC to switch the player character to\r\n   * @returns ModuleCreature\r\n   */\r\n  static SwitchPlayerCharacter(npcId = 0){\r\n    let partyMember: ModuleCreature;\r\n    if(npcId == -1){\r\n      partyMember = new ModulePlayer(PartyManager.ActualPlayerTemplate);\r\n      PartyManager.PlayerTemplate = PartyManager.ActualPlayerTemplate;\r\n    }else{\r\n      partyMember = new ModuleCreature(PartyManager.NPCS[npcId].template);\r\n    }\r\n     \r\n    const oldPC = PartyManager.Player;\r\n    PartyManager.Player = partyMember;\r\n\r\n    if(PartyManager.Player.isPlayer && npcId >= 0){\r\n      PartyManager.ActualPlayerTemplate = PartyManager.Player.save();\r\n      CurrentGame.WriteFile('pc.utc', PartyManager.ActualPlayerTemplate.getExportBuffer());\r\n    }\r\n\r\n    try{\r\n      const spawn = oldPC.position.clone();\r\n      const quaternion = oldPC.quaternion.clone();\r\n\r\n      partyMember.isPM = true;\r\n      partyMember.isPC = 1;\r\n      partyMember.npcId = npcId;\r\n      partyMember.load();\r\n      partyMember.clearAllActions();\r\n      partyMember.position.copy(spawn);\r\n      partyMember.quaternion.copy(quaternion);\r\n      partyMember.loadScripts();\r\n      partyMember.loadModel().then( (model: OdysseyModel3D) => {\r\n        PartyManager.party[0] = partyMember;\r\n        \r\n        model.userData.moduleObject = partyMember;\r\n        partyMember.position.copy(spawn);\r\n        partyMember.quaternion.copy(quaternion);\r\n        model.hasCollision = true;\r\n        \r\n        GameState.group.party.add( partyMember.container );\r\n        oldPC.destroy();\r\n        partyMember.onSpawn();\r\n      });\r\n      return partyMember;\r\n    }catch(e){\r\n      log.error(e instanceof Error ? e : String(e));\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save the current party member templates\r\n   * @returns void\r\n   */\r\n  static Save(){\r\n    const npcs = PartyManager.party.filter( (pm) => pm.npcId >= 0 );\r\n    for(let i = 0; i < npcs.length; i++){\r\n      const pm = npcs[i];\r\n      PartyManager.CurrentMembers[i] = {\r\n        isLeader: i == 0 ? true : false,\r\n        memberID: pm.npcId\r\n      };\r\n      PartyManager.SavePartyMember(pm.npcId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shift the current leader to the end of the party array\r\n   * @returns void\r\n   */\r\n  static ShiftLeader(){\r\n    PartyManager.party.push( PartyManager.party.shift() );\r\n    PartyManager.UpdateLeader();\r\n  }\r\n\r\n  /**\r\n   * Update the party members to see if any of them is the current party leader\r\n   * @returns void\r\n   */\r\n  static UpdateLeader(){\r\n    for(let i = 0; i < PartyManager.CurrentMembers.length; i++){\r\n      const isLeader = (PartyManager.party[0].npcId == PartyManager.CurrentMembers[i].memberID);\r\n      PartyManager.CurrentMembers[i].isLeader = isLeader;\r\n    }\r\n\r\n    PartyManager.RebuildPortraitOrder();\r\n  }\r\n\r\n  /**\r\n   * Check to see if the current leader is a party member and not the player\r\n   * @returns boolean\r\n   */\r\n  static IsPartyMemberLeader(){\r\n    return (PartyManager.party[0].npcId >= 0);\r\n  }\r\n\r\n  /**\r\n   * Check to see if the player character is the leader of the party\r\n   * @returns boolean\r\n   */\r\n  static IsPlayerPartyLeader(){\r\n    return !PartyManager.IsPartyMemberLeader();\r\n  }\r\n\r\n  /**\r\n   * Get the party member by the NPC ID\r\n   * @param npcId - The NPC ID\r\n   * @returns PartyMember\r\n   */\r\n  static GetPMByNPCId(npcId: number = -1){\r\n    return PartyManager.party.find( (obj) => obj.npcId == npcId);\r\n  }\r\n\r\n  /**\r\n   * Make the player character the leader of the party\r\n   * @param swapWorldPositions - Whether to swap the world positions of the player and the party leader\r\n   * @returns void\r\n   */\r\n  static MakePlayerLeader(swapWorldPositions: boolean = true){\r\n    const idx = PartyManager.party.indexOf(PartyManager.Player);\r\n    if(idx <= 0){ return; }\r\n\r\n    const old_pm = PartyManager.party[0];\r\n    const old_pm_pos = PartyManager.party[0].position.clone();\r\n    const old_player_pos = PartyManager.Player.position.clone();\r\n    PartyManager.SwitchLeaderAtIndex(idx);\r\n    if(swapWorldPositions){\r\n      PartyManager.Player.setPosition(old_pm_pos);\r\n      old_pm.setPosition(old_player_pos);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the index of the creature in the party array by the order of it's portrait resref in the PortraitOrder array\r\n   * @param creature - The creature to get the index of\r\n   * @returns number\r\n   */\r\n  static GetCreatureStartingPartyIndex(creature: ModuleCreature){\r\n\r\n    if(PartyManager.PortraitOrder[0]?.toLowerCase() == creature.getPortraitResRef().toLowerCase()){\r\n      return 0\r\n    }else if(PartyManager.PortraitOrder[1]?.toLowerCase() == creature.getPortraitResRef().toLowerCase()){\r\n      return 1;\r\n    }else if(PartyManager.PortraitOrder[2]?.toLowerCase() == creature.getPortraitResRef().toLowerCase()){\r\n      return 2\r\n    }\r\n\r\n    return PartyManager.party.length;\r\n\r\n  }\r\n\r\n  /**\r\n   * Load the PartyMember by it's index in the CurrentMembers array.\r\n   * @param nIdx - The index of the party member to load\r\n   * @returns void\r\n   */\r\n  static async LoadPartyMember(nIdx: number = 0){\r\n    const npc = PartyManager.NPCS[PartyManager.CurrentMembers[nIdx].memberID];\r\n    const template = npc.template;\r\n    template.RootNode.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue( GameState.ModuleObjectManager.GetNextPlayerId() );\r\n    const partyMember = new ModuleCreature(template);\r\n\r\n    if(nIdx < 0 || nIdx > 1){\r\n      log.warn('LoadPartyMember wrong index', nIdx, npc, partyMember);\r\n      return;\r\n    }\r\n\r\n    let currentSlot: ModuleCreature;\r\n\r\n    try{\r\n      if(!(currentSlot instanceof ModuleCreature)){\r\n        partyMember.isPM = true;\r\n        partyMember.npcId = PartyManager.CurrentMembers[nIdx].memberID;\r\n        partyMember.load();\r\n        partyMember.clearAllActions();\r\n        //PartyManager.party[nIdx+1] = partyMember;\r\n\r\n        /*if(PartyManager.CurrentMembers[nIdx].isLeader){\r\n          PartyManager.party.unshift(PartyManager.party.splice(nIdx+1, 1)[0]);\r\n        }*/\r\n        PartyManager.AddPortraitToOrder( partyMember.getPortraitResRef() );\r\n        PartyManager.party[ PartyManager.GetCreatureStartingPartyIndex(partyMember) ] = partyMember;\r\n        const spawn = PartyManager.GetSpawnLocation(partyMember);\r\n        partyMember.position.copy(spawn.position);\r\n        partyMember.setFacing(spawn.getFacing(), true);\r\n        \r\n        const model = await partyMember.loadModel();\r\n        model.userData.moduleObject = partyMember;\r\n\r\n        partyMember.position.copy(spawn.position);\r\n        partyMember.setFacing(spawn.getFacing(), true);\r\n        //partyMember.quaternion.setFromAxisAngle(new THREE.Vector3(0,0,1), -Math.atan2(0, 0));\r\n  \r\n        model.hasCollision = true;\r\n        GameState.group.party.add( partyMember.container );\r\n\r\n        partyMember.onSpawn();\r\n      }else{\r\n        const spawn = PartyManager.GetSpawnLocation(currentSlot);\r\n        currentSlot.position.copy(spawn.position);\r\n        currentSlot.setFacing(spawn.getFacing(), true);\r\n        //currentSlot.quaternion.setFromAxisAngle(new THREE.Vector3(0,0,1), -Math.atan2(0, 0));\r\n      }\r\n    }catch(e){\r\n      log.error(e instanceof Error ? e : String(e));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used in the TSL PartySelection menu to load creature for the 3D preview of the selected party member\r\n   * @param npcId - The NPC ID\r\n   * @param onLoad - The function to call when the party member is loaded\r\n   * @returns void\r\n   */\r\n  static LoadPartyMemberCreature(npcId = 0, onLoad?: (creature: ModuleCreature | null) => void){\r\n    const npc = PartyManager.NPCS[npcId];\r\n    if(!npc){\r\n      if(typeof onLoad === 'function')\r\n        onLoad(null);\r\n\r\n      return;\r\n    }\r\n\r\n    if(!npc.template){\r\n      if(typeof onLoad === 'function')\r\n        onLoad(null);\r\n\r\n      return;\r\n    }\r\n    \r\n    const partyMember = new ModuleCreature(npc.template);\r\n    partyMember.npcId = npcId;\r\n    partyMember.isPM = true;\r\n    partyMember.load();\r\n    partyMember.clearAllActions();\r\n    partyMember.loadModel().then( (model: OdysseyModel3D) => {\r\n      model.userData.moduleObject = partyMember;\r\n      partyMember.onSpawn();\r\n      if(typeof onLoad === 'function')\r\n        onLoad(partyMember);\r\n\r\n    });\r\n    \r\n  }\r\n\r\n  /**\r\n   * Get the spawn location of the creature\r\n   * @param creature - The creature to get the spawn location of\r\n   * @returns EngineLocation\r\n   */\r\n  static GetSpawnLocation( creature: ModuleCreature ){\r\n    if( BitWise.InstanceOfObject(creature, ModuleObjectType.ModuleCreature) ){\r\n      if( GameState.isLoadingSave ){\r\n        return new EngineLocation(\r\n          creature.position.x, \r\n          creature.position.y, \r\n          creature.position.z,\r\n          creature.getXOrientation(), \r\n          creature.getYOrientation(), \r\n          creature.getZOrientation()\r\n        );\r\n      }else if( GameState.module.area.transWP ){\r\n        if( GameState.module.area.transWP ){\r\n          //log.debug('TransWP - PM', GameState.module.area.transWP);\r\n        }\r\n        const index = PartyManager.PortraitOrder.indexOf( creature.getPortraitResRef().toLowerCase() );\r\n        const spawnLoc = GameState.module.area.getSpawnLocation();\r\n        const facing = -Math.atan2(spawnLoc.rotation.x, spawnLoc.rotation.y);\r\n        switch(index){\r\n          case 0:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x,\r\n              spawnLoc.position.y, \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z\r\n            );\r\n          case 1:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x + 1.5 * Math.cos(facing), \r\n              spawnLoc.position.y + 1.5 * Math.sin(facing), \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z\r\n            );\r\n          case 2:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x + -1.5 * Math.cos(facing), \r\n              spawnLoc.position.y + -1.5 * Math.sin(facing), \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z\r\n            );\r\n        }\r\n      }else{\r\n        const index = PartyManager.PortraitOrder.indexOf( creature.getPortraitResRef().toLowerCase() );\r\n        const spawnLoc = GameState.module.area.getSpawnLocation();\r\n        const facing = spawnLoc.getFacing();\r\n        switch(index){\r\n          case 0:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x,\r\n              spawnLoc.position.y, \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z,\r\n            );\r\n          case 1:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x + 1.5 * Math.cos(facing), \r\n              spawnLoc.position.y + 1.5 * Math.sin(facing), \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z,\r\n            );\r\n          case 2:\r\n            return new EngineLocation(\r\n              spawnLoc.position.x + -1.5 * Math.cos(facing), \r\n              spawnLoc.position.y + -1.5 * Math.sin(facing), \r\n              spawnLoc.position.z,\r\n              spawnLoc.rotation.x,\r\n              spawnLoc.rotation.y, \r\n              spawnLoc.rotation.z,\r\n            );\r\n        }\r\n      }\r\n    }\r\n    \r\n    return GameState.module.area.getSpawnLocation();\r\n\r\n  }\r\n\r\n  static #tmpFollowPositionTarget = new THREE.Vector3();\r\n  static #tmpFollowPosition = new THREE.Vector3();\r\n  /**\r\n   * Get the follow position of the creature\r\n   * @param creature - The creature to get the follow position of\r\n   * @returns THREE.Vector3\r\n   */\r\n  static GetFollowPosition(creature: ModuleCreature){\r\n    return this.GetFollowPositionAtIndex(PartyManager.party.indexOf(creature));\r\n  }\r\n\r\n  /**\r\n   * Get the follow position of the creature at the index\r\n   * @param idx - The index of the party member to get the follow position of\r\n   * @returns THREE.Vector3\r\n   */\r\n  static GetFollowPositionAtIndex(idx: number = 1){\r\n    const leader = PartyManager.party[0];\r\n    const creature = PartyManager.party[idx];\r\n\r\n    if(!creature)\r\n      return new THREE.Vector3();\r\n\r\n    const targetOffset = (idx == 2) ? -1.5 :1.5;\r\n\r\n    this.#tmpFollowPositionTarget.set(\r\n      targetOffset * Math.cos(leader.rotation.z), \r\n      targetOffset * Math.sin(leader.rotation.z), \r\n      0\r\n    );\r\n    this.#tmpFollowPosition.copy(leader.position).sub(this.#tmpFollowPositionTarget);\r\n\r\n    return (creature.area.isPointWalkable(this.#tmpFollowPosition)) ?\r\n      this.#tmpFollowPosition : creature.area.getNearestWalkablePoint(this.#tmpFollowPosition, creature.getHitDistance());\r\n  }\r\n\r\n  /**\r\n   * Give XP to the player\r\n   * @param nXP - The amount of XP to give\r\n   * @returns void\r\n   */\r\n  static GiveXP(nXP = 0){\r\n    this.Player.experience += nXP;\r\n    GameState.UINotificationManager.EnableUINotificationIconType(UIIconTimerType.PLOT_XP_RECEIVED);\r\n  }\r\n\r\n  /**\r\n   * Export the party member template\r\n   * @param index - The index of the party member to export\r\n   * @param template - The template to export\r\n   * @returns void\r\n   */\r\n  static async ExportPartyMemberTemplate( index = 0, template: GFFObject ){\r\n    if(!(template instanceof GFFObject)){ return; }\r\n    template.removeFieldByLabel('TemplateResRef');\r\n    await template.export( path.join( CurrentGame.gameinprogress_dir, 'AVAILNPC'+index+'.utc'));\r\n  }\r\n\r\n  /**\r\n   * Export the party member templates\r\n   * @returns void\r\n   */\r\n  static async ExportPartyMemberTemplates(){\r\n    return new Promise<void>( async (resolve, reject) => {\r\n      const maxPartyMembers = (GameState.GameKey == GameEngineType.KOTOR) ? 9 : 12;\r\n      for(let i = 0; i < maxPartyMembers; i++){\r\n        const pm = PartyManager.NPCS[i];\r\n        if(!pm){\r\n          log.warn(`ExportPartyMemberTemplates: Failed to export template for NPC at index [${i}]. pm was undefined.`);\r\n          continue;\r\n        }\r\n\r\n        if(!(pm.template instanceof GFFObject)){\r\n          log.warn(`ExportPartyMemberTemplates: Failed to export template for NPC at index [${i}]. template was not an instance of GFFObject`);\r\n          continue;\r\n        }\r\n\r\n        await PartyManager.ExportPartyMemberTemplate(i, pm.template);\r\n      }\r\n      await PartyManager.ExportPlayerCharacter();\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Export the player character\r\n   * @returns void\r\n   */\r\n  static async ExportPlayerCharacter(){\r\n    if(!GameState.PartyManager.ActualPlayerTemplate){ return; }\r\n    const gff = GameState.PartyManager.ActualPlayerTemplate;\r\n    await gff.export( path.join( CurrentGame.gameinprogress_dir, 'pc.utc'));\r\n  }\r\n\r\n  /**\r\n   * Save the party member\r\n   * @param npcId - The NPC ID\r\n   * @returns void\r\n   */\r\n  public static async SavePartyMember(npcId: number = 0){\r\n    const pm = PartyManager.party.find( (pm) => pm.npcId == npcId );\r\n    if(pm) pm.save();\r\n    const npc = PartyManager.NPCS[npcId];\r\n    if(!npc){ return; }\r\n    if(npc.template instanceof GFFObject){\r\n      await PartyManager.ExportPartyMemberTemplate(npcId, npc.template);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate the player template\r\n   * @returns GFFObject\r\n   */\r\n  public static GeneratePlayerTemplate(): GFFObject {\r\n    const pTPL = new GFFObject();\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue( GameState.ModuleObjectManager.GetNextPlayerId() );\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'Appearance_Type') ).setValue(GameState.GameKey == GameEngineType.TSL ? 134 : 177);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'FirstName') ).setValue(GameState.GameKey == GameEngineType.TSL ? 'Leia Organa' : 'Luke Skywalker');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.INT, 'Age') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.SHORT, 'ArmorClass') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'BodyBag') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'ChallengeRating') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'FactionID') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'PortraitId') ).setValue(GameState.GameKey == GameEngineType.TSL ? 10 : 26);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'HitPoints') ).setValue(100);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'MaxHitPoints') ).setValue(100);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'CurrentHitPoints') ).setValue(70);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'ForcePoints') ).setValue(15);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'MaxForcePoints') ).setValue(15);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'Commandable') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'CurrentForce') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'DeadSelectable') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'DetectMode') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'Disarmable') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'IsDestroyable') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'IsPC') ).setValue(1);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'IsRaiseable') ).setValue(1);\r\n    const equipment = pTPL.RootNode.addField( new GFFField(GFFDataType.LIST, 'Equip_ItemList') );\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptAttacked') ).setValue('k_hen_attacked01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptDamaged') ).setValue('k_def_damage01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptDeath') ).setValue('');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptDialogue') ).setValue('k_hen_dialogue01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptDisturbed') ).setValue('');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptEndDialogu') ).setValue('');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptEndRound') ).setValue('k_hen_combend01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptHeartbeat') ).setValue('k_hen_heartbt01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptOnBlocked') ).setValue('k_def_blocked01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptOnNotice') ).setValue('k_hen_percept01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptRested') ).setValue('');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptSpawn') ).setValue('k_hen_spawn01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptSpellAt') ).setValue('k_def_spellat01');\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'ScriptUserDefine') ).setValue('k_def_userdef01');\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'GoodEvil') ).setValue(50);\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'NaturalAC') ).setValue(0);\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Con') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Dex') ).setValue(14);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Str') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Wis') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Cha') ).setValue(10);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Int') ).setValue(10);\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'fortbonus') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'refbonus') ).setValue(0);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'willbonus') ).setValue(0);\r\n\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.BYTE, 'PerceptionRange') ).setValue(12);\r\n\r\n    const classList = pTPL.RootNode.addField( new GFFField(GFFDataType.LIST, 'ClassList') );\r\n    for(let i = 0; i < 1; i++){\r\n      const _class = new GFFStruct();\r\n      _class.addField( new GFFField(GFFDataType.INT, 'Class') ).setValue(0);\r\n      _class.addField( new GFFField(GFFDataType.SHORT, 'ClassLevel') ).setValue(1);\r\n      _class.addField( new GFFField(GFFDataType.LIST, 'KnownList0') );\r\n      classList.addChildStruct(_class);\r\n    }\r\n\r\n    const skillList = pTPL.RootNode.addField( new GFFField(GFFDataType.LIST, 'SkillList') );\r\n\r\n    for(let i = 0; i < 8; i++){\r\n      const _skill = new GFFStruct();\r\n      _skill.addField( new GFFField(GFFDataType.RESREF, 'Rank') ).setValue(0);\r\n      skillList.addChildStruct(_skill);\r\n    }\r\n\r\n    const armorStruct = new GFFStruct(ModuleCreatureArmorSlot.ARMOR);\r\n    armorStruct.addField( new GFFField(GFFDataType.RESREF, 'EquippedRes') ).setValue('g_a_jedirobe01');\r\n    const rhStruct = new GFFStruct(ModuleCreatureArmorSlot.RIGHTHAND);\r\n    rhStruct.addField( new GFFField(GFFDataType.RESREF, 'EquippedRes') ).setValue('g_w_lghtsbr01');\r\n\r\n    equipment.addChildStruct( armorStruct );\r\n    equipment.addChildStruct( rhStruct );\r\n\r\n    // SoundSetFile\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'SoundSetFile') ).setValue(85);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.RESREF, 'Race') ).setValue(6);\r\n\r\n    /*let spawnLoc = this.getSpawnLocation();\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'XPosition') ).setValue(spawnLoc.XPosition);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'YPosition') ).setValue(spawnLoc.YPosition);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'ZPosition') ).setValue(spawnLoc.ZPosition);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'XOrientation') ).setValue(spawnLoc.XOrientation);\r\n    pTPL.RootNode.addField( new GFFField(GFFDataType.WORD, 'YOrientation') ).setValue(spawnLoc.YOrientation);*/\r\n    PartyManager.PlayerTemplate = pTPL;\r\n    PartyManager.PlayerTemplate.json = PartyManager.PlayerTemplate.toJSON();\r\n    return PartyManager.PlayerTemplate;\r\n  }\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param type - The type of event to add\r\n   * @param cb - The function to call when the event is triggered\r\n   * @returns void\r\n   */\r\n  static AddEventListener(type: PartyManagerEvent, cb: (...args: (string | number | boolean | object)[]) => void){\r\n    if(typeof cb !== 'function'){ return; }\r\n\r\n    const events = PartyManager.#eventListeners.get(type) || [];\r\n    if(events.indexOf(cb) === -1){\r\n      events.push(cb);\r\n    }\r\n\r\n    if(!PartyManager.#eventListeners.has(type)){\r\n      PartyManager.#eventListeners.set(type, events);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an event listener\r\n   * @param type - The type of event to remove\r\n   * @param cb - The function to remove\r\n   * @returns void\r\n   */\r\n  static RemoveEventListener(type: PartyManagerEvent, cb: (...args: (string | number | boolean | object)[]) => void){\r\n    if(!PartyManager.#eventListeners.has(type)){ return; }\r\n\r\n    const events = PartyManager.#eventListeners.get(type) || [];\r\n    const idx = events.indexOf(cb);\r\n    if(idx >= -1){\r\n      events.splice(idx, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process an event listener\r\n   * @param type - The type of event to process\r\n   * @param args - The arguments to pass to the event listener\r\n   * @returns void\r\n   */\r\n  static ProcessEventListener(type: PartyManagerEvent, args: (string | number | boolean | object)[]){\r\n    const events = PartyManager.#eventListeners.get(type) || [];\r\n    for(let i = 0; i < events.length; i++){\r\n      events[i](...args);\r\n    }\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\ResolutionManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":33,"column":26,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":33,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":33,"column":38,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":33,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":147,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":147,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":147,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":147,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":157,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":157,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":157,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":157,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":166,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":166,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":166,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":166,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":175,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":175,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":175,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":175,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":184,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":184,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":184,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":184,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":193,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":193,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":193,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":193,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":202,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":202,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":202,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":202,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":212,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":212,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":212,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":212,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":221,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":221,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":221,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":221,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":230,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":230,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":230,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":230,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":239,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":239,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":239,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":239,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":248,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":248,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":248,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":248,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":257,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":257,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":257,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":257,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":266,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":266,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":266,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":266,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":275,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":275,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":275,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":275,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type ``any``. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":284,"column":30,"nodeType":"ReturnStatement","messageId":"unsafeReturnThis","endLine":284,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .label on an `any` value. `this` is typed as `any`.\nYou can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.","line":284,"column":42,"nodeType":"Identifier","messageId":"unsafeThisMemberExpression","endLine":284,"endColumn":47}],"suppressedMessages":[],"errorCount":34,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IScreenResolution } from \"@/interface/graphics/IScreenResolution\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Manager);\n\n/**\n * ResolutionManager class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file ResolutionManager.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\n/* eslint-disable @typescript-eslint/no-extraneous-class -- static manager pattern */\nexport class ResolutionManager {\n\n  public static vpScaleFactor: number = 1;\n  public static hpScaleFactor: number = 1;\n\n  public static windowResolution: { width: number; height: number } = {\n    width: 0,\n    height: 0\n  };\n\n  private static resolutionsGenerated: boolean = false;\n  static #_screenResolution: IScreenResolution = {\n    label: 'Auto Resolution',\n    width: 1,\n    height: 1,\n    ratio: 1.33,\n    isDynamicRes: true,\n    getName: function(){ return this.label }\n  };\n  static availableResolutions: IScreenResolution[] = [];\n\n  public static get screenResolution(): IScreenResolution {\n    return this.#_screenResolution;\n  }\n\n  public static set screenResolution(res: IScreenResolution) {\n    const isChanging = this.#_screenResolution !== res;\n    const oldRes = this.#_screenResolution;\n    this.#_screenResolution = res;\n    if (isChanging) {\n      log.debug('ResolutionManager.screenResolution changed label=%s', res.label ?? res.getName?.() ?? '');\n      this.processEventListener('onChange', res, oldRes);\n    }\n  }\n\n\n  static #eventListeners: {[key: string]: ((...args: (string | number | boolean | object)[]) => void)[]} = {\n    'onChange': [],\n    'onResize': []\n  };\n\n  static addEventListener(key: string, func: (...args: (string | number | boolean | object)[]) => void): void {\n    log.trace('ResolutionManager.addEventListener()', key);\n    const el = this.#eventListeners[key];\n    if (Array.isArray(el)) {\n      const canPush = el.indexOf(func) === -1;\n      if (canPush) {\n        el.push(func);\n        log.debug('ResolutionManager.addEventListener() added listener for key=%s', key);\n      }\n    }\n  }\n\n  static removeEventListener(key: string, func: (...args: (string | number | boolean | object)[]) => void): void {\n    log.trace('ResolutionManager.removeEventListener()', key);\n    const el = this.#eventListeners[key];\n    if (Array.isArray(el)) {\n      const idx = el.indexOf(func);\n      const removeAll = typeof func === 'undefined';\n      if (removeAll) {\n        this.#eventListeners[key] = [];\n        log.debug('ResolutionManager.removeEventListener() cleared all for key=%s', key);\n      } else if (idx >= 0) {\n        el.splice(idx, 1);\n        log.debug('ResolutionManager.removeEventListener() removed one for key=%s', key);\n      }\n    }\n  }\n\n  static processEventListener(key: string, ...args: (string | number | boolean | object)[]): void {\n    const el = this.#eventListeners[key];\n    if (Array.isArray(el)) {\n      log.trace('ResolutionManager.processEventListener() key=%s listenerCount=%s', key, String(el.length));\n      for (let i = 0, len = el.length; i < len; i++) {\n        el[i](...args);\n      }\n    }\n  }\n\n  static getViewportWidth(): number {\n    return this.screenResolution.isDynamicRes ? window.innerWidth : this.screenResolution.width;\n  }\n\n  static getViewportHeight(): number {\n    return this.screenResolution.isDynamicRes ? window.innerHeight : this.screenResolution.height;\n  }\n\n  static getViewportWidthScaled(): number {\n    return this.screenResolution.isDynamicRes ? window.innerWidth : this.screenResolution.width * this.vpScaleFactor;\n  }\n\n  static getViewportHeightScaled(): number {\n    return this.screenResolution.isDynamicRes ? window.innerHeight : this.screenResolution.height * this.hpScaleFactor;\n  }\n\n  static getWindowWidth(): number {\n    return this.windowResolution.width;\n  }\n\n  static getWindowHeight(): number {\n    return this.windowResolution.height;\n  }\n\n  static recalculate(): void {\n    log.trace('ResolutionManager.recalculate()');\n    const scaleX = window.innerWidth / this.getViewportWidth();\n    const scaleY = window.innerHeight / this.getViewportHeight();\n\n    const xExceeds = (this.getViewportWidth() * scaleX) > window.innerWidth;\n    const yExceeds = (this.getViewportHeight() * scaleY) > window.innerHeight;\n\n    this.vpScaleFactor = 1.0;\n    this.hpScaleFactor = 1.0;\n\n    if (!this.screenResolution.isDynamicRes) {\n      this.vpScaleFactor = scaleY;\n      this.hpScaleFactor = scaleX;\n      log.debug('ResolutionManager.recalculate() fixed res scaleX=%s scaleY=%s', String(scaleX), String(scaleY));\n    }\n  }\n\n  static getSupportedResolutions(): IScreenResolution[] {\n    log.trace('ResolutionManager.getSupportedResolutions()');\n    if (!this.resolutionsGenerated) {\n      log.debug('ResolutionManager.getSupportedResolutions() generating resolutions list');\n      this.availableResolutions.push({\n        label: 'Auto Resolution',\n        width: 1,\n        height: 1,\n        ratio: 1,\n        isDynamicRes: true,\n        getName: function(){ return this.label }\n      });\n\n      //4:3\n      this.availableResolutions.push({\n        label: '640 x 480 (4:3)',\n        width: 640,\n        height: 480,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '800 x 600 (4:3)',\n        width: 800,\n        height: 600,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '960 x 720 (4:3)',\n        width: 960,\n        height: 720,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '1024 x 768 (4:3)',\n        width: 1024,\n        height: 768,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '1280 x 1024 (4:3)',\n        width: 1280,\n        height: 1024,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '1600 x 1200 (4:3)',\n        width: 1600,\n        height: 1200,\n        ratio: 1.33,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      //16:9\n      this.availableResolutions.push({\n        label: '1280 x 720 (16:9)',\n        width: 1280,\n        height: 720,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '1600 x 900 (16:9)',\n        width: 1600,\n        height: 900,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '1920 x 1080 (16:9)',\n        width: 1920,\n        height: 1080,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '2048 x 1152 (16:9)',\n        width: 2048,\n        height: 1152,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '2880 x 1620 (16:9)',\n        width: 2880,\n        height: 1620,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '3072 x 1728 (16:9)',\n        width: 3072,\n        height: 1728,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '3840 x 2160 (16:9)',\n        width: 3840,\n        height: 2160,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '4096 x 2304 (16:9)',\n        width: 4096,\n        height: 2304,\n        ratio: 1.78,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n\n      this.availableResolutions.push({\n        label: '3440 x 1440 (Ultra-wide)',\n        width: 3440,\n        height: 1440,\n        ratio: 2.39,\n        isDynamicRes: false,\n        getName: function(){ return this.label }\n      });\n      this.resolutionsGenerated = true;\n      log.info('ResolutionManager.getSupportedResolutions() generated count=%s', String(this.availableResolutions.length));\n    }\n    return this.availableResolutions;\n  }\n\n}\n\nwindow.addEventListener('resize', () => {\n  log.trace('ResolutionManager window resize innerWidth=%s innerHeight=%s', String(window.innerWidth), String(window.innerHeight));\n  ResolutionManager.windowResolution.width = window.innerWidth;\n  ResolutionManager.windowResolution.height = window.innerHeight;\n  ResolutionManager.recalculate();\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\managers\\VideoEffectManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":47,"column":4,"nodeType":"MemberExpression","messageId":"errorCall","endLine":47,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":54,"column":4,"nodeType":"MemberExpression","messageId":"errorCall","endLine":54,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":72,"column":3,"nodeType":"MemberExpression","messageId":"errorCall","endLine":72,"endColumn":60}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { VideoEffect } from \"@/engine/VideoEffect\";\r\nimport { GameState } from \"@/GameState\";\r\nimport type { TwoDAObject } from \"@/resource/TwoDAObject\";\r\n\r\n/**\r\n * VideoEffectManager class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file VideoEffectManager.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class VideoEffectManager {\r\n\r\n  static videoEffects: VideoEffect[] = [];\r\n  static videoEffect: VideoEffect;\r\n  static videoEffectId: number = -1;\r\n\r\n  static SetVideoEffect(id: number = -1){\r\n    if(VideoEffectManager.videoEffectId == id){ return; }\r\n\r\n    VideoEffectManager.videoEffectId = id;\r\n    if(VideoEffectManager.videoEffectId == -1){\r\n      VideoEffectManager.Reset();\r\n      return;\r\n    }\r\n\r\n    const vEffect = GameState.VideoEffectManager.videoEffects[id];\r\n    if(!vEffect){\r\n      VideoEffectManager.Reset();\r\n      return;\r\n    }\r\n\r\n    VideoEffectManager.videoEffect = vEffect;\r\n  }\r\n\r\n  static Update(delta: number = 0){\r\n    if(!VideoEffectManager.videoEffect){ return; }\r\n    \r\n    if(!GameState.odysseyShaderPass){ return; }\r\n    \r\n    const effect = VideoEffectManager.videoEffect;\r\n\r\n    if(effect.enableSaturation){\r\n\t\t\tGameState.odysseyShaderPass.uniforms.saturation.value = effect.saturation;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.modulation.value.set(\r\n\t\t\t\teffect.modulation.red, effect.modulation.green, effect.modulation.blue\r\n\t\t\t);\r\n\t\t\tGameState.odysseyShaderPass.uniforms.bmodulate.value = true;\r\n\t\t}else{\r\n\t\t\tGameState.odysseyShaderPass.uniforms.bmodulate.value = false;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.saturation.value = 1;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.modulation.value.set(1, 1, 1);\r\n\t\t}\r\n\r\n    if(effect.enableScanNoise){\r\n\t\t\tGameState.odysseyShaderPass.uniforms.bscanlines.value = true;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.grayscale.value = true;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.sCount.value = (Math.floor(Math.random() * 256) + 250)*0.5;\r\n\t\t}else{\r\n\t\t\tGameState.odysseyShaderPass.uniforms.bscanlines.value = false;\r\n\t\t\tGameState.odysseyShaderPass.uniforms.grayscale.value = false;\r\n    }\r\n  }\r\n\r\n  static Reset(){\r\n    VideoEffectManager.videoEffectId = -1;\r\n    VideoEffectManager.videoEffect = undefined;\r\n\t\tGameState.odysseyShaderPass.uniforms.bmodulate.value = false;\r\n\t\tGameState.odysseyShaderPass.uniforms.saturation.value = 1;\r\n\t\tGameState.odysseyShaderPass.uniforms.modulation.value.set(1, 1, 1);\r\n\t\t\r\n\t\tGameState.odysseyShaderPass.uniforms.bscanlines.value = false;\r\n\t\tGameState.odysseyShaderPass.uniforms.grayscale.value = false;\r\n  }\r\n\r\n  static Init2DA(dataTable: TwoDAObject){\r\n    if(!dataTable){ return; }\r\n\r\n    for(let i = 0; i < dataTable.RowCount; i++){\r\n      VideoEffectManager.videoEffects[i] = VideoEffect.From2DA(dataTable.rows[i]);\r\n    }\r\n\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\AreaMap.ts","messages":[{"ruleId":"no-mixed-spaces-and-tabs","severity":2,"message":"Mixed spaces and tabs.","line":169,"column":3,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":169,"endColumn":5},{"ruleId":"no-mixed-spaces-and-tabs","severity":2,"message":"Mixed spaces and tabs.","line":178,"column":3,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":178,"endColumn":5}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { MapNorthAxis } from \"@/enums/engine/MapNorthAxis\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport type { ModuleWaypoint } from \"@/module/ModuleWaypoint\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\n\r\n\r\n/**\r\n* AreaMap class.\r\n* \r\n* Class representing the logic that powers mini and large game maps ingame.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file AreaMap.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class AreaMap {\r\n  data: Uint8Array;\r\n  mapResX: number;\r\n  mapResY: number;\r\n  northAxis: number;\r\n  worldPt1X: number;\r\n  worldPt1Y: number;\r\n  worldPt2X: number;\r\n  worldPt2Y: number;\r\n  mapPt1X: number;\r\n  mapPt1Y: number;\r\n  mapPt2X: number;\r\n  mapPt2Y: number;\r\n  mapZoom: number;\r\n  dataSize: number;\r\n\r\n  fogAlphaPixelData: Uint8Array;\r\n  fogAlphaTexture: THREE.DataTexture;\r\n\r\n  _mapCoordinates: THREE.Vector2 = new THREE.Vector2(0, 0);\r\n\r\n  mapNotes: ModuleWaypoint[] = [];\r\n\r\n  eventListeners: {\r\n    mapNoteAdded: ((...args: (string | number | boolean | object)[]) => void)[],\r\n    mapNoteRemoved: ((...args: (string | number | boolean | object)[]) => void)[],\r\n  } = {\r\n    mapNoteAdded: [],\r\n    mapNoteRemoved: []\r\n  };\r\n\r\n  constructor(){\r\n    this.data = new Uint8Array(4);\r\n\r\n    this.mapResX = 0;\r\n    this.mapResY = 0;\r\n    this.northAxis = 0;\r\n    this.worldPt1X = 0;\r\n    this.worldPt1Y = 0;\r\n    this.worldPt2X = 0;\r\n    this.worldPt2Y = 0;\r\n    this.mapPt1X = 0;\r\n    this.mapPt1Y = 0;\r\n    this.mapPt2X = 0;\r\n    this.mapPt2Y = 0;\r\n    this.mapZoom = 0;\r\n\r\n  }\r\n\r\n  init(){\r\n    this.generateResY();\r\n    this.generateMapData();\r\n  }\r\n\r\n  setResX( mapResX = 0 ){\r\n    this.mapResX = mapResX;\r\n    this.generateResY();\r\n    this.generateMapData();\r\n  }\r\n\r\n  generateResY(){\r\n    this.mapResY = Math.max(1, Math.floor((this.mapResX * 256) / 440));\r\n  }\r\n\r\n  generateMapData(){\r\n    this.dataSize = (Math.ceil(((this.mapResX+1) * (this.mapResY+1)) / 32) * 32) / 8;\r\n    this.data = new Uint8Array(this.dataSize);\r\n    this.generateAlphaTexture();\r\n  }\r\n\r\n  generateAlphaTexture(){\r\n    const resX = this.mapResX+1;\r\n    const resY = this.mapResY+1;\r\n    this.fogAlphaPixelData = new Uint8Array(resX * resY);\r\n    this.fogAlphaTexture = new THREE.DataTexture(this.fogAlphaPixelData as Uint8Array, resX, resY, THREE.AlphaFormat);\r\n    this.fogAlphaTexture.minFilter = THREE.LinearFilter;\r\n    this.fogAlphaTexture.magFilter = THREE.LinearFilter;\r\n    this.fogAlphaTexture.flipY = true;\r\n    this.fogAlphaTexture.needsUpdate = true;\r\n\r\n    const stride = resX;\r\n    const totalBits = stride * resY;\r\n\r\n    let byteIndex = 0;\r\n    for(let i = 0; i < totalBits; i++){\r\n      const bitIndex = i % 8;\r\n      const explored = !!(this.data[byteIndex] & 1 << bitIndex);\r\n      this.fogAlphaPixelData[i * 1] = !explored ? 255 : 0;\r\n      \r\n      if(!((i+1) % 8)){\r\n        byteIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  loadDataStruct( struct: GFFStruct ){\r\n    if(struct instanceof GFFStruct){\r\n      this.data = struct.getFieldByLabel('AreaMapData').getVoid();\r\n      this.dataSize = struct.getFieldByLabel('AreaMapDataSize').getValue() as number;\r\n      this.mapResX = struct.getFieldByLabel('AreaMapResX').getValue() as number;\r\n      this.mapResY = struct.getFieldByLabel('AreaMapResY').getValue() as number;\r\n      this.generateAlphaTexture();      \r\n    }\r\n  }\r\n\r\n  addMapNote(note: ModuleWaypoint){\r\n    if(!note) return;\r\n    if(this.mapNotes.indexOf(note) >= 0) return;\r\n    if(!note.hasMapNote) return;\r\n\r\n    this.mapNotes.push(note);\r\n    this.processEventListener('mapNoteAdded', [note]);\r\n  }\r\n\r\n  removeMapNote(note: ModuleWaypoint){\r\n    if(!note) return;\r\n    const index = this.mapNotes.indexOf(note);\r\n    if(index >= 0){\r\n      this.mapNotes.splice(index, 1);\r\n      this.processEventListener('mapNoteRemoved', [note]);\r\n    }\r\n  }\r\n\r\n  toMapCoordinates(x: number = 0, y: number = 0): THREE.Vector2 {\r\n    let scaleX = 0, scaleY = 0;\r\n    switch(this.northAxis){\r\n      case MapNorthAxis.NORTH: //end_m01aa\r\n        {\r\n          scaleY = (this.mapPt1Y - this.mapPt2Y) / (this.worldPt1Y - this.worldPt2Y);\r\n          scaleX = (this.mapPt1X - this.mapPt2X) / (this.worldPt1X - this.worldPt2X);\r\n\r\n          this._mapCoordinates.x = (( x - this.worldPt1X) * scaleX) + this.mapPt1X;\r\n          this._mapCoordinates.y = 1 - (((y - this.worldPt1Y) * scaleY) + this.mapPt1Y);\r\n        }\r\n      break;\r\n      case MapNorthAxis.SOUTH: //152HAR\r\n        {\r\n          scaleY = (this.mapPt1Y - this.mapPt2Y) / (this.worldPt1Y - this.worldPt2Y);\r\n          scaleX = (this.mapPt1X - this.mapPt2X) / (this.worldPt1X - this.worldPt2X);\r\n\r\n          this._mapCoordinates.y = ((( x - this.worldPt1X) * scaleX) + this.mapPt1X);\r\n          this._mapCoordinates.x = (((-y - this.worldPt1Y) * scaleY) + this.mapPt1Y);\r\n        }\r\n      break;\r\n      case MapNorthAxis.EAST:\r\n        {\r\n          scaleX = (this.mapPt1Y - this.mapPt2Y) / (this.worldPt1X - this.worldPt2X);\r\n\t\t\t    scaleY = (this.mapPt1X - this.mapPt2X) / (this.worldPt1Y - this.worldPt2Y);\r\n\r\n          this._mapCoordinates.x = (((y - this.worldPt1Y) * scaleY) + this.mapPt1X);\r\n          this._mapCoordinates.y = (((x - this.worldPt1X) * scaleX) + this.mapPt1Y);\r\n        }\r\n      break;\r\n      case MapNorthAxis.WEST: //end_m01ab\r\n        {\r\n          scaleX = (this.mapPt1Y - this.mapPt2Y) / (this.worldPt1X - this.worldPt2X);\r\n\t\t\t    scaleY = (this.mapPt1X - this.mapPt2X) / (this.worldPt1Y - this.worldPt2Y);\r\n\r\n          this._mapCoordinates.x = (((y - this.worldPt1Y) * scaleY) + this.mapPt1X);\r\n          this._mapCoordinates.y = 1 - (((x - this.worldPt1X) * scaleX) + this.mapPt1Y);\r\n        }\r\n      break;\r\n    }\r\n    return this._mapCoordinates;\r\n  }\r\n\r\n  getRevealedMapNotes(){\r\n    return this.mapNotes.filter( (note) => {\r\n      return this.isMapPositionExplored(note.position.x, note.position.y);\r\n    })\r\n  }\r\n\r\n  isMapPositionExplored(x: number = 0, y: number = 0){\r\n    const resX = (this.mapResX+1);\r\n    const resY = (this.mapResY+1);\r\n\r\n    const mapPos = this.toMapCoordinates(x, y);\r\n    mapPos.x = THREE.MathUtils.clamp(mapPos.x, 0, 1);\r\n    mapPos.y = 1 - THREE.MathUtils.clamp(mapPos.y, 0, 1);\r\n\r\n    const gridX = Math.floor(resX * mapPos.x);\r\n    const gridY = Math.floor(resY * mapPos.y);\r\n    if(this.fogAlphaPixelData[(resX * gridY) + gridX] == 0){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  revealPosition(x: number = 0, y: number = 0, radius: number = 0){\r\n    if(radius == -1){\r\n      this.revealEntireMap();\r\n      return;\r\n    }\r\n\r\n    radius = Math.abs(radius);\r\n    const resX = (this.mapResX+1);\r\n    const resY = (this.mapResY+1);\r\n\r\n    const mapPos = this.toMapCoordinates(x, y);\r\n    mapPos.x = THREE.MathUtils.clamp(mapPos.x, 0, 1);\r\n    mapPos.y = 1 - THREE.MathUtils.clamp(mapPos.y, 0, 1);\r\n\r\n    const gridX = Math.floor(resX * mapPos.x);\r\n    const gridY = Math.floor(resY * mapPos.y);\r\n    \r\n    let needsUpdate = this.revealFogAtArrayIndex((resX * gridY) + gridX);\r\n\r\n    //reveal radius\r\n    for(let y = 1; y < radius; y++){\r\n      for(let x = 1; x < radius; x++){\r\n        const tY = gridY-y;\r\n        if(tY >= 0){\r\n          if(gridX-x >= 0){\r\n            const tlIndex = (resX * (tY)) + (gridX-x);\r\n            if(this.revealFogAtArrayIndex(tlIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n  \r\n          const tIndex = (resX * (tY)) + (gridX);\r\n          if(this.revealFogAtArrayIndex(tIndex)){\r\n            needsUpdate = true;\r\n          }\r\n  \r\n          if(gridX+x < resX){\r\n            const trIndex = (resX * (tY)) + (gridX+x);\r\n            if(this.revealFogAtArrayIndex(trIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n        }\r\n  \r\n        if(gridY >= 0 && gridY < resY){\r\n          if(gridX-x >= 0){\r\n            const mlIndex = (resX * (gridY)) + (gridX-x);\r\n            if(this.revealFogAtArrayIndex(mlIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n  \r\n          if(gridX+x < resX){\r\n            const mrIndex = (resX * (gridY)) + (gridX+x);\r\n            if(this.revealFogAtArrayIndex(mrIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n        }\r\n  \r\n        const bY = gridY+y;\r\n        if(bY >= 0 && bY < resY){\r\n          if(gridX-x >= 0){\r\n            const blIndex = (resX * (bY)) + (gridX-x);\r\n            if(this.revealFogAtArrayIndex(blIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n  \r\n          const bIndex = (resX * (bY)) + (gridX);\r\n          if(this.revealFogAtArrayIndex(bIndex)){\r\n            needsUpdate = true;\r\n          }\r\n  \r\n          if(gridX+x < resX){\r\n            const brIndex = (resX * (bY)) + (gridX+x);\r\n            if(this.revealFogAtArrayIndex(brIndex)){\r\n              needsUpdate = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if(needsUpdate) this.fogAlphaTexture.needsUpdate = true;\r\n  }\r\n\r\n  revealFogAtArrayIndex(index: number = 0){\r\n    let needsUpdate = false;\r\n    if(index >= 0 && index < this.fogAlphaPixelData.length){\r\n      if(this.fogAlphaPixelData[index]){\r\n        this.fogAlphaPixelData[index] = 0;\r\n        needsUpdate = true;\r\n      }\r\n    }\r\n    return needsUpdate;\r\n  }\r\n\r\n  revealEntireMap(){\r\n    this.fogAlphaPixelData.fill(0);\r\n    this.fogAlphaTexture.needsUpdate = true;\r\n  }\r\n\r\n  dispose(){\r\n    for(let i = 0; i < this.mapNotes.length; i++){\r\n      this.processEventListener('mapNoteRemoved', [this.mapNotes[i]]);\r\n    }\r\n  }\r\n\r\n  export(): GFFStruct {\r\n    const mapStruct = new GFFStruct(14);\r\n\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'MapPt1X') ).setValue(this.mapPt1X);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'MapPt1Y') ).setValue(this.mapPt1Y);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'MapPt2X') ).setValue(this.mapPt2X);\r\n    mapStruct.addField( new GFFField(GFFDataType.INT, 'MapPt2Y') ).setValue(this.mapPt2Y);\r\n    mapStruct.addField( new GFFField(GFFDataType.INT, 'MapResX') ).setValue(this.mapResX);\r\n    mapStruct.addField( new GFFField(GFFDataType.INT, 'MapZoom') ).setValue(this.mapZoom);\r\n    mapStruct.addField( new GFFField(GFFDataType.INT, 'NorthAxis') ).setValue(this.northAxis);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'WorldPt1X') ).setValue(this.worldPt1X);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'WorldPt1Y') ).setValue(this.worldPt1Y);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'WorldPt2X') ).setValue(this.worldPt2X);\r\n    mapStruct.addField( new GFFField(GFFDataType.FLOAT, 'WorldPt2Y') ).setValue(this.worldPt2Y);\r\n\r\n    return mapStruct;\r\n  }\r\n\r\n  exportData(){\r\n    const dataStruct = new GFFStruct(14);\r\n\r\n    let byteIndex = 0;\r\n    for(let i = 0; i < this.fogAlphaPixelData.length; i++){\r\n      const bitIndex = i % 8;\r\n      this.data[byteIndex] |= 1 << bitIndex;\r\n\r\n      if(!((i+1) % 8)){\r\n        byteIndex++;\r\n      }\r\n    }\r\n\r\n    dataStruct.addField( new GFFField(GFFDataType.VOID, 'AreaMapData') ).setData(this.data);\r\n    dataStruct.addField( new GFFField(GFFDataType.DWORD, 'AreaMapDataSize') ).setValue(this.dataSize);\r\n    dataStruct.addField( new GFFField(GFFDataType.INT, 'AreaMapResX') ).setValue(this.mapResX);\r\n    dataStruct.addField( new GFFField(GFFDataType.INT, 'AreaMapResY') ).setValue(this.mapResY);\r\n    \r\n    return dataStruct;\r\n  }\r\n\r\n  addEventListener(name: 'mapNoteRemoved'|'mapNoteAdded', callback: (...args: (string | number | boolean | object)[]) => void){\r\n    if(!(typeof callback === 'function')) return;\r\n\r\n    const list = this.eventListeners[name];\r\n    if(!Array.isArray(list)) return;\r\n\r\n    if(list.indexOf(callback) >= 0) return;\r\n    list.push(callback);\r\n  }\r\n\r\n  removeEventListener(name: 'mapNoteRemoved'|'mapNoteAdded', callback: (...args: (string | number | boolean | object)[]) => void){\r\n    if(!(typeof callback === 'function')) return;\r\n\r\n    const list = this.eventListeners[name];\r\n    if(!Array.isArray(list)) return;\r\n\r\n    const index = list.indexOf(callback);\r\n    if(index == -1) return;\r\n\r\n    list.splice(index, 1);\r\n  }\r\n\r\n  processEventListener(name: 'mapNoteRemoved'|'mapNoteAdded', args: (string | number | boolean | object)[]){\r\n    const list = this.eventListeners[name];\r\n    if(!Array.isArray(list)) return;\r\n\r\n    for(let i = 0, len = list.length; i < len; i++){\r\n      list[i](...args);\r\n    }\r\n  }\r\n\r\n  static FromStruct( struct: GFFStruct ){\r\n    if(struct instanceof GFFStruct){\r\n      const areaMap = new AreaMap();\r\n\r\n      areaMap.mapPt1X = struct.getFieldByLabel('MapPt1X').getValue() as number;\r\n      areaMap.mapPt1Y = struct.getFieldByLabel('MapPt1Y').getValue() as number;\r\n      areaMap.mapPt2X = struct.getFieldByLabel('MapPt2X').getValue() as number;\r\n      areaMap.mapPt2Y = struct.getFieldByLabel('MapPt2Y').getValue() as number;\r\n      areaMap.mapResX = struct.getFieldByLabel('MapResX').getValue() as number;\r\n      areaMap.mapZoom = struct.getFieldByLabel('MapZoom').getValue() as number;\r\n      areaMap.northAxis = struct.getFieldByLabel('NorthAxis').getValue() as number;\r\n      areaMap.worldPt1X = struct.getFieldByLabel('WorldPt1X').getValue() as number;\r\n      areaMap.worldPt1Y = struct.getFieldByLabel('WorldPt1Y').getValue() as number;\r\n      areaMap.worldPt2X = struct.getFieldByLabel('WorldPt2X').getValue() as number;\r\n      areaMap.worldPt2Y = struct.getFieldByLabel('WorldPt2Y').getValue() as number;\r\n\r\n      areaMap.init();\r\n\r\n      return areaMap;\r\n    }\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\Module.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":223,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":223,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":225,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":225,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":227,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":227,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":228,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":228,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":229,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":229,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":230,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":230,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":231,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":231,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":232,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":232,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":233,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":233,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":243,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":243,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":245,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":245,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":246,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":246,"endColumn":18}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from \"path\";\n\nimport * as THREE from \"three\";\n\nimport { AudioEmitter } from \"@/audio/AudioEmitter\";\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { GameEffect } from \"@/effects\";\nimport { CurrentGame } from \"@/engine/CurrentGame\";\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { AudioEmitterType } from \"@/enums/audio/AudioEmitterType\";\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport type { GameEvent } from \"@/events/GameEvent\";\nimport { GameEventFactory } from \"@/events/GameEventFactory\";\nimport { GameState } from \"@/GameState\";\nimport { IAreaListItem } from \"@/interface/area/IAreaListItem\";\nimport { IModuleScripts } from \"@/interface/module/IModuleScripts\";\nimport { ResourceLoader, TextureLoader } from \"@/loaders\";\nimport { ModuleArea } from \"@/module/ModuleArea\";\nimport type { ModuleObject } from \"@/module/ModuleObject\";\nimport { ModuleTimeManager } from \"@/module/ModuleTimeManager\";\nimport type { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { CExoLocString } from \"@/resource/CExoLocString\";\nimport { ERFObject } from \"@/resource/ERFObject\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFObject } from \"@/resource/GFFObject\";\n// import { NWScript } from \"@/nwscript/NWScript\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { RIMObject } from \"@/resource/RIMObject\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\nconst log = createScopedLogger(LogScope.Loader);\n\n/** Holder object for a game effect (model, position, audio, dispose). */\ninterface IModuleEffectHolder {\n  model: THREE.Object3D;\n  position: THREE.Vector3;\n  audioEmitter: InstanceType<typeof AudioEmitter>;\n  dispose(): void;\n  removeEffect(effect: GameEffect): void;\n}\n\ntype ModuleScriptKeys = 'Mod_OnAcquirItem' | 'Mod_OnActvtItem' | 'Mod_OnClientEntr' | 'Mod_OnClientLeav' | 'Mod_OnHeartbeat' | 'Mod_OnModLoad' | 'Mod_OnModStart' | 'Mod_OnPlrDeath' | 'Mod_OnPlrDying' | 'Mod_OnPlrLvlUp' | 'Mod_OnPlrRest' | 'Mod_OnSpawnBtnDn' | 'Mod_OnUnAqreItem' | 'Mod_OnUsrDefined';\n\n/**\n * Module class.\n *\n * Class representing an ingame module.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file Module.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class Module {\n\n  static ModuleArea: typeof ModuleArea = ModuleArea;\n\n  ifo: GFFObject;\n\n  areaName: string;\n  area: ModuleArea;\n  areas: ModuleArea[] = [];\n  entryArea: string;\n  entryDirectionX: number;\n  entryDirectionY: number;\n  entryX: number;\n  entryY: number;\n  entryZ: number;\n\n  scripts: { [key: string]: NWScriptInstance };\n  scriptResRefs: Map<ModuleScriptKeys, string> = new Map<ModuleScriptKeys, string>();\n\n  timeManager: ModuleTimeManager;\n\n  archives: (RIMObject | ERFObject)[] = [];\n  effects: GameEffect[] = [];\n  eventQueue: GameEvent[] = [];\n  customTokens: Map<number, string>;\n  transition: number;\n  transWP: string;\n\n  /**\n   * List of Areas in the module\n   */\n  areaList: IAreaListItem[] = [];\n\n  /**\n   * Description of module\n   */\n  description: CExoLocString;\n\n  /**\n   * Game hour at which dawn begins (0-23). Area lighting will begin transitioning from Night to Day colors over the course of 1 game hour.\n   */\n  dawnHour: number;\n\n  /**\n   * Game hour at which dusk begins (0-23). Area lighting will begin transitioning from Day to Night colors over the course of 1 game hour\n   */\n  duskHour: number;\n\n  /**\n   * Bit flags specifying what expansion packs are required to run this module. Once a bit is set, it is never unset. Bit 0 = Expansion 1, Bit 1 = Expansion 2, etc\n   */\n  expansionPack: number = 0;\n\n  /**\n   * Arbitrarily generated 16-byte number sequence assigned when toolset creates a new module. It is never\n   * modified afterward by toolset. The game saves out 32 bytes instead of 16. Applications other than the toolset\n   * can set this to all null bytes when creating a new IFO file.\n   */\n  id: Uint8Array = new Uint8Array(16);\n\n  /**\n   * Name of module\n   */\n  name: CExoLocString;\n\n  /**\n   * Module's Tag\n   */\n  tag: string;\n\n  /**\n   * Name of the modules Voice Over folder\n   */\n  voId: string;\n\n  /**\n   * Module version. Is always set to 3.\n   */\n  version: number = 3;\n\n  /**\n   * Percentage by which to multiply all XP gained through killing creatures.\n   */\n  xpScale: number = 10;\n\n  /**\n   * ResRef of movie in 'movies' folder to play when starting module\n   */\n  startMovie: string = '';\n\n  /**\n   * Keeps track of which id to give the next character created\n   */\n  nextCharId0: number;\n\n  /**\n   * Keeps track of which id to give the next character created\n   */\n  nextCharId1: number;\n\n  /**\n   * Keeps track of which id to give the next object created\n   */\n  nextObjId0: number;\n\n  /**\n   * Keeps track of which id to give the next object created\n   */\n  nextObjId1: number;\n\n  /**\n   * ID to use for the next Effect\n   */\n  effectNextId: number;\n\n  /**\n   * @deprecated Deprecated: since NWN\n   */\n  expansionList: unknown[] = [];\n\n  /**\n   * @deprecated Deprecated: since NWN\n   */\n  globalVariableList: unknown[] = [];\n\n  /**\n   * @deprecated Obsolete: since NWN\n   */\n  hak: string;\n\n  /**\n   * @deprecated Deprecated: since NWN\n   */\n  cutSceneList: unknown[] = [];\n\n  /**\n   * always set to 2\n   * @deprecated Deprecated: since NWN\n   */\n  creatorId: number = 2;\n\n  filename: string;\n  readyToProcessEvents: boolean = false;\n  isSaveGame: boolean = false;\n\n  constructor() {\n    this.scripts = {} as { [key in ModuleObjectScript]?: NWScriptInstance };\n    this.archives = [];\n    this.effects = [];\n    this.eventQueue = [];\n    this.area = new ModuleArea();\n    this.timeManager = new ModuleTimeManager();\n    this.customTokens = new Map();\n\n    this.initProperties();\n  }\n\n  update(delta: number = 0) {\n    if (this.area) {\n      this.area.update(delta);\n    }\n  }\n\n  initProperties() {\n    this.expansionPack;\n    this.areaList = [];\n    this.dawnHour;\n    this.description = new CExoLocString();\n    this.duskHour;\n    this.entryArea;\n    this.entryDirectionX;\n    this.entryDirectionY;\n    this.entryX;\n    this.entryY;\n    this.entryZ;\n\n    this.isSaveGame = false;\n    this.name = new CExoLocString();\n\n    this.nextCharId0 = 0; // DWORD Keeps track of which id to give the next character created\n    this.nextCharId1 = 0; // DWORD -\n    this.nextObjId0 = 0; // DWORD Keeps track of which id to give the next object created\n    this.nextObjId1 = 0; // DWORD -\n\n    this.tag;\n    this.voId = '';\n    this.version;\n    this.xpScale;\n  }\n\n  setFromIFO(ifo: GFFObject, isLoadingSave = false) {\n    if (!(ifo instanceof GFFObject)) { return; }\n    this.ifo = ifo;\n\n    //Setup Module Calendar\n    this.timeManager.setFromIFO(ifo);\n\n    const areaList = ifo.getFieldByLabel('Mod_Area_list');\n    if (!areaList) {\n      throw new Error('Module IFO missing Mod_Area_list - corrupt or invalid module data');\n    }\n    const childStructs = areaList.getChildStructs();\n    const areaCount = childStructs.length;\n    if (areaCount === 0) {\n      throw new Error('Module IFO Mod_Area_list is empty - corrupt or invalid module data');\n    }\n    const Mod_Area = childStructs[0];\n\n    this.areaName = ifo.getFieldByLabel('Area_Name', Mod_Area.getFields()).getValue();\n\n    this.areaList = [];\n    //KOTOR modules should only ever have one area. But just incase lets loop through the list\n    for (let i = 0; i < areaCount; i++) {\n      const Mod_Area = childStructs[i];\n      const area: Partial<IAreaListItem> = {};\n\n      if (Mod_Area.hasField('Area_Name'))\n        area.areaName = Mod_Area.getFieldByLabel('Area_Name').getValue() as number;\n\n      if (Mod_Area.hasField('ObjectId'))\n        area.objectId = Mod_Area.getFieldByLabel('ObjectId').getValue() as number;\n\n      this.areaList.push(area as IAreaListItem);\n    }\n\n    //LISTS\n    if (ifo.RootNode.hasField('Expansion_Pack')) {\n      this.expansionPack = ifo.getFieldByLabel('Expansion_Pack').getValue();\n    } else {\n      this.expansionPack = 0;\n    }\n\n    this.creatorId = ifo.getFieldByLabel('Mod_Creator_ID').getValue();\n    this.description = ifo.getFieldByLabel('Mod_Description').getCExoLocString();\n\n    this.entryArea = ifo.getFieldByLabel('Mod_Entry_Area').getValue();\n    this.entryDirectionX = ifo.getFieldByLabel('Mod_Entry_Dir_X').getValue();\n    this.entryDirectionY = ifo.getFieldByLabel('Mod_Entry_Dir_Y').getValue();\n    this.entryX = ifo.getFieldByLabel('Mod_Entry_X').getValue();\n    this.entryY = ifo.getFieldByLabel('Mod_Entry_Y').getValue();\n    this.entryZ = ifo.getFieldByLabel('Mod_Entry_Z').getValue();\n\n    this.hak = ifo.getFieldByLabel('Mod_Hak').getValue();\n    this.id = ifo.getFieldByLabel('Mod_ID').getVoid(); //Generated by the toolset (Not sure if it is used in game)\n    this.name = ifo.getFieldByLabel('Mod_Name').getCExoLocString();\n\n    //Mod_Tokens\n    if (ifo.RootNode.hasField('Mod_Tokens') && isLoadingSave) {\n      const tokenList = ifo.getFieldByLabel('Mod_Tokens').getChildStructs();\n      for (let i = 0, len = tokenList.length; i < len; i++) {\n        this.setCustomToken(\n          tokenList[i].getFieldByLabel('Mod_TokensNumber').getValue(),\n          tokenList[i].getFieldByLabel('Mod_TokensValue').getValue()\n        );\n      }\n    }\n\n    if (ifo.RootNode.hasField('Mod_PlayerList') && isLoadingSave) {\n      const playerList = ifo.getFieldByLabel('Mod_PlayerList').getChildStructs();\n      if (playerList.length) {\n        GameState.PartyManager.PlayerTemplate = GFFObject.FromStruct(playerList[0]);\n        GameState.PartyManager.ActualPlayerTemplate = GameState.SaveGame.pc || GameState.PartyManager.PlayerTemplate;\n        // if(GameState.PartyManager.PlayerTemplate.getFieldByLabel('IsPC').getValue()){\n        //   GameState.PartyManager.ActualPlayerTemplate = GameState.PartyManager.PlayerTemplate;\n        // }else{\n        //   GameState.PartyManager.ActualPlayerTemplate = GameState.SaveGame.pc;\n        // }\n      }\n    }\n\n    //Scripts\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerAcquireItem, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerAcquireItem).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerActivateItem, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerActivateItem).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerClientEnter, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerClientEnter).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerClientLeave, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerClientLeave).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnHeartbeat, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnHeartbeat).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnLoad, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnLoad).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnStart, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnStart).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerDeath, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerDeath).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerDying, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerDying).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerLevelUp, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerLevelUp).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnPlayerRest, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnPlayerRest).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnSpawnButtonDown, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnSpawnButtonDown).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnUnAcquireItem, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnUnAcquireItem).getValue());\n    this.scriptResRefs.set(ModuleObjectScript.ModuleOnUserDefined, ifo.getFieldByLabel(ModuleObjectScript.ModuleOnUserDefined).getValue());\n\n    if (ifo.RootNode.hasField('Mod_StartMovie')) {\n      this.startMovie = ifo.getFieldByLabel('Mod_StartMovie').getValue();\n    } else {\n      this.startMovie = '';\n    }\n\n    this.tag = ifo.getFieldByLabel('Mod_Tag').getValue();\n\n    if (ifo.RootNode.hasField('Mod_VO_ID')) {\n      this.voId = ifo.getFieldByLabel('Mod_VO_ID').getValue();\n    }\n\n    this.version = ifo.getFieldByLabel('Mod_Version').getValue();\n    this.xpScale = ifo.getFieldByLabel('Mod_XPScale').getValue();\n\n    if (ifo.RootNode.hasField('Mod_NextCharId0'))\n      this.nextCharId0 = ifo.getFieldByLabel('Mod_NextCharId0').getValue();\n\n    if (ifo.RootNode.hasField('Mod_NextCharId1'))\n      this.nextCharId1 = ifo.getFieldByLabel('Mod_NextCharId1').getValue();\n\n    if (ifo.RootNode.hasField('Mod_NextObjId0'))\n      this.nextObjId0 = ifo.getFieldByLabel('Mod_NextObjId0').getValue();\n\n    if (ifo.RootNode.hasField('Mod_NextObjId1'))\n      this.nextObjId1 = ifo.getFieldByLabel('Mod_NextObjId1').getValue();\n  }\n\n  addEffect(effect?: GameEffect, lLocation?: EngineLocation) {\n    if (!(effect instanceof GameEffect)) { return; }\n\n    effect.loadModel();\n    const moduleEffects = this.effects;\n    const object: IModuleEffectHolder = {\n      model: new THREE.Object3D(),\n      position: lLocation.position,\n      dispose() {\n        if (typeof (effect as GameEffect & { onRemove?: () => void }).onRemove === 'function') {\n          (effect as GameEffect & { onRemove: () => void }).onRemove();\n        }\n        const idx = moduleEffects.indexOf(effect);\n        if (idx >= 0) moduleEffects.splice(idx, 1);\n      },\n      removeEffect(effectToRemove: GameEffect) {\n        const idx = moduleEffects.indexOf(effectToRemove);\n        if (idx >= 0) moduleEffects.splice(idx, 1);\n      },\n      audioEmitter: new AudioEmitter(AudioEngine.GetAudioEngine())\n    };\n    object.audioEmitter.maxDistance = 50;\n    object.audioEmitter.type = AudioEmitterType.POSITIONAL;\n    object.audioEmitter.load();\n    object.audioEmitter.setPosition(lLocation.position.x, lLocation.position.y, lLocation.position.z);\n\n    object.model.position.copy(lLocation.position);\n\n    effect.setCreator(object as unknown as ModuleObject);\n    effect.setAttachedObject(this);\n    effect.onApply(object as unknown as ModuleObject);\n    this.effects.push(effect);\n\n    GameState.group.effects.add(object.model);\n  }\n\n  addEvent(event: GameEvent) {\n    if (this.eventQueue.indexOf(event) >= 0) { return; }\n    this.eventQueue.push(event);\n  }\n\n  tick(delta = 0) {\n\n    if (this.readyToProcessEvents) {\n\n      //Process EventQueue\n      const eqLen = this.eventQueue.length - 1;\n      for (let i = eqLen; i >= 0; i--) {\n        const event = this.eventQueue[i];\n\n        if (this.timeManager.pauseDay >= event.day && this.timeManager.pauseTime >= event.time) {\n          event.execute();\n          this.eventQueue.splice(i, 1);\n        }\n      }\n\n      //Process EffectList\n      const elLen = this.effects.length - 1;\n      for (let i = elLen; i >= 0; i--) {\n        this.effects[i].update(delta);\n      }\n\n      if (this.area) {\n        this.area.update(delta);\n      }\n\n      this.timeManager.update(delta);\n\n    }\n\n  }\n\n  tickPaused(delta = 0) {\n    if (this.readyToProcessEvents) {\n      if (this.area) {\n        this.area.updatePaused(delta);\n      }\n    }\n  }\n\n  setReturnStrRef(enabled = false, str1 = -1, str2 = -1) {\n    GameState.MenuManager.MenuMap.BTN_RETURN.setText(GameState.TLKManager.GetStringById(str1).Value);\n  }\n\n  async loadScene() {\n    try {\n      GameState.PartyManager.party = [];\n\n      GameState.ModuleObjectManager.ResetPlayerId();\n\n      if (this.area.sun.fogOn && this.area.sun.fogColor) {\n        GameState.globalLight.color.setHex(parseInt('0x' + this.area.sun.fogColor.toString(16)));\n      } else {\n        GameState.globalLight.color.setHex(parseInt('0x' + this.area.dynamicAmbientColor.toString(16)));\n      }\n\n      GameState.globalLight.color.setRGB(\n        THREE.MathUtils.clamp(GameState.globalLight.color.r, 0.2, 1),\n        THREE.MathUtils.clamp(GameState.globalLight.color.g, 0.2, 1),\n        THREE.MathUtils.clamp(GameState.globalLight.color.b, 0.2, 1),\n      );\n\n      GameState.camera.position.setX(this.entryX);\n      GameState.camera.position.setY(this.entryY);\n      GameState.camera.position.setZ(this.entryZ + 2);\n      GameState.camera.rotation.set(Math.PI / 2, -Math.atan2(this.entryDirectionX, this.entryDirectionY), 0);\n\n      //this.camera.pitch = THREE.MathUtils.radToDeg(this.camera.rotation.y) * -1;\n      //this.camera.yaw = THREE.MathUtils.radToDeg(this.camera.rotation.x);\n\n      const ypr = this.toEulerianAngle(GameState.camera.quaternion);\n\n      GameState.camera.userData.pitch = THREE.MathUtils.radToDeg(ypr.pitch);\n      GameState.camera.userData.yaw = THREE.MathUtils.radToDeg(ypr.yaw) * -1;\n\n      if (GameState.camera.userData.pitch > 89.0)\n        GameState.camera.userData.pitch = 89.0;\n      if (GameState.camera.userData.pitch < -89.0)\n        GameState.camera.userData.pitch = -89.0;\n\n      GameState.MenuManager.LoadScreen.setProgress(0);\n\n      await this.area.loadScene();\n      this.transWP = '';\n    } catch (e) {\n      log.error(e instanceof Error ? e : new Error(String(e)));\n    }\n  }\n\n  async initScripts() {\n    for (const [key, resRef] of this.scriptResRefs) {\n      const script = GameState.NWScript.Load(resRef);\n      if (!script) { continue; }\n      this.scripts[key] = script;\n    }\n\n    const onLoad = this.scripts[ModuleObjectScript.ModuleOnLoad];\n    if (onLoad) {\n      onLoad.enteringObject = GameState.PartyManager.party[0];\n      onLoad.run(this.area, 0);\n    }\n\n    const onPlayerClientEnter = this.scripts[ModuleObjectScript.ModuleOnPlayerClientEnter];\n    if (onPlayerClientEnter) {\n      onPlayerClientEnter.enteringObject = GameState.PartyManager.party[0];\n      onPlayerClientEnter.run(this.area, 0);\n    }\n  }\n\n  setCustomToken(tokenNumber = 0, tokenValue = '') {\n    this.customTokens.set(tokenNumber, tokenValue);\n  }\n\n  getCustomToken(tokenNumber: number) {\n    return this.customTokens.get(tokenNumber) || `<Missing CustomToken ${tokenNumber}>`;\n  }\n\n  initEventQueue() {\n    //Load module EventQueue after the area is intialized so that ModuleObject ID's are set\n    if (this.ifo.RootNode.hasField('EventQueue')) {\n      const eventQueue = this.ifo.getFieldByLabel('EventQueue').getChildStructs();\n      for (let i = 0; i < eventQueue.length; i++) {\n        const event_struct = eventQueue[i];\n        const event = GameEventFactory.EventFromStruct(event_struct);\n        log.debug('event_struct', event_struct, event);\n        if (event) {\n          this.eventQueue.push(event);\n        }\n      }\n    }\n  }\n\n  dispose() {\n    GameState.collisionList = [];\n\n    //Remove all effects\n    if (this) {\n      while (this.effects.length) {\n        this.effects[0].dispose();\n        this.effects.shift();\n      }\n    }\n\n    //Cleanup texture cache\n    Array.from(TextureLoader.textures.keys()).forEach((key) => {\n      TextureLoader.textures.get(key).dispose();\n      TextureLoader.textures.delete(key);\n    });\n\n    //Clear walkmesh list\n    while (GameState.walkmeshList.length) {\n      const wlkmesh = GameState.walkmeshList.shift();\n      //wlkmesh.dispose();\n      GameState.group.room_walkmeshes.remove(wlkmesh);\n    }\n\n    if (GameState.PartyManager.Player) {\n      GameState.PartyManager.Player.destroy();\n      GameState.PartyManager.Player = undefined;\n    }\n\n    //Clear emitters\n    while (GameState.group.emitters.children.length) {\n      GameState.group.emitters.remove(GameState.group.emitters.children[0]);\n    }\n\n    if (this.area) {\n      this.area.dispose();\n    }\n  }\n\n  async save(isSaveGame = false) {\n    GameState.PartyManager.Save();\n\n    const ifo = new GFFObject();\n    ifo.FileType = 'IFO ';\n\n    ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Creature List'));\n    const eventQueue = ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'EventQueue'));\n    for (let i = 0; i < this.eventQueue.length; i++) {\n      const event = this.eventQueue[i];\n      if (event) {\n        eventQueue.addChildStruct(event.export());\n      }\n    }\n\n    const areaList = ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Mod_Area_list'));\n    if (this.area) {\n      areaList.addChildStruct(this.area.saveAreaListStruct());\n      this.area.save();\n    }\n\n    ifo.RootNode.addField(new GFFField(GFFDataType.INT, 'Mod_Creator_ID')).setValue(this.creatorId);\n    ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Mod_CutSceneList'));\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_DawnHour')).setValue(this.timeManager.dawnHour);\n    ifo.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'Mod_Description')).setValue(this.description);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_DuskHour')).setValue(this.timeManager.duskHour);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD64, 'Mod_Effect_NxtId')).setValue(this.effectNextId);\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_Entry_Area')).setValue(this.entryArea);\n    ifo.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'Mod_Entry_Dir_X')).setValue(this.entryDirectionX);\n    ifo.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'Mod_Entry_Dir_Y')).setValue(this.entryDirectionY);\n    ifo.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'Mod_Entry_X')).setValue(this.entryX);\n    ifo.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'Mod_Entry_Y')).setValue(this.entryY);\n    ifo.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'Mod_Entry_Z')).setValue(this.entryZ);\n    ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Mod_Expan_List'));\n    ifo.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Mod_Hak')).setValue(this.hak);\n    ifo.RootNode.addField(new GFFField(GFFDataType.VOID, 'Mod_ID'));\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_IsNWMFile')).setValue(0);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_IsSaveGame')).setValue(isSaveGame ? 1 : 0);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_MinPerHour')).setValue(this.timeManager.minutesPerHour);\n    ifo.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'Mod_Name')).setValue(this.name);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_NextCharId0')).setValue(this.nextCharId0);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_NextCharId1')).setValue(this.nextCharId1);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_NextObjId0')).setValue(this.nextObjId0);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_NextObjId1')).setValue(this.nextObjId1);\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnAcquirItem')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerAcquireItem]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnActvtItem')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerActivateItem]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnClientEntr')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerClientEnter]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnClientLeav')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerClientLeave]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnHeartbeat')).setValue(this.scripts[ModuleObjectScript.ModuleOnHeartbeat]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnModLoad')).setValue(this.scripts[ModuleObjectScript.ModuleOnLoad]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnModStart')).setValue(this.scripts[ModuleObjectScript.ModuleOnStart]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnPlrDeath')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerDeath]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnPlrDying')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerDying]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnPlrLvlUp')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerLevelUp]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnPlrRest')).setValue(this.scripts[ModuleObjectScript.ModuleOnPlayerRest]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnSpawnBtnDn')).setValue(this.scripts[ModuleObjectScript.ModuleOnSpawnButtonDown]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnUnAqreItem')).setValue(this.scripts[ModuleObjectScript.ModuleOnUnAcquireItem]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Mod_OnUsrDefined')).setValue(this.scripts[ModuleObjectScript.ModuleOnUserDefined]?.name || '');\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_PauseDay')).setValue(this.timeManager.pauseDay);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_PauseTime')).setValue(this.timeManager.pauseTime);\n\n    //Player\n    const playerList = ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Mod_PlayerList'));\n    if (GameState.PartyManager.Player) {\n      playerList.addChildStruct(GameState.PartyManager.Player.save().RootNode);\n    }\n\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_StartDay')).setValue(this.timeManager.day);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_StartHour')).setValue(this.timeManager.hour);\n    ifo.RootNode.addField(new GFFField(GFFDataType.WORD, 'Mod_StartMiliSec')).setValue(this.timeManager.milisecond);\n    ifo.RootNode.addField(new GFFField(GFFDataType.WORD, 'Mod_StartMinute')).setValue(this.timeManager.minute);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_StartMonth')).setValue(this.timeManager.month);\n    ifo.RootNode.addField(new GFFField(GFFDataType.WORD, 'Mod_StartSecond')).setValue(this.timeManager.second);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_StartYear')).setValue(this.timeManager.year);\n    ifo.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Mod_Tag')).setValue(this.tag);\n    ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'Mod_Tokens'));\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_Transition')).setValue(this.transition);\n    ifo.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Mod_Version')).setValue(this.version);\n    ifo.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_XPScale').setValue(this.xpScale));\n    ifo.RootNode.addField(new GFFField(GFFDataType.STRUCT, 'SWVarTable'));\n    ifo.RootNode.addField(new GFFField(GFFDataType.LIST, 'VarTable'));\n\n    this.ifo = ifo;\n\n    const sav = new ERFObject();\n    sav.addResource('module', ResourceTypes['ifo'], this.ifo.getExportBuffer());\n    for (let i = 0; i < this.areas.length; i++) {\n      const area = this.areas[i];\n      sav.addResource(area.name, ResourceTypes['are'], area.are.getExportBuffer());\n      sav.addResource(area.name, ResourceTypes['git'], area.git.getExportBuffer());\n    }\n\n    if (this.includeInSave()) {\n      await sav.export(path.join(CurrentGame.gameinprogress_dir, this.filename + '.sav'));\n    }\n\n    log.debug('Current Module Exported', this.filename);\n\n    await GameState.InventoryManager.Save();\n    await GameState.PartyManager.ExportPartyMemberTemplates();\n    await GameState.FactionManager.Export(path.join(CurrentGame.gameinprogress_dir, 'repute.fac'));\n  }\n\n  includeInSave() {\n    const modulesave2DA = GameState.TwoDAManager.datatables.get('modulesave');\n    if (modulesave2DA) {\n      const moduleSave = modulesave2DA.getRowByColumnAndValue('modulename', this.filename);\n      if (moduleSave) {\n        return parseInt(moduleSave.includeInSave) == 0 ? false : true;\n      }\n    }\n    return true;\n  }\n\n  static async GetModuleMod(resRef = '') {\n    const resource_path = path.join('modules', `${resRef}.mod`);\n    try {\n      const mod = new ERFObject(resource_path);\n      await mod.load();\n      log.debug('Module.GetModuleMod success', resource_path);\n      return mod;\n    } catch (e) {\n      log.error('Module.GetModuleMod failed', resource_path, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleRimA(resRef = ''): Promise<RIMObject> {\n    const resourcePath = path.join('modules', `${resRef}.rim`);\n    try {\n      const rim = new RIMObject(resourcePath);\n      await rim.load();\n      return rim;\n    } catch (e) {\n      log.error('Module.GetModuleRimA failed', resourcePath, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleRimB(resRef = ''): Promise<RIMObject> {\n    const resourcePath = path.join('modules', `${resRef}_s.rim`);\n    try {\n      const rim = new RIMObject(resourcePath);\n      await rim.load();\n      return rim;\n    } catch (e) {\n      log.warn('Module.GetModuleRimB failed', resourcePath, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleLipsLoc(): Promise<ERFObject> {\n    const resourcePath = path.join('lips', 'localization.mod');\n    try {\n      const mod = new ERFObject(resourcePath);\n      await mod.load();\n      log.debug('Module.GetModuleLipsLoc success', resourcePath);\n      return mod;\n    } catch (e) {\n      log.warn('Module.GetModuleLipsLoc failed', resourcePath, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleLips(resRef = ''): Promise<ERFObject> {\n    const resource_path = path.join('lips', `${resRef}_loc.mod`);\n    try {\n      const mod = new ERFObject(resource_path);\n      await mod.load();\n      return mod;\n    } catch (e) {\n      log.warn('Module.GetModuleLips failed', resource_path, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleDLG(resRef = ''): Promise<ERFObject> {\n    const resourcePath = path.join('modules', `${resRef}_dlg.erf`);\n    try {\n      const erf = new ERFObject(resourcePath);\n      await erf.load();\n      return erf;\n    } catch (e) {\n      log.warn('Module.GetModuleDLG failed', resourcePath, e instanceof Error ? e : new Error(String(e)));\n      return undefined;\n    }\n  }\n\n  static async GetModuleArchives(modName = ''): Promise<(RIMObject | ERFObject)[]> {\n    const archives: (RIMObject | ERFObject)[] = [];\n    let archive = undefined;\n\n    const isModuleSaved = await CurrentGame.IsModuleSaved(modName);\n\n    try {\n      if (isModuleSaved) {\n        archive = await CurrentGame.GetModuleRim(modName);\n        if (archive instanceof ERFObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's MOD file\n        archive = await Module.GetModuleMod(modName);\n        if (archive instanceof ERFObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's RIM_S file\n        archive = await Module.GetModuleRimB(modName);\n        if (archive instanceof RIMObject) {\n          archives.push(archive);\n        }\n      } else {\n        //Locate the module's MOD file\n        archive = await Module.GetModuleMod(modName);\n        if (archive instanceof ERFObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's RIM file\n        archive = await Module.GetModuleRimA(modName);\n        if (archive instanceof RIMObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's RIM_S file\n        archive = await Module.GetModuleRimB(modName);\n        if (archive instanceof RIMObject) {\n          archives.push(archive);\n        }\n      }\n\n      //Locate the module's LIPs file\n      archive = await Module.GetModuleLips(modName);\n      if (archive instanceof ERFObject) {\n        archives.push(archive);\n      }\n\n      //Locate the global LIPs file\n      archive = await Module.GetModuleLipsLoc();\n      if (archive instanceof ERFObject) {\n        archives.push(archive);\n      }\n\n      //Locate the module's dialog MOD file (TSL)\n      archive = await Module.GetModuleDLG(modName);\n      if (archive instanceof ERFObject) {\n        archives.push(archive);\n      }\n    } catch (e) {\n      log.error(e instanceof Error ? e : new Error(String(e)));\n    }\n\n    //Return the archive array\n    return archives;\n  }\n\n  static async GetModuleProjectArchives(modName = ''): Promise<(RIMObject | ERFObject)[]> {\n    return new Promise<(RIMObject | ERFObject)[]>(async (resolve, reject) => {\n      const archives: (RIMObject | ERFObject)[] = [];\n      let archive = undefined;\n\n      try {\n        //Locate the module's RIM file\n        archive = await Module.GetModuleRimA(modName);\n        if (archive instanceof RIMObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's RIM_S file\n        archive = await Module.GetModuleRimB(modName);\n        if (archive instanceof RIMObject) {\n          archives.push(archive);\n        }\n\n        //Locate the module's dialog MOD file (TSL)\n        archive = await Module.GetModuleDLG(modName);\n        if (archive instanceof ERFObject) {\n          archives.push(archive);\n        }\n      } catch (e) {\n        log.error(e instanceof Error ? e : new Error(String(e)));\n      }\n\n      //Return the archive array\n      resolve(archives);\n    });\n  }\n\n  //ex: end_m01aa end_m01aa_s\n  static async Load(modName: string, waypoint?: string) {\n    log.debug('Load', modName);\n    const module = new Module();\n    module.filename = modName;\n    module.transWP = waypoint;\n    if (!modName) { return module; }\n    try {\n      GameState.ModuleObjectManager.Reset();\n      const archives = await Module.GetModuleArchives(modName);\n      await ResourceLoader.InitModuleCache(archives);\n      const ifo_data = await ResourceLoader.loadResource(ResourceTypes['ifo'], 'module');\n      const ifo = new GFFObject(ifo_data);\n      module.setFromIFO(ifo, GameState.isLoadingSave);\n      GameState.time = module.timeManager.pauseTime / 1000;\n\n      const gitBuffer = await ResourceLoader.loadResource(ResourceTypes['git'], module.entryArea);\n      const git = new GFFObject(gitBuffer);\n\n      const areBuffer = await ResourceLoader.loadResource(ResourceTypes['are'], module.entryArea);\n      const are = new GFFObject(areBuffer)\n      module.area = new ModuleArea(module.entryArea, are, git);\n      module.areas = [module.area];\n      module.area.module = module;\n      module.area.setTransitionWaypoint(module.transWP);\n      await module.area.load();\n\n      if (module.nextObjId0)\n        GameState.ModuleObjectManager.COUNT = module.nextObjId0;\n\n      GameState.ModuleObjectManager.module = module;\n\n      if (GameState.isLoadingSave) {\n        log.debug('Module', 'SaveGame.loadInventory');\n        await GameState.SaveGame.loadInventory();\n      }\n\n      return module;\n    } catch (e) {\n      log.warn('Module.Load: failed to load module.', e instanceof Error ? e : new Error(String(e)));\n    }\n  }\n\n  toEulerianAngle(q: THREE.Quaternion) {\n    const ysqr = q.y * q.y;\n\n    // roll (x-axis rotation)\n    const t0 = +2.0 * (q.w * q.x + q.y * q.z);\n    const t1 = +1.0 - 2.0 * (q.x * q.x + ysqr);\n    const roll = Math.atan2(t0, t1);\n\n    // pitch (y-axis rotation)\n    let t2 = +2.0 * (q.w * q.y - q.z * q.x);\n    t2 = t2 > 1.0 ? 1.0 : t2;\n    t2 = t2 < -1.0 ? -1.0 : t2;\n    const pitch = Math.asin(t2);\n\n    // yaw (z-axis rotation)\n    const t3 = +2.0 * (q.w * q.z + q.x * q.y);\n    const t4 = +1.0 - 2.0 * (ysqr + q.z * q.z);\n    const yaw = Math.atan2(t3, t4);\n\n    return { yaw: yaw, pitch: pitch, roll: roll };\n  }\n\n  Save() {\n\n    //Export .ifo\n\n    //Export .are\n\n    //Export .git\n\n    return {\n      are: null as GFFObject | null,\n      git: null as GFFObject | null,\n      ifo: null as GFFObject | null\n    };\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleArea.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":487,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":487,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":979,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":979,"endColumn":103},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":979,"column":24,"nodeType":"MemberExpression","messageId":"errorCall","endLine":979,"endColumn":101},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string`.","line":982,"column":35,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":982,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1132,"column":46,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1132,"endColumn":96},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1136,"column":16,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1136,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1136,"column":80,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1136,"endColumn":130}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AudioEngine } from \"@/audio\";\nimport { AudioLoader } from \"@/audio/AudioLoader\";\nimport { SpellCastInstance } from \"@/combat/SpellCastInstance\";\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { FollowerCamera } from \"@/engine/FollowerCamera\";\nimport { TextSprite3D } from \"@/engine/TextSprite3D\";\nimport { BackgroundMusicMode } from \"@/enums/audio/BackgroundMusicMode\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport { GameState } from \"@/GameState\";\nimport { IAmbientSource } from \"@/interface/area/IAmbientSource\";\nimport { IAreaAudioProperties } from \"@/interface/area/IAreaAudioProperties\";\nimport { IGrassProperties } from \"@/interface/area/IGrassProperties\";\nimport { ITextureLoaderQueuedRef } from \"@/interface/loaders/ITextureLoaderQueuedRef\";\nimport { IVISRoom } from \"@/interface/module/IVISRoom\";\nimport type { ILayoutDoorHook } from \"@/interface/resource/ILayoutDoorHook\";\nimport { ResourceLoader, TextureLoader } from \"@/loaders\";\nimport { AreaMap } from \"@/module/AreaMap\";\nimport { AreaWeather } from \"@/module/AreaWeather\";\n// import { MenuManager, TwoDAManager, PartyManager, ModuleObjectManager } from \"@/managers\";\n\nimport type { Module } from \"@/module/Module\";\nimport { ModuleAreaOfEffect } from \"@/module/ModuleAreaOfEffect\";\nimport { ModuleCamera } from \"@/module/ModuleCamera\";\nimport { ModuleCreature } from \"@/module/ModuleCreature\";\nimport { ModuleDoor } from \"@/module/ModuleDoor\";\nimport { ModuleEncounter } from \"@/module/ModuleEncounter\";\nimport { ModuleItem } from \"@/module/ModuleItem\";\nimport { ModuleMGEnemy } from \"@/module/ModuleMGEnemy\";\nimport { ModuleMGObstacle } from \"@/module/ModuleMGObstacle\";\nimport { ModuleMGPlayer } from \"@/module/ModuleMGPlayer\";\nimport { ModuleMGTrack } from \"@/module/ModuleMGTrack\";\nimport { ModuleMiniGame } from \"@/module/ModuleMiniGame\";\nimport { ModuleObject } from \"@/module/ModuleObject\";\nimport { ModulePath } from \"@/module/ModulePath\";\nimport { ModulePlaceable } from \"@/module/ModulePlaceable\";\nimport { ModulePlayer } from \"@/module/ModulePlayer\";\nimport { ModuleRoom } from \"@/module/ModuleRoom\";\nimport { ModuleSound } from \"@/module/ModuleSound\";\nimport { ModuleStore } from \"@/module/ModuleStore\";\nimport { ModuleTrigger } from \"@/module/ModuleTrigger\";\nimport { ModuleWaypoint } from \"@/module/ModuleWaypoint\";\nimport { NWScript } from \"@/nwscript/NWScript\";\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { OdysseyWalkMesh } from \"@/odyssey/OdysseyWalkMesh\";\nimport type { WalkmeshEdge } from \"@/odyssey/WalkmeshEdge\";\nimport { CExoLocString } from \"@/resource/CExoLocString\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { LYTObject } from \"@/resource/LYTObject\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { VISObject } from \"@/resource/VISObject\";\nimport type { OdysseyFace3 } from \"@/three/odyssey/OdysseyFace3\";\nimport { OdysseyModel3D } from \"@/three/odyssey/OdysseyModel3D\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\n\nconst log = createScopedLogger(LogScope.Module);\n\ntype AreaScriptKeys = 'OnEnter'|'OnExit'|'OnHeartbeat'|'OnUserDefined';\n\n/**\n * ModuleArea class.\n *\n * Class representing an ingame area.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file ModuleArea.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class ModuleArea extends ModuleObject {\n\n  static ModuleObject: typeof ModuleObject = ModuleObject;\n  static ModuleAreaOfEffect: typeof ModuleAreaOfEffect = ModuleAreaOfEffect;\n  static ModuleCamera: typeof ModuleCamera = ModuleCamera;\n  static ModuleCreature: typeof ModuleCreature = ModuleCreature;\n  static ModuleDoor: typeof ModuleDoor = ModuleDoor;\n  static ModuleEncounter: typeof ModuleEncounter = ModuleEncounter;\n  static ModuleItem: typeof ModuleItem = ModuleItem;\n  static ModuleMGEnemy: typeof ModuleMGEnemy = ModuleMGEnemy;\n  static ModuleMGObstacle: typeof ModuleMGObstacle = ModuleMGObstacle;\n  static ModuleMGPlayer: typeof ModuleMGPlayer = ModuleMGPlayer;\n  static ModuleMGTrack: typeof ModuleMGTrack = ModuleMGTrack;\n  static ModuleMiniGame: typeof ModuleMiniGame = ModuleMiniGame;\n  static ModulePath: typeof ModulePath = ModulePath;\n  static ModulePlaceable: typeof ModulePlaceable = ModulePlaceable;\n  static ModulePlayer: typeof ModulePlayer = ModulePlayer;\n  static ModuleRoom: typeof ModuleRoom = ModuleRoom;\n  static ModuleSound: typeof ModuleSound = ModuleSound;\n  static ModuleStore: typeof ModuleStore = ModuleStore;\n  static ModuleTrigger: typeof ModuleTrigger = ModuleTrigger;\n  static ModuleWaypoint: typeof ModuleWaypoint = ModuleWaypoint;\n\n  module: Module;\n  are: GFFObject;\n  git: GFFObject;\n  transWP: string|GFFObject;\n  weather: AreaWeather = new AreaWeather(this);\n  fog: THREE.Fog;\n  path: ModulePath;\n  visObject: VISObject;\n  layout: LYTObject;\n  areaMap: AreaMap;\n\n  cameras: ModuleCamera[] = [];\n  creatures: ModuleCreature[] = [];\n  doorhooks: ILayoutDoorHook[] = [];\n  doors: ModuleDoor[] = [];\n  encounters: ModuleEncounter[] = [];\n  items: ModuleItem[] = [];\n  placeables: ModulePlaceable[] = [];\n  sounds: ModuleSound[] = [];\n  stores: ModuleStore[] = [];\n  triggers: ModuleTrigger[] = [];\n  waypoints: ModuleWaypoint[] = [];\n  areaOfEffects: ModuleAreaOfEffect[] = [];\n  miniGame: ModuleMiniGame;\n  walkmesh_rooms: ModuleRoom[] = [];\n\n  scriptResRefs: Map<AreaScriptKeys, string> = new Map<AreaScriptKeys, string>();\n\n  audio: IAreaAudioProperties = {\n    ambient: {\n      day: 0,\n      dayVolume: 0,\n      night: 0,\n      nightVolume: 0\n    },\n    music: {\n      day: 0,\n      battle: 0,\n      night: 0,\n      delay: 0\n    },\n    environmentAudio: 0,\n  };\n\n  alphaTest = 0.200000002980232;\n\n  /**\n   * Index into camerastyle.2da\n   */\n  cameraStyle = 0;\n\n  /**\n   * Module designer comments\n   */\n  comments = '';\n\n  /**\n   * @deprecated Deprecated: since NWN\n   */\n  creatorId = -1;\n\n  /**\n   * Determines if there is an active day/night cycle\n   * @remarks not supported by KotOR or TSL. not sure if we will add support for this in the engine\n   */\n  dayNightCycle: boolean = false;\n\n  /**\n   *\n   */\n  defaultEnvMap = '';\n\n  /**\n   *\n   */\n  dynamicAmbientColor = 6312778;\n\n  /**\n   * @deprecated Deprecated: since NWN\n   */\n  expansionList: unknown[] = [];\n\n  /**\n   * Set of bit flags specifying area terrain type:\n   * Bit 0: INTERIOR     (exterior if unset)\n   * Bit 1: UNDERGROUND  (aboveground if unset)\n   * Bit 2: NATURAL      (urban if unset)\n   * These flags affect game behaviour with respect to ability to hear things behind walls, map exploration visibility, and whether certain feats are active, though not necessarily in that order. They do not affect how the toolset presents the area to the user.\n   * @remarks currently unused\n   */\n  flags = 1;\n\n  grass: IGrassProperties = {\n    ambient: 0,\n    density: 0,\n    diffuse: 0,\n    probability: {\n      lowerLeft: 0.25,\n      lowerRight: 0.25,\n      upperLeft: 0.25,\n      upperRight: 0.25\n    },\n    quadSize: 0,\n    textureName: ''\n  };\n\n  /**\n   * TRUE if the area is always night, FALSE if area is always day. Meaningful only if DayNightCycle is FALSE\n   */\n  isNight: boolean = false;\n\n  lightingScheme = 0;\n\n  /**\n   * Index into loadscreens.2da. Default loading screen to use when loading this area.\n   * @remarks Note that a Door or Trigger that has an area transition can override the loading screen of the destination area\n   * not supported by KotOR or TSL. not sure if we will add support for this in the engine\n   */\n  loadScreenId = 0;\n\n  /**\n   * Modifier to Listen akill checks made in area\n   */\n  modListenCheck = 0;\n\n  /**\n   * Modifier to Spot skill checks made in area\n   */\n  modSpotCheck = 0;\n\n  /**\n   * Moon AmbientSource properties\n   */\n  moon: IAmbientSource = {\n    ambientColor: 0,\n    diffuseColor: 0,\n    fogColor: 0,\n    fogNear: 99,\n    fogFar: 100,\n    fogAmount: 1,\n    fogOn: false,\n    shadows: false\n  };\n\n  /**\n   * Sun AmbientSource properties\n   */\n  sun: IAmbientSource = {\n    ambientColor: 0,\n    diffuseColor: 0,\n    fogColor: 0,\n    fogNear: 1000,\n    fogFar: 2000,\n    fogAmount: 1,\n    fogOn: false,\n    shadows: false\n  };\n\n  /**\n   * Name of area as seen in game.\n   * ToDo: If there is a colon (:) in the name, then the game does not show any of the text up to and including the first colon\n   */\n  areaName: CExoLocString;\n\n  /**\n   * @remarks unimplemented\n   */\n  noHangBack: boolean;\n\n  /**\n   * Determines if the player can rest\n   */\n  noRest: boolean;\n\n  playerOnly: boolean = false;\n\n  /**\n   * Index into pvpsettings.2da.\n   * Note that the settings are actually hard-coded into the game, and pvpsettings.2da serves only to provide text descriptions of the settings\n   */\n  playerVsPlayer: boolean = false;\n\n  /**\n   * Opacity of shadows (0-100)\n   */\n  shadowOpacity = 0;\n\n  /**\n   * Determines if the Stealth XP mechanic is enabled for this area\n   */\n  stealthXPEnabled = 0;\n\n  /**\n   * The amount of XP that will be subtracted from the stealthXP if the player is perceived by an enemy\n   * If a player is able to successfully hide from an enemy, the stealthXPLoss will be added to the player's stealthXP after it's divided by two\n   */\n  stealthXPLoss = 0;\n\n  /**\n   * The maximum amount of stealth XP that can be gained in this area\n   */\n  stealthXPMax = 0;\n\n  /**\n   * The amount of stealth XP that the player has gained in this area\n   */\n  stealthXP = 0;\n\n  /**\n   * Tag of the area, used for scripting\n   */\n  tag = '';\n\n  /**\n   * Determines if the player can escape to the hideout\n   */\n  unescapable: boolean = false;\n\n  /**\n   * Revision number of the area. Initially 1 when area is first saved to disk, and increments every time the ARE file is saved. Equals 2 on second save, and so on\n   */\n  version = 1;\n\n  /**\n   * Strength of the wind in the area. None, Weak, or Strong (0-2).\n   */\n  windPower = 0;\n\n  restrictMode: number;\n\n  spellInstances: SpellCastInstance[] = [];\n  textSprites: TextSprite3D[] = [];\n\n  roomWalkmeshes: OdysseyWalkMesh[] = [];\n  doorWalkmeshes: OdysseyWalkMesh[] = [];\n\n  walkEdges: WalkmeshEdge[] = [];\n  walkFaces: OdysseyFace3[] = [];\n\n  constructor(resRef = '', are = new GFFObject(), git = new GFFObject()){\n    super(are);\n    this.objectType |= ModuleObjectType.ModuleArea;\n    this.name = resRef;\n    this.are = are;\n    this.git = git;\n    this.transWP = '';\n  }\n\n  dispose(){\n    this.areaMap.dispose();\n\n    //clear area room objects\n    while (this.rooms.length){\n      this.rooms[0].destroy();\n    }\n\n    //clear area areaOfEffect objects\n    while (this.areaOfEffects.length){\n      this.areaOfEffects[0].destroy();\n    }\n\n    //clear area creature objects\n    while (this.creatures.length){\n      this.creatures[0].destroy();\n    }\n\n    //clear area item objects\n    while (this.items.length){\n      this.items[0].destroy();\n    }\n\n    //clear area placeable objects\n    while (this.placeables.length){\n      this.placeables[0].destroy();\n    }\n\n    //clear area door objects\n    while (this.doors.length){\n      this.doors[0].destroy();\n    }\n\n    //clear area trigger objects\n    while (this.triggers.length){\n      this.triggers[0].destroy();\n    }\n\n    //clear area waypoint objects\n    while (this.waypoints.length){\n      this.waypoints[0].destroy();\n    }\n\n    //clear area sound objects\n    while (this.sounds.length){\n      this.sounds[0].destroy();\n    }\n\n    while (GameState.PartyManager.party.length){\n      const pm = GameState.PartyManager.party.shift();\n      pm.destroy();\n    }\n\n    this.weather.destroy();\n  }\n\n  update(delta: number = 0){\n    const roomCount = this.rooms.length;\n    const aoeCount = this.areaOfEffects.length;\n    const trigCount = this.triggers.length;\n    const encounterCount = this.encounters.length;\n    const creatureCount = this.creatures.length;\n    const placeableCount = this.placeables.length;\n    const doorCount = this.doors.length;\n    const partyCount = GameState.PartyManager.party.length;\n\n    //update triggers\n    for(let i = 0; i < trigCount; i++){\n      this.triggers[i].update(delta);\n    }\n\n    //update encounters\n    for(let i = 0; i < encounterCount; i++){\n      this.encounters[i].update(delta);\n    }\n\n    //update aoe\n    for(let i = 0; i < aoeCount; i++){\n      this.areaOfEffects[i].update(delta);\n    }\n\n    //update party\n    for(let i = 0; i < partyCount; i++){\n      GameState.PartyManager.party[i].update(delta);\n    }\n\n    //update creatures\n    for(let i = 0; i < creatureCount; i++){\n      this.creatures[i].update(delta);\n    }\n\n    //update placeables\n    for(let i = 0; i < placeableCount; i++){\n      this.placeables[i].update(delta);\n    }\n\n    //update doors\n    for(let i = 0; i < doorCount; i++){\n      this.doors[i].update(delta);\n    }\n\n    //unset party controlled\n    for(let i = 0; i < partyCount; i++){\n      GameState.PartyManager.party[i].controlled = false;\n    }\n\n    if(GameState.Mode == EngineMode.MINIGAME){\n      this.miniGame.tick(delta);\n    }\n\n    //update rooms\n    for(let i = 0; i < roomCount; i++){\n      this.rooms[i].update(delta);\n      // this.rooms[i].hide();\n    }\n\n    for(let i = 0, spellCount = this.spellInstances.length; i < spellCount; i++){\n      this.spellInstances[i].update(delta);\n    }\n\n    let spellIndex = this.spellInstances.length;\n    while(spellIndex--){\n      const spellInstance = this.spellInstances[spellIndex];\n      if(spellInstance && spellInstance.completed){\n        spellInstance.dispose();\n        this.spellInstances.splice(spellIndex, 1);\n      }\n    }\n\n    const textSpriteIndexer = new Map();\n    for(let i = 0, textSpriteCount = this.textSprites.length; i < textSpriteCount; i++){\n      const sprite = this.textSprites[i];\n      if(!sprite) continue;\n\n      if(!textSpriteIndexer.has(sprite.owner.id)){\n        textSpriteIndexer.set(sprite.owner.id, 0);\n      }\n      const index = textSpriteIndexer.get(sprite.owner.id);\n\n      sprite.container.position.copy(sprite.position);\n      sprite.container.position.z = sprite.position.z + (0.1 * index);\n\n      sprite.update(delta);\n      textSpriteIndexer.set(sprite.owner.id, index + 1);\n    }\n\n    let textSpriteIndex = this.textSprites.length;\n    while(textSpriteIndex--){\n      const textSprite = this.textSprites[textSpriteIndex];\n      if(textSprite && textSprite.expired){\n        textSprite.dispose();\n        this.textSprites.splice(textSpriteIndex, 1);\n      }\n    }\n\n    this.updateRoomVisibility(delta);\n    FollowerCamera.update(delta, this);\n\n    this.weather.update(delta);\n\n    if(this.path){\n      this.path.update(delta);\n    }\n\n    this.updateMusic(delta);\n  }\n\n  updatePaused(delta: number = 0){\n    const roomCount = this.rooms.length;\n    const trigCount = this.triggers.length;\n    const encounterCount = this.encounters.length;\n    const aoeCount = this.areaOfEffects.length;\n    const creatureCount = this.creatures.length;\n    const placeableCount = this.placeables.length;\n    const doorCount = this.doors.length;\n    const partyCount = GameState.PartyManager.party.length;\n\n    //update triggers\n    for(let i = 0; i < trigCount; i++){\n      this.triggers[i].updatePaused(delta);\n    }\n\n    //update encounters\n    for(let i = 0; i < encounterCount; i++){\n      this.encounters[i].updatePaused(delta);\n    }\n\n    //update aoe\n    for(let i = 0; i < aoeCount; i++){\n      this.areaOfEffects[i].updatePaused(delta);\n    }\n\n    //update party\n    for(let i = 0; i < partyCount; i++){\n      GameState.PartyManager.party[i].updatePaused(delta);\n    }\n\n    //update creatures\n    for(let i = 0; i < creatureCount; i++){\n      this.creatures[i].updatePaused(delta);\n    }\n\n    //update placeables\n    for(let i = 0; i < placeableCount; i++){\n      this.placeables[i].updatePaused(delta);\n    }\n\n    //update doors\n    for(let i = 0; i < doorCount; i++){\n      this.doors[i].updatePaused(delta);\n    }\n\n    if(GameState.Mode == EngineMode.MINIGAME){\n      this.miniGame.tickPaused(delta);\n    }\n\n    //update rooms\n    // for(let i = 0; i < roomCount; i++){\n    //   this.rooms[i].hide();\n    // }\n\n    this.updateRoomVisibility(delta);\n    FollowerCamera.update(delta, this);\n\n    this.updateMusic(delta);\n  }\n\n  /**\n   * Update room models width lightmaps to use animated lights\n   * Animated lights are the only lights that can influence lightmapped surfaces\n   * @param delta\n   */\n  updateRoomAnimatedLights(delta: number = 0){\n\n    const lm = GameState.lightManager;\n    const animatedLightUniformStructList = lm.animatedLights;\n\n    const rooms = this.rooms;\n    for(let i = 0, il = rooms.length; i < il; i++){\n      const room = rooms[i];\n      if(!room.isVisible() || !room.model){ continue; }\n      if(!(room.model instanceof OdysseyModel3D)){ continue; }\n\n      for(let j = 0, jl = room.model.materials.length; j < jl; j++){\n        const material = room.model.materials[j];\n        if(!(material instanceof THREE.ShaderMaterial && !material.defines?.USE_LIGHTMAP)){ continue; }\n        if(material.userData.animatedLightCacheID == lm.animatedLightsCacheID){ continue; }\n        material.uniforms.animPointLights.value = animatedLightUniformStructList;\n        (material.uniforms.animPointLights as THREE.IUniform & { needsUpdate?: boolean }).needsUpdate = true;\n        material.userData.animatedLightCacheID = lm.animatedLightsCacheID;\n        material.uniformsNeedUpdate = true;\n        material.defines.NUM_ANIM_POINT_LIGHTS = animatedLightUniformStructList.length.toString();\n        material.needsUpdate = true;\n      }\n    }\n  }\n\n  updateMusic(delta: number = 0){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    const oPC = GameState.getCurrentPlayer();\n    if(oPC.excitedDuration > 0 && audioEngine.bgmMode == BackgroundMusicMode.AREA && audioEngine.battleMusicLoaded){\n      audioEngine.bgmMode = BackgroundMusicMode.BATTLE;\n      audioEngine.areaMusicDayAudioEmitter.stop();\n      audioEngine.battleMusicAudioEmitter.play(true);\n    }else if(oPC.excitedDuration <= 0 && audioEngine.bgmMode == BackgroundMusicMode.BATTLE && audioEngine.battleMusicLoaded){\n      audioEngine.bgmMode = audioEngine.battleStingerLoaded ? BackgroundMusicMode.BATTLE_STINGER : BackgroundMusicMode.AREA;\n      audioEngine.battleMusicAudioEmitter.stop();\n    }\n  }\n\n  musicBackgroundPlay(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.areaMusicDayAudioEmitter.play();\n  }\n\n  musicBackgroundStop(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.areaMusicDayAudioEmitter.stop();\n  }\n\n  musicBackgroundSetDelay(delay: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.bgmLoopTime = delay;\n  }\n\n  async musicBackgroundDaySet(index: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    //Load the background music\n    const ambientmusic2DA = GameState.TwoDAManager.datatables.get('ambientmusic');\n    const bgMusic = ambientmusic2DA.rows[index];\n    this.audio.music.day = index;\n    try{\n      if(bgMusic.resource != '****'){\n        log.debug('Loading Background Music', bgMusic.resource);\n        const data = await AudioLoader.LoadMusic(bgMusic.resource);\n        audioEngine.setAudioBuffer('BACKGROUND_MUSIC_DAY', data.buffer as ArrayBuffer, bgMusic.resource);\n      }\n    }catch(e){\n      log.warn('Background Music not found', bgMusic);\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  async musicBackgroundNightSet(index: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    //Load the battle music\n    const ambientmusic2DA = GameState.TwoDAManager.datatables.get('ambientmusic');\n    const bgMusic = ambientmusic2DA.rows[index];\n    this.audio.music.night = index;\n    try{\n      if(bgMusic.resource != '****'){\n        log.debug('Loading Background Music', bgMusic.resource);\n        const data = await AudioLoader.LoadMusic(bgMusic.resource);\n        audioEngine.setAudioBuffer('BACKGROUND_MUSIC_NIGHT', data.buffer as ArrayBuffer, bgMusic.resource);\n      }\n    }catch(e){\n      log.warn('Background Music not found', bgMusic);\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  musicBattlePlay(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.battleMusicAudioEmitter.play();\n  }\n\n  musicBattleStop(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.battleMusicAudioEmitter.stop();\n  }\n\n  async musicBattleSet(index: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    //Load the battle music\n    const ambientmusic2DA = GameState.TwoDAManager.datatables.get('ambientmusic');\n    const battleMusic = ambientmusic2DA.rows[index];\n    this.audio.music.battle = index;\n    try{\n      if(battleMusic.resource != '****'){\n        log.info('Loading Battle Music', battleMusic.resource);\n        const data = await AudioLoader.LoadMusic(battleMusic.resource);\n        audioEngine.setAudioBuffer('BATTLE', data.buffer as ArrayBuffer, battleMusic.resource);\n      }\n      //Load the battle stinger\n      try{\n        if(battleMusic.stinger1 != '****'){\n          log.debug('Loading Battle Stinger', battleMusic.stinger1);\n          const data = await AudioLoader.LoadStreamSound(battleMusic.stinger1);\n          audioEngine.setAudioBuffer('BATTLE_STINGER', data.buffer as ArrayBuffer, battleMusic.stinger1);\n        }\n      }catch(e){\n        log.warn('Battle Stinger not found', battleMusic.stinger1);\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }catch(e){\n      log.warn('Background Music not found', battleMusic);\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  ambientSoundPlay(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.ambientAudioDayEmitter.play();\n  }\n\n  ambientSoundStop(){\n    const audioEngine = AudioEngine.GetAudioEngine();\n    audioEngine.ambientAudioDayEmitter.stop();\n  }\n\n  async ambientSoundDaySet(index: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n\n    this.audio.ambient.day = index;\n    const ambientsound2DA = GameState.TwoDAManager.datatables.get('ambientsound');\n    if(ambientsound2DA){\n      //Load the ambient day sound\n      const ambientDay = ambientsound2DA.rows[this.audio.ambient.day];\n      if(!ambientDay || ambientDay.resource == '****'){\n        return;\n      }\n      log.debug('Loading Ambient Day Sound', ambientDay.resource);\n      try{\n        const data = await AudioLoader.LoadAmbientSound(ambientDay.resource);\n        audioEngine.setAudioBuffer('AMBIENT_DAY', data.buffer as ArrayBuffer, ambientDay.resource);\n        audioEngine.ambientAudioDayEmitter.play(true);\n      }catch(e){\n        log.error('Ambient Audio not found', ambientDay);\n      }\n    }\n  }\n\n  async ambientSoundNightSet(index: number){\n    const audioEngine = AudioEngine.GetAudioEngine();\n\n    this.audio.ambient.night = index;\n    const ambientsound2DA = GameState.TwoDAManager.datatables.get('ambientsound');\n    if(ambientsound2DA){\n      //Load the ambient day sound\n      const ambientDay = ambientsound2DA.rows[this.audio.ambient.night];\n      if(!ambientDay || ambientDay.resource == '****'){\n        return;\n      }\n      log.debug('Loading Ambient Day Sound', ambientDay.resource);\n      try{\n        const data = await AudioLoader.LoadAmbientSound(ambientDay.resource);\n        audioEngine.setAudioBuffer('AMBIENT_NIGHT', data.buffer as ArrayBuffer, ambientDay.resource);\n        audioEngine.ambientAudioNightEmitter.play(true);\n      }catch(e){\n        log.error('Ambient Audio not found', ambientDay);\n      }\n    }\n  }\n\n  attachSpellInstance(spellInstance: SpellCastInstance){\n    if(!spellInstance) return;\n    GameState.group.spell_instances.add(spellInstance.container);\n    this.spellInstances.push(spellInstance);\n  }\n\n  attachTextSprite3D(sprite: TextSprite3D){\n    if(!sprite) return;\n    GameState.group.effects.add(sprite.container);\n    this.textSprites.push(sprite);\n  }\n\n  lastRoom: ModuleRoom = undefined;\n  updateRoomVisibility(delta: number = 0){\n    switch(GameState.Mode){\n      case EngineMode.DIALOG:\n        this.lastRoom = undefined;\n        const roomInView: boolean[] = [];\n        const pos = GameState.currentCamera.position.clone().add(GameState.playerFeetOffset);\n\n\n        for(let i = 0, roomCount = this.rooms.length; i < roomCount; i++){\n          const room = this.rooms[i];\n          const inCamera = GameState.viewportFrustum.intersectsBox(room.box);\n          roomInView[i] = (!room.visObject || room.box.containsPoint(pos) || inCamera);\n          if(!roomInView[i]){\n            room.hide();\n            continue;\n          }\n          room.show(false);\n        }\n      break;\n      case EngineMode.MINIGAME:\n        this.lastRoom = undefined;\n        for(let i = 0, len = this.rooms.length; i < len; i++){\n          const room = this.rooms[i];\n          if(!room) continue;\n          room.show(false);\n        }\n      break;\n      case EngineMode.INGAME:\n      case EngineMode.FREELOOK:\n      default:\n        const player = GameState.getCurrentPlayer();\n        if(!player){ return; }\n        //Check to see if the player has moved to a new room\n        if(this.lastRoom && this.lastRoom == player.room){\n          return;\n        }\n        this.lastRoom = player.room;\n\n        if(this.lastRoom?.envAudio >= 0){\n          AudioEngine.GetAudioEngine().setReverbProfile(this.lastRoom?.envAudio || 0);\n        }\n\n        //Reset all room's visibility to hidden\n        const roomCount = this.rooms.length;\n        for(let i = 0; i < roomCount; i++){\n          const room = this.rooms[i];\n          room.hide();\n        }\n\n        if(!player.room){\n          return;\n        }\n\n        //Show the current room and all of it's linked rooms\n        player.room.show(true);\n      break;\n    }\n  }\n\n  async reloadTextures(){\n    GameState.MenuManager.LoadScreen.open();\n    GameState.MenuManager.LoadScreen.LBL_HINT.setText('');\n    GameState.loadingTextures = true;\n    //Cleanup texture cache\n    Array.from(TextureLoader.textures.keys()).forEach( (key) => {\n      TextureLoader.textures.get(key).dispose();\n      TextureLoader.textures.delete(key);\n    });\n\n\n    for(let i = 0; i < this.rooms.length; i++){\n      const room = this.rooms[i];\n      //room.LoadModel();\n    }\n\n    for(let i = 0; i < this.creatures.length; i++){\n      const creature = this.creatures[i];\n      await creature.loadModel();\n    }\n\n    for(let i = 0; i < GameState.PartyManager.party.length; i++){\n      const creature = GameState.PartyManager.party[i];\n      await creature.loadModel();\n    }\n\n    for(let i = 0; i < this.placeables.length; i++){\n      const placeable = this.placeables[i];\n      await placeable.loadModel();\n    }\n\n    for(let i = 0; i < this.doors.length; i++){\n      const door = this.doors[i];\n      await door.loadModel();\n    }\n\n    for(let i = 0; i < this.rooms.length; i++){\n      const room = this.rooms[i];\n      await room.loadModel();\n    }\n\n    TextureLoader.LoadQueue((ref: ITextureLoaderQueuedRef, index: number, count: number) => {\n      GameState.MenuManager.LoadScreen.setProgress((index/count + 1) * 100);\n      GameState.MenuManager.LoadScreen.LBL_HINT.setText('Loading: '+ref.name);\n      //log.info('tex', textureName, index, count);\n    }).then(() => {\n      GameState.MenuManager.LoadScreen.close();\n      GameState.loadingTextures = false;\n    });\n  }\n\n  setTransitionWaypoint(sTag = ''){\n    this.transWP = sTag;\n  }\n\n  async load(){\n\n    //BEGIN AREA LOAD\n\n    if(this.are.RootNode.hasField('ObjectId'))\n      this.id = this.are.getFieldByLabel('ObjectId').getValue();\n\n    const rooms = this.are.getFieldByLabel('Rooms');\n\n    this.alphaTest = this.are.getFieldByLabel('AlphaTest').getValue();\n    this.cameraStyle = this.are.getFieldByLabel('CameraStyle').getValue();\n    this.weather.chanceLightning = this.are.getFieldByLabel('ChanceLightning').getValue();\n    this.weather.chanceRain = this.are.getFieldByLabel('ChanceRain').getValue();\n    this.weather.chanceSnow = this.are.getFieldByLabel('ChanceSnow').getValue();\n    this.comments = this.are.getFieldByLabel('Comments').getValue();\n    this.creatorId = this.are.getFieldByLabel('Creator_ID').getValue();\n    this.dayNightCycle = this.are.getFieldByLabel('DayNightCycle').getValue();\n    this.defaultEnvMap = this.are.getFieldByLabel('DefaultEnvMap').getValue();\n    this.dynamicAmbientColor = this.are.getFieldByLabel('DynAmbientColor').getValue();\n    this.expansionList = [];\n\n    this.flags = this.are.getFieldByLabel('Flags').getValue();\n    this.grass = {\n      ambient: this.are.getFieldByLabel('Grass_Ambient').getValue(),\n      density: this.are.getFieldByLabel('Grass_Density').getValue(),\n      diffuse: this.are.getFieldByLabel('Grass_Diffuse').getValue(),\n      probability: {\n        lowerLeft: this.are.getFieldByLabel('Grass_Prob_LL').getValue(),\n        lowerRight: this.are.getFieldByLabel('Grass_Prob_LR').getValue(),\n        upperLeft: this.are.getFieldByLabel('Grass_Prob_UL').getValue(),\n        upperRight: this.are.getFieldByLabel('Grass_Prob_UR').getValue()\n      },\n      quadSize: this.are.getFieldByLabel('Grass_QuadSize').getValue(),\n      textureName: this.are.getFieldByLabel('Grass_TexName').getValue()\n    };\n\n    this.id = this.are.getFieldByLabel('ID').getValue();\n    this.isNight = this.are.getFieldByLabel('IsNight').getValue();\n    this.lightingScheme = this.are.getFieldByLabel('LightingScheme').getValue();\n    this.loadScreenId = this.are.getFieldByLabel('LoadScreenID').getValue();\n\n    const map = this.are.getFieldByLabel('Map').getChildStructs()[0];\n    if(map){\n      this.areaMap = AreaMap.FromStruct(map);\n    }\n\n    if(this.are.RootNode.hasField('MiniGame')){\n      this.miniGame = new ModuleMiniGame(\n        this.are.getFieldByLabel('MiniGame').getChildStructs()[0]\n      );\n    }\n\n    this.modListenCheck = this.are.getFieldByLabel('ModListenCheck').getValue();\n    this.modSpotCheck = this.are.getFieldByLabel('ModSpotCheck').getValue();\n    this.moon.ambientColor = this.are.getFieldByLabel('MoonAmbientColor').getValue();\n    this.moon.diffuseColor = this.are.getFieldByLabel('MoonDiffuseColor').getValue();\n    this.moon.fogColor = this.are.getFieldByLabel('MoonFogColor').getValue();\n    this.moon.fogFar = this.are.getFieldByLabel('MoonFogFar').getValue();\n    this.moon.fogFar = this.are.getFieldByLabel('MoonFogNear').getValue();\n    this.moon.fogOn = !!this.are.getFieldByLabel('MoonFogOn').getValue();\n    this.moon.shadows = !!this.are.getFieldByLabel('MoonShadows').getValue();\n    this.areaName = this.are.getFieldByLabel('Name').getCExoLocString();\n\n    this.noHangBack = !!this.are.getFieldByLabel('NoHangBack').getValue();\n    this.noRest = !!this.are.getFieldByLabel('NoRest').getValue();\n\n    if(this.are.RootNode.hasField(ModuleObjectScript.AreaOnEnter)){\n      this.scriptResRefs.set(ModuleObjectScript.AreaOnEnter, this.are.getFieldByLabel(ModuleObjectScript.AreaOnEnter).getValue());\n    }\n\n    if(this.are.RootNode.hasField(ModuleObjectScript.AreaOnExit)){\n      this.scriptResRefs.set(ModuleObjectScript.AreaOnExit, this.are.getFieldByLabel(ModuleObjectScript.AreaOnExit).getValue());\n    }\n\n    if(this.are.RootNode.hasField(ModuleObjectScript.AreaOnHeartbeat)){\n      this.scriptResRefs.set(ModuleObjectScript.AreaOnHeartbeat, this.are.getFieldByLabel(ModuleObjectScript.AreaOnHeartbeat).getValue());\n    }\n\n    if(this.are.RootNode.hasField(ModuleObjectScript.AreaOnUserDefined)){\n      this.scriptResRefs.set(ModuleObjectScript.AreaOnUserDefined, this.are.getFieldByLabel(ModuleObjectScript.AreaOnUserDefined).getValue());\n    }\n\n    this.playerOnly = !!this.are.getFieldByLabel('PlayerOnly').getValue();\n    this.playerVsPlayer = this.are.getFieldByLabel('PlayerVsPlayer').getValue();\n\n    //Rooms\n    for(let i = 0; i < rooms.childStructs.length; i++ ){\n      const strt = rooms.childStructs[i];\n      const roomName = this.are.getFieldByLabel('RoomName', strt.getFields()).getValue().toLowerCase();\n      const envAudio = this.are.getFieldByLabel('EnvAudio', strt.getFields()).getValue();\n      const ambientScale = this.are.getFieldByLabel('AmbientScale', strt.getFields()).getValue();\n      const room = new ModuleRoom(roomName, this);\n      room.area = this;\n      room.setAmbientScale(ambientScale);\n      room.setEnvAudio(envAudio);\n      this.rooms.push(room);\n    }\n\n    this.shadowOpacity = this.are.getFieldByLabel('ShadowOpacity').getValue();\n\n    this.stealthXPEnabled = this.are.getFieldByLabel('StealthXPEnabled').getValue();\n    this.stealthXPLoss = this.are.getFieldByLabel('StealthXPLoss').getValue();\n    this.stealthXPMax = this.are.getFieldByLabel('StealthXPMax').getValue();\n\n    this.sun.ambientColor = this.are.getFieldByLabel('SunAmbientColor').getValue();\n    this.sun.diffuseColor = this.are.getFieldByLabel('SunDiffuseColor').getValue();\n    this.sun.fogColor = this.are.getFieldByLabel('SunFogColor').getValue();\n    this.sun.fogFar = this.are.getFieldByLabel('SunFogFar').getValue();\n    this.sun.fogNear = this.are.getFieldByLabel('SunFogNear').getValue();\n    this.sun.fogOn = this.are.getFieldByLabel('SunFogOn').getValue();\n    this.sun.shadows = this.are.getFieldByLabel('SunShadows').getValue();\n    this.tag = this.are.getFieldByLabel('Tag').getValue();\n    this.unescapable = this.are.getFieldByLabel('Unescapable').getValue() ? true : false;\n    this.version = this.are.getFieldByLabel('Version').getValue();\n    this.windPower = this.are.getFieldByLabel('WindPower').getValue();\n\n    this.fog = undefined;\n\n    if(this.sun.fogOn){\n      this.fog = new THREE.Fog(\n        this.sun.fogColor,\n        this.sun.fogNear,\n        this.sun.fogFar\n      );\n      GameState.scene.fog = this.fog;\n    }else{\n      GameState.scene.fog = undefined;\n    }\n\n    //BEGIN GIT LOAD\n\n    const areaMap = this.git.getFieldByLabel('AreaMap');\n    const areaProps = this.git.getFieldByLabel('AreaProperties');\n    const areaEffects = this.git.getFieldByLabel('AreaEffectList');\n    const cameras = this.git.getFieldByLabel('CameraList');\n    const creatures = this.git.getFieldByLabel('Creature List');\n    const doors = this.git.getFieldByLabel('Door List');\n    const encounters = this.git.getFieldByLabel('Encounter List');\n    const placeables = this.git.getFieldByLabel('Placeable List');\n    const sounds = this.git.getFieldByLabel('SoundList');\n    const stores = this.git.getFieldByLabel('StoreList');\n    const triggers = this.git.getFieldByLabel('TriggerList');\n    const waypoints = this.git.getFieldByLabel('WaypointList');\n\n    const areaPropsField = areaProps.getChildStructs()[0].getFields();\n    this.audio.ambient.day = this.git.getFieldByLabel('AmbientSndDay', areaPropsField).getValue();\n    this.audio.ambient.dayVolume = this.git.getFieldByLabel('AmbientSndDayVol', areaPropsField).getValue();\n    this.audio.ambient.night = this.git.getFieldByLabel('AmbientSndNight', areaPropsField).getValue();\n    this.audio.ambient.nightVolume = this.git.getFieldByLabel('AmbientSndNitVol', areaPropsField).getValue();\n    if(areaProps.getChildStructs()[0].hasField('EnvAudio')){\n      this.audio.environmentAudio = this.git.getFieldByLabel('EnvAudio', areaPropsField).getValue();\n    }else{\n      this.audio.environmentAudio = -1;\n    }\n\n    this.audio.music.battle = this.git.getFieldByLabel('MusicBattle', areaPropsField).getValue();\n    this.audio.music.day = this.git.getFieldByLabel('MusicDay', areaPropsField).getValue();\n    this.audio.music.delay = this.git.getFieldByLabel('MusicDelay', areaPropsField).getValue();\n    this.audio.music.night = this.git.getFieldByLabel('MusicNight', areaPropsField).getValue();\n    AudioEngine.GetAudioEngine().setAreaAudioProperties(this.audio);\n\n    //Cameras\n    if(cameras){\n      for(let i = 0; i < cameras.childStructs.length; i++){\n        const strt = cameras.childStructs[i];\n        const camera = new ModuleCamera(GFFObject.FromStruct(strt) );\n        this.cameras.push(camera);\n      }\n    }\n\n    //AreaEffects\n    if(areaEffects){\n      for(let i = 0; i < areaEffects.childStructs.length; i++){\n        const strt = areaEffects.childStructs[i];\n        this.attachObject( new ModuleAreaOfEffect(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Creatures\n    if(creatures){\n      for(let i = 0; i < creatures.childStructs.length; i++){\n        const strt = creatures.childStructs[i];\n        this.attachObject( new ModuleCreature(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Triggers\n    if(triggers){\n      for(let i = 0; i < triggers.childStructs.length; i++){\n        const strt = triggers.childStructs[i];\n        this.attachObject( new ModuleTrigger(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Encounter\n    if(encounters){\n      for(let i = 0; i < encounters.childStructs.length; i++){\n        const strt = encounters.childStructs[i];\n        this.attachObject( new ModuleEncounter(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Doors\n    if(doors){\n      for(let i = 0; i < doors.childStructs.length; i++ ){\n        const strt = doors.childStructs[i];\n        this.attachObject( new ModuleDoor(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Placeables\n    if(placeables){\n      for(let i = 0; i < placeables.childStructs.length; i++ ){\n        const strt = placeables.childStructs[i];\n        this.attachObject( new ModulePlaceable(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Sounds\n    if(sounds){\n      for(let i = 0; i < sounds.childStructs.length; i++ ){\n        const strt = sounds.childStructs[i];\n        this.attachObject( new ModuleSound(GFFObject.FromStruct(strt), AudioEngine.GetAudioEngine()) );\n      }\n    }\n\n    //Stores\n    if(stores){\n      for(let i = 0; i < stores.childStructs.length; i++ ){\n        const strt = stores.childStructs[i];\n        this.attachObject( new ModuleStore(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //Waypoints\n    if(waypoints){\n      for(let i = 0; i < waypoints.childStructs.length; i++ ){\n        const strt = waypoints.childStructs[i];\n\n        if(this.transWP){\n          if(typeof this.transWP === 'string'){\n            if(this.transWP.toLowerCase() == strt.getFieldByLabel('Tag').getValue().toLowerCase()){\n              this.transWP = GFFObject.FromStruct(strt);\n            }\n          }else if(this.transWP instanceof GFFObject){\n            if(this.transWP.getFieldByLabel('Tag').getValue().toLowerCase() == strt.getFieldByLabel('Tag').getValue().toLowerCase()){\n              this.transWP = GFFObject.FromStruct(strt);\n            }\n          }\n        }\n\n        this.attachObject( new ModuleWaypoint(GFFObject.FromStruct(strt)) );\n      }\n    }\n\n    //AreaMapData\n    if(areaMap){\n      const areaMapStruct = areaMap.getChildStructs()[0];\n      if(areaMapStruct){\n        this.areaMap.loadDataStruct(areaMapStruct);\n      }\n    }\n\n    if(!(this.transWP instanceof GFFObject)){\n      this.transWP = null;\n    }\n\n    if(this.git.RootNode.hasField('SWVarTable')){\n      log.trace('SWVarTable', this.git);\n      const localBools = this.git.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('BitArray').getChildStructs();\n      //log.info(localBools);\n      for(let i = 0; i < localBools.length; i++){\n        const data = localBools[i].getFieldByLabel('Variable').getValue();\n        for(let bit = 0; bit < 32; bit++){\n          this._locals.Booleans[bit + (i*32)] = ( (data>>bit) % 2 != 0);\n        }\n      }\n    }\n\n    GameState.AlphaTest = this.alphaTest;\n\n    AudioEngine.GetAudioEngine().setReverbProfile(this.audio.environmentAudio);\n\n    FollowerCamera.setCameraStyle(this.getCameraStyle());\n    if(this.miniGame){\n      FollowerCamera.setCameraFOV(this.miniGame.cameraViewAngle);\n    }else{\n      FollowerCamera.setCameraFOV(FollowerCamera.DEFAULT_FOV);\n    }\n\n    await this.loadVis();\n    await this.loadLayout();\n    await this.loadScripts();\n    GameState.scene.fog = this.fog;\n\n  }\n\n  getCameraStyle(){\n    const cameraStyle2DA = GameState.TwoDAManager.datatables.get('camerastyle');\n    if(cameraStyle2DA){\n      return cameraStyle2DA.rows[this.cameraStyle];\n    }\n    return cameraStyle2DA.rows[0];\n  }\n\n  async loadPath(){\n    log.debug('ModuleArea.loadPath');\n    this.path = new ModulePath(this);\n    try{\n      await this.path.load();\n    }catch(e){\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  async loadVis(){\n    log.info('ModuleArea.loadVis');\n    try{\n      const buffer = await ResourceLoader.loadResource(ResourceTypes.vis, this.name);\n      this.visObject = new VISObject(buffer);\n      this.visObject.read();\n      return;\n    }catch(e){\n      this.visObject = new VISObject();\n      log.error(e instanceof Error ? e : String(e));\n    }\n    this.visObject.attachArea(this);\n  }\n\n  async loadLayout(){\n    log.info('ModuleArea.loadLayout');\n    try{\n      const buffer = await ResourceLoader.loadResource(ResourceTypes.lyt, this.name);\n      this.layout = new LYTObject(buffer);\n\n      //Resort the rooms based on the LYT file because it matches the walkmesh transition index numbers\n      const sortedRooms = [];\n      for(let i = 0; i < this.layout.rooms.length; i++){\n        const roomLYT = this.layout.rooms[i];\n        for(let r = 0; r != this.rooms.length; r++ ){\n          const room = this.rooms[r];\n          if(room.roomName.toLowerCase() == roomLYT.name.toLowerCase()){\n            room.position.copy(roomLYT.position);\n            sortedRooms.push(room);\n          }\n        }\n      }\n\n      this.rooms = sortedRooms;\n\n      for(let i = 0; i < this.layout.doorhooks.length; i++){\n        const _doorHook = this.layout.doorhooks[i];\n        this.doorhooks.push(_doorHook);\n      }\n\n      if(this.miniGame){\n        for(let i = 0; i < this.layout.tracks.length; i++){\n          this.miniGame.tracks.push(new ModuleMGTrack(this.layout.tracks[i]));\n        }\n\n        for(let i = 0; i < this.layout.obstacles.length; i++){\n          this.miniGame.obstacles.push(new ModuleMGObstacle(undefined, this.layout.obstacles[i]));\n        }\n      }\n    } catch (e) {\n      log.error(e instanceof Error ? e : new Error(String(e)));\n      this.layout = new LYTObject();\n    }\n  }\n\n  cleanupUninitializedObjects(){\n\n    let i = this.creatures.length\n    while (i--) {\n      if (!(this.creatures[i] instanceof ModuleCreature) || !this.creatures[i].initialized) {\n        this.creatures.splice(i, 1);\n      }\n    }\n\n    i = this.placeables.length\n    while (i--) {\n      if (!(this.placeables[i] instanceof ModulePlaceable) || !this.placeables[i].initialized) {\n        this.placeables.splice(i, 1);\n      }\n    }\n\n    i = this.doors.length\n    while (i--) {\n      if (!(this.doors[i] instanceof ModuleDoor) || !this.doors[i].initialized) {\n        this.doors.splice(i, 1);\n      }\n    }\n\n    i = this.sounds.length\n    while (i--) {\n      if (!(this.sounds[i] instanceof ModuleSound) || !this.sounds[i].initialized) {\n        this.sounds.splice(i, 1);\n      }\n    }\n\n    i = this.waypoints.length\n    while (i--) {\n      if (!(this.waypoints[i] instanceof ModuleWaypoint) || !this.waypoints[i].initialized) {\n        this.waypoints.splice(i, 1);\n      }\n    }\n\n    i = this.triggers.length\n    while (i--) {\n      if (!(this.triggers[i] instanceof ModuleTrigger) || !this.triggers[i].initialized) {\n        this.triggers.splice(i, 1);\n      }\n    }\n\n    i = this.stores.length\n    while (i--) {\n      if (!(this.stores[i] instanceof ModuleStore) || !this.stores[i].initialized) {\n        this.stores.splice(i, 1);\n      }\n    }\n\n  }\n\n  async loadScene(){\n    try{\n      try{\n        GameState.MenuManager.InGameOverlay.miniMap.setAreaMap(this.areaMap);\n        GameState.MenuManager.InGameOverlay.SetMapTexture('lbl_map'+this.name);\n        GameState.MenuManager.MenuMap.miniMap.setAreaMap(this.areaMap);\n        GameState.MenuManager.MenuMap.SetMapTexture('lbl_map'+this.name);\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n\n      try { await this.loadRooms(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      await this.loadPath();\n\n      this.roomWalkmeshes = this.rooms.filter( (r) => { return r?.model?.wok}).map( (r) => { return r.model.wok; });\n\n      GameState.MenuManager.LoadScreen.setProgress(10);\n\n      try { await this.loadPlayer(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      try { await this.loadCameras(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      try { await this.loadPlaceables(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(20);\n\n      try { await this.loadWaypoints(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(30);\n\n      try { await this.loadAreaEffects(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n      try { await this.loadCreatures(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n      try { await this.loadParty(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(40);\n\n      try { await this.loadsounds(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(50);\n\n      try { await this.loadTriggers(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      try { await this.loadEncounters(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(60);\n\n      if(this.miniGame){\n        try { await this.miniGame.load(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n      }\n\n      GameState.MenuManager.LoadScreen.setProgress(70);\n\n      try { await this.loadDoors(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      this.doorWalkmeshes = this.doors.filter( (d) => { return d?.collisionManager?.walkmesh}).map( (d) => { return d.collisionManager.walkmesh; });\n\n      try { await this.loadStores(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      GameState.MenuManager.LoadScreen.setProgress(80);\n\n      GameState.MenuManager.LoadScreen.setProgress(90);\n\n      try{\n        await this.loadAreaMusic();\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n\n      GameState.MenuManager.LoadScreen.setProgress(100);\n\n      FollowerCamera.facing = Utility.NormalizeRadian(GameState.PartyManager.party[0].getFacing() - Math.PI/2);\n\n      try { await this.weather.load(); } catch(e){ log.error(e instanceof Error ? e : String(e)); }\n\n      this.transWP = null;\n\n      this.cleanupUninitializedObjects();\n      this.detectRoomObjects();\n\n      if(GameState.group.grass){\n        GameState.group.grass.visible = !!GameState.iniConfig.getProperty('Graphics Options.Grass');\n      }\n    }catch(e){\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  getSpawnLocation(): EngineLocation {\n    if(GameState.isLoadingSave){\n      return new EngineLocation(\n        GameState.PartyManager.PlayerTemplate.RootNode.getFieldByLabel('XPosition').getValue(),\n        GameState.PartyManager.PlayerTemplate.RootNode.getFieldByLabel('YPosition').getValue(),\n        GameState.PartyManager.PlayerTemplate.RootNode.getFieldByLabel('ZPosition').getValue(),\n        GameState.PartyManager.PlayerTemplate.RootNode.getFieldByLabel('XOrientation').getValue(),\n        GameState.PartyManager.PlayerTemplate.RootNode.getFieldByLabel('YOrientation').getValue(),\n        0\n      );\n    }else if(this.transWP instanceof GFFObject){\n      log.info('TransWP', this.transWP);\n      return new EngineLocation(\n        this.transWP.RootNode.getFieldByLabel('XPosition').getValue(),\n        this.transWP.RootNode.getFieldByLabel('YPosition').getValue(),\n        this.transWP.RootNode.getFieldByLabel('ZPosition').getValue(),\n        this.transWP.RootNode.getFieldByLabel('XOrientation').getValue(),\n        this.transWP.RootNode.getFieldByLabel('YOrientation').getValue(),\n        0\n      );\n    }else{\n      log.info('No TransWP');\n      return new EngineLocation(\n        this.module.entryX,\n        this.module.entryY,\n        this.module.entryZ,\n        this.module.entryDirectionX,\n        this.module.entryDirectionY,\n        0\n      );\n    }\n  }\n\n  getPlayerTemplate(): GFFObject {\n    if(GameState.PartyManager.PlayerTemplate){\n      GameState.PartyManager.PlayerTemplate.RootNode.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue( GameState.ModuleObjectManager.GetNextPlayerId() );\n      return GameState.PartyManager.PlayerTemplate;\n    }else{\n      return GameState.PartyManager.GeneratePlayerTemplate();\n    }\n  }\n\n  attachObject(object: ModuleObject){\n    if(!object) return;\n    object.area = this;\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n      if(this.creatures.indexOf(object as ModuleCreature) >= 0) return;\n      this.creatures.push(object as ModuleCreature);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModulePlaceable)){\n      if(this.placeables.indexOf(object as ModulePlaceable) >= 0) return;\n      this.placeables.push(object as ModulePlaceable);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleDoor)){\n      if(this.doors.indexOf(object as ModuleDoor) >= 0) return;\n      this.doors.push(object as ModuleDoor);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleTrigger)){\n      if(this.triggers.indexOf(object as ModuleTrigger) >= 0) return;\n      this.triggers.push(object as ModuleTrigger);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleEncounter)){\n      if(this.encounters.indexOf(object as ModuleEncounter) >= 0) return;\n      this.encounters.push(object as ModuleEncounter);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleStore)){\n      if(this.stores.indexOf(object as ModuleStore) >= 0) return;\n      this.stores.push(object as ModuleStore);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleWaypoint)){\n      if(this.waypoints.indexOf(object as ModuleWaypoint) >= 0) return;\n      this.waypoints.push(object as ModuleWaypoint);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleSound)){\n      if(this.sounds.indexOf(object as ModuleSound) >= 0) return;\n      this.sounds.push(object as ModuleSound);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleAreaOfEffect)){\n      if(this.areaOfEffects.indexOf(object as ModuleAreaOfEffect) >= 0) return;\n      this.areaOfEffects.push(object as ModuleAreaOfEffect);\n    }\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleRoom)){\n      if(this.rooms.indexOf(object as ModuleRoom) >= 0) return;\n      this.rooms.push(object as ModuleRoom);\n    }\n  }\n\n  detachObject(object: ModuleObject){\n    if(!object) return;\n\n    object.area = undefined;\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n      const idx = this.creatures.indexOf(object as ModuleCreature);\n      if(idx >= 0){\n        this.creatures.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModulePlaceable)){\n      const idx = this.placeables.indexOf(object as ModulePlaceable);\n      if(idx >= 0){\n        this.placeables.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleDoor)){\n      const idx = this.doors.indexOf(object as ModuleDoor);\n      if(idx >= 0){\n        this.doors.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleTrigger)){\n      const idx = this.triggers.indexOf(object as ModuleTrigger);\n      if(idx >= 0){\n        this.triggers.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleEncounter)){\n      const idx = this.encounters.indexOf(object as ModuleEncounter);\n      if(idx >= 0){\n        this.encounters.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleStore)){\n      const idx = this.stores.indexOf(object as ModuleStore);\n      if(idx >= 0){\n        this.stores.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleWaypoint)){\n      const idx = this.waypoints.indexOf(object as ModuleWaypoint);\n      if(idx >= 0){\n        this.waypoints.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleSound)){\n      const idx = this.sounds.indexOf(object as ModuleSound);\n      if(idx >= 0){\n        this.sounds.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleAreaOfEffect)){\n      const idx = this.areaOfEffects.indexOf(object as ModuleAreaOfEffect);\n      if(idx >= 0){\n        this.areaOfEffects.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleItem)){\n      const idx = this.items.indexOf(object as ModuleItem);\n      if(idx >= 0){\n        this.items.splice(idx, 1);\n      }\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleRoom)){\n      const idx = this.rooms.indexOf(object as ModuleRoom);\n      if(idx >= 0){\n        this.rooms.splice(idx, 1);\n      }\n    }else{\n      log.warn(`destroyObject: unhandled objectType, ${object.objectType}`);\n    }\n  }\n\n  async loadPlayer(): Promise<void> {\n    log.info('Loading Player', GameState.PartyManager.Player)\n    try{\n      if(GameState.PartyManager.Player instanceof ModuleCreature){\n        GameState.PartyManager.Player.npcId = -1;\n\n        if(!this.miniGame){\n          GameState.PartyManager.party[ GameState.PartyManager.GetCreatureStartingPartyIndex(GameState.currentLeader) ] = GameState.currentLeader;\n          GameState.group.party.add( GameState.PartyManager.Player.container );\n        }\n\n        //Reset the players actions between modules\n        GameState.PartyManager.Player.clearAllActions();\n        GameState.PartyManager.Player.force = 0;\n        GameState.PartyManager.Player.collisionManager.groundFace = undefined;\n        GameState.PartyManager.Player.collisionManager.lastGroundFace = undefined;\n        GameState.PartyManager.Player.load();\n        try{\n          const model = await GameState.PartyManager.Player.loadModel();\n          GameState.PartyManager.Player.model = model;\n          GameState.PartyManager.Player.model.hasCollision = true;\n          //let spawnLoc = this.getSpawnLocation();\n          const spawnLoc = GameState.PartyManager.GetSpawnLocation(GameState.PartyManager.Player);\n          GameState.PartyManager.Player.position.copy(spawnLoc.position);\n          GameState.PartyManager.Player.setFacing(-Math.atan2(spawnLoc.rotation.x, spawnLoc.rotation.y), true);\n\n          GameState.PartyManager.Player.getCurrentRoom();\n          // GameState.PartyManager.Player.computeBoundingBox(true);\n        }catch(e){\n          log.error(e instanceof Error ? e : String(e));\n        }\n      }else{\n        const player = new ModulePlayer( this.getPlayerTemplate() );\n        player.npcId = -1;\n\n        player.load();\n        // GameState.currentLeader = player;\n        GameState.PartyManager.Player = player;\n\n        if(!this.miniGame){\n          GameState.PartyManager.party[ GameState.PartyManager.GetCreatureStartingPartyIndex(player) ] = player;\n          GameState.group.party.add( player.container );\n        }\n\n        try{\n          const model = await player.loadModel();\n          model.userData.moduleObject = player;\n          model.hasCollision = true;\n\n          const spawnLoc = this.getSpawnLocation();\n\n          player.position.copy(spawnLoc.position);\n          player.setFacing(-Math.atan2(spawnLoc.rotation.x, spawnLoc.rotation.y), true);\n          //player.quaternion.setFromAxisAngle(new THREE.Vector3(0,0,1), -Math.atan2(spawnLoc.XOrientation, spawnLoc.YOrientation));\n\n          player.getCurrentRoom();\n          player.computeBoundingBox(true);\n        }catch(e){\n          log.error(e instanceof Error ? e : String(e));\n        }\n      }\n    }catch(e){\n      log.error(e instanceof Error ? e : String(e));\n    }\n  }\n\n  /**\n   * Load the active party members\n   */\n  async loadParty(): Promise<void> {\n    log.info('Loading Party Member');\n    for(let i = 0; i < GameState.PartyManager.CurrentMembers.length; i++){\n      await GameState.PartyManager.LoadPartyMember(i);\n    }\n  }\n\n  /**\n   * Load the area's static cameras\n   */\n  async loadCameras(){\n    log.info('Loading Cameras');\n    for(let i = 0; i < this.cameras.length; i++){\n      const camera = this.cameras[i];\n      camera.load();\n      GameState.staticCameras.push(camera.perspectiveCamera);\n    }\n  }\n\n  /**\n   * Load the area's rooms\n   */\n  async loadRooms(): Promise<void> {\n    log.info('Loading Rooms');\n    this.walkEdges = [];\n    this.walkFaces = [];\n\n    for(let i = 0; i < this.rooms.length; i++){\n      const room = this.rooms[i];\n      const model = await room.loadModel();\n      if(model instanceof OdysseyModel3D){\n        if(room.collisionManager.walkmesh instanceof OdysseyWalkMesh){\n          GameState.walkmeshList.push( room.collisionManager.walkmesh.mesh );\n          GameState.group.room_walkmeshes.add( room.collisionManager.walkmesh.mesh );\n        }\n\n        if(typeof model.walkmesh != 'undefined'){\n          GameState.collisionList.push(model.walkmesh);\n        }\n\n        if(typeof model.wok != 'undefined'){\n          this.walkEdges = [...this.walkEdges, ...model.wok.edges.values()];\n          this.walkFaces = [...this.walkFaces, ...model.wok.walkableFaces];\n        }\n\n        model.name = room.roomName;\n        GameState.group.rooms.add(room.container);\n\n        room.computeBoundingBox();\n        room.model.updateMatrix();\n      }\n    }\n\n    for(let j = 0; j < this.rooms.length; j++){\n      this.rooms[j].linkRooms();\n    }\n\n    //Room Linking Pass 2\n    for(let i = 0, iLen = this.rooms.length; i < iLen; i++ ){\n      const room1 = this.rooms[i];\n      //log.info(room1.linked_rooms);\n      //Look for all rooms that can see this room\n      for(let j = 0, jLen = this.rooms.length; j < jLen; j++){\n        const room2 = this.rooms[j];\n        //log.info(room2.linked_rooms);\n        if(room2 instanceof ModuleRoom){\n          const room1_room_links = this.visObject.getRoom(room1.roomName)?.rooms || [];\n          const room2_room_links = this.visObject.getRoom(room2.roomName)?.rooms || [];\n          const room2_links_to_room1 = room2_room_links.indexOf(room1.roomName) >= 0;\n          const room1_links_to_room2 = room1_room_links.indexOf(room2.roomName) >= 0;\n\n          const should_link = room2_links_to_room1 || room1_links_to_room2;\n          //log.info('room', room1.roomName, room2.roomName, should_link);\n          if(should_link && !room1.linkedRooms.has(room2.roomName)){\n            room1.linkedRooms.set(room2.roomName, room2);\n          }\n\n          if(should_link && !room2.linkedRooms.has(room1.roomName)){\n            room2.linkedRooms.set(room1.roomName, room1);\n          }\n        }\n      }\n      this.walkmesh_rooms = [room1].concat(Array.from(room1.linkedRooms.values()));\n    }\n  }\n\n  /**\n   * Load the area's doors\n   */\n  async loadDoors(): Promise<void> {\n    log.info('Loading Doors');\n    for(let i = 0; i < this.doors.length; i++){\n      const door = this.doors[i];\n      try{\n        door.load();\n        // door.position.x = door.getX();\n        // door.position.y = door.getY();\n        // door.position.z = door.getZ();\n        door.rotation.set(0, 0, door.getBearing());\n        const model = await door.loadModel();\n        door.computeBoundingBox();\n        const dwk = await door.loadWalkmesh(model.name);\n\n        try{\n          model.userData.walkmesh = dwk;\n          door.collisionManager.setWalkmesh(dwk);\n          GameState.walkmeshList.push( dwk.mesh );\n\n          if(dwk.mesh instanceof THREE.Object3D){\n            dwk.mat4.makeRotationFromEuler(door.rotation);\n            dwk.mat4.setPosition( door.position.x, door.position.y, door.position.z);\n            dwk.mesh.geometry.applyMatrix4(dwk.mat4);\n            dwk.updateMatrix();\n            //dwk.mesh.position.copy(door.position);\n            // if(!door.isOpen()){\n            //   GameState.group.room_walkmeshes.add( dwk.mesh );\n            // }\n          }\n        }catch(e){\n          log.error('Failed to add dwk', model.name, dwk, e);\n        }\n\n        if(door.model instanceof OdysseyModel3D){\n          door.box.setFromObject(door.model);\n        }\n\n        if(door.openState){\n          door.model.playAnimation('opened1', true);\n        }\n        door.getCurrentRoom();\n        GameState.group.doors.add( door.container );\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's placeables\n   */\n  async loadPlaceables(): Promise<void> {\n    log.info('Loading Placeables');\n    for(let i = 0; i < this.placeables.length; i++){\n      const plc = this.placeables[i];\n      plc.load();\n      plc.position.set(plc.getX(), plc.getY(), plc.getZ());\n      plc.rotation.set(0, 0, plc.getBearing());\n      const model = await plc.loadModel();\n      GameState.group.placeables.add( plc.container );\n      const pwk = await plc.loadWalkmesh(model.name);\n      GameState.walkmeshList.push( pwk.mesh );\n      plc.computeBoundingBox();\n\n      if(pwk.mesh instanceof THREE.Object3D){\n        pwk.mat4.makeRotationFromEuler(plc.rotation);\n        pwk.mat4.setPosition( plc.position.x, plc.position.y, plc.position.z + .01 );\n        pwk.mesh.geometry.applyMatrix4(pwk.mat4);\n        pwk.updateMatrix();\n        pwk.buildEdgeNormalHelpers();\n        //pwk.mesh.position.copy(plc.position);\n        GameState.group.room_walkmeshes.add( pwk.mesh );\n      }\n\n      plc.getCurrentRoom();\n      plc.position.set(plc.getX(), plc.getY(), plc.getZ());\n      plc.computeBoundingBox();\n    }\n  }\n\n  /**\n   * Load the area's waypoints\n   */\n  async loadWaypoints(): Promise<void> {\n    log.info('Loading Waypoints');\n    for(let i = 0; i < this.waypoints.length; i++){\n      const waypnt = this.waypoints[i];\n      waypnt.load();\n      const wpObj = new THREE.Object3D();\n      wpObj.name = waypnt.getTag();\n      wpObj.position.copy(waypnt.position);\n      wpObj.quaternion.setFromAxisAngle(new THREE.Vector3(0,0,1), Math.atan2(-waypnt.getYOrientation(), -waypnt.getXOrientation()));\n      waypnt.rotation.z = Math.atan2(-waypnt.getYOrientation(), -waypnt.getXOrientation()) + Math.PI/2;\n      GameState.group.waypoints.add(wpObj);\n\n      let _distance = 1000000000;\n      let _currentRoom = null;\n      const roomCenter = new THREE.Vector3();\n      for(let i = 0; i < GameState.group.rooms.children.length; i++){\n        const room = GameState.group.rooms.children[i];\n        if(room instanceof OdysseyModel3D){\n          if(room.box.containsPoint(wpObj.position)){\n            room.box.getCenter(roomCenter);\n            const distance = wpObj.position.distanceTo(roomCenter);\n            if(distance < _distance){\n              _distance = distance;\n              _currentRoom = room;\n            }\n          }\n        }\n      }\n      wpObj.userData.area = _currentRoom;\n      this.areaMap.addMapNote(waypnt);\n    }\n  }\n\n  /**\n   * Load the area's encounters\n   */\n  async loadEncounters(): Promise<void> {\n    log.info('Loading Encounters');\n    for(let i = 0; i < this.encounters.length; i++){\n      const encounter = this.encounters[i];\n      try{\n        encounter.load();\n        let _distance = 1000000000;\n        let _currentRoom = null;\n        const roomCenter = new THREE.Vector3();\n        for(let i = 0; i < GameState.group.rooms.children.length; i++){\n          const room = GameState.group.rooms.children[i];\n          if(room instanceof OdysseyModel3D){\n            if(room.box.containsPoint(encounter.mesh.position)){\n              room.box.getCenter(roomCenter);\n              const distance = encounter.mesh.position.distanceTo(roomCenter);\n              if(distance < _distance){\n                _distance = distance;\n                _currentRoom = room;\n              }\n            }\n          }\n        }\n        encounter.mesh.userData.area = _currentRoom;\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's Area of Effects\n   */\n  async loadAreaEffects(): Promise<void> {\n    log.info('Loading AreaEffects');\n    for(let i = 0; i < this.areaOfEffects.length; i++){\n      try{\n        const aoe = this.areaOfEffects[i];\n        aoe.load();\n        GameState.group.effects.add( aoe.container );\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's triggers\n   */\n  async loadTriggers(): Promise<void> {\n    log.info('Loading Triggers');\n    for(let i = 0; i < this.triggers.length; i++){\n      try{\n        const trig = this.triggers[i];\n        trig.load();\n        let _distance = 1000000000;\n        let _currentRoom = null;\n        const roomCenter = new THREE.Vector3();\n        for(let i = 0; i < GameState.group.rooms.children.length; i++){\n          const room = GameState.group.rooms.children[i];\n          if(room instanceof OdysseyModel3D){\n            if(room.box.containsPoint(trig.mesh.position)){\n              room.box.getCenter(roomCenter);\n              const distance = trig.mesh.position.distanceTo(roomCenter);\n              if(distance < _distance){\n                _distance = distance;\n                _currentRoom = room;\n              }\n            }\n          }\n        }\n        trig.mesh.userData.area = _currentRoom;\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's creatures\n   */\n  async loadCreatures(): Promise<void> {\n    log.info('Loading Creatures');\n    for(let i = 0; i < this.creatures.length; i++){\n      try{\n        const creature = this.creatures[i];\n        creature.load();\n        const model = await creature.loadModel();\n        creature.model.userData.moduleObject = creature;\n\n        //creature.setFacing(Math.atan2(creature.getXOrientation(), creature.getYOrientation()) + Math.PI/2, true);\n        creature.setFacing(-Math.atan2(creature.getXOrientation(), creature.getYOrientation()), true);\n\n        model.hasCollision = true;\n        model.name = creature.getTag();\n        GameState.group.creatures.add( creature.container );\n\n        creature.getCurrentRoom();\n        creature.updateCollision(0.0000000000000000000001);\n        creature.update(0.0000000000000000000001);\n        creature.computeBoundingBox();\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's stores\n   */\n  async loadStores(): Promise<void> {\n    log.info('Loading Stores');\n    for(let i = 0; i < this.stores.length; i++){\n      try{\n        const store = this.stores[i];\n        store.load();\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's sounds\n   */\n  async loadsounds(): Promise<void> {\n    log.info('Loading Sound Emitter');\n    for(let i = 0; i < this.sounds.length; i++){\n      try{\n        const sound = this.sounds[i];\n        sound.load();\n        await sound.loadSound();\n      }catch(e){\n        log.error(e instanceof Error ? e : String(e));\n      }\n    }\n  }\n\n  /**\n   * Load the area's background music\n   */\n  async loadAreaMusic(): Promise<void> {\n    const audioEngine = AudioEngine.GetAudioEngine();\n    await this.musicBackgroundDaySet(this.audio.music.day);\n    await this.musicBackgroundNightSet(this.audio.music.night);\n    await this.musicBattleSet(this.audio.music.battle);\n    await this.ambientSoundDaySet(this.audio.ambient.day);\n    await this.ambientSoundNightSet(this.audio.ambient.night);\n  }\n\n  /**\n   * Load the area's scripts\n   */\n  async loadScripts(){\n    log.debug('ModuleArea.loadScripts');\n    for (const [key, resRef] of this.scriptResRefs) {\n      const script = GameState.NWScript.Load(resRef);\n      if(!script){ continue; }\n      script.caller = this;\n      this.scripts[key] = script;\n    }\n  }\n\n  async initAreaObjects(runSpawnScripts = false){\n    for(let i = 0; i < this.doors.length; i++){\n      if(this.doors[i] instanceof ModuleObject){\n        this.doors[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    for(let i = 0; i < this.placeables.length; i++){\n      if(this.placeables[i] instanceof ModuleObject){\n        this.placeables[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    for(let i = 0; i < this.triggers.length; i++){\n      if(this.triggers[i] instanceof ModuleObject){\n        this.triggers[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    for(let i = 0; i < this.waypoints.length; i++){\n      if(this.waypoints[i] instanceof ModuleObject){\n        this.waypoints[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    for(let i = 0; i < this.creatures.length; i++){\n      if(this.creatures[i] instanceof ModuleObject){\n        this.creatures[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    for(let i = 0; i < GameState.PartyManager.party.length; i++){\n      if(GameState.PartyManager.party[i] instanceof ModuleObject){\n        GameState.PartyManager.party[i].onSpawn(runSpawnScripts);\n      }\n    }\n\n    if(this.miniGame){\n      this.miniGame.initMiniGameObjects();\n    }\n\n    this.runStartScripts();\n  }\n\n  runOnEnterScripts(){\n    const nwscript = this.scripts[ModuleObjectScript.AreaOnEnter];\n    if(!nwscript){ return; }\n    nwscript.enteringObject = GameState.PartyManager.party[0];\n    nwscript.run(this, 0);\n  }\n\n  async runStartScripts(){\n    if(this.miniGame) this.miniGame.runMiniGameScripts();\n    this.runOnEnterScripts();\n  }\n\n  detectRoomObjects(){\n    for(let i = 0, len = this.rooms.length; i < len; i++){\n      this.rooms[i].detectChildObjects();\n    }\n  }\n\n  /**\n   * Determines the distance score from the edge of all walkable faces\n   * A low score means that the point is near a walkmesh perimiter\n   * A high scror means that the point is further away from all walkmesh pemimiters\n   * @param point point to examine\n   * @returns\n   */\n  scorePointEdgeDistance(point: THREE.Vector3){\n    let distance = Infinity;\n    const tmpTarget = new THREE.Vector3();\n    for(let i = 0, len = this.walkEdges.length; i < len; i++){\n      const edge = this.walkEdges[i];\n      edge.line.closestPointToPoint(point, true, tmpTarget);\n      const d = tmpTarget.distanceTo(point);\n      distance = (d < distance) ? d : distance;\n    }\n    return distance;\n  }\n\n  isPointWalkable(point: THREE.Vector3){\n    for(let i = 0, len = this.walkFaces.length; i < len; i++){\n      if(this.walkFaces[i].pointInFace2d(point)){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getNearestWalkablePoint(point: THREE.Vector3, safeDistance = 1.5){\n    let nearest = Infinity;\n    const nearest_point = point.clone();\n    let distance = 0;\n    const tmpPoint = new THREE.Vector3();\n\n    const tmp1 = new THREE.Vector3();\n    const tmp2 = new THREE.Vector3();\n    const tmpN = new THREE.Vector3();\n    const inwardDirection = new THREE.Vector3();\n    // const dir = new THREE.Vector3();\n    // const isOOB = this.isPointWalkable(point);\n    for(let i = 0, len = this.walkFaces.length; i < len; i++){\n      const f = this.walkFaces[i];\n      f.triangle.closestPointToPoint(point, tmpPoint);\n\n      // Calculate the normal of the triangle\n      const edge1 = tmp1.subVectors(f.triangle.b, f.triangle.a);\n      const edge2 = tmp2.subVectors(f.triangle.c, f.triangle.a);\n      const normal = tmpN.crossVectors(edge1, edge2).normalize();\n\n      // Determine the inward direction\n      inwardDirection.set(0, 0, 0);\n      if (f.adjacent[0] == -1 && f.pointIsOnEdge(tmpPoint, 'a')) {\n        inwardDirection.add(new THREE.Vector3().crossVectors(normal, edge1).normalize());\n        tmpPoint.add(inwardDirection.multiplyScalar(safeDistance));\n      } else if (f.adjacent[1] == -1 && f.pointIsOnEdge(tmpPoint, 'b')) {\n        inwardDirection.add(new THREE.Vector3().crossVectors(normal, new THREE.Vector3().subVectors(f.triangle.c, f.triangle.b)).normalize());\n        tmpPoint.add(inwardDirection.multiplyScalar(safeDistance));\n      } else if (f.adjacent[2] == -1 && f.pointIsOnEdge(tmpPoint, 'c')) {\n        inwardDirection.add(new THREE.Vector3().crossVectors(normal, new THREE.Vector3().subVectors(f.triangle.a, f.triangle.c)).normalize());\n        tmpPoint.add(inwardDirection.multiplyScalar(safeDistance));\n      }\n\n      distance = point.distanceTo(tmpPoint);\n      if(distance >= nearest)\n        continue;\n\n      nearest_point.copy(tmpPoint);//this.walkableFaces[i].centroid;\n      nearest = distance;\n    }\n\n    // const repellingForce = new THREE.Vector3();\n    // const safeDistance = 1;\n\n    // const closestPoint = new THREE.Vector3();\n    // this.walkEdges.forEach(edge => {\n    //   const line = edge.line;\n    //   line.closestPointToPoint(nearest_point, true, closestPoint);\n\n    //   const distance = nearest_point.distanceTo(closestPoint);\n\n    //   if (distance < safeDistance) {\n    //     // Calculate the repelling vector\n    //     const repelDirection = new THREE.Vector3().subVectors(nearest_point, closestPoint).normalize();\n    //     const repelStrength = safeDistance - distance;\n\n    //     // Accumulate the repelling force\n    //     repellingForce.add(repelDirection.multiplyScalar(repelStrength));\n    //   }\n    // });\n\n    // // Update the position by applying the accumulated repelling force\n    // return nearest_point.add(repellingForce);\n\n    return nearest_point;\n  }\n\n  setRestrictMode( restrictMode = 0 ){\n    this.restrictMode = restrictMode;\n  }\n\n  setStealthXPEnabled( stealthXPEnabled: boolean ){\n    this.stealthXPEnabled = stealthXPEnabled ? 1 : 0;\n  }\n\n  addStealthXP(){\n    this.stealthXP += Math.floor(this.stealthXPLoss/2);\n    if(this.stealthXP > this.stealthXPMax){\n      this.stealthXP = this.stealthXPMax;\n    }\n  }\n\n  subtractStealthXP(){\n    this.stealthXP -= this.stealthXPLoss;\n    if(this.stealthXP < 0){\n      this.stealthXP = 0;\n    }\n  }\n\n  getAreaPropertiesStruct(){\n    const struct = new GFFStruct();\n    struct.addField( new GFFField(GFFDataType.INT, 'AmbientSndDay') ).setValue(this.audio.ambient.day);\n    struct.addField( new GFFField(GFFDataType.INT, 'AmbientSndDayVol') ).setValue(this.audio.ambient.dayVolume);\n    struct.addField( new GFFField(GFFDataType.INT, 'AmbientSndNight') ).setValue(this.audio.ambient.night);\n    struct.addField( new GFFField(GFFDataType.INT, 'AmbientSndNitVol') ).setValue(this.audio.ambient.nightVolume);\n    struct.addField( new GFFField(GFFDataType.INT, 'EnvAudio') ).setValue(this.audio.environmentAudio);\n\n    struct.addField( new GFFField(GFFDataType.INT, 'MusicBattle') ).setValue(this.audio.music.battle);\n    struct.addField( new GFFField(GFFDataType.INT, 'MusicDay') ).setValue(this.audio.music.day);\n    struct.addField( new GFFField(GFFDataType.INT, 'MusicDelay') ).setValue(this.audio.music.delay);\n    struct.addField( new GFFField(GFFDataType.INT, 'MusicNight') ).setValue(this.audio.music.night);\n\n    struct.addField( new GFFField(GFFDataType.BYTE, 'RestrictMode') ).setValue(this.restrictMode ? 1 : 0);\n    struct.addField( new GFFField(GFFDataType.DWORD, 'StealthXPCurrent') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.BYTE, 'StealthXPLoss') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.DWORD, 'StealthXPMax') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.DWORD, 'SunFogColor') ).setValue(0);\n\n    struct.addField( new GFFField(GFFDataType.BYTE, 'TransPendCurrID') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.BYTE, 'TransPendNextID') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.BYTE, 'TransPending') ).setValue(0);\n    struct.addField( new GFFField(GFFDataType.BYTE, 'Unescapable') ).setValue(this.unescapable);\n    return struct;\n  }\n\n  saveAreaListStruct(){\n    const areaStruct = new GFFStruct();\n    areaStruct.addField( new GFFField(GFFDataType.RESREF, 'Area_Name') ).setValue(this.name);\n    areaStruct.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue(this.id);\n    //unescapable\n    return areaStruct;\n  }\n\n  save(): { git: GFFObject, are: GFFObject }{\n    const git = new GFFObject();\n    git.FileType = 'GIT ';\n\n    const aoeList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'AreaEffectList') );\n    for(let i = 0; i < this.areaOfEffects.length; i++){\n      aoeList.addChildStruct( this.areaOfEffects[i].save().RootNode );\n    }\n\n    const areaMapField = git.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'AreaMap') );\n    areaMapField.addChildStruct( this.areaMap.exportData() );\n\n    const areaPropertiesField = git.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'AreaProperties') );\n    areaPropertiesField.addChildStruct( this.getAreaPropertiesStruct() );\n\n    const cameraList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'CameraList') );\n    for(let i = 0; i < this.cameras.length; i++){\n      cameraList.addChildStruct( this.cameras[i].save().RootNode );\n    }\n\n    const creatureList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'Creature List') );\n    for(let i = 0; i < this.creatures.length; i++){\n      creatureList.addChildStruct( this.creatures[i].save().RootNode );\n    }\n\n    git.RootNode.addField( new GFFField(GFFDataType.LIST, 'CurrentWeather') ).setValue(this.weather.currentWeather);\n\n    const doorList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'Door List') );\n    for(let i = 0; i < this.doors.length; i++){\n      doorList.addChildStruct( this.doors[i].save().RootNode );\n    }\n\n    const encounterList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'Encounter List') );\n    for(let i = 0; i < this.encounters.length; i++){\n      encounterList.addChildStruct( this.encounters[i].save().RootNode );\n    }\n\n    //Area Items List\n    const list = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'List') );\n\n    const placeableList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'Placeable List') );\n    for(let i = 0; i < this.placeables.length; i++){\n      placeableList.addChildStruct( this.placeables[i].save().RootNode );\n    }\n\n    //SWVarTable\n    const swVarTable = git.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'SWVarTable') );\n    swVarTable.addChildStruct( this.getSWVarTableSaveStruct() );\n\n    const soundList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'SoundList') );\n    for(let i = 0; i < this.sounds.length; i++){\n      soundList.addChildStruct( this.sounds[i].save().RootNode );\n    }\n\n    const storeList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'StoreList') );\n    for(let i = 0; i < this.stores.length; i++){\n      storeList.addChildStruct( this.stores[i].save().RootNode );\n    }\n\n    git.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TransPendCurrID') ).setValue(0);\n    git.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TransPendNextID') ).setValue(0);\n    git.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TransPending') ).setValue(0);\n\n    const triggerList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'TriggerList') );\n    for(let i = 0; i < this.triggers.length; i++){\n      triggerList.addChildStruct( this.triggers[i].save().RootNode );\n    }\n\n    git.RootNode.addField( new GFFField(GFFDataType.LIST, 'VarTable') );\n\n    const waypointList = git.RootNode.addField( new GFFField(GFFDataType.LIST, 'WaypointList') );\n    for(let i = 0; i < this.waypoints.length; i++){\n      waypointList.addChildStruct( this.waypoints[i].save().RootNode );\n    }\n\n    git.RootNode.addField( new GFFField(GFFDataType.BYTE, 'WeatherStarted') ).setValue(this.weather.started ? 1 : 0);\n\n    this.git = git;\n\n    this.are.FileType = 'ARE ';\n\n    return {git: git, are: this.are};\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleCreature.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fog on a type that cannot be resolved.","line":635,"column":86,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":635,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fog on a type that cannot be resolved.","line":636,"column":61,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":636,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fog on a type that cannot be resolved.","line":639,"column":43,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":639,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fog on a type that cannot be resolved.","line":639,"column":99,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":639,"endColumn":102},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3022,"column":45,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3022,"endColumn":72}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as THREE from \"three\";\n\n\nimport type { Action } from \"@/actions/Action\";\nimport { AudioEmitter } from \"@/audio/AudioEmitter\";\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { CombatRoundAction } from \"@/combat\";\nimport { CreatureClass } from \"@/combat/CreatureClass\";\nimport { EffectRacialType } from \"@/effects\";\nimport { GameEffectFactory } from \"@/effects/GameEffectFactory\";\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { SWCreatureAppearance } from \"@/engine/rules/SWCreatureAppearance\";\nimport { TextSprite3D } from \"@/engine/TextSprite3D\";\nimport { ActionParameterType } from \"@/enums/actions/ActionParameterType\";\nimport { ActionType } from \"@/enums/actions/ActionType\";\nimport { AudioEmitterType } from \"@/enums/audio/AudioEmitterType\";\nimport { AttackResult } from \"@/enums/combat/AttackResult\";\nimport { CombatActionType } from \"@/enums/combat/CombatActionType\";\nimport { WeaponWield } from \"@/enums/combat/WeaponWield\";\nimport { GameEffectDurationType } from \"@/enums/effects/GameEffectDurationType\";\nimport { GameEffectType } from \"@/enums/effects/GameEffectType\";\nimport { AutoPauseState } from \"@/enums/engine/AutoPauseState\";\nimport { EngineDebugType } from \"@/enums/engine/EngineDebugType\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { ExperienceType } from \"@/enums/engine/ExperienceType\";\nimport { PerceptionType } from \"@/enums/engine/PerceptionType\";\nimport { UIIconTimerType } from \"@/enums/engine/UIIconTimerType\";\nimport { ModuleCreatureAnimState } from \"@/enums/module/ModuleCreatureAnimState\";\nimport { ModuleCreatureArmorSlot } from \"@/enums/module/ModuleCreatureArmorSlot\";\nimport { ModuleObjectConstant } from \"@/enums/module/ModuleObjectConstant\";\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { ModuleTriggerType } from \"@/enums/module/ModuleTriggerType\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport { SSFType } from \"@/enums/resource/SSFType\";\nimport { GameState } from \"@/GameState\";\nimport { ICreatureAnimationState } from \"@/interface/animation/ICreatureAnimationState\";\nimport { IOverlayAnimationState } from \"@/interface/animation/IOverlayAnimationState\";\nimport { ITwoDAAnimation } from \"@/interface/twoDA/ITwoDAAnimation\";\nimport { MDLLoader, ResourceLoader } from \"@/loaders\";\nimport { OdysseyModelAnimation } from \"@/odyssey\";\nimport { DLGObject } from \"@/resource/DLGObject\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { LIPObject } from \"@/resource/LIPObject\";\nimport { createScopedLogger , LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Game);\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { SSFObject } from \"@/resource/SSFObject\";\nimport { TalentFeat } from \"@/talents/TalentFeat\";\nimport { TalentObject } from \"@/talents/TalentObject\";\nimport { TalentSkill } from \"@/talents/TalentSkill\";\nimport { TalentSpell } from \"@/talents/TalentSpell\";\nimport { OdysseyModel3D, OdysseyObject3D } from \"@/three/odyssey\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { Utility } from \"@/utility/Utility\";\n// import { ICombatAction } from \"@/interface/combat/ICombatAction\";\n\nimport type { ModuleItem } from \"@/module/ModuleItem\";\nimport { ModuleObject } from \"@/module/ModuleObject\";\nimport type { ModuleRoom } from \"@/module/ModuleRoom\";\n\n/** Equipment slot map; index signature allows iteration by slot key. */\nexport interface ModuleCreatureEquipment {\n  [slot: string]: ModuleItem | undefined;\n  HEAD: ModuleItem;\n  ARMOR: ModuleItem;\n  ARMS: ModuleItem;\n  RIGHTHAND: ModuleItem;\n  RIGHTHAND2: ModuleItem;\n  LEFTHAND: ModuleItem;\n  LEFTHAND2: ModuleItem;\n  LEFTARMBAND: ModuleItem;\n  RIGHTARMBAND: ModuleItem;\n  IMPLANT: ModuleItem;\n  BELT: ModuleItem;\n  CLAW1: ModuleItem;\n  CLAW2: ModuleItem;\n  CLAW3: ModuleItem;\n  HIDE: ModuleItem;\n}\n\n/**\n* ModuleCreature class.\n*\n* Class representing a creature found in module areas.\n*\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n*\n* @file ModuleCreature.ts\n* @author KobaltBlu <https://github.com/KobaltBlu>\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n* @memberof KotOR\n*/\nexport class ModuleCreature extends ModuleObject {\n  debugLabel: TextSprite3D;\n  pm_IsDisguised: boolean; //polymorphIsDisguised\n  pm_Appearance: number; //polymorphAppearance\n  anim: OdysseyModelAnimation | null;\n  head: OdysseyModel3D;\n  aiStyle: number;\n  isCommandable: boolean;\n  bodyBag: number;\n  bodyVariation: number;\n\n  cha: number;\n  con: number;\n  dex: number;\n  int: number;\n  str: number;\n  wis: number;\n  fortbonus: number;\n  refbonus: number;\n  willbonus: number;\n\n  challengeRating: number;\n  classes: CreatureClass[];\n  comment: string;\n  currentForce: number;\n  currentHitPoints: number;\n  deity: string;\n  disarmable: number;\n  /** Set while examine-mine delay (4s) is queued; cleared when examine check completes. */\n  examineMineInProgress: boolean = false;\n  /** Set while recover-mine delay (~4.5s) is queued; cleared when recover check completes. */\n  recoverMineInProgress: boolean = false;\n  isHologram: boolean;\n  experience: number;\n  feats: TalentFeat[];\n  firstName: string;\n  forcePoints: number;\n  gender: number = 0;\n  goodEvil: number = 50;\n  hitPoints: number;\n  interruptable: number;\n  isPC: number;\n  lastName: string;\n  maxHitPoints: number;\n  naturalAC: number;\n  noPermDeath: number;\n  notReorienting: number;\n  palletID: number;\n  partyInteract: number;\n  phenotype: number;\n  race: number;\n  skills: TalentSkill[];\n  soundSetFile: number;\n  specialAbilities: number[];\n  subrace: number;\n  subraceIndex: number;\n  templateList: string[];\n  textureVar: number;\n  walkRate: number;\n  blockingTimer: number;\n  groundTilt: THREE.Vector3;\n  up: THREE.Vector3;\n  declare lipObject: LIPObject;\n  walk: boolean;\n  targetPositions: { angle: number; object?: unknown; cos: number; sin: number; owner: ModuleCreature; targetVector: THREE.Vector3 }[];\n  declare audioEmitter: AudioEmitter;\n  declare footstepEmitter: AudioEmitter;\n  props: Record<string, unknown>;\n  maxForcePoints: number;\n  bodyModel: string;\n  bodyTexture: number;\n  headModel: string | undefined;\n  ssf: SSFObject;\n  joiningXP: number;\n  skillPoints: number;\n  npcId: number;\n  // appearance: number; // appearance id from 2DA\n\n  animationState: ICreatureAnimationState;\n  overlayAnimationState: IOverlayAnimationState;\n\n  equipment: ModuleCreatureEquipment;\n  regenTimer: number;\n  regenTimerMax: number;\n  excitedDuration: number;\n  turning: number;\n  deathAnimationPlayed: boolean;\n  deathStarted: boolean;\n  getUpAnimationPlayed: boolean;\n  animSpeed: number;\n  selectedNPC: number;\n  creatureAppearance: SWCreatureAppearance;\n\n  constructor(gff = new GFFObject()) {\n    super(gff);\n    this.objectType |= ModuleObjectType.ModuleCreature;\n    this.deferEventUpdate = true;\n\n    this.template = gff;\n\n    this.isReady = false;\n    this.anim = null;\n    this.head = null;\n    this.deathAnimationPlayed = false;\n    this.aiStyle = 0;\n\n    this.isCommandable = true;\n\n    this.lastTriggerEntered = null;\n    this.lastTriggerExited = null;\n    this.lastAreaEntered = null;\n    this.lastAreaExited = null;\n    this.lastModuleEntered = null;\n    this.lastModuleExited = null;\n    this.lastDoorEntered = null;\n    this.lastDoorExited = null;\n    this.lastPlaceableEntered = null;\n    this.lastPlaceableExited = null;\n    this.lastAoeEntered = null;\n    this.lastAoeExited = null;\n\n    //Last target this creature attempted to attack\n    this.combatData.lastAttemptedAttackTarget = undefined;\n    //Last target attacked by this creature\n    this.combatData.lastAttackTarget = undefined;\n    //Last target attacked with a spell by this creature\n    this.combatData.lastSpellTarget = undefined;\n    //Last attempted target attacked with a spell by this creature\n    this.combatData.lastAttemptedSpellTarget = undefined;\n    //Last creature who damaged this creature\n    this.combatData.lastDamager = undefined;\n    //Last creature who attacked this creature\n    this.combatData.lastAttacker = undefined;\n    //Last creature who attacked this creature with a spell\n    this.combatData.lastSpellAttacker = undefined;\n    //Last Combat Feat Used\n    this.combatData.lastCombatFeatUsed = undefined;\n    //Last Force Power Used\n    this.combatData.lastForcePowerUsed = undefined;\n    //Last Attack Result\n    this.combatData.lastAttackResult = undefined;\n\n    this.excitedDuration = 0;\n\n    this.cha = 0;\n    this.con = 0;\n    this.dex = 0;\n    this.int = 0;\n    this.str = 0;\n    this.wis = 0;\n    this.fortbonus = 0;\n    this.refbonus = 0;\n    this.willbonus = 0;\n\n    this.appearance = 0;\n    this.pm_Appearance = 0;\n    this.pm_IsDisguised = false;\n    this.bodyBag = 0;\n    this.bodyVariation = 0;\n    this.challengeRating = 0;\n    this.classes = [];\n    this.comment = '';\n    this.currentForce = 0;\n    this.currentHitPoints = 0; //The Creature's current hit points, not counting any bonuses. This value may be higher or lower than the creature's maximum hit points.\n    this.regenTimer = 0;\n    this.regenTimerMax = 6;\n    this.deity = '';\n    this.description = '';\n    this.disarmable = 0;\n    this.isHologram = false;\n    this.resetAnimationState();\n    this.resetOverlayAnimationState();\n\n    this.equipment = {\n      HEAD: undefined,\n      ARMOR: undefined,\n      ARMS: undefined,\n      RIGHTHAND: undefined,\n      RIGHTHAND2: undefined,\n      LEFTHAND: undefined,\n      LEFTHAND2: undefined,\n      LEFTARMBAND: undefined,\n      RIGHTARMBAND: undefined,\n      IMPLANT: undefined,\n      BELT: undefined,\n\n      CLAW1: undefined,\n      CLAW2: undefined,\n      CLAW3: undefined,\n      HIDE: undefined,\n    };\n\n    this.experience = 0;\n    this.feats = [];\n    this.firstName = '';\n    this.forcePoints = 0;\n    this.gender = 0;\n    this.goodEvil = 50;\n    this.hitPoints = 0; //Base Maximum Hit Points, not considering any bonuses. See Section 3.4 for more details.\n    this.interruptable = 1;\n    this.isPC = 0;\n    this.lastName = '';\n    this.maxHitPoints = 0; //Maximum Hit Points, after considering all bonuses and penalties.\n    this.min1HP = false;\n    this.naturalAC = 0;\n    this.noPermDeath = 0;\n    this.notReorienting = 0;\n    this.palletID = 0; //for use in biowares editor\n    this.partyInteract = 0;\n    this.perceptionRange = GameState.SWRuleSet.ranges[11];\n    this.phenotype = 0;\n    this.plot = false;\n    this.portraitId = 0;\n    this.race = 0;\n\n    this.scripts[ModuleObjectScript.CreatureOnAttacked] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnDamaged] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnDeath] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnDialog] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnDisturbed] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnEndDialog] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnEndRound] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnHeartbeat] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnBlocked] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnNotice] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnRested] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnSpawn] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnSpellAt] = undefined;\n    this.scripts[ModuleObjectScript.CreatureOnUserDefined] = undefined;\n\n    this.skills = [];\n\n    this.soundSetFile = 0;\n    this.specialAbilities = [];\n    this.subrace = 0;\n    this.subraceIndex = 0;\n    this.tag = '';\n    this.templateList = [];\n    this.templateResRef = '';\n    this.textureVar = 1;\n    this.walkRate = 7;\n\n    this.xOrientation = 0;\n    this.yOrientation = 0;\n    this.zOrientation = 0;\n\n    this.perceptionList = [];\n\n    this.setAnimationState(ModuleCreatureAnimState.IDLE);\n    this.combatData.combatActionTimer = 3;\n    this.combatData.combatState = false;\n    this.combatData.lastAttackAction = ActionType.ActionInvalid;\n    this.collisionManager.blockingTimer = 0;\n\n    this.fp_push_played = false;\n    this.fp_land_played = false;\n    this.fp_getup_played = false;\n\n    // this.groundFace = undefined;\n    this.groundTilt = new THREE.Vector3();\n    this.up = new THREE.Vector3(0, 0, 1);\n\n    this.lockDialogOrientation = false;\n    this.lipObject = undefined;\n    this.walk = false;\n\n    this.isListening = false;\n    this.listeningPatterns = {};\n    this.heardStrings = [];\n\n    this.targetPositions = [];\n    const numNodes = 8;\n    for (let i = 0; i < numNodes; i++) {\n      const angle = (i / (numNodes / 2)) * Math.PI; // Calculate the angle at which the element will be placed.\n      // For a semicircle, we would use (i / numNodes) * Math.PI.\n      this.targetPositions.push({\n        angle: angle,\n        object: undefined,\n        cos: Math.cos(angle),\n        sin: Math.sin(angle),\n        owner: this,\n        targetVector: new THREE.Vector3()\n      });\n    }\n\n    try {\n\n      this.audioEmitter = new AudioEmitter(AudioEngine.GetAudioEngine());\n      this.audioEmitter.maxDistance = 50;\n      this.audioEmitter.type = AudioEmitterType.POSITIONAL;\n      this.audioEmitter.load();\n\n      this.footstepEmitter = new AudioEmitter(AudioEngine.GetAudioEngine());\n      this.footstepEmitter.maxDistance = 50;\n      this.footstepEmitter.type = AudioEmitterType.POSITIONAL;\n      this.footstepEmitter.load();\n    } catch (e) {\n      log.error('AudioEmitter failed to create on object', e);\n    }\n\n  }\n\n  update(delta = 0) {\n\n    super.update(delta);\n\n    if (this.audioEmitter) {\n      this.audioEmitter.setPosition(this.position.x, this.position.y, this.position.z + 1.0);\n      this.footstepEmitter.setPosition(this.position.x, this.position.y, this.position.z);\n    }\n\n    this.forceVector.set(0, 0, 0);\n    this.sphere.center.copy(this.position);\n    this.sphere.radius = this.getHitDistance() * 2;\n\n    if (GameState.Mode == EngineMode.INGAME || GameState.Mode == EngineMode.MINIGAME || GameState.Mode == EngineMode.DIALOG) {\n\n      if (this.animationState.index == ModuleCreatureAnimState.IDLE) {\n        this.footstepEmitter.isLooping = false;\n        this.footstepEmitter.stop();\n      }\n\n      if (!this.isReady) {\n        //this.getModel().visible = true;\n        return;\n      } else {\n        //do nothing\n      }\n\n      //Get the first action in the queue\n      this.action = this.actionQueue[0];\n\n      this.area = GameState.module.area;\n\n      /*if(this == GameState.getCurrentPlayer() && this.room instanceof ModuleRoom){\n        //this.room.show(true);\n      }else if(this.room instanceof ModuleRoom){\n        if(this.room.model instanceof OdysseyModel3D){\n          if(this.model){\n            this.model.visible = this.room.model.visible;\n          }\n        }\n      }*/\n\n      if (!this.isDead() && (\n        this.animationState.index == ModuleCreatureAnimState.DEAD ||\n        this.animationState.index == ModuleCreatureAnimState.DEAD1 ||\n        this.animationState.index == ModuleCreatureAnimState.GET_UP_DEAD ||\n        this.animationState.index == ModuleCreatureAnimState.GET_UP_DEAD1\n      )\n      ) {\n        this.deathAnimationPlayed = false;\n        this.setAnimationState(ModuleCreatureAnimState.GET_UP_DEAD);\n      }\n\n      if (!this.isDead()) {\n\n        //Process DamageList\n        const elLen = this.damageList.length - 1;\n        for (let i = elLen; i >= 0; i--) {\n          this.damageList[i].delay -= delta;\n          if (this.damageList[i].delay <= 0) {\n            this.subtractHP(this.damageList[i].amount);\n\n            const painsound = THREE.MathUtils.randInt(0, 1);\n            switch (painsound) {\n              case 1:\n                this.playSoundSet(SSFType.PAIN_2);\n                break;\n              default:\n                this.playSoundSet(SSFType.PAIN_1);\n                break;\n            }\n\n            this.damageList.splice(i, 1);\n          }\n        }\n\n        this.deathStarted = false;\n\n        if (this.animationState.index != ModuleCreatureAnimState.DEAD) {\n          this.updateActionQueue(delta);\n        }\n\n        if (this.dialogAnimation && (GameState.Mode == EngineMode.DIALOG) && (!this.action || this.action.type != ActionType.ActionPlayAnimation)) {\n          if (this.model) {\n\n            if (!this.speed) {\n\n              const _animIsValid = (this.dialogAnimation.animation instanceof OdysseyModelAnimation);\n              if (_animIsValid) {\n                const _animIsPlaying = (this.model.animationManager.currentAnimation == this.dialogAnimation.animation);\n                if (!_animIsPlaying && !this.dialogAnimation.started) {\n                  const _newAnim = this.dialogAnimation.animation;\n                  if (_newAnim instanceof OdysseyModelAnimation) {\n                    this.model.playAnimation(_newAnim, !!parseInt(this.dialogAnimation.data.looping));\n                    this.dialogAnimation.started = true;\n                  } else {\n                    //Kill the dialogAnimation if the animation isn't valid\n                    this.dialogAnimation = null;\n                  }\n                } else if (!_animIsPlaying && this.dialogAnimation.started) {\n                  //Kill the dialogAnimation if it has already played\n                  this.dialogAnimation = null;\n                }\n              } else {\n                //Kill the dialogAnimation if the animation isn't valid\n                this.dialogAnimation = null;\n              }\n\n            }\n\n          } else {\n            //Kill the dialogAnimation if there is no model to animate?\n            this.dialogAnimation = null;\n          }\n        } else {\n          this.dialogAnimation = null;\n        }\n      } else {\n        this.damageList = [];\n        this.getUpAnimationPlayed = false;\n        if (\n          this.deathStarted &&\n          this.animationState.index != ModuleCreatureAnimState.DEAD &&\n          this.animationState.index != ModuleCreatureAnimState.DIE\n        ) {\n          this.setAnimationState(ModuleCreatureAnimState.DEAD);\n          this.deathAnimationPlayed = true;\n        }\n        if (!this.deathStarted) {\n          this.deathAnimationPlayed = false;\n          this.deathStarted = true;\n          this.clearAllActions();\n          this.onDeath();\n          this.playSoundSet(SSFType.DEAD);\n          this.resetOverlayAnimationState();\n          this.setAnimationState(ModuleCreatureAnimState.DIE);\n        }\n      }\n\n      if (this.isDebilitated()) {\n        this.force = 0;\n        this.speed = 0;\n        this.setAnimationState(ModuleCreatureAnimState.IDLE);\n      }\n\n      //-------------------------//\n      // BEGIN: Move Speed Logic //\n      //-------------------------//\n\n      if (\n        this.isDead() ||\n        (\n          this.animationState.index == ModuleCreatureAnimState.DIE ||\n          this.animationState.index == ModuleCreatureAnimState.DIE1 ||\n          this.animationState.index == ModuleCreatureAnimState.GET_UP_DEAD ||\n          this.animationState.index == ModuleCreatureAnimState.GET_UP_DEAD1\n        )\n      ) {\n        this.force = 0;\n        this.speed = 0;\n        this.animSpeed = 1;\n        this.forceVector.set(0, 0, 0);\n      }\n\n      this.forceVector.z = 0;\n\n      this.speed += (this.getMovementSpeed() * 2.5) * this.force * delta;\n\n      if (this.speed > this.getMovementSpeed()) {\n        this.speed = this.getMovementSpeed();\n      }\n\n      const forceDelta = Math.max(this.force * delta, this.speed * delta);\n      const _gravityDelta = -1 * delta;\n\n      if (this.speed) {\n        this.animSpeed = this.speed / this.getRunSpeed();\n      } else {\n        this.animSpeed = 1;\n      }\n\n      if (!this.forceVector.length()) {\n        this.forceVector.x = (Math.cos(this.rotation.z + Math.PI / 2) * forceDelta);\n        this.forceVector.y = (Math.sin(this.rotation.z + Math.PI / 2) * forceDelta);\n        if (this.forceVector.length()) {\n          if (this.animSpeed > 0.75) {\n            this.setAnimationState(ModuleCreatureAnimState.RUNNING);\n          } else {\n            this.setAnimationState(ModuleCreatureAnimState.WALKING);\n          }\n        }\n        //this.forceVector.z = gravityDelta;\n      } else {\n        this.forceVector.multiplyScalar(forceDelta);\n      }\n\n      if (this.force < 1) {\n        this.speed -= (this.getMovementSpeed() * 2.5) * delta;\n      }\n\n      if (this.speed < 0) {\n        this.speed = 0;\n      }\n\n      if (!this.forceVector.length() && (this.animationState.index == ModuleCreatureAnimState.RUNNING || this.animationState.index == ModuleCreatureAnimState.WALKING)) {\n        this.setAnimationState(ModuleCreatureAnimState.IDLE);\n        this.speed = 0;\n        this.force = 0;\n      }\n\n      //-----------------------//\n      // END: Move Speed Logic //\n      //-----------------------//\n\n      if (this.combatData.combatState && this.animationState.index == ModuleCreatureAnimState.PAUSE) {\n        this.setAnimationState(ModuleCreatureAnimState.READY);\n      }\n\n      this.updateExcitedDuration(delta);\n      this.updateCombat(delta);\n      this.updateCasting(delta);\n      this.updateAnimationState();\n      this.updateItems(delta);\n\n      if (this.model instanceof OdysseyModel3D && this.model.bonesInitialized) {\n\n        //BEGIN: Animation Optimization\n        this.model.animateFrame = true;\n        //If the object is further than 50 meters, animate every other frame\n        if (this.distanceToCamera > 50) {\n          this.model.animateFrame = this.model.oddFrame;\n        }\n\n        if (this.model.animateFrame) {\n          //If we can animate and there is fog, make sure the distance isn't greater than the far point of the fog effect\n          if (GameState.PartyManager.party.indexOf(this) == -1 && this.context.scene.fog) {\n            if (this.distanceToCamera >= this.context.scene.fog.far) {\n              this.model.animateFrame = false;\n              //If the object is past the near point, and the near point is greater than zero, animate every other frame\n            } else if (this.context.scene.fog.near && this.distanceToCamera >= this.context.scene.fog.near) {\n              this.model.animateFrame = this.model.oddFrame;\n            }\n          }\n        }\n        //END: Animation Optimization\n\n        if (GameState.Mode != EngineMode.DIALOG) {\n          this.model.update(this.movementSpeed * delta);\n          if (this.lipObject instanceof LIPObject) {\n            this.lipObject.update(delta, this.model);\n          }\n        } else {\n          this.model.update(delta);\n          if (this.lipObject instanceof LIPObject) {\n            this.lipObject.update(delta, this.model);\n          }\n          if (this.cutsceneMode && this.model) {\n            for (let i = 0, len = this.model.skins.length; i < len; i++) {\n              this.model.skins[i].frustumCulled = false;\n            }\n          }\n        }\n      }\n\n      if (this.collisionManager.blockingObject != this.collisionManager.lastBlockingObject) {\n        this.collisionManager.lastBlockingObject = this.collisionManager.blockingObject;\n        //log.debug('blocking script', this.blocking);\n        this.onBlocked();\n      }\n\n      if (this.forceVector.length())\n        this.collisionManager.updateCollision(delta);\n\n      this.updatePerceptionList(delta);\n      this.updateListeningPatterns();\n\n\n      //If a non controlled party member is stuck, warp them to their follow position\n      if (this.npcId != undefined && this !== GameState.getCurrentPlayer() && this.collisionTimer >= 1) {\n        this.setPosition(GameState.PartyManager.GetFollowPosition(this));\n        this.collisionTimer = 0;\n      }\n\n      this.turning = 0;\n      if (this.facingAnim) {//this.facing != this.rotation.z){\n        this.facingTweenTime += 10 * delta;\n        if (this.facingTweenTime >= 1) {\n          this.rotation.z = this.facing;\n          this.facingAnim = false;\n        } else {\n          const oldFacing = Utility.NormalizeRadian(this.rotation.z);\n          this.rotation.z = Utility.interpolateAngle(this.wasFacing, this.facing, this.facingTweenTime);\n          const diff = oldFacing - Utility.NormalizeRadian(this.rotation.z);\n          this.turning = Math.sign(Utility.NormalizeRadian(oldFacing - Utility.NormalizeRadian(this.rotation.z)));\n          if (diff < 0.0000001 || diff > -0.0000001) {\n            this.facingAnim = false;\n            this.rotation.z = Utility.interpolateAngle(this.wasFacing, this.facing, 1);\n            this.wasFacing = this.facing;\n          }\n        }\n      }\n\n      //Update equipment\n      if (this.equipment.HEAD) {\n        this.equipment.HEAD.update(delta);\n      }\n      if (this.equipment.ARMS) {\n        this.equipment.ARMS.update(delta);\n      }\n\n      if (this.equipment.RIGHTARMBAND) {\n        this.equipment.RIGHTARMBAND.update(delta);\n      }\n\n      if (this.equipment.LEFTARMBAND) {\n        this.equipment.LEFTARMBAND.update(delta);\n      }\n\n      if (this.equipment.RIGHTHAND) {\n        this.equipment.RIGHTHAND.update(delta);\n      }\n\n      if (this.equipment.LEFTHAND) {\n        this.equipment.LEFTHAND.update(delta);\n      }\n\n      if (this.equipment.ARMOR) {\n        this.equipment.ARMOR.update(delta);\n      }\n\n      if (this.equipment.BELT) {\n        this.equipment.BELT.update(delta);\n      }\n\n      if (this.equipment.CLAW1) {\n        this.equipment.CLAW1.update(delta);\n      }\n\n      if (this.equipment.CLAW2) {\n        this.equipment.CLAW2.update(delta);\n      }\n\n      if (this.equipment.CLAW3) {\n        this.equipment.CLAW3.update(delta);\n      }\n\n      //Loop through and update the effects\n      if (this.deferEventUpdate) {\n        for (let i = 0, len = this.effects.length; i < len; i++) {\n          this.effects[i].update(delta);\n        }\n      }\n\n      if (!this.position.equals(this.lastPosition)) {\n        this.lastPosition.copy(this.position);\n        this.positionChanged = true;\n      }\n\n      if (this.positionChanged) {\n        this.onPositionChanged();\n      }\n    } else {\n      this.updateAnimationState();\n      this.updateItems(delta);\n    }\n\n    this.updateRegen(delta);\n\n    this.collisionTimer -= delta;\n    if (this.collisionTimer < 0)\n      this.collisionTimer = 0;\n\n    this.force = 0;\n  }\n\n  updateRegen(delta = 0) {\n    this.regenTimer -= delta;\n    if (this.regenTimer <= 0) {\n      this.regenTimer = this.regenTimerMax;\n\n      const regen2DA = GameState.TwoDAManager.datatables.get('regeneration').rows[this.combatData.combatState ? 0 : 1];\n      if (regen2DA) {\n        const regen_force = parseFloat(String(regen2DA['forceregen'] ?? ''));\n        if (!isNaN(regen_force)) {\n          this.addFP(Math.abs(regen_force));\n        }\n\n        const regen_health = parseFloat(String(regen2DA['healthregen'] ?? ''));\n        if (!isNaN(regen_health)) {\n          this.addHP(Math.abs(regen_health));\n        }\n      }\n    }\n  }\n\n  updateActionQueue(delta = 0) {\n    if (this.isDebilitated())\n      return;\n\n    if (!GameState.module.readyToProcessEvents)\n      return;\n\n\n    this.actionQueue.process(delta);\n    this.action = this.actionQueue[0];\n    if (!(this.action)) {\n      if (\n        !this.combatData.combatState &&\n        this.isPartyMember() &&\n        this != GameState.getCurrentPlayer()\n      ) {\n        this.setFacing(\n          Math.atan2(\n            this.position.y - GameState.getCurrentPlayer().position.y,\n            this.position.x - GameState.getCurrentPlayer().position.x\n          ) + Math.PI / 2,\n          false\n        );\n      }\n    }\n\n  }\n\n  updateListeningPatterns() {\n\n    if (this.isDead())\n      return;\n\n    const str = this.heardStrings[0];\n    if (!this.isListening || !str) { return; }\n    //log.debug('HeardString', this.id, str, this.isListening, this);\n\n    const pattern = this.listeningPatterns[str.string];\n    if (typeof pattern === 'undefined') { return; }\n\n    this.heardStrings.shift();\n    this.onDialog(str.speaker, pattern);\n  }\n\n  updatePerceptionList(delta = 0) {\n\n    if (this.isDead())\n      return true;\n\n    if (this.room) {\n      if (!this.room.model.visible) {\n        return;\n      }\n    }\n\n    if (!this.spawned || !GameState.module.readyToProcessEvents) {\n      return;\n    }\n\n    if (this.perceptionTimer < 3) {\n      this.perceptionTimer += 1 * delta;\n      return;\n    }\n\n    this.perceptionTimer = 0;\n\n    //if(!Engine.Flags.CombatEnabled)\n    //  return;\n\n    //Check modules creatures\n    const creatureLen = GameState.module.area.creatures.length;\n    for (let i = 0; i < creatureLen; i++) {\n      const creature = GameState.module.area.creatures[i];\n      //creature cannot perceive itself\n      if (this == creature) {\n        continue;\n      }\n\n      if (creature.isDead()) {\n        this.notifyPerceptionSeenObject(creature, false);\n        continue;\n      }\n\n      const distance = this.position.distanceTo(creature.position);\n      if (distance < this.getPerceptionRangePrimary() && this.hasLineOfSight(creature)) {\n        if (GameState.PartyManager.party.indexOf(this) == -1) {\n          if (this.isHostile(creature)) {\n            this.resetExcitedDuration();\n            if (this == GameState.getCurrentPlayer() && !this.combatData.combatState) {\n              GameState.AutoPauseManager.SignalAutoPauseEvent(AutoPauseState.EnemySighted);\n            }\n          }\n        }\n\n        this.notifyPerceptionSeenObject(creature, true);\n      } else if (distance < this.getPerceptionRangeSecondary() && this.hasLineOfSight(creature)) {\n        this.notifyPerceptionHeardObject(creature, true);\n      }\n    }\n\n    //Check party creatures\n    const partyLen = GameState.PartyManager.party.length;\n    for (let i = 0; i < partyLen; i++) {\n      const creature = GameState.PartyManager.party[i];\n      //creature cannot perceive itself\n      if (this == creature) {\n        continue;\n      }\n\n      if (creature.isDead()) {\n        this.notifyPerceptionSeenObject(creature, false);\n        continue;\n      }\n\n      const distance = this.position.distanceTo(creature.position);\n      if (distance < this.getPerceptionRangePrimary() && this.hasLineOfSight(creature)) {\n        if (GameState.PartyManager.party.indexOf(this) == -1) {\n          if (this.isHostile(creature)) {\n            this.resetExcitedDuration();\n          }\n\n          this.notifyPerceptionSeenObject(creature, true);\n        }\n      } else if (distance < this.getPerceptionRangeSecondary() && this.hasLineOfSight(creature)) {\n        this.notifyPerceptionHeardObject(creature, true);\n      }\n    }\n\n    for (let i = 0, triglen = this.area.triggers.length; i < triglen; i++) {\n      const trig = this.area.triggers[i];\n      if (trig.type != ModuleTriggerType.TRAP) { continue; }\n      if (trig.trapDetected) { continue; }\n      const actionFlag = new GameState.ActionFactory.ActionFlagMine();\n      actionFlag.setParameter(0, ActionParameterType.DWORD, trig);\n      this.actionQueue.addFront(actionFlag);\n    }\n\n  }\n\n  updateCombat(delta = 0) {\n    // this.combatData.update(delta);\n    this.combatRound.update(delta);\n\n    if (this.combatData.lastAttackTarget instanceof ModuleObject && this.combatData.lastAttackTarget.isDead()) {\n      this.combatData.clearTarget(this.combatData.lastAttackTarget);\n    }\n\n    if (this.combatData.lastAttacker instanceof ModuleObject && this.combatData.lastAttacker.isDead())\n      this.combatData.lastAttacker = undefined;\n\n    if (this.combatData.lastAttemptedAttackTarget instanceof ModuleObject && this.combatData.lastAttemptedAttackTarget.isDead())\n      this.combatData.lastAttemptedAttackTarget = undefined;\n\n    if (this.combatData.lastAttemptedSpellTarget instanceof ModuleObject && this.combatData.lastAttemptedSpellTarget.isDead())\n      this.combatData.lastAttemptedSpellTarget = undefined;\n\n    if (this.combatData.lastDamager instanceof ModuleObject && this.combatData.lastDamager.isDead())\n      this.combatData.lastDamager = undefined;\n\n    if (this.combatData.lastSpellAttacker instanceof ModuleObject && this.combatData.lastSpellAttacker.isDead())\n      this.combatData.lastSpellAttacker = undefined;\n\n    if (this.isDead()) {\n      this.clearTarget();\n      this.combatRound.clearActions();\n    }\n\n    if (this.combatData.combatState) {\n      //If creature is being controller by the player, keep at least one basic action in the attack queue while attack target is still alive\n      if (GameState.getCurrentPlayer() == this) {\n        if (!this.combatRound.scheduledActionList.length && !this.combatRound.action) {\n          if (this.combatData.lastAttackTarget) {\n            this.attackCreature(this.combatData.lastAttackTarget, undefined);\n          } else if (this.combatData.lastAttacker) {\n            this.attackCreature(this.combatData.lastAttacker, undefined);\n          } else {\n            //TODO: Attack nearest perceived hostile creature?\n          }\n        }\n      }\n    } else {\n      if (this.animationState.index == ModuleCreatureAnimState.READY) {\n        this.setAnimationState(ModuleCreatureAnimState.PAUSE);\n      }\n    }\n  }\n\n  updateCasting(delta = 0) {\n    //Update active spells\n    for (let i = 0, len = this.casting.length; i < len; i++) {\n      this.casting[i].spell.update(this.casting[i].target, this, this.casting[i], delta);\n    }\n\n    //Remove completed spells\n    let i = this.casting.length;\n    while (i--) {\n      if (this.casting[i].completed) {\n        this.casting.splice(i, 1);\n      }\n    }\n\n  }\n\n  clearTarget() {\n    this.combatData.lastAttackTarget = undefined;\n    this.combatData.lastDamager = undefined;\n  }\n\n  actionInRange(action: Action): boolean {\n    if (action) {\n      if (action.type == ActionType.ActionCastSpell) {\n        const spell = new TalentSpell(action.getParameter(0));\n        const target: ModuleObject = action.getParameter(5);\n        if (target instanceof ModuleObject) {\n          return spell.inRange(target, this);\n        } else {\n          return true;\n        }\n      } else if (action.type == ActionType.ActionItemCastSpell) {\n        const spell = new TalentSpell(action.getParameter(5));\n        const target: ModuleObject = action.getParameter(0);\n        if (target instanceof ModuleObject) {\n          return spell.inRange(target, this);\n        } else {\n          return true;\n        }\n      } else if (action.type == ActionType.ActionPhysicalAttacks) {\n        const target: ModuleObject = action.getParameter(1);\n        if (target instanceof ModuleObject) {\n          let distance = Infinity;\n          /*if(this.openSpot){\n            distance = this.position.distanceTo(this.openSpot.targetVector);\n          }else{*/\n          distance = this.position.distanceTo(target.position);\n          // }\n          return distance < ((this.combatData.getEquippedWeaponType() == 1 || this.combatData.getEquippedWeaponType() == 3) ? 2.0 : 15.0);\n        } else {\n          return true;\n        }\n      } else {\n        log.warn(`actionInRange: Invalid action type ${action.type}`, action)\n      }\n    } else {\n      log.warn(`actionInRange: Invalid action`, action)\n    }\n    return true;\n  }\n\n  //Return the best point surrounding this object for the attacker to move towards\n  getBestAttackPoint(_targeter: ModuleObject) {\n    return { x: 0, y: 0, z: 0 };\n  }\n\n  updateAnimationState() {\n\n    if (!(this.model instanceof OdysseyModel3D))\n      return;\n\n    const currentAnimation = this.model.getAnimationName();\n\n    if (this.overlayAnimationState.animationName && !this.isDead()) {\n      //(this.animationState.index != ModuleCreatureAnimState.WALKING && this.animationState.index != ModuleCreatureAnimState.RUNNING)\n      // if( this.overlayAnimationState.animation.overlay == '1'){\n      if (currentAnimation != this.overlayAnimationState.animationName) {\n        if (!this.overlayAnimationState.started) {\n          this.overlayAnimationState.started = true;\n          this.model.playOverlayAnimation(this.overlayAnimationState.animationName, this.overlayAnimationState.animation);\n        } else {\n          this.resetOverlayAnimationState();\n        }\n      }\n      return;\n      // }else{\n      //   this.resetOverlayAnimationState();\n      // }\n    } else {\n      this.resetOverlayAnimationState();\n    }\n\n    if ((GameState.Mode == EngineMode.DIALOG) && this.dialogAnimation && !this.speed && !this.isDead())\n      return;\n\n    if (this.animationState.animation) {\n      if (currentAnimation != this.animationState.animation.name?.toLowerCase()) {\n        if (!this.animationState.started) {\n          this.animationState.started = true;\n          const aLooping = (!parseInt(this.animationState.animation.fireforget) && parseInt(this.animationState.animation.looping) == 1);\n          this.model.playAnimation(this.animationState.animation.name?.toLowerCase(), aLooping);\n        } else {\n          this.setAnimationState(ModuleCreatureAnimState.PAUSE);\n        }\n      }\n    } else {\n      log.error('Animation Missing', this.getTag(), this.getName(), this.animationState);\n      this.setAnimationState(ModuleCreatureAnimState.PAUSE);\n    }\n\n  }\n\n  damage(amount = 0, oAttacker: ModuleObject, delayTime = 0) {\n    if (delayTime) {\n      this.damageList.push({ amount: amount, delay: delayTime });\n    } else {\n      this.subtractHP(amount);\n    }\n    this.combatData.lastDamager = oAttacker;\n    this.combatData.lastAttacker = oAttacker;\n\n    if (this.combatData.lastAttackTarget == undefined || (this.combatData.lastAttackTarget instanceof ModuleObject && this.combatData.lastAttackTarget.isDead()))\n      this.combatData.lastAttackTarget = oAttacker;\n\n    if (typeof oAttacker != 'undefined')\n      this.onDamaged();\n  }\n\n  canMove() {\n    return !this.isParalyzed() && !this.isStunned() && (\n      this.animationState.index != ModuleCreatureAnimState.DEAD &&\n      this.animationState.index != ModuleCreatureAnimState.DEAD1 &&\n      this.animationState.index != ModuleCreatureAnimState.DIE &&\n      this.animationState.index != ModuleCreatureAnimState.DIE1 &&\n      this.animationState.index != ModuleCreatureAnimState.GET_UP_DEAD &&\n      this.animationState.index != ModuleCreatureAnimState.GET_UP_DEAD1\n    ) && !this.casting.length;\n  }\n\n  getCurrentAction() {\n    if (this.actionQueue.length) {\n      return this.actionQueue[0].type;\n    }\n    return 65535;\n  }\n\n  JumpToLocation(lLocation: EngineLocation): void {\n    super.JumpToLocation(lLocation);\n    this.updateCollision();\n  }\n\n  moveToObject(target: ModuleObject, bRun = true, distance = 1.0) {\n\n    if (target instanceof ModuleObject) {\n\n      // this.openSpot = undefined;\n      const action = new GameState.ActionFactory.ActionMoveToPoint();\n      action.setParameter(0, ActionParameterType.FLOAT, target.position.x);\n      action.setParameter(1, ActionParameterType.FLOAT, target.position.y);\n      action.setParameter(2, ActionParameterType.FLOAT, target.position.z);\n      action.setParameter(3, ActionParameterType.DWORD, GameState.module.area.id);\n      action.setParameter(4, ActionParameterType.DWORD, target.id);\n      action.setParameter(5, ActionParameterType.INT, bRun ? 1 : 0);\n      action.setParameter(6, ActionParameterType.FLOAT, Math.max(1.5, distance));\n      action.setParameter(7, ActionParameterType.INT, 0);\n      action.setParameter(8, ActionParameterType.FLOAT, 30.0);\n      this.actionQueue.add(action);\n    }\n\n  }\n\n  detachFromRoom(room: ModuleRoom): void {\n    if (!room) return;\n    const index = room.creatures.indexOf(this);\n    if (index >= 0) {\n      room.creatures.splice(index, 1);\n    }\n  }\n\n  randomWalk() {\n\n    if (this.room && this.room.collisionManager.walkmesh) {\n      const run = false;\n      const maxDistance = 1.5\n      const position = new THREE.Vector3();\n\n      const faces = this.room.collisionManager.walkmesh.walkableFaces;\n      const face = faces[Math.floor(Math.random() * faces.length)];\n      if (face) {\n        position.copy(face.centroid);\n        const action = new GameState.ActionFactory.ActionMoveToPoint();\n        action.setParameter(0, ActionParameterType.FLOAT, position.x);\n        action.setParameter(1, ActionParameterType.FLOAT, position.y);\n        action.setParameter(2, ActionParameterType.FLOAT, position.z);\n        action.setParameter(3, ActionParameterType.DWORD, GameState.module.area.id);\n        action.setParameter(4, ActionParameterType.DWORD, 0xFFFFFFFF);\n        action.setParameter(5, ActionParameterType.INT, run ? 1 : 0);\n        action.setParameter(6, ActionParameterType.FLOAT, Math.max(1.5, maxDistance));\n        action.setParameter(7, ActionParameterType.INT, 0);\n        action.setParameter(8, ActionParameterType.FLOAT, 30.0);\n        this.actionQueue.add(action);\n      }\n\n    }\n\n  }\n\n  moveToLocation(target: ModuleObject | EngineLocation, bRun = true) {\n\n    if (target instanceof EngineLocation || target instanceof ModuleObject) {\n\n      let distance = 0.1;\n      const creatures = GameState.module.area.creatures;\n\n      //Check if creatures are too close to location\n      for (let i = 0; i < creatures.length; i++) {\n        const creature = creatures[i];\n        if (this == creature)\n          continue;\n\n        const d = target.position.distanceTo(creature.position);\n        if (d < 1.0) {\n          distance = 2.0;\n        }\n      }\n\n      //Check if party are too close to location\n      for (let i = 0; i < GameState.PartyManager.party.length; i++) {\n        const creature = GameState.PartyManager.party[i];\n        if (this == creature)\n          continue;\n\n        const d = target.position.distanceTo(creature.position);\n        if (d < 1.0) {\n          distance = 2.0;\n        }\n      }\n\n\n      // this.openSpot = undefined;\n      const action = new GameState.ActionFactory.ActionMoveToPoint();\n      action.setParameter(0, ActionParameterType.FLOAT, target.position.x);\n      action.setParameter(1, ActionParameterType.FLOAT, target.position.y);\n      action.setParameter(2, ActionParameterType.FLOAT, target.position.z);\n      action.setParameter(3, ActionParameterType.DWORD, GameState.module.area.id);\n      action.setParameter(4, ActionParameterType.DWORD, target instanceof EngineLocation ? ModuleObjectConstant.OBJECT_INVALID : target.id);\n      action.setParameter(5, ActionParameterType.INT, bRun ? 1 : 0);\n      action.setParameter(6, ActionParameterType.FLOAT, Math.max(1.5, distance));\n      action.setParameter(7, ActionParameterType.INT, 0);\n      action.setParameter(8, ActionParameterType.FLOAT, 30.0);\n      this.actionQueue.add(action);\n\n    }\n\n  }\n\n  jumpToObject(target: ModuleObject) {\n    log.debug('jumpToObject', target, this);\n    if (target instanceof ModuleObject) {\n\n      const action = new GameState.ActionFactory.ActionJumpToObject();\n      action.setParameter(0, ActionParameterType.DWORD, target.id);\n      action.setParameter(1, ActionParameterType.INT, 0);\n      this.actionQueue.add(action);\n\n    }\n\n  }\n\n  jumpToLocation(target: EngineLocation) {\n    log.debug('jumpToLocation', target, this);\n    if (target instanceof EngineLocation) {\n      const action = new GameState.ActionFactory.ActionJumpToPoint();\n      action.setParameter(0, ActionParameterType.FLOAT, target.position.x);\n      action.setParameter(1, ActionParameterType.FLOAT, target.position.y);\n      action.setParameter(2, ActionParameterType.FLOAT, target.position.z);\n      action.setParameter(3, ActionParameterType.DWORD, GameState.module.area.id);\n      action.setParameter(4, ActionParameterType.INT, 0);\n      action.setParameter(5, ActionParameterType.FLOAT, 20.0);\n      action.setParameter(6, ActionParameterType.FLOAT, target.rotation.x);\n      action.setParameter(7, ActionParameterType.FLOAT, target.rotation.y);\n      this.actionQueue.add(action);\n    }\n\n  }\n\n  resetExcitedDuration() {\n    this.excitedDuration = 10000;\n  }\n\n  cancelExcitedDuration() {\n    this.excitedDuration = 0;\n  }\n\n  updateExcitedDuration(delta = 0) {\n    if (this.isDead()) {\n      this.excitedDuration = 0;\n      this.cancelCombat();\n      this.weaponPowered(false);\n    }\n\n    if (this.excitedDuration > 0) {\n      this.excitedDuration -= (1000 * delta);\n      this.combatData.combatState = true;\n    }\n\n    if (this.excitedDuration <= 0) {\n      this.combatData.combatState = false;\n      this.excitedDuration = 0;\n      this.weaponPowered(false);\n    }\n  }\n\n  isDueling(): boolean {\n    if (!(BitWise.InstanceOf(this.combatData.lastAttackTarget?.objectType, ModuleObjectType.ModuleCreature))) return false;\n    const target = this.combatData.lastAttackTarget as ModuleCreature;\n    if (target.combatData.lastAttackTarget != this) return false;\n    return (target.isDuelingWeaponEquipped() && this.isDuelingWeaponEquipped());\n  }\n\n  isDuelingWeaponEquipped() {\n    if (!this.equipment.RIGHTHAND) return false;\n    return (\n      this.equipment.RIGHTHAND.getWeaponWield() == WeaponWield.STUN_BATON ||\n      this.equipment.RIGHTHAND.getWeaponWield() == WeaponWield.ONE_HANDED_SWORD ||\n      this.equipment.RIGHTHAND.getWeaponWield() == WeaponWield.TWO_HANDED_SWORD\n    );\n  }\n\n  isDuelingObject(oObject: ModuleObject) {\n    return (oObject instanceof ModuleObject && this.combatData.lastAttackTarget == oObject && oObject.combatData.lastAttackTarget == this && oObject.combatData.getEquippedWeaponType() == 1 && this.combatData.getEquippedWeaponType() == 1);\n  }\n\n  attackCreature(\n    target: ModuleObject, feat?: TalentFeat, isCutsceneAttack = false,\n    attackDamage = 0, attackAnimation?: string, attackResult?: AttackResult\n  ) {\n\n    if (target == undefined)\n      return;\n\n    if (target == this)\n      target = GameState.PartyManager.party[0];\n\n    if (target.isDead())\n      return;\n\n    const combatAction = new CombatRoundAction();\n    combatAction.actionType = CombatActionType.ATTACK;\n    combatAction.target = target;\n    combatAction.animation = ModuleCreatureAnimState.ATTACK;\n    combatAction.animationTime = 1500;\n    combatAction.isCutsceneAttack = isCutsceneAttack;\n\n    if (feat) {\n      combatAction.actionType = CombatActionType.ATTACK_USE_FEAT;\n      combatAction.setFeat(feat);\n    }\n\n    combatAction.attackResult = attackResult;\n    combatAction.attackDamage = attackDamage;\n\n    if (isCutsceneAttack) {\n      combatAction.animationName = attackAnimation;\n      combatAction.twoDAAnimation = OdysseyModelAnimation.GetAnimation2DA(attackAnimation);\n    }\n\n    this.combatRound.addAction(combatAction);\n\n    if (!this.actionQueue.actionTypeExists(ActionType.ActionCombat)) {\n      const action = new GameState.ActionFactory.ActionCombat(0xFFFF);\n      this.actionQueue.add(action);\n    }\n\n  }\n\n  useTalent(talent: TalentObject, oTarget: ModuleObject): Action {\n    let action: Action;\n    if (talent instanceof TalentObject) {\n      const combatAction = new CombatRoundAction();\n      switch (talent.objectType) {\n        case 1: //FEAT\n          combatAction.actionType = CombatActionType.ATTACK_USE_FEAT;\n          combatAction.target = oTarget;\n          combatAction.setFeat(talent as TalentFeat);\n          this.combatRound.addAction(combatAction);\n          break;\n        case 2: //SKILL\n          if (talent.id == 6) { //Security\n            action = new GameState.ActionFactory.ActionUnlockObject();\n            action.setParameter(0, ActionParameterType.DWORD, oTarget.id || ModuleObjectConstant.OBJECT_INVALID);\n            this.actionQueue.add(action);\n          }\n          break;\n        case 0: //SPELL\n          combatAction.actionType = CombatActionType.CAST_SPELL;\n          combatAction.setSpell(talent as TalentSpell);\n          combatAction.target = oTarget;\n          this.combatRound.addAction(combatAction);\n          break;\n      }\n    }\n    return action;\n  }\n\n  setAnimationState(animState: ModuleCreatureAnimState) {\n    if (!animState) { return; }\n\n    this.animationState.index = animState;\n    this.animationState.animation = this.animationConstantToAnimation(animState);\n    this.animationState.started = false;\n  }\n\n  resetAnimationState() {\n    this.animationState = {\n      index: ModuleCreatureAnimState.PAUSE,\n      animation: undefined,\n      started: false,\n      speed: 1,\n    }\n  }\n\n  playTwoDAAnimation(animation: ITwoDAAnimation) {\n    if (animation) {\n      this.resetAnimationState();\n      this.animationState = {\n        index: ModuleCreatureAnimState.PAUSE,\n        animation: animation,\n        started: false,\n        speed: 1,\n      }\n    }\n  }\n\n  playOverlayAnimation(NWScriptAnimId = -1) {\n    this.resetOverlayAnimationState();\n    switch (NWScriptAnimId) {\n      case 123:\n        this.overlayAnimationState.animationName = 'diveroll';\n        break;\n    }\n\n    if (this.overlayAnimationState.animationName) {\n      const anim = OdysseyModelAnimation.GetAnimation2DA(this.overlayAnimationState.animationName);\n      if (anim && anim.overlay == '1') {\n        this.overlayAnimationState.animation = anim;\n      } else {\n        this.resetOverlayAnimationState();\n      }\n    }\n  }\n\n  resetOverlayAnimationState() {\n    this.overlayAnimationState = {\n      animationIndex: -1,\n      animationName: '',\n      animation: undefined,\n      started: false,\n      speed: 1,\n    }\n  }\n\n  dialogPlayOdysseyAnimation(anim: OdysseyModelAnimation) {\n    log.debug('dialogPlayOdysseyAnimation', anim)\n    if (!this.model) {\n      log.warn('dialogPlayOdysseyAnimation failed');\n      log.debug(this, anim);\n      return;\n    }\n    this.dialogAnimation = {\n      animation: anim,\n      data: {\n        fireforget: '1',\n        looping: '0'\n      } as ITwoDAAnimation,\n      started: false,\n    };\n  }\n\n  dialogPlayAnimation(data: ITwoDAAnimation = {} as ITwoDAAnimation) {\n    log.debug('dialogPlayAnimation', data)\n    if (!this.model) {\n      log.warn('dialogPlayAnimation failed');\n      log.debug(this, data);\n      return;\n    }\n    this.dialogAnimation = {\n      animation: this.model.odysseyAnimationMap.get(data.name.toLowerCase().trim()),\n      data: data,\n      started: false,\n    };\n  }\n\n  cancelCombat() {\n    this.clearTarget();\n    this.combatData.combatState = false;\n    this.cancelExcitedDuration();\n    this.resetOverlayAnimationState();\n    if (this.animationState.index == ModuleCreatureAnimState.READY)\n      this.setAnimationState(ModuleCreatureAnimState.PAUSE)\n  }\n\n  getDamageAnimation(attackAnim: string): ITwoDAAnimation {\n\n    let attackAnimIndex = -1;\n\n    const modeltype = this.creatureAppearance.modeltype;\n    const _attackKey = this.getCombatAnimationAttackType();\n    const weaponWield = this.getCombatAnimationWeaponType();\n\n    const anims = GameState.TwoDAManager.datatables.get('animations');\n    for (let i = 0; i < anims.RowCount; i++) {\n      if (String(anims.rows[i]?.['name'] ?? '') === attackAnim) {\n        attackAnimIndex = i;\n        break;\n      }\n    }\n\n    const combatAnimation = GameState.TwoDAManager.datatables.get('combatanimations').getByID(attackAnimIndex);\n    //log.debug('getDamageAnimation', this.getName(), attackAnim, attackAnimIndex, combatAnimation, 'damage'+weaponWield);\n    if (combatAnimation) {\n      const damageAnimIndex = combatAnimation['damage' + weaponWield];\n      const damageAnim = anims.getByID(damageAnimIndex);\n      const damageAnimName = String(damageAnim?.['name'] ?? '');\n      if (damageAnim && damageAnimName && this.model.odysseyAnimationMap.get(damageAnimName.toLowerCase().trim())) {\n        //log.debug('damage anim', this.getName(), damageAnim.name)\n        return OdysseyModelAnimation.GetAnimation2DA(damageAnimName);\n      }\n    }\n\n    switch (modeltype) {\n      case 'S':\n      case 'L':\n        return OdysseyModelAnimation.GetAnimation2DA('cdamages');\n    }\n    //log.debug(attackAnim);\n\n    switch (attackAnim) {\n      case 'c2a1':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d1')\n      case 'c2a2':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d2')\n      case 'c2a3':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d3')\n      case 'c2a4':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d4')\n      case 'c2a5':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d5')\n    }\n\n    return OdysseyModelAnimation.GetAnimation2DA('g' + weaponWield + 'd1');\n\n  }\n\n  getDodgeAnimation(attackAnim: string): ITwoDAAnimation {\n\n    let attackAnimIndex = -1;\n\n    const modeltype = this.creatureAppearance.modeltype;\n    const attackKey = this.getCombatAnimationAttackType();\n    const weaponWield = this.getCombatAnimationWeaponType();\n\n    const anims = GameState.TwoDAManager.datatables.get('animations');\n    for (let i = 0; i < anims.RowCount; i++) {\n      if (anims.rows[i].name == attackAnim) {\n        attackAnimIndex = i;\n        break;\n      }\n    }\n\n    //log.debug('getDodgeAnimation', this.getName(), attackAnim, attackAnimIndex);\n\n    const combatAnimation = GameState.TwoDAManager.datatables.get('combatanimations').getByID(attackAnimIndex);\n    if (combatAnimation) {\n      if (Number(combatAnimation['hits']) === 1 && [4, 2, 3].indexOf(weaponWield) >= 0) {\n        const damageAnimIndex = combatAnimation['parry' + weaponWield];\n        const damageAnim = anims.getByID(damageAnimIndex);\n        const parryAnimName = String(damageAnim?.['name'] ?? '');\n        if (damageAnim && parryAnimName && this.model.odysseyAnimationMap.get(parryAnimName.toLowerCase().trim())) {\n          //log.debug('dodge/parry anim', this.getName(), damageAnim.name)\n          return OdysseyModelAnimation.GetAnimation2DA(parryAnimName);\n        }\n      }\n\n      const damageAnimIndex = combatAnimation['dodge' + weaponWield];\n      const damageAnim = anims.getByID(damageAnimIndex);\n      const dodgeAnimName = String(damageAnim?.['name'] ?? '');\n      if (damageAnim && dodgeAnimName && this.model.odysseyAnimationMap.get(dodgeAnimName.toLowerCase().trim())) {\n        //log.debug('dodge anim', this.getName(), damageAnim.name)\n        return OdysseyModelAnimation.GetAnimation2DA(dodgeAnimName);\n      }\n    }\n\n    switch (modeltype) {\n      case 'S':\n      case 'L':\n        return OdysseyModelAnimation.GetAnimation2DA('cdodgeg');\n    }\n    //log.debug(attackAnim);\n\n    switch (attackAnim) {\n      case 'c2a1':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d1')\n      case 'c2a2':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d2')\n      case 'c2a3':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d3')\n      case 'c2a4':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d4')\n      case 'c2a5':\n        return OdysseyModelAnimation.GetAnimation2DA('c2d5')\n    }\n\n    return OdysseyModelAnimation.GetAnimation2DA('g' + weaponWield + 'g1');\n\n  }\n\n  getParryAnimation(attackAnim: string): ITwoDAAnimation {\n\n    let attackAnimIndex = -1;\n\n    const modeltype = this.creatureAppearance.modeltype;\n    const attackKey = this.getCombatAnimationAttackType();\n    const weaponWield = this.getCombatAnimationWeaponType();\n\n    const anims = GameState.TwoDAManager.datatables.get('animations');\n    for (let i = 0; i < anims.RowCount; i++) {\n      if (String(anims.rows[i]?.['name'] ?? '') === attackAnim) {\n        attackAnimIndex = i;\n        break;\n      }\n    }\n\n    //log.debug('getParryAnimation', this.getName(), attackAnim, attackAnimIndex);\n    const combatAnimation = GameState.TwoDAManager.datatables.get('combatanimations').getByID(attackAnimIndex);\n    if (combatAnimation) {\n      const damageAnimIndex = combatAnimation['parry' + weaponWield];\n      const damageAnim = anims.getByID(damageAnimIndex);\n      const parryAnimName = String(damageAnim?.['name'] ?? '');\n      if (damageAnim && parryAnimName && this.model.odysseyAnimationMap.get(parryAnimName.toLowerCase().trim())) {\n        //log.debug('parry anim', this.getName(), damageAnim.name)\n        return OdysseyModelAnimation.GetAnimation2DA(parryAnimName);\n      }\n    }\n\n    switch (modeltype) {\n      case 'S':\n      case 'L':\n        return OdysseyModelAnimation.GetAnimation2DA('cdodgeg');\n    }\n    //log.debug(attackAnim);\n    switch (attackAnim) {\n      case 'c2a1':\n        return OdysseyModelAnimation.GetAnimation2DA('c2p1')\n      case 'c2a2':\n        return OdysseyModelAnimation.GetAnimation2DA('c2p2')\n      case 'c2a3':\n        return OdysseyModelAnimation.GetAnimation2DA('c2p3')\n      case 'c2a4':\n        return OdysseyModelAnimation.GetAnimation2DA('c2p4')\n      case 'c2a5':\n        return OdysseyModelAnimation.GetAnimation2DA('c2p5')\n    }\n\n    return OdysseyModelAnimation.GetAnimation2DA('g' + weaponWield + 'g1');\n\n  }\n\n  getCombatAnimationAttackType(): string {\n    const weapon = this.equipment.RIGHTHAND;\n    let weaponType = 0;\n    //let weaponWield = this.getCombatAnimationWeaponType();\n\n    if (this.equipment.RIGHTHAND) {\n      weaponType = (this.equipment.RIGHTHAND.getWeaponType());\n\n      switch (weaponType) {\n        case 4:\n          return 'b';\n        case 1:\n          return 'm';\n      }\n\n    } else if (this.equipment.CLAW1) {\n      weaponType = (this.equipment.CLAW1.getWeaponType());\n\n      switch (weaponType) {\n        case 1:\n        case 3:\n        case 4:\n          return 'm';\n      }\n    } else if (this.equipment.CLAW2) {\n      weaponType = (this.equipment.CLAW2.getWeaponType());\n\n      switch (weaponType) {\n        case 1:\n        case 3:\n        case 4:\n          return 'm';\n      }\n    } else if (this.equipment.CLAW3) {\n      weaponType = (this.equipment.CLAW3.getWeaponType());\n\n      switch (weaponType) {\n        case 1:\n        case 3:\n        case 4:\n          return 'm';\n      }\n    } else {\n      return 'g';\n    }\n\n    /*if(weaponWield == 0)//this.isSimpleCreature())\n      return 'm';\n\n    if(weaponWield == 5 || weaponWield == 6 || weaponWield == 7 || weaponWield == 8 || weaponWield == 9){\n      return 'b';\n    }\n    return 'c';*/\n  }\n\n  //Return the WeaponType ID for the current equipped items\n  // g*r1 in this case * is the value we are trying to determine\n\n  getCombatAnimationWeaponType() {\n    const lWeapon = this.equipment.LEFTHAND;\n    const rWeapon = this.equipment.RIGHTHAND;\n    const cWeapon1 = this.equipment.CLAW1;\n    const cWeapon2 = this.equipment.CLAW2;\n    const cWeapon3 = this.equipment.CLAW3;\n    const bothHands = (lWeapon) && (rWeapon);\n\n    if (cWeapon1 || cWeapon2 || cWeapon3 || this.isSimpleCreature()) {\n      return 0;\n    }\n\n    const weapon = rWeapon || lWeapon;\n\n    if (weapon) {\n\n      if (bothHands) {\n        switch ((weapon.getWeaponWield())) {\n          case 1: //Stun Baton\n          case 2: //Single Blade Melee\n            return 4;\n          case 4: //Blaster\n            return 6;\n        }\n      } else {\n        switch ((weapon.getWeaponWield())) {\n          case 1: //Stun Baton\n            return 1;\n          case 2: //Single Blade Melee\n            return 2;\n          case 3: //Double Blade Melee\n            return 3;\n          case 4: //Blaster\n            return 5;\n          case 5: //Blaster Rifle\n            return 7;\n          case 6: //Heavy Carbine\n            return 9;\n        }\n      }\n    }\n\n    //If no weapons are equipped then use unarmed animations\n    return 8;\n\n  }\n\n  getEquippedWeaponType() {\n    const lWeapon = this.equipment.LEFTHAND;\n    const rWeapon = this.equipment.RIGHTHAND;\n    const claw1 = this.equipment.CLAW1;\n    const claw2 = this.equipment.CLAW2;\n    const claw3 = this.equipment.CLAW3;\n\n    if (rWeapon) {\n      return (rWeapon.getWeaponType());\n    }\n\n    if (lWeapon) {\n      return (lWeapon.getWeaponType());\n    }\n\n    if (claw1) {\n      return (claw1.getWeaponType());\n    }\n\n    if (claw2) {\n      return (claw2.getWeaponType());\n    }\n\n    if (claw3) {\n      return (claw3.getWeaponType());\n    }\n\n    return 0;\n  }\n\n  isRangedEquipped() {\n    if (this.equipment.RIGHTHAND) {\n      return this.equipment.RIGHTHAND.isRangedWeapon();\n    }\n\n    if (this.equipment.LEFTHAND) {\n      return this.equipment.LEFTHAND.isRangedWeapon();\n    }\n\n    if (this.equipment.CLAW1) {\n      return this.equipment.CLAW1.isRangedWeapon();\n    }\n\n    if (this.equipment.CLAW2) {\n      return this.equipment.CLAW2.isRangedWeapon();\n    }\n\n    if (this.equipment.CLAW3) {\n      return this.equipment.CLAW3.isRangedWeapon();\n    }\n\n    return false;\n  }\n\n  updateItems(delta = 0) {\n\n    if (this.equipment.RIGHTHAND) {\n      if (this.equipment.RIGHTHAND.model instanceof OdysseyModel3D) {\n        this.equipment.RIGHTHAND.model.update(delta)\n      }\n    }\n\n    if (this.equipment.LEFTHAND) {\n      if (this.equipment.LEFTHAND.model instanceof OdysseyModel3D) {\n        this.equipment.LEFTHAND.model.update(delta)\n      }\n    }\n\n  }\n\n  playEvent(event: THREE.Event) {\n    this.audioEmitter.setPosition(this.position.x, this.position.y, this.position.z);\n    this.footstepEmitter.setPosition(this.position.x, this.position.y, this.position.z);\n\n    const appearance = this.creatureAppearance;\n    const rhSounds = this.equipment.RIGHTHAND?.weaponSound;\n    const lhSounds = this.equipment.LEFTHAND?.weaponSound;\n    const footstepSounds = GameState.SWRuleSet.footSteps[appearance.footsteptype];\n\n    let rhWeaponSoundResRef = '';\n    const lhWeaponSoundResRef = '';\n    let footstepSoundResRef = '';\n    let footstepIsLooping = false;\n\n    const eventName = (event as THREE.Event & { event?: string }).event ?? '';\n    switch (eventName) {\n      case 'snd_footstep':\n        if (footstepSounds) {\n          const isRolling = footstepSounds.isRolling();\n          footstepSoundResRef = isRolling ? footstepSounds.getRollingResRef() : footstepSounds.getSurfaceSoundResRef(this.collisionManager.surfaceId);\n          footstepIsLooping = isRolling;\n        }\n        break;\n      case 'Swingshort':\n        rhWeaponSoundResRef = rhSounds?.getSwingShortResRef() || '';\n        break;\n      case 'Swinglong':\n        rhWeaponSoundResRef = rhSounds?.getSwingLongResRef() || '';\n        break;\n      case 'HitParry':\n        rhWeaponSoundResRef = rhSounds?.getHitParryResRef() || '';\n        break;\n      case 'Contact':\n        rhWeaponSoundResRef = rhSounds?.getClashResRef() || '';\n        break;\n      case 'Clash':\n        rhWeaponSoundResRef = rhSounds?.getClashResRef() || '';\n        break;\n      case 'Hit':\n        if (this.combatData.combatAction && this.combatData.combatAction.hits && this.combatData.combatAction.damage) {\n          this.combatData.combatAction.target.damage(this.combatData.combatAction.damage, this);\n        }\n\n        rhWeaponSoundResRef = rhSounds?.getLeatherResRef() || '';\n        break;\n    }\n\n    if (footstepSoundResRef && footstepIsLooping && !this.footstepEmitter.isPlayingSound(footstepSoundResRef)) {\n      log.debug('Playing rolling sound', footstepSoundResRef);\n      this.footstepEmitter.playSound(footstepSoundResRef);\n    } else if (footstepSoundResRef) {\n      this.footstepEmitter.playSoundFireAndForget(footstepSoundResRef);\n    }\n\n    if (rhWeaponSoundResRef) {\n      this.audioEmitter.playSoundFireAndForget(rhWeaponSoundResRef);\n    }\n  }\n\n  hasWeapons() {\n    const lWeapon = this.equipment.LEFTHAND;\n    const rWeapon = this.equipment.RIGHTHAND;\n    const cWeapon1 = this.equipment.CLAW1;\n    const cWeapon2 = this.equipment.CLAW2;\n    const cWeapon3 = this.equipment.CLAW3;\n    return (lWeapon) || (rWeapon) || (cWeapon1) || (cWeapon2) || (cWeapon3);\n  }\n\n  flourish() {\n    this.resetExcitedDuration();\n    const isSimple = this.isSimpleCreature();\n    const weaponType = this.getCombatAnimationWeaponType();\n\n    if (!isSimple) {\n      if (weaponType) {\n        this.clearAllActions();\n        this.setAnimationState(ModuleCreatureAnimState.FLOURISH);\n        this.weaponPowered(true);\n      }\n    }\n  }\n\n  /**\n   * Set the weapon powered state\n   * @param on - Whether the weapon should be powered\n   */\n  weaponPowered(on: boolean = false): void {\n    const weaponType = this.getCombatAnimationWeaponType();\n    const isSimple = this.isSimpleCreature();\n    if (isSimple || !weaponType) { return; }\n\n    this.equipment.LEFTHAND?.setPowered(on);\n    this.equipment.RIGHTHAND?.setPowered(on);\n  }\n\n  setLIP(lip: LIPObject) {\n    //log.debug(lip);\n    this.lipObject = lip;\n  }\n\n  getClosesetOpenSpot(oObject: ModuleObject) {\n    let maxDistance = Infinity;\n    const radius = this.creatureAppearance.hitdist;\n    let closest = undefined;\n    let distance = 0;\n    const origin = this.position;\n\n    let alreadyClaimedSpot = false;\n\n    //Check to see if oObject already has claimed a targetPosition around this creature\n    for (let i = 0, len = this.targetPositions.length; i < len; i++) {\n      const targetPosition = this.targetPositions[i];\n      if (targetPosition.object == oObject) {\n        closest = targetPosition;\n        alreadyClaimedSpot = true;\n        break;\n      }\n    }\n\n    if (!alreadyClaimedSpot) {\n      for (let i = 0, len = this.targetPositions.length; i < len; i++) {\n        const targetPosition = this.targetPositions[i];\n        if (targetPosition.object == undefined) {\n          //Generate the target vector for the\n          targetPosition.targetVector.x = origin.x + (targetPosition.cos * radius);\n          targetPosition.targetVector.y = origin.y + (targetPosition.sin * radius);\n          targetPosition.targetVector.z = origin.z;\n          distance = targetPosition.targetVector.distanceTo(oObject.position);\n\n          //is this target position is closer to oObject\n          if (distance < maxDistance) {\n            //Set the current targetPosition as the current closest position\n            closest = targetPosition;\n            //Update the maxDistance\n            maxDistance = distance;\n          }\n        }\n      }\n      if (typeof closest != 'undefined') {\n        for (let i = 0, len = GameState.module.area.creatures.length; i < len; i++) {\n          GameState.module.area.creatures[i].removeObjectFromTargetPositions(oObject);\n        }\n\n        for (let i = 0, len = GameState.PartyManager.party.length; i < len; i++) {\n          GameState.PartyManager.party[i].removeObjectFromTargetPositions(oObject);\n        }\n        closest.object = oObject;\n      }\n    }\n    return closest;\n  }\n\n  removeObjectFromTargetPositions(oObject: ModuleObject) {\n    if (typeof oObject != 'undefined') {\n      for (let i = 0, len = this.targetPositions.length; i < len; i++) {\n        if (this.targetPositions[i].object == oObject) {\n          this.targetPositions[i].object = undefined;\n        }\n      }\n    }\n  }\n\n  setFacingVector(facing = new THREE.Vector3()) {\n\n    this.props['XOrientation'] = facing.x;\n    this.props['YOrientation'] = facing.y;\n\n    if (this.model instanceof OdysseyModel3D)\n      this.model.quaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.atan2(Number(this.props['XOrientation']), Number(this.props['YOrientation'])));\n\n  }\n\n  getFacingVector() {\n    if ((this.model instanceof OdysseyModel3D)) {\n      const facing = new THREE.Vector3(0, 1, 0);\n      facing.applyQuaternion(this.model.quaternion);\n      return facing;\n    }\n    return new THREE.Vector3(0, 0, 0);\n  }\n\n  getFacing() {\n    return this.rotation.z;\n  }\n\n  setFacingObject(target: ModuleObject) {\n    if (target instanceof ModuleObject) {\n      this.setFacing(\n        Math.atan2(\n          this.position.y - target.position.y,\n          this.position.x - target.position.x\n        ) + Math.PI / 2,\n        false\n      );\n    }\n  }\n\n  onClick(callee: ModuleObject) {\n\n    //You can't interact with yourself\n    if (this === GameState.PartyManager.Player && GameState.getCurrentPlayer() === this) {\n      return;\n    }\n\n    if (this.isHostile(callee) && !this.isDead()) {\n      GameState.getCurrentPlayer().attackCreature(this, undefined);\n    } else if (this.isHostile(callee) && this.isDead()) {\n      this.clearAllActions();\n      GameState.getCurrentPlayer().actionUseObject(this);\n    } else if (!this.isDead()) {\n      this.clearAllActions();\n      if (this.getConversation() && this.getConversation().resref) {\n        GameState.getCurrentPlayer().actionDialogObject(this, this.getConversation().resref, false, undefined, undefined, true);\n      }\n    }\n\n  }\n\n  positionChanged: boolean = false;\n\n  /**\n   * Called when the creature's position changes\n   */\n  onPositionChanged() {\n    this.positionChanged = false;\n    //check if the creature is inside a trigger\n    const triggers = GameState.module.area.triggers;\n    const tLen = triggers.length;\n    for (let i = 0; i < tLen; i++) {\n      triggers[i].updateObjectInside(this);\n    }\n  }\n\n  //---------------//\n  // SCRIPT EVENTS\n  //---------------//\n\n  onCombatRoundEnd() {\n    if (this.combatData.lastAttemptedAttackTarget instanceof ModuleObject && this.combatData.lastAttemptedAttackTarget.isDead())\n      this.combatData.lastAttemptedAttackTarget = undefined;\n\n    if (this.isDead() || !this.combatData.combatState)\n      return true;\n\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnEndRound];\n    if (!nwscript) { return true; }\n    const instance = nwscript.newInstance();\n    instance.run(this);\n  }\n\n  onDeath() {\n    this.weaponPowered(false);\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnDeath];\n    if (!nwscript) { return true; }\n    const instance = nwscript.newInstance();\n    instance.run(this);\n  }\n\n  onDialog(oSpeaker: ModuleObject, listenPatternNumber = -1, conversation: DLGObject = undefined) {\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnDialog];\n    if (!nwscript) { return false; }\n    const instance = nwscript.newInstance();\n    instance.listenPatternNumber = listenPatternNumber;\n    instance.listenPatternSpeaker = oSpeaker;\n    instance.conversation = conversation;\n    instance.run(this, 0);\n    return true;\n  }\n\n  onAttacked(attackType: CombatActionType) {\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnAttacked];\n    if (!nwscript) { return; }\n    const instance = nwscript.newInstance();\n    const script_num = (GameState.PartyManager.party.indexOf(this) > -1) ? 2005 : 1005;\n    instance.run(this, script_num);\n  }\n\n  onDamaged() {\n    if (this.isDead())\n      return true;\n\n    this.resetExcitedDuration();\n\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnDamaged];\n    if (!nwscript) { return true; }\n    const instance = nwscript.newInstance();\n    const script_num = (GameState.PartyManager.party.indexOf(this) > -1) ? 2006 : 1006;\n    instance.run(this, script_num);\n  }\n\n  onBlocked() {\n    if (this == GameState.getCurrentPlayer())\n      return;\n\n    const nwscript = this.scripts[ModuleObjectScript.CreatureOnBlocked];\n    if (!nwscript) { return; }\n    const instance = nwscript.newInstance();\n    const script_num = (GameState.PartyManager.party.indexOf(this) > -1) ? 2009 : 1009;\n    instance.run(this, script_num);\n  }\n\n  use(object: ModuleObject) {\n    if (this.hasInventory()) {\n      GameState.MenuManager.MenuContainer.AttachContainer(this);\n      GameState.MenuManager.MenuContainer.open();\n    }\n  }\n\n  hasInventory() {\n    return this.inventory.length;\n  }\n\n  retrieveInventory() {\n    while (this.inventory.length) {\n      GameState.InventoryManager.addItem(this.inventory.pop())\n    }\n  }\n\n  isUseable() {\n    return !this.isDead() || this.isDeadSelectable;\n  }\n\n  isDead() {\n    return this.getHP() <= 0 && !this.min1HP;\n  }\n\n  isDiseased() {\n    return this.hasEffect(GameEffectType.EffectDisease);\n  }\n\n  isPoisoned() {\n    return this.hasEffect(GameEffectType.EffectPoison);\n  }\n\n  isConfused() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 1) ? true : false;\n  }\n\n  isFrightened() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 2) ? true : false;\n  }\n\n  isDroidStunned() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 3) ? true : false;\n  }\n\n  isStunned() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 4) ? true : false;\n  }\n\n  isParalyzed() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 5) ? true : false;\n  }\n\n  isSleeping() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 6) ? true : false;\n  }\n\n  isChoking() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 7) ? true : false;\n  }\n\n  isHorrified() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 8) ? true : false;\n  }\n\n  isForcePushed() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 9) ? true : false;\n  }\n\n  isWhirlwind() {\n    return this.effects.find(e => e.type == GameEffectType.EffectSetState && e.getInt(0) == 10) ? true : false;\n  }\n\n  isDebilitated() {\n    return this.isConfused() || this.isStunned() || this.isDroidStunned() || this.isParalyzed() || this.isFrightened() || this.isChoking() || this.isForcePushed() || this.isHorrified();\n  }\n\n  setCommadable(arg0: boolean | number) {\n    this.isCommandable = !!arg0;\n  }\n\n  getCommadable() {\n    return this.isCommandable;\n  }\n\n  getItemInSlot(slot = 0) {\n    switch (slot) {\n      case ModuleCreatureArmorSlot.IMPLANT:\n        return this.equipment.IMPLANT;\n      case ModuleCreatureArmorSlot.HEAD:\n        return this.equipment.HEAD;\n      case ModuleCreatureArmorSlot.ARMS:\n        return this.equipment.ARMS;\n      case ModuleCreatureArmorSlot.LEFTARMBAND:\n        return this.equipment.LEFTARMBAND;\n      case ModuleCreatureArmorSlot.ARMOR:\n        return this.equipment.ARMOR;\n      case ModuleCreatureArmorSlot.RIGHTARMBAND:\n        return this.equipment.RIGHTARMBAND;\n      case ModuleCreatureArmorSlot.LEFTHAND:\n        return this.equipment.LEFTHAND;\n      case ModuleCreatureArmorSlot.BELT:\n        return this.equipment.BELT;\n      case ModuleCreatureArmorSlot.RIGHTHAND:\n        return this.equipment.RIGHTHAND;\n      case ModuleCreatureArmorSlot.CLAW1:\n        return this.equipment.CLAW1;\n      case ModuleCreatureArmorSlot.CLAW2:\n        return this.equipment.CLAW2;\n      case ModuleCreatureArmorSlot.CLAW3:\n        return this.equipment.CLAW3;\n      default:\n        return null;\n    }\n  }\n\n  getInventory(): ModuleItem[] {\n    if (this.isPartyMember()) {\n      return GameState.InventoryManager.getInventory();\n    }\n    return this.inventory;\n  }\n\n  getXOrientation() {\n    return this.xOrientation;\n  }\n\n  getYOrientation() {\n    return this.yOrientation;\n  }\n\n  getZOrientation() {\n    return this.zOrientation;\n  }\n\n  getRotation() {\n    if (this.model) {\n      return Math.floor(this.rotation.z * 180) + 180\n    }\n    return 0;\n  }\n\n  getRace() {\n    return this.race;\n  }\n\n  getSubRace() {\n    return this.subrace;\n  }\n\n  getGender() {\n    return this.gender;\n  }\n\n  getXP() {\n    return this.experience;\n  }\n\n  setXP(value = 0) {\n    this.experience = value;\n  }\n\n  addXP(value = 0, xpType: ExperienceType = ExperienceType.PLOT) {\n    this.experience += parseInt(value.toString());\n    if (this.isPartyMember()) {\n      GameState.UINotificationManager.EnableUINotificationIconType(xpType == ExperienceType.PLOT ? UIIconTimerType.PLOT_XP_RECEIVED : UIIconTimerType.STEALTH_XP_RECEIVED);\n    }\n  }\n\n  getGoodEvil() {\n    return this.goodEvil;\n  }\n\n  /**\n   * Sets the alignment of the creature.\n   * @param value - The alignment to set the creature to.\n   */\n  setGoodEvil(value: number = 0) {\n    const oldValue = this.goodEvil;\n    this.goodEvil = value;\n    if (this.goodEvil < 0) this.goodEvil = 0;\n    if (this.goodEvil > 100) this.goodEvil = 100;\n    if (this.isPartyMember()) {\n      GameState.UINotificationManager.EnableUINotificationIconType(value >= oldValue ? UIIconTimerType.LIGHT_SHIFT : UIIconTimerType.DARK_SHIFT);\n    }\n  }\n\n  /**\n   * Adds to the alignment of the creature.\n   * @param value - The amount to add to the alignment.\n   */\n  addGoodEvil(value: number = 0) {\n    this.goodEvil += value;\n    if (this.goodEvil < 0) this.goodEvil = 0;\n    if (this.goodEvil > 100) this.goodEvil = 100;\n    if (this.isPartyMember()) {\n      GameState.UINotificationManager.EnableUINotificationIconType(value >= 0 ? UIIconTimerType.LIGHT_SHIFT : UIIconTimerType.DARK_SHIFT);\n    }\n  }\n\n  /**\n   * Adjusts the alignment of the creature.\n   * @param value - The amount to adjust the alignment by.\n   * @param alignment - The alignment to adjust the creature's alignment to. 1 = NEUTRAL, 2 = LIGHT, 3 = DARK\n   */\n  adjustAlignment(value: number = 0, alignment: number = 0) {\n    value = Math.abs(value);\n    const oldValue = this.goodEvil;\n    let alignmentShifted = 0\n    if (alignment == 1) {\n      /**\n       * Shifted to DARK\n       */\n      if (this.goodEvil > 50) {\n        this.goodEvil -= value;\n        if (this.goodEvil < 50) {\n          this.goodEvil = 50;\n        }\n        alignmentShifted = 3;\n      }\n      /**\n       * Shifted to LIGHT\n       */\n      else {\n        this.goodEvil += value;\n        if (this.goodEvil > 50) {\n          this.goodEvil = 50;\n        }\n        alignmentShifted = 2;\n      }\n    }\n    /**\n     * Shift light\n     */\n    else if (alignment == 2) {\n      this.goodEvil += value;\n      alignmentShifted = 2;\n    }\n    /**\n     * Shift dark\n     */\n    else if (alignment == 3) {\n      this.goodEvil -= value;\n      alignmentShifted = 3;\n    }\n    if (this.goodEvil < 0) this.goodEvil = 0;\n    if (this.goodEvil > 100) this.goodEvil = 100;\n    if (this.isPartyMember() && (alignmentShifted == 2 || alignmentShifted == 3)) {\n      GameState.UINotificationManager.EnableUINotificationIconType(alignmentShifted == 2 ? UIIconTimerType.LIGHT_SHIFT : UIIconTimerType.DARK_SHIFT);\n    }\n  }\n\n  getSubraceIndex() {\n    return this.subraceIndex;\n  }\n\n  setHP(nAmount = 0) {\n    const bonus = this.maxHitPoints - this.hitPoints;\n    this.currentHitPoints = nAmount - bonus;\n  }\n\n  addHP(nAmount = 0, ignoreMaxHitPoints = false) {\n    if (ignoreMaxHitPoints) {\n      this.currentHitPoints += nAmount;\n    } else {\n      const currentHP = this.getHP();\n      if (currentHP < this.getMaxHP()) {\n        if (currentHP + nAmount > this.getMaxHP()) {\n          this.currentHitPoints += nAmount + (this.getMaxHP() - (currentHP + nAmount));\n        } else {\n          this.currentHitPoints += nAmount;\n        }\n      }\n    }\n\n    if (this.min1HP && this.getHP() < 1)\n      this.setHP(1);\n  }\n\n  subtractHP(nAmount = 0) {\n    this.currentHitPoints -= nAmount;\n    if (this.min1HP && this.getHP() < 1)\n      this.setHP(1);\n  }\n\n  getHP() {\n    switch (this.subraceIndex) {\n      case 0: //NONE\n        return (this.maxHitPoints + this.currentHitPoints) - this.hitPoints;\n      case 1: //WOOKIE\n      case 2: //BEAST\n        return this.hitPoints + this.currentHitPoints;\n      default:\n        return (this.maxHitPoints + this.currentHitPoints) - this.hitPoints;\n    }\n  }\n\n  getMaxHP() {\n    return this.maxHitPoints;\n  }\n\n  setMaxHP(nAmount = 0) {\n    return this.maxHitPoints = nAmount;\n  }\n\n  setMinOneHP(bMinOneHP = false) {\n    this.min1HP = bMinOneHP ? true : false;\n  }\n\n  getFP() {\n    return this.forcePoints;\n  }\n\n  getMaxFP() {\n    return this.maxForcePoints;\n  }\n\n  setFP(nAmount = 0) {\n    const bonus = this.maxForcePoints - this.forcePoints;\n    this.currentForce = nAmount - bonus;\n  }\n\n  addFP(nAmount = 0, ignoreMaxForcePoints = false) {\n    if (ignoreMaxForcePoints) {\n      this.currentForce += nAmount;\n    } else {\n      const currentFP = this.getFP();\n      if (currentFP < this.getMaxFP()) {\n        if (currentFP + nAmount > this.getMaxFP()) {\n          this.currentForce += nAmount + (this.getMaxFP() - (currentFP + nAmount));\n        } else {\n          this.currentForce += nAmount;\n        }\n      }\n    }\n\n    if (this.getFP() < 0)\n      this.setFP(0);\n  }\n\n  subtractFP(nAmount = 0) {\n    this.currentForce -= nAmount;\n    if (this.getFP() < 0)\n      this.setFP(0);\n  }\n\n  getCameraHeight() {\n    if (this.model && this.model.camerahook) {\n      return this.model.camerahook.position.z;\n    } else {\n      return 1.5;\n    }\n  }\n\n  getAC() {\n    const baseac = 10;\n    let classBonus = 0;\n\n    for (let i = 0; i < this.classes.length; i++) {\n      classBonus += this.classes[i].getACBonus();\n    }\n\n    const armorAC = (this.equipment.ARMOR?.getACBonus() || 0);\n\n    const dexBonus = Math.floor((this.getDEX() - 10) / 2);\n\n    return baseac + classBonus + armorAC + dexBonus;\n  }\n\n  getSTR(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.str;\n    } else {\n      return this.str +\n        (this.equipment.HEAD?.getSTRBonus() || 0) +\n        (this.equipment.ARMOR?.getSTRBonus() || 0) +\n        (this.equipment.ARMS?.getSTRBonus() || 0) +\n        (this.equipment.RIGHTHAND?.getSTRBonus() || 0) +\n        (this.equipment.LEFTHAND?.getSTRBonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getSTRBonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getSTRBonus() || 0) +\n        (this.equipment.IMPLANT?.getSTRBonus() || 0) +\n        (this.equipment.BELT?.getSTRBonus() || 0) +\n        (this.equipment.CLAW1?.getSTRBonus() || 0) +\n        (this.equipment.CLAW2?.getSTRBonus() || 0) +\n        (this.equipment.HIDE?.getSTRBonus() || 0);\n    }\n  }\n\n  getDEX(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.dex;\n    } else {\n      return this.dex +\n        (this.equipment.HEAD?.getDEXBonus() || 0) +\n        (this.equipment.ARMOR?.getDEXBonus() || 0) +\n        (this.equipment.ARMS?.getDEXBonus() || 0) +\n        (this.equipment.RIGHTHAND?.getDEXBonus() || 0) +\n        (this.equipment.LEFTHAND?.getDEXBonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getDEXBonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getDEXBonus() || 0) +\n        (this.equipment.IMPLANT?.getDEXBonus() || 0) +\n        (this.equipment.BELT?.getDEXBonus() || 0) +\n        (this.equipment.CLAW1?.getDEXBonus() || 0) +\n        (this.equipment.CLAW2?.getDEXBonus() || 0) +\n        (this.equipment.HIDE?.getDEXBonus() || 0);\n    }\n  }\n\n  getCON(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.con;\n    } else {\n      return this.con +\n        (this.equipment.HEAD?.getCONBonus() || 0) +\n        (this.equipment.ARMOR?.getCONBonus() || 0) +\n        (this.equipment.ARMS?.getCONBonus() || 0) +\n        (this.equipment.RIGHTHAND?.getCONBonus() || 0) +\n        (this.equipment.LEFTHAND?.getCONBonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getCONBonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getCONBonus() || 0) +\n        (this.equipment.IMPLANT?.getCONBonus() || 0) +\n        (this.equipment.BELT?.getCONBonus() || 0) +\n        (this.equipment.CLAW1?.getCONBonus() || 0) +\n        (this.equipment.CLAW2?.getCONBonus() || 0) +\n        (this.equipment.HIDE?.getCONBonus() || 0);\n    }\n  }\n\n  getCHA(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.cha;\n    } else {\n      return this.cha +\n        (this.equipment.HEAD?.getCHABonus() || 0) +\n        (this.equipment.ARMOR?.getCHABonus() || 0) +\n        (this.equipment.ARMS?.getCHABonus() || 0) +\n        (this.equipment.RIGHTHAND?.getCHABonus() || 0) +\n        (this.equipment.LEFTHAND?.getCHABonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getCHABonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getCHABonus() || 0) +\n        (this.equipment.IMPLANT?.getCHABonus() || 0) +\n        (this.equipment.BELT?.getCHABonus() || 0) +\n        (this.equipment.CLAW1?.getCHABonus() || 0) +\n        (this.equipment.CLAW2?.getCHABonus() || 0) +\n        (this.equipment.HIDE?.getCHABonus() || 0);\n    }\n  }\n\n  getWIS(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.wis;\n    } else {\n      return this.wis +\n        (this.equipment.HEAD?.getWISBonus() || 0) +\n        (this.equipment.ARMOR?.getWISBonus() || 0) +\n        (this.equipment.ARMS?.getWISBonus() || 0) +\n        (this.equipment.RIGHTHAND?.getWISBonus() || 0) +\n        (this.equipment.LEFTHAND?.getWISBonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getWISBonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getWISBonus() || 0) +\n        (this.equipment.IMPLANT?.getWISBonus() || 0) +\n        (this.equipment.BELT?.getWISBonus() || 0) +\n        (this.equipment.CLAW1?.getWISBonus() || 0) +\n        (this.equipment.CLAW2?.getWISBonus() || 0) +\n        (this.equipment.HIDE?.getWISBonus() || 0);\n    }\n  }\n\n  getINT(calculateBonuses = true) {\n    if (!calculateBonuses) {\n      return this.int;\n    } else {\n      return this.int +\n        (this.equipment.HEAD?.getINTBonus() || 0) +\n        (this.equipment.ARMOR?.getINTBonus() || 0) +\n        (this.equipment.ARMS?.getINTBonus() || 0) +\n        (this.equipment.RIGHTHAND?.getINTBonus() || 0) +\n        (this.equipment.LEFTHAND?.getINTBonus() || 0) +\n        (this.equipment.LEFTARMBAND?.getINTBonus() || 0) +\n        (this.equipment.RIGHTARMBAND?.getINTBonus() || 0) +\n        (this.equipment.IMPLANT?.getINTBonus() || 0) +\n        (this.equipment.BELT?.getINTBonus() || 0) +\n        (this.equipment.CLAW1?.getINTBonus() || 0) +\n        (this.equipment.CLAW2?.getINTBonus() || 0) +\n        (this.equipment.HIDE?.getINTBonus() || 0);\n    }\n  }\n\n  getSpellSaveDC() {\n    return 10 + this.getSpellCasterLevel();\n  }\n\n  getSpellCasterLevel() {\n    let level = 0;\n    for (let i = 0; i < this.classes.length; i++) {\n      if (this.classes[i].spellcaster) {\n        level += this.classes[i].level;\n      }\n    }\n    return level;\n  }\n\n  getIsPC() {\n    return this.isPC;\n  }\n\n  getPortraitId() {\n    return this.portraitId;\n  }\n\n  getPortraitResRef() {\n    if (!this.portrait) return '';\n    return this.portrait.getPortraitGoodEvil(this.goodEvil);\n  }\n\n  getWalkRateId() {\n\n    if (GameState.PartyManager.party.indexOf(this) >= 0) {\n      return 0;\n    }\n\n    return this.walkRate;\n  }\n\n  getName() {\n    return this.firstName;\n  }\n\n  getAppearance(): SWCreatureAppearance {\n    return this.creatureAppearance;\n  }\n\n  isWalking() {\n    if (this.action && this.action.type == ActionType.ActionMoveToPoint) {\n      return !this.action.getParameter(5) ? true : false;\n    }\n    return this.walk;\n  }\n\n  getRunSpeed() {\n    if (this.getWalkRateId() == 7) {\n      return this.creatureAppearance.rundist\n    }\n    const creaturespeed2DA = GameState.TwoDAManager.datatables.get('creaturespeed');\n    if (creaturespeed2DA) {\n      return parseFloat(String(creaturespeed2DA.rows[this.getWalkRateId()]?.['runrate'] ?? ''));\n    }\n  }\n\n  getWalkSpeed() {\n    if (this.getWalkRateId() == 7) {\n      return this.creatureAppearance.walkdist\n    }\n    const creaturespeed2DA = GameState.TwoDAManager.datatables.get('creaturespeed');\n    if (creaturespeed2DA) {\n      return parseFloat(String(creaturespeed2DA.rows[this.getWalkRateId()]?.['walkrate'] ?? ''));\n    }\n  }\n\n  getMovementSpeed() {\n    return (this.isWalking() ? this.getWalkSpeed() : this.getRunSpeed()) * this.movementSpeed;\n  }\n\n  getHitDistance() {\n    return this.creatureAppearance.hitdist;\n  }\n\n  getMainClass() {\n    if (!this.classes.length)\n      return false;\n\n    return this.classes[this.classes.length - 1];\n  }\n\n  getTotalClassLevel() {\n    let total = 0;\n    for (let i = 0, len = this.classes.length; i < len; i++) {\n      total += this.classes[i].level;\n    }\n    return total;\n  }\n\n  getClassLevel(nClass = 0) {\n    for (let i = 0, len = this.classes.length; i < len; i++) {\n      if (this.classes[i].id == nClass) {\n        return this.classes[i].level;\n      }\n    }\n    return 0;\n  }\n\n  //Does the creature have enough EXP to level up\n  canLevelUp() {\n    const level = this.getTotalClassLevel();\n    const exptable2DA = GameState.TwoDAManager.datatables.get('exptable');\n    if (exptable2DA) {\n      const nextLevelEXP = exptable2DA.rows[level];\n      if (nextLevelEXP != null && this.getXP() >= parseInt(String(nextLevelEXP['xp'] ?? ''), 10)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  //Get the effective creature level based on the creatures current amount of EXP\n  getEffectiveLevel() {\n    let level = 0;\n\n    const exptable2DA = GameState.TwoDAManager.datatables.get('exptable');\n    if (exptable2DA) {\n      const totalLevels = exptable2DA.RowCount;\n      const expLevels = exptable2DA.rows;\n\n      for (let i = 0; i < totalLevels; i++) {\n        if (this.getXP() > parseInt(String(expLevels[i]?.['level'] ?? ''), 10)) {\n          level = i;\n        }\n      }\n    }\n\n    return level;\n  }\n\n  autoLevelUp() {\n    if (this.canLevelUp()) {\n      const mainClass = this.getMainClass();\n      if (!mainClass) { return; }\n\n      mainClass.level += 1;\n\n      if (this.getTotalClassLevel() % 4 == 0) {\n        switch (mainClass.primaryabil.toLowerCase()) {\n          case 'str':\n            this.str += 1;\n            break;\n          case 'con':\n            this.con += 1;\n            break;\n          case 'dex':\n            this.dex += 1;\n            break;\n          case 'wis':\n            this.wis += 1;\n            break;\n          case 'cha':\n            this.cha += 1;\n            break;\n          case 'int':\n            this.int += 1;\n            break;\n        }\n      }\n\n      this.maxHitPoints += mainClass.hitdie + ((this.getCON() - 10) / 2);\n      this.currentHitPoints = 0;\n\n    }\n  }\n\n  getBaseAttackBonus() {\n    let bab = 0;\n    for (let i = 0, len = this.classes.length; i < len; i++) {\n      bab += this.classes[i].getBaseAttackBonus();\n    }\n\n    const strMod = Math.floor((this.getSTR() - 10) / 2);\n    const dexMod = Math.floor((this.getDEX() - 10) / 2);\n\n    if (strMod > dexMod) {\n      bab += strMod;\n    } else if (dexMod > strMod) {\n      bab += dexMod;\n    }\n\n    return bab;\n  }\n\n  getFeats() {\n    return this.feats || [];\n  }\n\n  getFeat(id = 0) {\n    const feats = this.getFeats();\n    for (let i = 0, len = feats.length; i < len; i++) {\n      if (feats[i].id == id) {\n        return feats[i];\n      }\n    }\n    return null;\n  }\n\n  addFeat(feat: number | TalentFeat = 0) {\n    if (feat instanceof TalentFeat) {\n      if (!this.getFeat(feat.id)) {\n        this.feats.push(feat);\n      }\n    } else {\n      if (!this.getFeat(feat)) {\n        this.feats.push(new TalentFeat(feat));\n      }\n    }\n  }\n\n  getHasFeat(id: number = 0) {\n    const feats = this.getFeats();\n    for (let i = 0, len = feats.length; i < len; i++) {\n      if (feats[i].id == id) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getHasSkill(value: number) {\n    return this.skills[value].rank > 0;\n  }\n\n  getSkillLevel(value: number) {\n    return this.skills[value].rank;\n  }\n\n  getHasSpell(id = 0) {\n    return (this.getSpell(id) instanceof TalentSpell) ? true : false;\n  }\n\n  getSpell(id = 0) {\n    for (let i = 0; i < this.classes.length; i++) {\n      const cls = this.classes[i];\n      const spells = cls.getSpells();\n      for (let j = 0, len = spells.length; j < len; j++) {\n        const spell = spells[j];\n        if (spell.id == id)\n          return spell;\n      }\n    }\n\n    if (typeof this.equipment.RIGHTARMBAND != 'undefined') {\n      const spells = this.equipment.RIGHTARMBAND.getSpells();\n      for (let i = 0, len = spells.length; i < len; i++) {\n        if (spells[i].id == id) {\n          return spells[i];\n        }\n      }\n    }\n\n    if (typeof this.equipment.LEFTARMBAND != 'undefined') {\n      const spells = this.equipment.LEFTARMBAND.getSpells();\n      for (let i = 0, len = spells.length; i < len; i++) {\n        if (spells[i].id == id) {\n          return spells[i];\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  hasTalent(talent: TalentObject) {\n    //log.debug('hasTalent', talent);\n    if (typeof talent != 'undefined') {\n      switch (talent.objectType) {\n        case 0: //Force / Spell\n          return this.getHasSpell(talent.id) ? true : false;\n        case 1: //Feat\n          return this.getHasFeat(talent.id) ? true : false;\n        case 2: //Skill\n          return this.getHasSkill(talent.id) ? true : false;\n      }\n    }\n    return false;\n  }\n\n  getTalents() {\n\n    let talents: TalentObject[] = [];\n\n    //Merge Spell Talents from all classs\n    for (let i = 0; i < this.classes.length; i++) {\n      talents = talents.concat(this.classes[i].getSpells());\n    }\n\n    //Merge Feat Talents\n    talents = talents.concat(this.feats);\n    //Merge Skill Talents\n    talents = talents.concat(this.skills);\n\n    return talents;\n\n  }\n\n  getSpells(): TalentSpell[] {\n    const spells: TalentSpell[] = [];\n\n    for (let i = 0, len = this.classes.length; i < len; i++) {\n      spells.push(...this.classes[i].getSpells());\n    }\n\n    if (typeof this.equipment.RIGHTARMBAND != 'undefined') {\n      spells.push(...this.equipment.RIGHTARMBAND.getSpells());\n    }\n\n    if (typeof this.equipment.LEFTARMBAND != 'undefined') {\n      spells.push(...this.equipment.LEFTARMBAND.getSpells());\n    }\n\n    return spells;\n  }\n\n  getClassSpells() {\n    const spells = [];\n\n    for (let i = 0, len = this.classes.length; i < len; i++) {\n      spells.push(...this.classes[i].getSpells());\n    }\n\n    return spells;\n  }\n\n  getRandomTalent(category = 0, category2 = 0) {\n\n    const talents = this.getTalents().filter((talent: TalentObject) => talent.category == category || talent.category == category2);\n    const talent = talents[Math.floor(Math.random() * talents.length)];\n    //log.debug('getRandomTalent', talent);\n    return talent;\n\n  }\n\n  getTalentBest(nCategory = 0, nCRMax = 0, nInclusion = 0, nExcludeType = -1, nExcludeId = -1) {\n    const talents = this.getTalents().filter((talent: TalentObject) => (talent.category > -1 && ((talent.category & nCategory) == nCategory) && talent.maxCR <= nCRMax));\n    talents.sort((a: TalentObject, b: TalentObject) => (a.maxCR > b.maxCR) ? 1 : -1);\n    //log.debug('getTalentBest', talents);\n    if (talents.length) {\n      return talents[0];\n    }\n    return undefined;\n  }\n\n  isSimpleCreature() {\n    if (!this.creatureAppearance) return false;\n    return this.creatureAppearance.modeltype === 'S' || this.creatureAppearance.modeltype === 'L';\n  }\n\n  setListening(bVal = false) {\n    this.isListening = bVal ? true : false;\n  }\n\n  setListeningPattern(sString = '', iNum = 0) {\n    this.listeningPatterns[sString] = iNum;\n  }\n\n  getPersonalSpace() {\n    return this.creatureAppearance.perspace;\n  }\n\n  initEffects(): void {\n    const eRacialType = new EffectRacialType();\n    eRacialType.setSubType(GameEffectDurationType.INNATE);\n    eRacialType.setSkipOnLoad(true);\n    eRacialType.setInt(0, this.getRace());\n    this.addEffect(eRacialType);\n\n    this.initPerceptionList();\n    this.updateCollision();\n\n    super.initEffects();\n  }\n\n  load() {\n    if (this.getTemplateResRef()) {\n      //Load template and merge fields\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['utc'], String(this.getTemplateResRef() ?? ''));\n      if (buffer) {\n        const gff = new GFFObject(buffer);\n        this.template.merge(gff);\n        this.initProperties();\n        this.loadScripts();\n        GameState.FactionManager.AddCreatureToFaction(this);\n      } else {\n        log.error('Failed to load character template');\n        if (this.template instanceof GFFObject) {\n          this.initProperties();\n          this.loadScripts();\n        }\n      }\n    } else {\n      //We already have the template (From SAVEGAME)\n      this.initProperties();\n      this.loadScripts();\n      GameState.FactionManager.AddCreatureToFaction(this);\n    }\n\n    if (!this.debugLabel) {\n      this.debugLabel = new TextSprite3D(`${this.getName()} | ${this.getTag()}`);\n      this.debugLabel.setColor(this.helperColor);\n      this.debugLabel.container.visible = !!this.context?.GetDebugState(EngineDebugType.OBJECT_LABELS);\n      this.container.add(this.debugLabel.container);\n    }\n  }\n\n  loadScripts() {\n\n    const scriptKeys = [\n      ModuleObjectScript.CreatureOnAttacked,\n      ModuleObjectScript.CreatureOnDamaged,\n      ModuleObjectScript.CreatureOnDeath,\n      ModuleObjectScript.CreatureOnDialog,\n      ModuleObjectScript.CreatureOnDisturbed,\n      ModuleObjectScript.CreatureOnEndDialog,\n      ModuleObjectScript.CreatureOnEndRound,\n      ModuleObjectScript.CreatureOnHeartbeat,\n      ModuleObjectScript.CreatureOnBlocked,\n      ModuleObjectScript.CreatureOnNotice,\n      ModuleObjectScript.CreatureOnRested,\n      ModuleObjectScript.CreatureOnSpawn,\n      ModuleObjectScript.CreatureOnSpellAt,\n      ModuleObjectScript.CreatureOnUserDefined,\n    ];\n\n    const scriptsNode = this.template?.RootNode;\n    if (!scriptsNode) { return; }\n\n    for (const scriptKey of scriptKeys) {\n      if (scriptsNode.hasField(scriptKey)) {\n        const resRef = scriptsNode.getStringByLabel(scriptKey);\n        if (!resRef) { continue; }\n        const nwscript = GameState.NWScript.Load(resRef);\n        if (!nwscript) {\n          log.warn(`ModuleCreature.loadScripts: Failed to load script [${scriptKey}]:${resRef} for object ${this.name}`);\n          continue;\n        }\n        nwscript.caller = this;\n        this.scripts[scriptKey] = nwscript;\n      }\n    }\n\n  }\n\n  async loadModel(): Promise<OdysseyModel3D> {\n    this.isReady = false;\n    await this.loadEquipmentModels();\n    await this.loadBody();\n    await this.loadHead();\n    this.isReady = true;\n    this.updateCollision(0.0000000000000000000001);\n    this.update(0.0000000000000000000001);\n    return this.model;\n  }\n\n  async loadBody() {\n    const appearance = this.creatureAppearance;\n    const bodyVariation: string = this.equipment.ARMOR?.getBodyVariation() || '';\n    const textureVariation: number = this.equipment.ARMOR?.getTextureVariation() || 1;\n    const { model: bodyModel, texture: bodyTexture } = appearance.getBodyModelInfo(bodyVariation, textureVariation);\n    this.bodyModel = bodyModel;\n    this.bodyTexture = typeof bodyTexture === 'number' ? bodyTexture : (parseInt(String(bodyTexture), 10) || 0);\n\n    if (!this.bodyModel || this.bodyModel.length === 0) {\n      this.model = new OdysseyModel3D();\n      return this.model;\n    }\n\n    try {\n      const mdl = await MDLLoader.loader.load(this.bodyModel);\n      const model = await OdysseyModel3D.FromMDL(mdl, {\n        castShadow: true,\n        receiveShadow: true,\n        textureVar: String(this.bodyTexture ?? ''),\n        isHologram: this.isHologram,\n        context: this.context,\n      });\n\n      if (this.model) {\n        this.model.removeFromParent();\n        try { this.model.dispose(); } catch (e) { /* empty */ }\n      }\n\n      (model as THREE.Object3D).addEventListener('playEvent' as keyof THREE.Object3DEventMap, this.playEvent.bind(this) as (e: THREE.Event) => void);\n\n      this.model = model;\n      this.model.userData.moduleObject = this;\n      this.container.add(this.model);\n      this.box.setFromObject(this.container);\n\n      try {\n        if (this.model.lhand instanceof OdysseyObject3D) {\n          if (this.equipment.LEFTHAND && this.equipment.LEFTHAND.model instanceof OdysseyModel3D) {\n            this.model.lhand.add(this.equipment.LEFTHAND.model);\n          }\n        }\n      } catch (e) {\n        log.error('ModuleCreature.LoadBody', e);\n      }\n\n      try {\n        if (this.model.rhand instanceof OdysseyObject3D) {\n          if (this.equipment.RIGHTHAND && this.equipment.RIGHTHAND.model instanceof OdysseyModel3D) {\n            this.model.rhand.add(this.equipment.RIGHTHAND.model);\n          }\n        }\n      } catch (e) {\n        log.error('ModuleCreature.LoadBody', e);\n      }\n\n      this.model.disableMatrixUpdate();\n      return this.model;\n    } catch (e) {\n      log.error(e);\n      this.model = new OdysseyModel3D();\n      return this.model;\n    }\n  }\n\n  async loadHead(): Promise<OdysseyModel3D> {\n    const appearance = this.creatureAppearance;\n    const headId = appearance.normalhead;//.replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\n    this.headModel = undefined;\n    if (!(headId >= 0 && appearance.modeltype == 'B')) {\n      return;\n    }\n\n    const headDetails = GameState.SWRuleSet.heads[headId];\n    if (!headDetails) {\n      return;\n    }\n\n    const headTexture = headDetails.getTextureGoodEvil(this.getGoodEvil());\n    this.headModel = headDetails.head;\n    const mdl = await MDLLoader.loader.load(this.headModel);\n\n    const head = await OdysseyModel3D.FromMDL(mdl, {\n      context: this.context,\n      castShadow: true,\n      receiveShadow: true,\n      isHologram: this.isHologram,\n      textureVar: headTexture,\n    });\n\n    try {\n      if (this.head instanceof OdysseyModel3D && this.head.parent) {\n        this.head.parent.remove(this.head);\n        this.head.dispose();\n      }\n\n      this.head = head;\n      this.head.userData.moduleObject = this;\n      this.model.attachHead(head);\n\n      try {\n        if (this.head.gogglehook instanceof THREE.Object3D) {\n          if (this.equipment.HEAD && this.equipment.HEAD.model instanceof OdysseyModel3D) {\n            this.head.gogglehook.add(this.equipment.HEAD.model);\n          }\n        }\n      } catch (e) {\n        log.error('ModuleCreature', e);\n      }\n\n      this.head.disableMatrixUpdate();\n      return this.head;\n    }\n    catch (e) {\n      log.error(e);\n    }\n  }\n\n  /*getEquip_ItemList(){\n    if(this.template.RootNode.hasField('Equip_ItemList')){\n      return this.template.getFieldByLabel('Equip_ItemList').getChildStructs()\n    }\n    return [];\n  }*/\n\n  async equipItem(slot = 0x1, item: ModuleItem) {\n    if (!item) {\n      return;\n    }\n\n    this.unequipSlot(slot);\n    item.onEquip(this);\n    await item.loadModel();\n    switch (slot) {\n      case ModuleCreatureArmorSlot.ARMOR:\n        this.equipment.ARMOR = item;\n        await this.loadModel();\n        break;\n      case ModuleCreatureArmorSlot.RIGHTHAND:\n        this.equipment.RIGHTHAND = item;\n        await item.loadModel();\n        if (item.model instanceof OdysseyModel3D)\n          this.model.rhand.add(item.model);\n        break;\n      case ModuleCreatureArmorSlot.LEFTHAND:\n        this.equipment.LEFTHAND = item;\n        await item.loadModel();\n        if (item.model instanceof OdysseyModel3D)\n          this.model.lhand.add(item.model);\n        break;\n      case ModuleCreatureArmorSlot.RIGHTHAND2:\n        this.equipment.RIGHTHAND2 = item;\n        break;\n      case ModuleCreatureArmorSlot.LEFTHAND2:\n        this.equipment.LEFTHAND2 = item;\n        break;\n      case ModuleCreatureArmorSlot.CLAW1:\n        this.equipment.CLAW1 = item;\n        break;\n      case ModuleCreatureArmorSlot.CLAW2:\n        this.equipment.CLAW2 = item;\n        break;\n      case ModuleCreatureArmorSlot.CLAW3:\n        this.equipment.CLAW3 = item;\n        break;\n    }\n  }\n\n  unequipSlot(slot = 0x1) {\n    try {\n      switch (slot) {\n        case ModuleCreatureArmorSlot.IMPLANT:\n          try {\n            if (this.equipment.IMPLANT) {\n              this.equipment.IMPLANT.onUnEquip(this);\n              this.equipment.IMPLANT.destroy();\n              this.equipment.IMPLANT = undefined;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.HEAD:\n\n          if (this.equipment.HEAD) {\n            this.equipment.HEAD.onUnEquip(this);\n          }\n\n          try {\n            this.equipment.HEAD.model.parent.remove(this.equipment.HEAD.model);\n          } catch (_e) { /* empty */ }\n\n          this.equipment.HEAD = undefined;\n          this.loadModel();\n          break;\n        case ModuleCreatureArmorSlot.ARMS:\n          try {\n            if (this.equipment.ARMS) {\n              this.equipment.ARMS.onUnEquip(this);\n              this.equipment.ARMS.destroy();\n              this.equipment.ARMS = undefined;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.RIGHTARMBAND:\n          try {\n            if (this.equipment.RIGHTARMBAND) {\n              this.equipment.RIGHTARMBAND.onUnEquip(this);\n              this.equipment.RIGHTARMBAND.destroy();\n              this.equipment.RIGHTARMBAND = undefined;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.LEFTARMBAND:\n          try {\n            if (this.equipment.LEFTARMBAND) {\n              this.equipment.LEFTARMBAND.onUnEquip(this);\n              this.equipment.LEFTARMBAND.destroy();\n              this.equipment.LEFTARMBAND = undefined;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.ARMOR:\n\n          if (this.equipment.ARMOR) {\n            this.equipment.ARMOR.onUnEquip(this);\n          }\n\n          this.equipment.ARMOR = undefined;\n          this.loadModel();\n          break;\n        case ModuleCreatureArmorSlot.RIGHTHAND:\n          try {\n            if (this.equipment.RIGHTHAND) {\n              this.equipment.RIGHTHAND.onUnEquip(this);\n              this.model.rhand.remove(this.equipment.RIGHTHAND.model);\n              this.equipment.RIGHTHAND.destroy();\n              this.equipment.RIGHTHAND = undefined;\n            }\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          } catch (e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.RIGHTHAND2:\n          try {\n            if (this.equipment.RIGHTHAND2) {\n              this.equipment.RIGHTHAND2.onUnEquip(this);\n              // this.model.rhand.remove(this.equipment.RIGHTHAND2.model);\n              this.equipment.RIGHTHAND2.destroy();\n              this.equipment.RIGHTHAND2 = undefined;\n            }\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.BELT:\n          try {\n            if (this.equipment.BELT) {\n              this.equipment.BELT.onUnEquip(this);\n              this.model.rhand.remove(this.equipment.BELT.model);\n              this.equipment.BELT.destroy();\n              this.equipment.BELT = undefined;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.LEFTHAND:\n          try {\n            if (this.equipment.LEFTHAND) {\n              this.equipment.LEFTHAND.onUnEquip(this);\n              this.model.lhand.remove(this.equipment.LEFTHAND.model);\n              this.equipment.LEFTHAND.destroy();\n              this.equipment.LEFTHAND = null;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n        case ModuleCreatureArmorSlot.LEFTHAND2:\n          try {\n            if (this.equipment.LEFTHAND2) {\n              this.equipment.LEFTHAND2.onUnEquip(this);\n              // this.model.lhand.remove(this.equipment.LEFTHAND2.model);\n              this.equipment.LEFTHAND2.destroy();\n              this.equipment.LEFTHAND2 = null;\n            }\n          } catch (_e) { /* empty */ }\n          break;\n      }\n    } catch (e) {\n      log.error('unequipItem', e);\n    }\n  }\n\n  UnequipItems() {\n    //this.unequipSlot(ModuleCreatureArmorSlot.ARMOR);\n    this.unequipSlot(ModuleCreatureArmorSlot.LEFTHAND);\n    this.unequipSlot(ModuleCreatureArmorSlot.RIGHTHAND);\n  }\n\n  UnequipHeadItem() {\n    this.unequipSlot(ModuleCreatureArmorSlot.HEAD);\n  }\n\n  GetItemInSlot(slot = 0) {\n\n    switch (slot) {\n      case ModuleCreatureArmorSlot.IMPLANT:\n        return this.equipment.IMPLANT;\n      case ModuleCreatureArmorSlot.HEAD:\n        return this.equipment.HEAD;\n      case ModuleCreatureArmorSlot.ARMS:\n        return this.equipment.ARMS;\n      case ModuleCreatureArmorSlot.LEFTARMBAND:\n        return this.equipment.LEFTARMBAND;\n      case ModuleCreatureArmorSlot.ARMOR:\n        return this.equipment.ARMOR;\n      case ModuleCreatureArmorSlot.RIGHTARMBAND:\n        return this.equipment.RIGHTARMBAND;\n      case ModuleCreatureArmorSlot.LEFTHAND:\n        return this.equipment.LEFTHAND;\n      case ModuleCreatureArmorSlot.LEFTHAND2:\n        return this.equipment.LEFTHAND2;\n      case ModuleCreatureArmorSlot.BELT:\n        return this.equipment.BELT;\n      case ModuleCreatureArmorSlot.RIGHTHAND:\n        return this.equipment.RIGHTHAND;\n      case ModuleCreatureArmorSlot.RIGHTHAND2:\n        return this.equipment.RIGHTHAND2;\n      case ModuleCreatureArmorSlot.HIDE:\n        return this.equipment.HIDE;\n      case ModuleCreatureArmorSlot.CLAW1:\n        return this.equipment.CLAW1;\n      case ModuleCreatureArmorSlot.CLAW2:\n        return this.equipment.CLAW2;\n      case ModuleCreatureArmorSlot.CLAW3:\n        return this.equipment.CLAW3;\n      default:\n        return null;\n    }\n\n  }\n\n  initProperties() {\n    try {\n      this.classes = [];\n      this.feats = [];\n      this.skills = GameState.SWRuleSet.skills.slice(0).map((skill: TalentSkill) => {\n        return skill.clone();\n      });\n\n      if (!this.initialized) {\n        if (BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlayer)) {\n          this.id = GameState.ModuleObjectManager.GetNextPlayerId();\n        } else if (this.template.RootNode.hasField('ObjectId')) {\n          this.id = this.template.getNumberByLabel('ObjectId');\n        } else if (this.template.RootNode.hasField('ID')) {\n          this.id = this.template.getNumberByLabel('ID');\n        }\n\n        GameState.ModuleObjectManager.AddObjectById(this);\n      }\n\n      if (this.template.RootNode.hasField('Appearance_Type')) {\n        this.appearance = this.template.getNumberByLabel('Appearance_Type');\n        this.creatureAppearance = GameState.AppearanceManager.GetCreatureAppearanceById(this.appearance);\n      }\n\n      if (this.template.RootNode.hasField('BodyBag'))\n        this.bodyBag = this.template.getNumberByLabel('BodyBag');\n\n      if (this.template.RootNode.hasField('BodyVariation'))\n        this.bodyBag = this.template.getNumberByLabel('BodyVariation');\n\n      if (this.template.RootNode.hasField('ChallengeRating'))\n        this.challengeRating = this.template.getNumberByLabel('ChallengeRating');\n\n      if (this.template.RootNode.hasField('ClassList')) {\n        const classes = this.template.RootNode.getFieldByLabel('ClassList').getChildStructs();\n        for (let i = 0; i < classes.length; i++) {\n          this.classes.push(\n            CreatureClass.FromCreatureClassStruct(classes[i])\n          );\n        }\n      }\n\n      if (this.template.RootNode.hasField('Conversation')) {\n        this.conversation = DLGObject.FromResRef(this.template.getStringByLabel('Conversation'));\n      }\n\n      if (this.template.RootNode.hasField('CurrentForce'))\n        this.currentForce = this.template.getNumberByLabel('CurrentForce');\n\n      if (this.template.RootNode.hasField('CurrentHitPoints'))\n        this.currentHitPoints = this.template.getNumberByLabel('CurrentHitPoints');\n\n      if (this.template.RootNode.hasField('HitPoints'))\n        this.hitPoints = this.template.getNumberByLabel('HitPoints');\n\n      if (this.template.RootNode.hasField('Disarmable'))\n        this.disarmable = this.template.getNumberByLabel('Disarmable');\n\n      if (this.template.RootNode.hasField('Experience'))\n        this.experience = this.template.RootNode.getNumberByLabel('Experience');\n\n      if (this.template.RootNode.hasField('Listening')) {\n        this.setListening(this.template.RootNode.getNumberByLabel('Listening') !== 0);\n      }\n      if (this.template.RootNode.hasField('Commandable')) {\n        this.setCommadable(this.template.RootNode.getNumberByLabel('Commandable') !== 0);\n      }\n\n      if (this.template.RootNode.hasField('ExpressionList')) {\n        const expressions = this.template.RootNode.getFieldByLabel('ExpressionList').getChildStructs();\n        for (let i = 0; i < expressions.length; i++) {\n          this.setListeningPattern(\n            expressions[i].getStringByLabel('ExpressionString'),\n            expressions[i].getNumberByLabel('ExpressionId')\n          );\n        }\n      }\n\n      if (this.template.RootNode.hasField('FactionID')) {\n        this.factionId = this.template.getNumberByLabel('FactionID');\n        if ((this.factionId & 0xFFFFFFFF) == -1) {\n          this.factionId = 0;\n        }\n      }\n      this.faction = GameState.FactionManager.factions.get(this.factionId);\n\n      if (this.template.RootNode.hasField('FeatList')) {\n        const feats = this.template.RootNode.getFieldByLabel('FeatList').getChildStructs();\n        for (let i = 0; i < feats.length; i++) {\n          this.feats.push(\n            new TalentFeat(feats[i].getNumberByLabel('Feat'))\n          );\n        }\n      }\n\n      if (this.template.RootNode.hasField('FirstName'))\n        this.firstName = this.template.RootNode.getStringByLabel('FirstName');\n\n      if (this.template.RootNode.hasField('ForcePoints'))\n        this.forcePoints = this.template.RootNode.getNumberByLabel('ForcePoints');\n\n      if (this.template.RootNode.hasField('Gender'))\n        this.gender = this.template.RootNode.getNumberByLabel('Gender');\n\n      if (this.template.RootNode.hasField('GoodEvil'))\n        this.goodEvil = this.template.RootNode.getNumberByLabel('GoodEvil');\n\n      if (this.template.RootNode.hasField('Hologram'))\n        this.isHologram = this.template.getBooleanByLabel('Hologram');\n\n      if (this.template.RootNode.hasField('Interruptable'))\n        this.interruptable = this.template.getNumberByLabel('Interruptable');\n\n      if (this.template.RootNode.hasField('IsPC'))\n        this.isPC = this.template.getNumberByLabel('IsPC');\n\n      if (this.template.RootNode.hasField('LastName'))\n        this.lastName = this.template.getStringByLabel('LastName');\n\n      if (this.template.RootNode.hasField('MaxHitPoints')) {\n        this.maxHitPoints = this.template.getNumberByLabel('MaxHitPoints');\n      }\n\n      if (this.template.RootNode.hasField('MaxForcePoints')) {\n        this.maxForcePoints = this.template.getNumberByLabel('MaxForcePoints');\n      }\n\n      if (this.template.RootNode.hasField('Min1HP'))\n        this.min1HP = this.template.getNumberByLabel('Min1HP') !== 0;\n\n      if (this.template.RootNode.hasField('NaturalAC'))\n        this.naturalAC = this.template.getNumberByLabel('NaturalAC');\n\n      if (this.template.RootNode.hasField('NoPermDeath'))\n        this.noPermDeath = this.template.getNumberByLabel('NoPermDeath');\n\n      if (this.template.RootNode.hasField('NotReorienting'))\n        this.notReorienting = this.template.getNumberByLabel('NotReorienting');\n\n      if (this.template.RootNode.hasField('PartyInteract'))\n        this.partyInteract = this.template.getNumberByLabel('PartyInteract');\n\n      if (this.template.RootNode.hasField('PerceptionRange')) {\n        this.perceptionRange = GameState.SWRuleSet.ranges[this.template.getNumberByLabel('PerceptionRange')];\n      } else {\n        //https://forum.neverwintervault.org/t/perception-range/3191/9\n        //It appears that PerceptionRange isn't saved inside the GIT file.\n        //The original game appears to use PercepRngDefault when a creature is reloaded from a SaveGame\n        this.perceptionRange = GameState.SWRuleSet.ranges[11];\n      }\n\n      if (this.template.RootNode.hasField('Phenotype'))\n        this.phenotype = this.template.getNumberByLabel('Phenotype');\n\n      if (this.template.RootNode.hasField('Plot'))\n        this.plot = this.template.getBooleanByLabel('Plot');\n\n      if (this.template.RootNode.hasField('PortraitId')) {\n        this.portraitId = this.template.getNumberByLabel('PortraitId');\n        this.portrait = GameState.SWRuleSet.portraits[this.portraitId];\n      }\n\n      if (this.template.RootNode.hasField('Race'))\n        this.race = this.template.RootNode.getNumberByLabel('Race');\n\n      if (this.template.RootNode.hasField('SkillList')) {\n        const skills = this.template.RootNode.getFieldByLabel('SkillList').getChildStructs();\n        for (let i = 0; i < skills.length; i++) {\n          this.skills[i].rank = skills[i].getNumberByLabel('Rank');\n        }\n      }\n\n      if (this.template.RootNode.hasField('SoundSetFile'))\n        this.soundSetFile = this.template.RootNode.getNumberByLabel('SoundSetFile');\n\n      if (this.template.RootNode.hasField('SubRace'))\n        this.subrace = this.template.RootNode.getNumberByLabel('SubRace');\n\n      if (this.template.RootNode.hasField('Tag'))\n        this.tag = this.template.getStringByLabel('Tag');\n\n      if (this.template.RootNode.hasField('TemplateResRef'))\n        this.templateResRef = this.template.getStringByLabel('TemplateResRef');\n\n      if (this.template.RootNode.hasField('TextureVar'))\n        this.textureVar = this.template.getNumberByLabel('TextureVar');\n\n      if (this.template.RootNode.hasField('WalkRate'))\n        this.walkRate = this.template.getNumberByLabel('WalkRate');\n\n      if (this.template.RootNode.hasField('Str'))\n        this.str = this.template.getNumberByLabel('Str');\n\n      if (this.template.RootNode.hasField('Dex'))\n        this.dex = this.template.getNumberByLabel('Dex');\n\n      if (this.template.RootNode.hasField('Con'))\n        this.con = this.template.getNumberByLabel('Con');\n\n      if (this.template.RootNode.hasField('Cha'))\n        this.cha = this.template.getNumberByLabel('Cha');\n\n      if (this.template.RootNode.hasField('Wis'))\n        this.wis = this.template.getNumberByLabel('Wis');\n\n      if (this.template.RootNode.hasField('Int'))\n        this.int = this.template.getNumberByLabel('Int');\n\n      if (this.template.RootNode.hasField('XPosition'))\n        this.position.x = this.template.RootNode.getNumberByLabel('XPosition');\n\n      if (this.template.RootNode.hasField('YPosition'))\n        this.position.y = this.template.RootNode.getNumberByLabel('YPosition');\n\n      if (this.template.RootNode.hasField('ZPosition'))\n        this.position.z = this.template.RootNode.getNumberByLabel('ZPosition');\n\n      if (this.template.RootNode.hasField('XOrientation'))\n        this.xOrientation = this.template.RootNode.getNumberByLabel('XOrientation');\n\n      if (this.template.RootNode.hasField('YOrientation'))\n        this.yOrientation = this.template.RootNode.getNumberByLabel('YOrientation');\n\n      if (this.template.RootNode.hasField('ZOrientation'))\n        this.zOrientation = this.template.RootNode.getNumberByLabel('ZOrientation');\n\n      if (this.template.RootNode.hasField('FortSaveThrow'))\n        this.fortitudeSaveThrow = this.template.RootNode.getNumberByLabel('FortSaveThrow');\n\n      if (this.template.RootNode.hasField('RefSaveThrow'))\n        this.reflexSaveThrow = this.template.RootNode.getNumberByLabel('RefSaveThrow');\n\n      if (this.template.RootNode.hasField('WillSaveThrow'))\n        this.willSaveThrow = this.template.RootNode.getNumberByLabel('WillSaveThrow');\n\n      if (this.template.RootNode.hasField('SubraceIndex'))\n        this.subraceIndex = this.template.RootNode.getNumberByLabel('SubraceIndex');\n\n\n      if (this.template.RootNode.hasField('SWVarTable')) {\n        const localBools = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('BitArray').getChildStructs();\n        //log.debug(localBools);\n        for (let i = 0; i < localBools.length; i++) {\n          const data = localBools[i].getNumberByLabel('Variable');\n          for (let bit = 0; bit < 32; bit++) {\n            this._locals.Booleans[bit + (i * 32)] = ((data >> bit) % 2 != 0);\n          }\n        }\n        const localNumbers = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('ByteArray').getChildStructs();\n        //log.debug(localNumbers);\n        for (let i = 0; i < localNumbers.length; i++) {\n          const data = localNumbers[i].getNumberByLabel('Variable');\n          this.setLocalNumber(i, data);\n        }\n      }\n\n      if (this.template.RootNode.hasField('PM_Appearance'))\n        this.pm_Appearance = this.template.RootNode.getNumberByLabel('PM_Appearance');\n\n      if (this.template.RootNode.hasField('PM_IsDisguised'))\n        this.pm_IsDisguised = this.template.RootNode.getBooleanByLabel('PM_IsDisguised');\n\n      try {\n        if (this.template.RootNode.hasField('EffectList')) {\n          const effects = this.template.RootNode.getFieldByLabel('EffectList').getChildStructs() || [];\n          for (let i = 0; i < effects.length; i++) {\n            const effect = GameEffectFactory.EffectFromStruct(effects[i]);\n            if (effect) {\n              effect.setAttachedObject(this);\n              effect.loadModel();\n              //log.debug('attached');\n              this.effects.push(effect);\n              //this.addEffect(effect);\n            }\n          }\n        }\n      } catch (e: unknown) {\n        log.error(e);\n      }\n\n      try {\n        if (this.template.RootNode.hasField('Equip_ItemList')) {\n          const equipment = this.template.RootNode.getFieldByLabel('Equip_ItemList').getChildStructs() || [];\n          for (let i = 0; i < equipment.length; i++) {\n            const strt = equipment[i];\n            let equipped_item = undefined;\n            const slot_type = strt.type;\n            if (strt.hasField('EquippedRes')) {\n              equipped_item = new GameState.Module.ModuleArea.ModuleItem(strt.getStringByLabel('EquippedRes'));\n            } else {\n              equipped_item = new GameState.Module.ModuleArea.ModuleItem(GFFObject.FromStruct(strt));\n            }\n\n            switch (slot_type) {\n              case ModuleCreatureArmorSlot.HEAD:\n                this.equipment.HEAD = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.ARMS:\n                this.equipment.ARMS = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.ARMOR:\n                this.equipment.ARMOR = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.LEFTHAND:\n                this.equipment.LEFTHAND = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.LEFTHAND2:\n                this.equipment.LEFTHAND2 = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.RIGHTHAND:\n                this.equipment.RIGHTHAND = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.RIGHTHAND2:\n                this.equipment.RIGHTHAND2 = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.LEFTARMBAND:\n                this.equipment.LEFTARMBAND = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.RIGHTARMBAND:\n                this.equipment.RIGHTARMBAND = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.IMPLANT:\n                this.equipment.IMPLANT = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.BELT:\n                this.equipment.BELT = equipped_item;\n                break;\n\n              //Simple Creature Slots\n              case ModuleCreatureArmorSlot.HIDE:\n                this.equipment.HIDE = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.CLAW1:\n                this.equipment.CLAW1 = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.CLAW2:\n                this.equipment.CLAW2 = equipped_item;\n                break;\n              case ModuleCreatureArmorSlot.CLAW3:\n                this.equipment.CLAW3 = equipped_item;\n                break;\n              default:\n                log.warn('ModuleCreature.initProperties', 'Unhandled Equipment Slot', equipped_item);\n                break;\n            }\n          }\n        }\n      } catch (e: unknown) {\n        log.error(e);\n      }\n\n      this.parseEquipmentSlots();\n\n      if (this.template.RootNode.hasField('ItemList')) {\n        const inventory = this.template.RootNode.getFieldByLabel('ItemList').getChildStructs();\n        for (let i = 0; i < inventory.length; i++) {\n          this.loadItem(GFFObject.FromStruct(inventory[i]));\n        }\n      }\n      this.loadSoundSet();\n\n      //ActionList\n      try {\n        if (this.template.RootNode.hasField('ActionList')) {\n          const actionStructs = this.template.RootNode.getFieldByLabel('ActionList').getChildStructs();\n          for (let i = 0, len = actionStructs.length; i < len; i++) {\n            const action = GameState.ActionFactory.FromStruct(actionStructs[i]);\n            if (action) {\n              this.actionQueue.add(action);\n            }\n          }\n        }\n      } catch (e: unknown) {\n        log.error(e);\n      }\n\n      //PerceptionList\n      try {\n        if (this.template.RootNode.hasField('PerceptionList')) {\n          const perceptionList = this.template.RootNode.getFieldByLabel('PerceptionList').getChildStructs();\n          if (perceptionList.length) {\n            this.perceptionList = [];\n          }\n\n          for (let i = 0, len = perceptionList.length; i < len; i++) {\n            const perception = perceptionList[i];\n\n            const objectId = perception.getNumberByLabel('ObjectId');\n            const data = perception.getNumberByLabel('PerceptionData') as PerceptionType;\n\n            this.perceptionList.push({\n              object: undefined,\n              objectId,\n              data\n            });\n          }\n        }\n      } catch (e: unknown) {\n        log.error(e);\n      }\n    } catch (e: unknown) {\n      log.error(e);\n    }\n\n    if (this.template.RootNode.hasField('Animation')) {\n      this.setAnimationState(\n        this.template.getNumberByLabel('Animation')\n      );\n    }\n\n    this.initialized = true;\n\n  }\n\n  async loadEquipmentModels(): Promise<void> {\n    const array = Object.keys(this.equipment);\n    for (let i = 0; i < array.length; i++) {\n      const slot_key = array[i];\n      const slot: ModuleItem | undefined = this.equipment[slot_key];\n      if (!slot) {\n        continue;\n      }\n      const model = await slot.loadModel();\n      if (slot_key == 'RIGHTHAND' || slot_key == 'LEFTHAND') {\n        model.playAnimation('off', true);\n      }\n    }\n  }\n\n  parseEquipmentSlots() {\n    const slots = Object.keys(this.equipment);\n    for (let i = 0; i < slots.length; i++) {\n      const slotKey = slots[i];\n      const item: ModuleItem | undefined = this.equipment[slotKey];\n      if (item) {\n        item.setPossessor(this);\n        if (!item.load()) {\n          this.equipment[slotKey] = undefined;\n          item.destroy();\n        }\n      }\n    }\n  }\n\n  loadSoundSet() {\n    const soundset2DA = GameState.TwoDAManager.datatables.get('soundset');\n    if (soundset2DA) {\n      const ss_row = soundset2DA.rows[this.soundSetFile];\n      if (ss_row) {\n        const resref = String(ss_row['resref'] ?? '').toLowerCase();\n        const buffer = ResourceLoader.loadCachedResource(ResourceTypes.ssf, resref);\n        if (buffer) this.ssf = new SSFObject(buffer);\n      }\n    }\n  }\n\n  loadItem(template: GFFObject) {\n    const item = new GameState.Module.ModuleArea.ModuleItem(template);\n    item.initProperties();\n    if (!item.load()) {\n      return;\n    }\n    const hasItem = this.getItemByTag(item.getTag());\n    if (hasItem) {\n      hasItem.setStackSize(Number(hasItem.getStackSize() ?? 0) + 1);\n      return hasItem;\n    } else {\n      this.inventory.push(item);\n      return item;\n    }\n  }\n\n  playSoundSet(type = -1) {\n    if (!(this.ssf instanceof SSFObject)) {\n      return;\n    }\n    const resref = this.ssf.GetSoundResRef(type).replace(/\\0.*$/g, '');\n    if (resref != '') {\n      if (this.audioEmitter)\n        this.audioEmitter.playSoundFireAndForget(resref);\n    }\n  }\n\n  destroy(): void {\n    super.destroy();\n    if (this.head instanceof OdysseyModel3D) {\n      if (this.head.parent instanceof THREE.Object3D) {\n        this.head.parent.remove(this.model);\n      }\n      this.head.dispose();\n      this.head = undefined;\n    }\n\n    if (this.equipment.ARMOR) {\n      this.equipment.ARMOR.destroy();\n      this.equipment.ARMOR = undefined;\n    }\n\n    if (this.equipment.ARMS) {\n      this.equipment.ARMS.destroy();\n      this.equipment.ARMS = undefined;\n    }\n\n    if (this.equipment.BELT) {\n      this.equipment.BELT.destroy();\n      this.equipment.BELT = undefined;\n    }\n\n    if (this.equipment.CLAW1) {\n      this.equipment.CLAW1.destroy();\n      this.equipment.CLAW1 = undefined;\n    }\n\n    if (this.equipment.CLAW2) {\n      this.equipment.CLAW2.destroy();\n      this.equipment.CLAW2 = undefined;\n    }\n\n    if (this.equipment.CLAW3) {\n      this.equipment.CLAW3.destroy();\n      this.equipment.CLAW3 = undefined;\n    }\n\n    if (this.equipment.HEAD) {\n      this.equipment.HEAD.destroy();\n      this.equipment.HEAD = undefined;\n    }\n\n    if (this.equipment.HIDE) {\n      this.equipment.HIDE.destroy();\n      this.equipment.HIDE = undefined;\n    }\n\n    if (this.equipment.IMPLANT) {\n      this.equipment.IMPLANT.destroy();\n      this.equipment.IMPLANT = undefined;\n    }\n\n    if (this.equipment.LEFTARMBAND) {\n      this.equipment.LEFTARMBAND.destroy();\n      this.equipment.LEFTARMBAND = undefined;\n    }\n\n    if (this.equipment.LEFTHAND) {\n      this.equipment.LEFTHAND.destroy();\n      this.equipment.LEFTHAND = undefined;\n    }\n\n    if (this.equipment.LEFTHAND2) {\n      this.equipment.LEFTHAND2.destroy();\n      this.equipment.LEFTHAND2 = undefined;\n    }\n\n    if (this.equipment.RIGHTARMBAND) {\n      this.equipment.RIGHTARMBAND.destroy();\n      this.equipment.RIGHTARMBAND = undefined;\n    }\n\n    if (this.equipment.RIGHTHAND) {\n      this.equipment.RIGHTHAND.destroy();\n      this.equipment.RIGHTHAND = undefined;\n    }\n\n    if (this.equipment.RIGHTHAND2) {\n      this.equipment.RIGHTHAND2.destroy();\n      this.equipment.RIGHTHAND2 = undefined;\n    }\n\n    while (this.inventory.length) {\n      const item = this.inventory[0];\n      if (item) {\n        item.destroy();\n      }\n      this.inventory.splice(0, 1);\n    }\n\n    GameState.FactionManager.RemoveCreatureFromFaction(this);\n\n    if (this.debugLabel) {\n      this.debugLabel.dispose();\n    }\n  }\n\n  save() {\n\n    const gff = new GFFObject();\n    gff.FileType = 'UTC ';\n\n    gff.RootNode.addField(new GFFField(GFFDataType.DWORD, 'ObjectId')).setValue(this.id);\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Mod_CommntyName')).setValue('Bad StrRef');\n    if (this.playerCreated) {\n      gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Mod_IsPrimaryPlr')).setValue(1);\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'Mod_FirstName'))\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'Mod_LastName'))\n\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'AIState')).setValue(0);\n\n    gff.RootNode.addField(this.actionQueueToActionList());\n\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'Age')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'AmbientAnimState')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'Animation')).setValue(this.animationState.index);\n    //gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Appearance_Head') ).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'Appearance_Type')).setValue(this.appearance);\n    //gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'AreaId') ).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'ArmorClass')).setValue(this.getAC());\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'BodyBag')).setValue(this.bodyBag);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Cha')).setValue(this.cha);\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'ChallengeRating')).setValue(this.challengeRating);\n\n    //Classes\n    const classList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'ClassList'));\n    for (let i = 0; i < this.classes.length; i++) {\n      classList.addChildStruct(this.classes[i].save());\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Color_Hair')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Color_Skin')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Color_Tattoo1')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Color_Tattoo2')).setValue(0);\n\n    const combatInfoStruct = gff.RootNode.addField(new GFFField(GFFDataType.STRUCT, 'CombatInfo'));\n\n    //TODO: CombatInfo\n\n    const combatRoundDataStruct = gff.RootNode.addField(new GFFField(GFFDataType.STRUCT, 'CombatRoundData'));\n\n    //TODO: CombatRoundData\n\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Commandable')).setValue(this.getCommadable() ? 1 : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Con')).setValue(this.str);\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Conversation')).setValue(this.conversation ? this.conversation.resref : '');\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'CreatnScrptFird')).setValue(this.spawned ? 1 : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'CreatureSize')).setValue(3);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'CurrentForce')).setValue(this.currentForce);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'CurrentHitPoints')).setValue(this.currentHitPoints);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'DeadSelectable')).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Deity')).setValue('');\n    //gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'Description') ).setValue();\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'DetectMode')).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Dex')).setValue(this.dex);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Disarmable')).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'DuplicatingHead')).setValue(255);\n\n    //Effects\n    const effectList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'EffectList'));\n    for (let i = 0; i < this.effects.length; i++) {\n      effectList.addChildStruct(this.effects[i].save());\n    }\n\n    //Equipment\n    const equipItemList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'Equip_ItemList'));\n\n    if (this.equipment.ARMOR) {\n      const equipItem = this.equipment.ARMOR.save();\n      equipItem.setType(ModuleCreatureArmorSlot.ARMOR);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.ARMS) {\n      const equipItem = this.equipment.ARMS.save();\n      equipItem.setType(ModuleCreatureArmorSlot.ARMS);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.BELT) {\n      const equipItem = this.equipment.BELT.save();\n      equipItem.setType(ModuleCreatureArmorSlot.BELT);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.CLAW1) {\n      const equipItem = this.equipment.CLAW1.save();\n      equipItem.setType(ModuleCreatureArmorSlot.CLAW1);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.CLAW2) {\n      const equipItem = this.equipment.CLAW2.save();\n      equipItem.setType(ModuleCreatureArmorSlot.CLAW2);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.CLAW3) {\n      const equipItem = this.equipment.CLAW3.save();\n      equipItem.setType(ModuleCreatureArmorSlot.CLAW3);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.HEAD) {\n      const equipItem = this.equipment.HEAD.save();\n      equipItem.setType(ModuleCreatureArmorSlot.HEAD);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.HIDE) {\n      const equipItem = this.equipment.HIDE.save();\n      equipItem.setType(ModuleCreatureArmorSlot.HIDE);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.IMPLANT) {\n      const equipItem = this.equipment.IMPLANT.save();\n      equipItem.setType(ModuleCreatureArmorSlot.IMPLANT);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.LEFTARMBAND) {\n      const equipItem = this.equipment.LEFTARMBAND.save();\n      equipItem.setType(ModuleCreatureArmorSlot.LEFTARMBAND);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.LEFTHAND) {\n      const equipItem = this.equipment.LEFTHAND.save();\n      equipItem.setType(ModuleCreatureArmorSlot.LEFTHAND);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.RIGHTARMBAND) {\n      const equipItem = this.equipment.RIGHTARMBAND.save();\n      equipItem.setType(ModuleCreatureArmorSlot.RIGHTARMBAND);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    if (this.equipment.RIGHTHAND) {\n      const equipItem = this.equipment.RIGHTHAND.save();\n      equipItem.setType(ModuleCreatureArmorSlot.RIGHTHAND);\n      equipItemList.addChildStruct(equipItem)\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Experience')).setValue(this.experience);\n\n    const expressionList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'ExpressionList'));\n    const expressions = Object.keys(this.listeningPatterns);\n    for (let i = 0; i < expressions.length; i++) {\n      const expressionString = expressions[i];\n      const expressionId = this.listeningPatterns[expressionString];\n\n      const expressionStruct = new GFFStruct();\n      expressionStruct.addField(new GFFField(GFFDataType.INT, 'ExpressionId')).setValue(expressionId);\n      expressionStruct.addField(new GFFField(GFFDataType.CEXOSTRING, 'ExpressionString')).setValue(expressionString);\n      expressionList.addChildStruct(expressionStruct);\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'FactionID')).setValue(this.faction ? this.faction.id : this.factionId);\n\n    //Feats\n    const featList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'FeatList'));\n    for (let i = 0; i < this.feats.length; i++) {\n      featList.addChildStruct(this.feats[i].save());\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'FirstName')).setValue(this.template.RootNode.getFieldByLabel('FirstName')?.getCExoLocString());\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'ForcePoints')).setValue(this.forcePoints);\n    gff.RootNode.addField(new GFFField(GFFDataType.CHAR, 'FortSaveThrow')).setValue(this.fortitudeSaveThrow);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Gender')).setValue(this.gender);\n    gff.RootNode.addField(new GFFField(GFFDataType.DWORD, 'Gold')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'GoodEvil')).setValue(this.goodEvil);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'HitPoints')).setValue(this.hitPoints);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Int')).setValue(this.int);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Interruptable')).setValue(this.interruptable ? 1 : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'IsDestroyable')).setValue(1);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'IsPC')).setValue(this.playerCreated ? 1 : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'IsRaiseable')).setValue(1);\n    if (this.playerCreated) {\n      gff.RootNode.addField(new GFFField(GFFDataType.INT, 'PlayerCreated')).setValue(1);\n    }\n\n    //Creature Inventory\n    const itemList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'ItemList'));\n    for (let i = 0; i < this.inventory.length; i++) {\n      const itemStruct = this.inventory[i].save();\n      itemList.addChildStruct(itemStruct);\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'JoiningXP')).setValue(this.joiningXP ? this.joiningXP : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'LastName')).setValue(this.template.RootNode.getFieldByLabel('LastName')?.getCExoLocString());\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Listening')).setValue(this.isListening ? 1 : 0);\n\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'MaxForcePoints')).setValue(this.maxForcePoints);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'MaxHitPoints')).setValue(this.maxHitPoints);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Min1HP')).setValue(this.min1HP ? 1 : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'MovementRate')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'NaturalAC')).setValue(this.naturalAC);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'NotReorienting')).setValue(this.notReorienting);\n\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PM_IsDisguised')).setValue(this.hasEffect(GameEffectType.EffectDisguise) ? 1 : 0);\n    if (this.hasEffect(GameEffectType.EffectDisguise)) {\n      gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'PM_Appearance')).setValue(this.appearance);\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PartyInteract')).setValue(this.partyInteract);\n\n    //Save PerceptionLists\n    const perceptionList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'PerceptionList'));\n    for (let i = 0; i < this.perceptionList.length; i++) {\n      const percept = this.perceptionList[i];\n\n      const perceptionStruct = new GFFStruct();\n      perceptionStruct.addField(new GFFField(GFFDataType.DWORD, 'ObjectId')).setValue(percept.objectId);\n      perceptionStruct.addField(new GFFField(GFFDataType.BYTE, 'PerceptionData')).setValue((percept.data & 0xFF));\n      perceptionList.addChildStruct(perceptionStruct);\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PerceptionRange')).setValue(this.perceptionRange?.id || 0);\n\n    gff.RootNode.addField(new GFFField(GFFDataType.INT, 'Phenotype')).setValue(this.phenotype);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Plot')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'PortraitId')).setValue(this.portraitId);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'PregameCurrent')).setValue(28);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Race')).setValue(this.race);\n    gff.RootNode.addField(new GFFField(GFFDataType.CHAR, 'RefSaveThrow')).setValue(this.reflexSaveThrow);\n\n    const swVarTable = gff.RootNode.addField(new GFFField(GFFDataType.STRUCT, 'SWVarTable'));\n    swVarTable.addChildStruct(this.getSWVarTableSaveStruct());\n\n    //Scripts\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptAttacked')).setValue(this.scripts[ModuleObjectScript.CreatureOnAttacked]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDamaged')).setValue(this.scripts[ModuleObjectScript.CreatureOnDamaged]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDeath')).setValue(this.scripts[ModuleObjectScript.CreatureOnDeath]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDialogue')).setValue(this.scripts[ModuleObjectScript.CreatureOnDialog]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDisturbed')).setValue(this.scripts[ModuleObjectScript.CreatureOnDisturbed]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptEndDialogu')).setValue(this.scripts[ModuleObjectScript.CreatureOnEndDialog]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptEndRound')).setValue(this.scripts[ModuleObjectScript.CreatureOnEndRound]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptHeartbeat')).setValue(this.scripts[ModuleObjectScript.CreatureOnHeartbeat]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptOnBlocked')).setValue(this.scripts[ModuleObjectScript.CreatureOnBlocked]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptOnNotice')).setValue(this.scripts[ModuleObjectScript.CreatureOnNotice]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptRested')).setValue(this.scripts[ModuleObjectScript.CreatureOnRested]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptSpawn')).setValue(this.scripts[ModuleObjectScript.CreatureOnSpawn]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptSpellAt')).setValue(this.scripts[ModuleObjectScript.CreatureOnSpellAt]?.name || '');\n    gff.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptUserDefine')).setValue(this.scripts[ModuleObjectScript.CreatureOnUserDefined]?.name || '');\n\n    //Skills\n    const skillList = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'SkillList'));\n    for (let i = 0; i < 8; i++) {\n      skillList.addChildStruct(this.skills[i].save());\n    }\n\n    gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'SkillPoints')).setValue(this.skillPoints ? this.skillPoints : 0);\n    gff.RootNode.addField(new GFFField(GFFDataType.WORD, 'SoundSetFile')).setValue(this.soundSetFile);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'StartingPackage')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'StealthMode')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Str')).setValue(this.str);\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Subrace')).setValue('');\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'SubraceIndex')).setValue(this.subrace);\n    gff.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Tag')).setValue(this.tag);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Tail')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'UseBackupHead')).setValue(0);\n    const varTable = gff.RootNode.addField(new GFFField(GFFDataType.LIST, 'VarTable'));\n    gff.RootNode.addField(new GFFField(GFFDataType.CHAR, 'WillSaveThrow')).setValue(this.willSaveThrow);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Wings')).setValue(0);\n    gff.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Wis')).setValue(this.wis);\n\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'XPosition')).setValue(this.position.x);\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'YPosition')).setValue(this.position.y);\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'ZPosition')).setValue(this.position.z);\n\n    const theta = this.rotation.z * Math.PI;\n\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'XOrientation')).setValue(1 * Math.cos(theta));\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'YOrientation')).setValue(1 * Math.sin(theta));\n    gff.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'ZOrientation')).setValue(0);\n\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'fortbonus')).setValue(this.fortbonus);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'refbonus')).setValue(this.refbonus);\n    gff.RootNode.addField(new GFFField(GFFDataType.SHORT, 'refbonus')).setValue(this.refbonus);\n\n    this.template = gff;\n\n    if (this.npcId >= 0) {\n      GameState.PartyManager.NPCS[this.npcId].template = this.template;\n    }\n\n    return gff;\n\n  }\n\n  static GenerateTemplate() {\n    const template = new GFFObject();\n    template.FileType = 'UTC ';\n\n    template.RootNode.addField(new GFFField(GFFDataType.WORD, 'Appearance_Type'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'BodyBag'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'BodyVariation'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Cha'));\n    template.RootNode.addField(new GFFField(GFFDataType.FLOAT, 'ChallengeRating'));\n    template.RootNode.addField(new GFFField(GFFDataType.LIST, 'ClassList'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Comment'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Con'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'Conversation'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'CurrentForce'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'CurrentHitPoints'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Deity'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'Description'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Dex'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Disarmable'));\n    template.RootNode.addField(new GFFField(GFFDataType.LIST, 'Equip_ItemList'));\n    template.RootNode.addField(new GFFField(GFFDataType.WORD, 'FactionID'));\n    template.RootNode.addField(new GFFField(GFFDataType.LIST, 'FeatList'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'FirstName'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'ForcePoints'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Gender'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'GoodEvil'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'HitPoints'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Int'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Interruptable'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'IsPC'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOLOCSTRING, 'LastName'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'LawfulChaotic'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'MaxHitPoints'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Min1HP'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'NaturalAC'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'NoPermDeath'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'NotReorienting'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PalletID')).setValue(4);\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PartyInteract'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'PerceptionRange'));\n    template.RootNode.addField(new GFFField(GFFDataType.INT, 'Phenotype'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Plot'));\n    template.RootNode.addField(new GFFField(GFFDataType.WORD, 'PortraitId'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Race'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptAttacked'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDamaged'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDeath'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDialogue'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptDisturbed'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptEndDialogu'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptEndRound'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptHeartbeat'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptOnBlocked'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptOnNotice'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptRested'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptSpawn'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptSpellAt'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'ScriptUserDefine'));\n    const skillList = template.RootNode.addField(new GFFField(GFFDataType.LIST, 'SkillList'));\n    template.RootNode.addField(new GFFField(GFFDataType.WORD, 'SoundSetFile'))\n    template.RootNode.addField(new GFFField(GFFDataType.LIST, 'SpecAbilityList'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Str'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Subrace'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'SubraceIndex'));\n    template.RootNode.addField(new GFFField(GFFDataType.CEXOSTRING, 'Tag'));\n    template.RootNode.addField(new GFFField(GFFDataType.LIST, 'TemplateList'));\n    template.RootNode.addField(new GFFField(GFFDataType.RESREF, 'TemplateResRef'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'TextureVar'));\n    template.RootNode.addField(new GFFField(GFFDataType.INT, 'WalkRate'));\n    template.RootNode.addField(new GFFField(GFFDataType.BYTE, 'Wis'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'fortbonus'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'refbonus'));\n    template.RootNode.addField(new GFFField(GFFDataType.SHORT, 'willbonus'));\n\n    for (let i = 0; i < 8; i++) {\n      const _skill = new GFFStruct();\n      _skill.addField(new GFFField(GFFDataType.RESREF, 'Rank')).setValue(0);\n      skillList.addChildStruct(_skill);\n    }\n\n    return template;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleDoor.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ModuleRoom`.","line":816,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":816,"endColumn":71}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AudioEmitter } from \"@/audio/AudioEmitter\";\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { GameEffectFactory } from \"@/effects/GameEffectFactory\";\nimport { SWDoorAppearance } from \"@/engine/rules/SWDoorAppearance\";\nimport { CombatActionType, ModulePlaceableObjectSound, SkillType } from \"@/enums\";\nimport { AudioEmitterType } from \"@/enums/audio/AudioEmitterType\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { ModuleDoorAnimState } from \"@/enums/module/ModuleDoorAnimState\";\nimport { ModuleDoorInteractSide } from \"@/enums/module/ModuleDoorInteractSide\";\nimport { ModuleDoorOpenState } from \"@/enums/module/ModuleDoorOpenState\";\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport { SSFType } from \"@/enums/resource/SSFType\";\nimport { GameState } from \"@/GameState\";\nimport { ITwoDAAnimation } from \"@/interface/twoDA/ITwoDAAnimation\";\nimport { MDLLoader, ResourceLoader } from \"@/loaders\";\nimport { ModuleObject } from \"@/module/ModuleObject\";\nimport type { ModuleRoom } from \"@/module/ModuleRoom\";\nimport { OdysseyModel, OdysseyWalkMesh } from \"@/odyssey\";\nimport { CExoLocString } from \"@/resource/CExoLocString\";\nimport { DLGObject } from \"@/resource/DLGObject\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport { OdysseyModel3D } from \"@/three/odyssey\";\nimport { BinaryReader } from \"@/utility/binary/BinaryReader\";\n// import { AppearanceManager, InventoryManager, MenuManager, ModuleObjectManager, PartyManager, TwoDAManager, FactionManager } from \"@/managers\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { createScopedLogger , LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\ninterface AnimStateInfo {\n  lastAnimState: ModuleDoorAnimState;\n  currentAnimState: ModuleDoorAnimState;\n  loop: boolean;\n  started: boolean;\n}\n\n/**\n* ModuleDoor class.\n*\n* Class representing a door found in module areas.\n*\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n*\n* @file ModuleDoor.ts\n* @author KobaltBlu <https://github.com/KobaltBlu>\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n* @memberof KotOR\n*/\nexport class ModuleDoor extends ModuleObject {\n  openState: ModuleDoorOpenState = ModuleDoorOpenState.DEFAULT;\n  objectInteractSide: ModuleDoorInteractSide = ModuleDoorInteractSide.SIDE_1;\n\n  lastObjectEntered: ModuleObject;\n  lastObjectExited: ModuleObject;\n  lastObjectOpened: ModuleObject;\n  lastObjectClosed: ModuleObject;\n  lastUsedBy: ModuleObject;\n\n  animationState: number;\n  closeLockDC: number;\n  disarmDC: number;\n  fort: number;\n  genericType: number;\n  hardness: number;\n  interruptable: boolean;\n  keyRequired: boolean;\n  lockable: boolean;\n  locked: boolean;\n  openLockDC: number;\n  paletteID: number;\n  ref: number;\n  static: boolean;\n  will: number;\n  x: number;\n  y: number;\n  z: number;\n  declare audioEmitter: AudioEmitter;\n  boxHelper: THREE.Box3Helper;\n  props: Record<string, unknown>;\n  useable: number;\n  bodyBag: number;\n\n  trans: THREE.Object3D;\n  transitionLineMin: THREE.Vector3 = new THREE.Vector3(-2.5, 0, 0);\n  transitionLineMax: THREE.Vector3 = new THREE.Vector3(2.5, 0, 0);\n  transitionLine: THREE.Line3;\n  transitionClosestPoint: THREE.Vector3 = new THREE.Vector3();\n  transitionDistance: number = Infinity;\n\n  animStateInfo: AnimStateInfo = {\n    lastAnimState: ModuleDoorAnimState.DEFAULT,\n    currentAnimState: ModuleDoorAnimState.DEFAULT,\n    loop: false,\n    started: false\n  };\n  destroyAnimationPlayed: boolean = false;\n\n  collisionDelay: number = 0;\n  doorAppearance: SWDoorAppearance;\n\n  constructor ( gff = new GFFObject() ) {\n    super(gff);\n    this.objectType |= ModuleObjectType.ModuleDoor;\n    this.template = gff;\n    this.lastObjectEntered = undefined;\n    this.lastObjectExited = undefined;\n    this.lastObjectOpened = undefined;\n    this.lastObjectClosed = undefined;\n    this.lastUsedBy = undefined;\n    this.model = undefined;\n\n    this.animationState = 0;\n    this.appearance = 0;\n    this.autoRemoveKey = false;\n    this.closeLockDC = 0;\n    this.currentHP = 0;\n    this.description = new CExoLocString();\n    this.disarmDC = 0;\n    this.fort = 0;\n    this.genericType = 0;\n    this.hp = 0;\n    this.hardness = 0;\n    this.interruptable = false;\n    this.keyName = '';\n    this.keyRequired = false;\n    this.loadScreenID = 0;\n    this.locName = new CExoLocString();\n    this.lockable = false;\n    this.locked = false;\n    this.min1HP = false;\n    this.openLockDC = 0;\n    this.paletteID = 0;\n    this.plot = false;\n    this.portraitId = 0;\n    this.ref = 0;\n    this.static = false;\n    this.tag = '';\n    this.templateResRef = '';\n    this.trapDetectDC = 0;\n    this.trapDetectable = false;\n    this.trapDisarmable = false;\n    this.trapFlag = false;\n    this.trapOneShot = false;\n    this.trapType = 0;\n    this.will = 0;\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.bearing = 0;\n\n    try{\n      this.audioEmitter = new AudioEmitter(AudioEngine.GetAudioEngine());\n      this.audioEmitter.maxDistance = 50;\n      this.audioEmitter.type = AudioEmitterType.POSITIONAL;\n      this.audioEmitter.load();\n    }catch(e){\n      log.error('AudioEmitter failed to create on object', e);\n    }\n\n  }\n\n  computeBoundingBox(force?: boolean): void {\n    if(this.container){\n      this.container.updateMatrixWorld(true);\n      this.container.updateMatrix();\n      if(force){\n        this.container.traverse( n => {\n          n.updateMatrixWorld(true);\n          n.updateMatrix();\n        })\n      }\n    }\n\n    if(this.model){\n      this.model.updateMatrixWorld(true);\n      this.model.updateMatrix();\n    }\n  }\n\n  isOnScreen(frustum: THREE.Frustum = GameState.viewportFrustum): boolean {\n    this.box.getBoundingSphere(this.sphere);\n    return frustum.intersectsSphere(this.sphere);\n  }\n\n  getX(){\n    return this.position.x;\n  }\n\n  getY(){\n    return this.position.y;\n  }\n\n  getZ(){\n    return this.position.z;\n  }\n\n  getBearing(){\n    return this.bearing;\n  }\n\n  isLocked(){\n    return this.locked;\n  }\n\n  setLocked(value: boolean){\n    this.locked = value ? true : false;\n  }\n\n  requiresKey(){\n    return this.keyRequired && this.keyName.length ? true : false;\n  }\n\n  getName(){\n    return this.locName.getValue();\n  }\n\n  getGenericType(){\n    return this.genericType;\n  }\n\n  getDoorAppearance(){\n    return this.doorAppearance;\n  }\n\n  getObjectSounds(){\n    const result = {\"__rowlabel\":-1,\"label\":\"\",\"armortype\":\"\",\"opened\":\"****\",\"closed\":\"****\",\"destroyed\":\"****\",\"used\":\"****\",\"locked\":\"****\"};\n    const appearance = this.getDoorAppearance();\n    if(!appearance) return result;\n\n    const soundIdx = appearance.soundapptype;\n    if(!isNaN(soundIdx) && soundIdx >= 0){\n      const table = GameState.TwoDAManager.datatables.get('placeableobjsnds');\n      if(table && typeof table.rows[soundIdx] !== 'undefined'){\n        return table.rows[soundIdx];\n      }\n    }\n    return result;\n  }\n\n  playObjectSound(type: ModulePlaceableObjectSound){\n    const objSounds = this.getObjectSounds();\n\n    if(!this.audioEmitter){\n      return;\n    }\n\n    switch(type){\n      case ModulePlaceableObjectSound.OPENED:\n        if(objSounds?.opened != '****'){\n          this.audioEmitter.playSound(String(objSounds?.opened ?? ''));\n        }\n      break;\n      case ModulePlaceableObjectSound.CLOSED:\n        if(objSounds?.closed != '****'){\n          this.audioEmitter.playSound(String(objSounds?.closed ?? ''));\n        }\n      break;\n      case ModulePlaceableObjectSound.DESTROYED:\n        if(objSounds?.destroyed != '****'){\n          this.audioEmitter.playSound(String(objSounds?.destroyed ?? ''));\n        }\n      break;\n      case ModulePlaceableObjectSound.USED:\n        if(objSounds?.used != '****'){\n          this.audioEmitter.playSound(String(objSounds?.used ?? ''));\n        }\n      break;\n      case ModulePlaceableObjectSound.LOCKED:\n        if(objSounds?.locked != '****'){\n          this.audioEmitter.playSound(String(objSounds?.locked ?? ''));\n        }\n      break;\n    }\n  }\n\n  /*getTemplateResRef(){\n    return this.templateResRef;\n  }*/\n\n  getModel(){\n    return this.model;\n  }\n\n  onHover(){\n\n  }\n\n  isUseable(){\n    return !this.openState && !this.static;\n  }\n\n  isOpen(){\n    return (this.openState == ModuleDoorOpenState.OPEN1 || this.openState == ModuleDoorOpenState.OPEN2);\n  }\n\n  updateCollisionState(): void {\n    // if(!this.collisionManager?.walkmesh?.mesh){ return; }\n\n    let idx = -1;\n    switch(this.openState){\n      case ModuleDoorOpenState.DESTROYED:\n      case ModuleDoorOpenState.OPEN1:\n      case ModuleDoorOpenState.OPEN2:\n        GameState.group.room_walkmeshes.remove( this.collisionManager.walkmesh.mesh );\n        idx = this.area.doorWalkmeshes.indexOf(this.collisionManager.walkmesh);\n        if(idx >= 0){ this.area.doorWalkmeshes.splice(idx, 1); }\n      break;\n      default:\n        GameState.group.room_walkmeshes.add( this.collisionManager.walkmesh.mesh );\n        idx = this.area.doorWalkmeshes.indexOf(this.collisionManager.walkmesh);\n        if(idx == -1){ this.area.doorWalkmeshes.push(this.collisionManager.walkmesh); }\n      break;\n    }\n  }\n\n  setOpenState(openState: ModuleDoorOpenState = ModuleDoorOpenState.CLOSED){\n    const currentOpenState = this.openState;\n    this.openState = openState;\n\n    this.updateCollisionState();\n\n    const wasClosed = (currentOpenState == ModuleDoorOpenState.CLOSED);\n    const attemptingOpen = (openState == ModuleDoorOpenState.OPEN1 || openState == ModuleDoorOpenState.OPEN2);\n    if(attemptingOpen){\n      if(wasClosed){\n        if(openState == ModuleDoorOpenState.OPEN1){\n          this.setAnimationState(ModuleDoorAnimState.OPENING1);\n        }else if(openState == ModuleDoorOpenState.OPEN2){\n          this.setAnimationState(ModuleDoorAnimState.OPENING2);\n        }\n      }else{\n        if(openState == ModuleDoorOpenState.OPEN1){\n          this.setAnimationState(ModuleDoorAnimState.OPENED1);\n        }else if(openState == ModuleDoorOpenState.OPEN2){\n          this.setAnimationState(ModuleDoorAnimState.OPENED2);\n        }\n      }\n      return;\n    }\n\n    const attemptingClose = (openState == ModuleDoorOpenState.CLOSED);\n    if(attemptingClose){\n      const needsToAnimate = (currentOpenState == ModuleDoorOpenState.OPEN1 || currentOpenState == ModuleDoorOpenState.OPEN2);\n      if(needsToAnimate){\n        if(currentOpenState == ModuleDoorOpenState.OPEN1){\n          this.setAnimationState(ModuleDoorAnimState.CLOSING1);\n        }else{\n          this.setAnimationState(ModuleDoorAnimState.CLOSING2);\n        }\n      }\n    }else{\n      this.setAnimationState(ModuleDoorAnimState.CLOSED);\n    }\n\n  }\n\n  onClick(_callee: ModuleObject){\n    GameState.getCurrentPlayer().actionOpenDoor( this );\n  }\n\n  use(object: ModuleObject){\n\n    this.lastUsedBy = object;\n\n    // If the door is already open, do nothing\n    if(this.openState){\n      log.debug('ModuleDoor', this.getTag(), this.getName(), 'already open');\n      return;\n    }\n\n    // If the caller is the door itself and the door is closed, open it\n    const isCallerSelf = object === this;\n    if(isCallerSelf){\n      this.openDoor(this);\n      return;\n    }\n\n    // If the door is locked and a key is required, try to unlock it\n    if(this.isLocked() && this.keyRequired){\n      if(this.keyName.length){\n        const keyItem = GameState.InventoryManager.getItemByTag(this.keyName);\n        if(keyItem && BitWise.InstanceOf(keyItem?.objectType, ModuleObjectType.ModuleItem)){\n          this.unlock(object);\n          if(this.autoRemoveKey){\n            object.removeItem(keyItem);\n          }\n          object.playSoundSet(SSFType.UNLOCK_SUCCESS);\n        }\n      }\n\n      object.playSoundSet(SSFType.UNLOCK_FAIL);\n    }\n\n    // If the door is still locked, run the on fail to open script\n    if(this.isLocked()){\n      const onFailToOpen = this.scripts[ModuleObjectScript.DoorOnFailToOpen];\n      if(onFailToOpen){\n        onFailToOpen.run(this);\n      }\n\n      this.playObjectSound(ModulePlaceableObjectSound.LOCKED);\n      return;\n    }\n\n    this.openDoor(object);\n\n  }\n\n  lock(_object: ModuleObject){\n    if(this.locked){ return; }\n    this.locked = true;\n\n    const onLock = this.scripts[ModuleObjectScript.DoorOnLock];\n    if(onLock){\n      onLock.run(this);\n    }\n  }\n\n  unlock(_object: ModuleObject){\n    if(!this.locked){ return; }\n    this.locked = false;\n\n    const onUnlock = this.scripts[ModuleObjectScript.DoorOnUnlock];\n    if(onUnlock){\n      onUnlock.run(this);\n    }\n  }\n\n  attemptUnlock(object: ModuleObject){\n    if(!BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleObject)){\n      return false;\n    }\n\n    const nSecuritySkill = object.getSkillLevel(SkillType.SECURITY);\n    if(this.isLocked() && !this.keyRequired && nSecuritySkill >= 1){\n      const d20 = 20;//d20 rolls are auto 20's outside of combat\n      const skillCheck = (((object.getWIS()/2) + nSecuritySkill) + d20) - this.openLockDC;\n      if(skillCheck >= 1 && nSecuritySkill >= 1){\n        this.unlock(object);\n        if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n          object.playSoundSet(SSFType.UNLOCK_SUCCESS);\n        }\n      }else{\n        if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n          object.playSoundSet(SSFType.UNLOCK_FAIL);\n        }\n      }\n    }\n\n    this.use(object);\n    return true;\n  }\n\n  openDoor(object: ModuleObject){\n\n    /*\n      Door Animations:\n      opening1 and opening2 are supposed to be used for swinging doors\n      they should play depending on which side the object that opened them was on.\n      an example of this would be the doors found on kashyyyk\n    */\n\n    if(object instanceof ModuleObject){\n      this.lastObjectOpened = object;\n      //object.lastDoorEntered = this;\n    }\n\n    const onOpen = this.scripts[ModuleObjectScript.DoorOnOpen];\n    if(onOpen){\n      onOpen.run(this);\n    }\n\n    this.playObjectSound(ModulePlaceableObjectSound.OPENED);\n\n    // if(GameState.selectedObject == this){\n    //   GameState.selectedObject = GameState.selected = undefined;\n    // }\n\n    //TODO: detect the correct side that the creature interacted from\n    switch(this.objectInteractSide){\n      case ModuleDoorInteractSide.SIDE_1:\n        this.setOpenState(ModuleDoorOpenState.OPEN1);\n      break;\n      default:\n        this.setOpenState(ModuleDoorOpenState.OPEN2);\n      break;\n    }\n\n    if(this.collisionManager.walkmesh && this.collisionManager.walkmesh.mesh){\n      this.collisionManager.walkmesh.mesh.removeFromParent();\n    }\n\n    //Notice all creatures within range that someone opened this door\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n      for(let i = 0, len = GameState.module.area.creatures.length; i < len; i++){\n        const creature = GameState.module.area.creatures[i];\n        const distance = creature.position.distanceTo(this.position);\n        if(distance <= creature.getPerceptionRangePrimary()){\n          creature.notifyPerceptionHeardObject(object, true);\n        }\n      }\n    }\n\n    if(GameState.CursorManager.selectedObject == this){\n      GameState.CursorManager.selected = undefined;\n      GameState.CursorManager.selectedObject = undefined;\n    }\n\n    if(GameState.CursorManager.hoveredObject == this){\n      GameState.CursorManager.hovered = undefined;\n      GameState.CursorManager.hoveredObject = undefined;\n    }\n\n  }\n\n  destroyDoor(_object: ModuleObject){\n\n    const onDeath = this.scripts[ModuleObjectScript.DoorOnDeath];\n    if(onDeath){\n      onDeath.run(this);\n    }\n\n    //TODO: detect the correct side that the creature interacted from\n    switch(this.objectInteractSide){\n      case ModuleDoorInteractSide.SIDE_1:\n        this.setOpenState(ModuleDoorOpenState.OPEN1);\n      break;\n      default:\n        this.setOpenState(ModuleDoorOpenState.OPEN2);\n      break;\n    }\n\n    if(this.collisionManager.walkmesh && this.collisionManager.walkmesh.mesh){\n      this.collisionManager.walkmesh.mesh.removeFromParent();\n    }\n\n  }\n\n  closeDoor(object: ModuleObject){\n\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\n      object.lastDoorExited = this;\n    }\n\n    this.playObjectSound(ModulePlaceableObjectSound.CLOSED);\n\n    if(this.collisionManager.walkmesh && this.collisionManager.walkmesh.mesh){\n      this.collisionManager.walkmesh.mesh.removeFromParent();\n    }\n\n    this.setOpenState(ModuleDoorOpenState.CLOSED);\n\n  }\n\n  //Some modules have exit triggers that are placed in the same location that the player spawns into\n  //This is my way of keeping the player from immediately activating the trigger\n  //They will be added to the objectsInside array without triggering the onEnter script\n  //If they leave the trigger and then return it will then fire normally\n  initObjectsInside(){\n    //Check to see if this trigger is linked to another module\n    if(this.linkedToModule && this.type == 1){\n      //Check Party Members\n      const partyLen = GameState.PartyManager.party.length;\n      for(let i = 0; i < partyLen; i++){\n        const partymember = GameState.PartyManager.party[i];\n        if(this.box.containsPoint(partymember.position)){\n          if(this.objectsInside.indexOf(partymember) == -1){\n            this.objectsInside.push(partymember);\n\n            partymember.lastDoorEntered = this;\n            this.lastObjectEntered = partymember;\n          }\n        }\n      }\n    }else{\n      //Check Creatures\n      const creatureLen = GameState.module.area.creatures.length;\n      for(let i = 0; i < creatureLen; i++){\n        const creature = GameState.module.area.creatures[i];\n        if(this.box.containsPoint(creature.position)){\n          if(this.objectsInside.indexOf(creature) == -1){\n            this.objectsInside.push(creature);\n\n            creature.lastDoorEntered = this;\n            this.lastObjectEntered = creature;\n          }\n        }\n      }\n    }\n  }\n\n  onSpawn(runScript = true){\n    super.onSpawn(runScript);\n\n    if(this.model instanceof OdysseyModel3D){\n      this.model.updateMatrix();\n\n      this.box.setFromObject(this.model);\n\n      this.audioEmitter.setPosition(this.position.x, this.position.y, this.position.z);\n      this.boxHelper = new THREE.Box3Helper( this.box, (new THREE.Color()).setHex(0xff0000) );\n      GameState.group.light_helpers.add( this.boxHelper );\n    }\n\n    if(this.collisionManager.walkmesh && this.model){\n      this.collisionManager.walkmesh.matrixWorld.copy(this.model.matrix);\n    }\n  }\n\n  onAttacked(attackType: CombatActionType){\n    const isSpellAttack = attackType == CombatActionType.CAST_SPELL || attackType == CombatActionType.ITEM_CAST_SPELL;\n    const instance = this.scripts[!isSpellAttack ? ModuleObjectScript.DoorOnMeleeAttacked : ModuleObjectScript.DoorOnSpellCastAt];\n    if(!instance){ return; }\n    instance.run(this);\n  }\n\n  onDamaged(): boolean{\n    const instance = this.scripts[ModuleObjectScript.DoorOnDamaged];\n    if(!instance){ return false; }\n    instance.run(this);\n    return false;\n  }\n\n  update(delta = 0){\n\n    super.update(delta);\n    if(this.model instanceof OdysseyModel3D){\n      this.model.update(delta);\n      //this.box.setFromObject(this.model);\n    }\n\n    if(this.isDead()){\n      if(!this.destroyAnimationPlayed){\n        this.destroyAnimationPlayed = true;\n        this.destroyDoor(this);\n      }\n    }else{\n      if(this.destroyAnimationPlayed) this.destroyAnimationPlayed = false;\n    }\n\n    this.action = this.actionQueue[0];\n    this.actionQueue.process( delta );\n\n    this.updateAnimationState(delta);\n\n    if(\n      this.animStateInfo.currentAnimState != ModuleDoorAnimState.CLOSING1 &&\n      this.animStateInfo.currentAnimState != ModuleDoorAnimState.CLOSING2\n    ){\n      this.collisionDelay = 0;\n    }else{\n      this.collisionDelay -= delta;\n      if(this.collisionDelay < 0) this.collisionDelay = 0;\n    }\n\n    if(this.isDead() && !this.isOpen()){\n      this.openDoor(this);\n    }\n\n    const partymember = GameState.PartyManager.party[0];\n    if(partymember){\n      const outer_distance = partymember.position.distanceTo(this.position);\n      if(outer_distance < 10){\n        this.testTransitionLine(partymember);\n        if(this.transitionDistance < 5){\n          if(this.getLinkedToModule() && this.isOpen()){\n            GameState.MenuManager.InGameAreaTransition.setTransitionObject(this);\n          }\n        }else{\n          GameState.MenuManager.InGameAreaTransition.unsetTransitionObject(this);\n        }\n        if(this.transitionDistance < 0.5){\n          if(partymember.lastDoorEntered !== this){\n            partymember.lastDoorEntered = this;\n            this.onEnter(partymember);\n          }\n        } else {\n          if(partymember.lastDoorEntered === this){\n            partymember.lastDoorExited = this;\n            this.onExit(partymember);\n          }\n        }\n      }else{\n        GameState.MenuManager.InGameAreaTransition.unsetTransitionObject(this);\n        if(partymember.lastDoorEntered === this){\n          partymember.lastDoorExited = this;\n          this.onExit(partymember);\n        }\n      }\n    }\n\n  }\n\n  updateAnimationState(_delta: number = 0){\n    if(!(this.model instanceof OdysseyModel3D))\n      return;\n\n    const currentAnimation = this.model.getAnimationName();\n    if(!this.animStateInfo.currentAnimState) this.setAnimationState(ModuleDoorAnimState.DEFAULT);\n    if(this.animStateInfo.currentAnimState){\n      const animation = this.animationConstantToAnimation(this.animStateInfo.currentAnimState);\n      if(animation){\n        if(currentAnimation != animation.name?.toLowerCase()){\n          if(!this.animStateInfo.started){\n            if(\n              this.animStateInfo.currentAnimState == ModuleDoorAnimState.CLOSING1 ||\n              this.animStateInfo.currentAnimState == ModuleDoorAnimState.CLOSING2\n            ){\n              this.collisionDelay = 0.75;\n            }\n            this.animStateInfo.started = true;\n            const aLooping = (!parseInt(animation.fireforget) && parseInt(animation.looping) == 1);\n            this.getModel().playAnimation(animation.name?.toLowerCase(), aLooping);\n          }else{\n            //Animation completed\n            switch(this.animStateInfo.currentAnimState){\n              //loop default animations\n              case ModuleDoorAnimState.OPENED1:\n                this.setAnimationState(ModuleDoorAnimState.OPENED1);\n              break;\n              case ModuleDoorAnimState.OPENED2:\n                this.setAnimationState(ModuleDoorAnimState.OPENED2);\n              break;\n              case ModuleDoorAnimState.CLOSED:\n                this.setAnimationState(ModuleDoorAnimState.CLOSED);\n              break;\n\n              //transition animations\n              case ModuleDoorAnimState.OPENING1:\n                this.setAnimationState(ModuleDoorAnimState.OPENED1);\n              break;\n              case ModuleDoorAnimState.OPENING2:\n                this.setAnimationState(ModuleDoorAnimState.OPENED2);\n              break;\n              case ModuleDoorAnimState.CLOSING1:\n              case ModuleDoorAnimState.CLOSING2:\n                this.setAnimationState(ModuleDoorAnimState.CLOSED);\n              break;\n              default:\n                this.setAnimationState(ModuleDoorAnimState.DEFAULT);\n              break;\n            }\n          }\n        }\n      }else{\n        log.error('Animation Missing', this.getTag(), this.getName(), this.animState);\n        this.setAnimationState(ModuleDoorAnimState.DEFAULT);\n      }\n    }\n  }\n\n  setAnimationState(animState: ModuleDoorAnimState = ModuleDoorAnimState.DEFAULT){\n    this.animStateInfo.currentAnimState = animState;\n    this.animState = animState;\n    this.animStateInfo.lastAnimState = this.animState;\n    this.animStateInfo.loop = false;\n    this.animStateInfo.started = false;\n    if(animState == ModuleDoorAnimState.CLOSED) this.animStateInfo.loop = true;\n    if(animState == ModuleDoorAnimState.DEFAULT) this.animStateInfo.loop = true;\n    if(this.model) this.model.stopAnimation();\n  }\n\n  detachFromRoom(room: ModuleRoom): void {\n    if(!room) return;\n    const index = room.doors.indexOf(this);\n    if(index >= 0){\n      room.doors.splice(index, 1);\n    }\n  }\n\n  getCurrentRoom(): void {\n    this.room = undefined;\n    const aabbFaces = [];\n    let intersects;// = GameState.raycaster.intersectOctreeObjects( meshesSearch );\n    const box = this.box.clone();\n\n    this.rooms = [];\n    for(let i = 0; i < GameState.module.area.rooms.length; i++){\n      const room = GameState.module.area.rooms[i];\n      if(room.box.containsPoint(this.position)){\n        this.roomIds.push(i);\n      }\n    }\n\n    if(box){\n      for(let j = 0, jl = this.roomIds.length; j < jl; j++){\n        const room = GameState.module.area.rooms[this.roomIds[j]];\n        if(room && room.collisionManager.walkmesh && room.collisionManager.walkmesh.aabbNodes.length){\n          aabbFaces.push({\n            object: room,\n            faces: room.collisionManager.walkmesh.getAABBCollisionFaces(box)\n          });\n        }\n      }\n    }\n\n    const scratchVec3 = new THREE.Vector3(0, 0, 2);\n    const playerFeetRay = this.position.clone().add(scratchVec3);\n    GameState.raycaster.ray.origin.set(playerFeetRay.x,playerFeetRay.y,playerFeetRay.z);\n    GameState.raycaster.ray.direction.set(0, 0,-1);\n\n    for(let j = 0, jl = aabbFaces.length; j < jl; j++){\n      const castableFaces = aabbFaces[j];\n      intersects = castableFaces.object.collisionManager.walkmesh.raycast(GameState.raycaster, castableFaces.faces) || [];\n\n      if(intersects.length){\n        if(intersects[0].object.userData.moduleObject){\n          this.attachToRoom(intersects[0].object.userData.moduleObject);\n          return;\n        }\n      }\n    }\n    if(this.rooms.length){\n      this.attachToRoom(GameState.module.area.rooms[this.roomIds[0]]);\n      return;\n    }\n  }\n\n  generateTransitionLine(){\n    this.transitionLineMin.set(-5, 0, 0);\n    this.transitionLineMax.set(5, 0, 0)\n    this.transitionLine = new THREE.Line3(this.transitionLineMin, this.transitionLineMax);\n    this.container.updateMatrix();\n    this.transitionLine.applyMatrix4(this.container.matrix);\n  }\n\n  testTransitionLine(object: ModuleObject){\n    this.transitionClosestPoint.set(0, 0, 0);\n    this.transitionLineMin.z = object.position.z;\n    this.transitionLineMax.z = object.position.z;\n    this.transitionLine.closestPointToPoint(object.position, true, this.transitionClosestPoint);\n    this.transitionDistance = object.position.distanceTo(this.transitionClosestPoint);\n  }\n\n  testTransitionLineCrosses(object: ModuleObject){\n    if(object == GameState.getCurrentPlayer()){\n      const trans = this?.model?.trans;\n      if(trans){\n        GameState.raycaster.ray.origin.copy(object.position);\n        GameState.raycaster.ray.origin.z += 1;\n        GameState.raycaster.ray.direction.copy(object.forceVector);\n        const intersections: THREE.Intersection[] =[];\n        trans.children[0].raycast(GameState.raycaster, intersections);\n        if(intersections.length){\n          this.transitNPC(object);\n        }\n      }\n    }\n  }\n\n  transitNPC(object: ModuleObject){\n    if(!(object instanceof ModuleObject)) return;\n    if(object != GameState.getCurrentPlayer()) return;\n    if(this.getLinkedToModule() && !(GameState.Mode == EngineMode.DIALOG) && this.isOpen()){\n      if(object.controlled){\n        GameState.LoadModule(this.getLinkedToModule().toLowerCase(), this.getLinkedTo().toLowerCase());\n      }else{\n        object.lastDoorEntered = this;\n      }\n    }\n  }\n\n  onEnter(object: ModuleObject){\n    object.lastDoorEntered = this;\n    if(this.getLinkedToModule() && this.isOpen()){\n      GameState.MenuManager.InGameAreaTransition.setTransitionObject(this);\n    }\n  }\n\n  onExit(object: ModuleObject){\n    object.lastDoorEntered = undefined;\n    if(this.getLinkedToModule()){\n      GameState.MenuManager.InGameAreaTransition.setTransitionObject(undefined);\n    }\n  }\n\n  load(){\n    const templateResRef = this.getTemplateResRef();\n    if(templateResRef != null && templateResRef !== ''){\n      //Load template and merge fields\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['utd'], String(templateResRef));\n      if(buffer){\n        const gff = new GFFObject(buffer);\n        this.template.merge(gff);\n        //log.info(this.template, gff, this)\n        this.initProperties();\n        this.loadScripts();\n      }else{\n        log.error(`Failed to load ${ModuleDoor.name} template`);\n        if(this.template instanceof GFFObject){\n          this.initProperties();\n          this.loadScripts();\n        }\n      }\n    }else{\n      //We already have the template (From SAVEGAME)\n      this.initProperties();\n      this.loadScripts();\n    }\n  }\n\n  loadModel(): Promise<OdysseyModel3D> {\n    const modelName = this.getDoorAppearance().modelname.replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\n    return new Promise<OdysseyModel3D>( (resolve, _reject) => {\n      MDLLoader.loader.load(modelName).then((mdl: OdysseyModel) => {\n        OdysseyModel3D.FromMDL(mdl, {\n          context: this.context,\n          //lighting: false,\n          static: this.static,\n          useTweakColor: this.useTweakColor,\n          tweakColor: this.tweakColor\n          //castShadow: true,\n          //receiveShadow: true\n        }).then((door: OdysseyModel3D) => {\n          if(this.model instanceof OdysseyModel3D){\n            this.model.removeFromParent();\n            try{ this.model.dispose(); }catch{ /* dispose may throw */ }\n          }\n\n          this.model = door;\n          this.model.userData.moduleObject = this;\n          this.model.name = modelName;\n          this.container.add(this.model);\n\n          this.trans = this.model.trans;\n          if(this.trans instanceof THREE.Object3D){\n            if(this.trans.children.length){\n              this.trans.children[0].userData.ignoreMousePicking = true;\n            }\n            this.trans.visible = false;\n          }\n\n          this.generateTransitionLine();\n\n          this.model.disableMatrixUpdate();\n\n          switch(this.openState){\n            case ModuleDoorOpenState.CLOSED:\n              this.setAnimationState(ModuleDoorAnimState.CLOSED);\n            break;\n            case ModuleDoorOpenState.OPEN1:\n              this.setAnimationState(ModuleDoorAnimState.OPENED1);\n            break;\n            case ModuleDoorOpenState.OPEN2:\n              this.setAnimationState(ModuleDoorAnimState.OPENED2);\n            break;\n            default:\n              this.setOpenState(ModuleDoorOpenState.CLOSED);\n            break;\n          }\n\n          resolve(this.model);\n        }).catch(() => {\n          resolve(this.model);\n        });\n      }).catch(() => {\n        resolve(this.model);\n      });\n    });\n  }\n\n  loadScripts(){\n    const scriptKeys = [\n      ModuleObjectScript.DoorOnClick,\n      ModuleObjectScript.DoorOnClosed,\n      ModuleObjectScript.DoorOnDamaged,\n      ModuleObjectScript.DoorOnDeath,\n      ModuleObjectScript.DoorOnDisarm,\n      ModuleObjectScript.DoorOnFailToOpen,\n      ModuleObjectScript.DoorOnHeartbeat,\n      ModuleObjectScript.DoorOnInvDisturbed,\n      ModuleObjectScript.DoorOnLock,\n      ModuleObjectScript.DoorOnMeleeAttacked,\n      ModuleObjectScript.DoorOnOpen,\n      ModuleObjectScript.DoorOnSpellCastAt,\n      ModuleObjectScript.DoorOnTrapTriggered,\n      ModuleObjectScript.DoorOnUnlock,\n      ModuleObjectScript.DoorOnUserDefined,\n    ];\n\n    const scriptsNode = this.template?.RootNode;\n    if(!scriptsNode){ return; }\n    for(const scriptKey of scriptKeys){\n      if(scriptsNode.hasField(scriptKey)){\n        const resRef = scriptsNode.getStringByLabel(scriptKey);\n        if(!resRef){ continue; }\n        const nwscript = GameState.NWScript.Load(resRef);\n        if(!nwscript){ continue; }\n        nwscript.caller = this;\n        this.scripts[scriptKey] = nwscript;\n      }\n    }\n  }\n\n  async loadWalkmesh(resRef = ''): Promise<OdysseyWalkMesh> {\n    try{\n      const buffer = await ResourceLoader.loadResource(ResourceTypes['dwk'], resRef+'0');\n      const walkmesh = new OdysseyWalkMesh(new BinaryReader(buffer));\n      walkmesh.mesh.name = walkmesh.name = resRef;\n      walkmesh.mesh.userData.moduleObject = walkmesh.moduleObject = this;\n      this.collisionManager.setWalkmesh(walkmesh);\n\n      this.updateCollisionState();\n\n      return this.collisionManager.walkmesh;\n    }catch(e){\n      log.error(e);\n    }\n  }\n\n  initProperties(){\n\n    if(!this.initialized){\n      if(this.template.RootNode.hasField('ObjectId')){\n        this.id = this.template.RootNode.getNumberByLabel('ObjectId');\n      }else if(this.template.RootNode.hasField('ID')){\n        this.id = this.template.RootNode.getNumberByLabel('ID');\n      }\n\n      GameState.ModuleObjectManager.AddObjectById(this);\n    }\n\n    if(this.template.RootNode.hasField('AnimationState'))\n      this.animationState = this.template.RootNode.getNumberByLabel('AnimationState');\n\n    if(this.template.RootNode.hasField('Appearance'))\n      this.appearance = this.template.RootNode.getNumberByLabel('Appearance');\n\n    if(this.template.RootNode.hasField('AutoRemoveKey'))\n      this.autoRemoveKey = this.template.RootNode.getNumberByLabel('AutoRemoveKey');\n\n    if(this.template.RootNode.hasField('CloseLockDC'))\n      this.closeLockDC = this.template.RootNode.getNumberByLabel('CloseLockDC');\n\n    if(this.template.RootNode.hasField('Conversation')){\n      this.conversation = DLGObject.FromResRef(this.template.RootNode.getStringByLabel('Conversation'));\n    }\n\n    if(this.template.RootNode.hasField('CurrentHP'))\n      this.currentHP = this.template.RootNode.getNumberByLabel('CurrentHP');\n\n    if(this.template.RootNode.hasField('DisarmDC'))\n      this.disarmDC = this.template.RootNode.getNumberByLabel('DisarmDC');\n\n    if(this.template.RootNode.hasField('Faction')){\n      this.factionId = this.template.RootNode.getNumberByLabel('Faction');\n      if((this.factionId & 0xFFFFFFFF) == -1){\n        this.factionId = 0;\n      }\n    }\n    this.faction = GameState.FactionManager.factions.get(this.factionId);\n\n    if(this.template.RootNode.hasField('Fort'))\n      this.fort = this.template.RootNode.getNumberByLabel('Fort');\n\n    if(this.template.RootNode.hasField('GenericType')){\n      this.genericType = this.template.RootNode.getNumberByLabel('GenericType');\n      this.doorAppearance = GameState.AppearanceManager.GetDoorAppearanceById(this.genericType);\n    }\n\n    if(this.template.RootNode.hasField('HP'))\n      this.hp = this.template.RootNode.getNumberByLabel('HP');\n\n    if(this.template.RootNode.hasField('Hardness'))\n      this.hardness = this.template.RootNode.getNumberByLabel('Hardness');\n\n    if(this.template.RootNode.hasField('Interruptable'))\n      this.interruptable = this.template.RootNode.getBooleanByLabel('Interruptable');\n\n    if(this.template.RootNode.hasField('KeyName'))\n      this.keyName = this.template.RootNode.getStringByLabel('KeyName');\n\n    if(this.template.RootNode.hasField('KeyRequired'))\n      this.keyRequired = this.template.RootNode.getBooleanByLabel('KeyRequired');\n\n    if(this.template.RootNode.hasField('LoadScreenID'))\n      this.loadScreenID = this.template.RootNode.getNumberByLabel('LoadScreenID');\n\n    if(this.template.RootNode.hasField('LocName'))\n      this.locName = this.template.getFieldByLabel('LocName').getCExoLocString();\n\n    if(this.template.RootNode.hasField('Locked'))\n      this.locked = this.template.RootNode.getBooleanByLabel('Locked');\n\n    if(this.template.RootNode.hasField('Min1HP'))\n      this.min1HP = this.template.RootNode.getBooleanByLabel('Min1HP');\n\n    if(this.template.RootNode.hasField('OpenLockDC'))\n      this.openLockDC = this.template.RootNode.getNumberByLabel('OpenLockDC');\n\n    if(this.template.RootNode.hasField('OpenState'))\n      this.openState = this.template.RootNode.getNumberByLabel('OpenState');\n\n    if(this.template.RootNode.hasField('PaletteID'))\n      this.paletteID = this.template.RootNode.getNumberByLabel('PaletteID');\n\n    if(this.template.RootNode.hasField('Plot'))\n      this.plot = this.template.RootNode.getBooleanByLabel('Plot');\n\n    if(this.template.RootNode.hasField('PortraidId')){\n      this.portraitId = this.template.RootNode.getNumberByLabel('PortraidId');\n      this.portrait = GameState.SWRuleSet.portraits[this.portraitId];\n    }\n\n\n    if(this.template.RootNode.hasField('Ref'))\n      this.ref = this.template.RootNode.getNumberByLabel('Ref');\n\n    if(this.template.RootNode.hasField('Static'))\n      this.static = this.template.RootNode.getBooleanByLabel('Static');\n\n    if(this.template.RootNode.hasField('Tag'))\n      this.tag = this.template.RootNode.getStringByLabel('Tag');\n\n    if(this.template.RootNode.hasField('TemplateResRef'))\n      this.templateResRef = this.template.RootNode.getStringByLabel('TemplateResRef');\n\n    if(this.template.RootNode.hasField('TrapDetectDC'))\n      this.trapDetectDC = this.template.RootNode.getNumberByLabel('TrapDetectDC');\n\n    if(this.template.RootNode.hasField('TrapDetectable'))\n      this.trapDetectable = this.template.RootNode.getBooleanByLabel('TrapDetectable');\n\n    if(this.template.RootNode.hasField('TrapDisarmable'))\n      this.trapDisarmable = this.template.RootNode.getBooleanByLabel('TrapDisarmable');\n\n    if(this.template.RootNode.hasField('TrapFlag'))\n      this.trapFlag = this.template.RootNode.getBooleanByLabel('TrapFlag');\n\n    if(this.template.RootNode.hasField('TrapOneShot'))\n      this.trapOneShot = this.template.RootNode.getBooleanByLabel('TrapOneShot');\n\n    if(this.template.RootNode.hasField('TemplateResRef'))\n      this.templateResRef = this.template.RootNode.getStringByLabel('TemplateResRef');\n\n    if(this.template.RootNode.hasField('TrapType'))\n      this.trapType = this.template.RootNode.getNumberByLabel('TrapType');\n\n    if(this.template.RootNode.hasField('Will'))\n      this.will = this.template.RootNode.getNumberByLabel('Will');\n\n    if(this.template.RootNode.hasField('X'))\n      this.x = this.position.x = this.template.RootNode.getNumberByLabel('X');\n\n    if(this.template.RootNode.hasField('Y'))\n      this.y = this.position.y = this.template.RootNode.getNumberByLabel('Y');\n\n    if(this.template.RootNode.hasField('Z'))\n      this.z = this.position.z = this.template.RootNode.getNumberByLabel('Z');\n\n    if(this.template.RootNode.hasField('Bearing'))\n      this.bearing = this.rotation.z = this.template.RootNode.getNumberByLabel('Bearing');\n\n    if(this.template.RootNode.hasField('SWVarTable')){\n      const localBools = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('BitArray').getChildStructs();\n      for(let i = 0; i < localBools.length; i++){\n        const data = localBools[i].getNumberByLabel('Variable');\n        for(let bit = 0; bit < 32; bit++){\n          this._locals.Booleans[bit + (i*32)] = ( (data>>bit) % 2 != 0);\n        }\n      }\n    }\n\n    if(this.template.RootNode.hasField('EffectList')){\n      const effects = this.template.RootNode.getFieldByLabel('EffectList').getChildStructs() || [];\n      for(let i = 0; i < effects.length; i++){\n        const effect = GameEffectFactory.EffectFromStruct(effects[i]);\n        if(effect){\n          effect.setAttachedObject(this);\n          effect.loadModel();\n          this.effects.push(effect);\n          //this.addEffect(effect);\n        }\n      }\n    }\n\n    if(this.template.RootNode.hasField('LinkedTo'))\n      this.linkedTo = this.template.RootNode.getStringByLabel('LinkedTo');\n\n    if(this.template.RootNode.hasField('LinkedToFlags'))\n      this.linkedToFlags = this.template.RootNode.getNumberByLabel('LinkedToFlags');\n\n    if(this.template.RootNode.hasField('LinkedToModule'))\n      this.linkedToModule = this.template.RootNode.getStringByLabel('LinkedToModule');\n\n    if(this.template.RootNode.hasField('TransitionDestin'))\n      this.transitionDestin = this.template.RootNode.getFieldByLabel('TransitionDestin').getCExoLocString();\n\n    //BEGIN: TSL Properties\n    if(this.template.RootNode.hasField('TweakColor'))\n      this.tweakColor = this.template.RootNode.getNumberByLabel('TweakColor');\n\n    if(this.template.RootNode.hasField('UseTweakColor'))\n      this.useTweakColor = this.template.RootNode.getBooleanByLabel('UseTweakColor');\n\n    if(this.template.RootNode.hasField('NotBlastable'))\n      this.notBlastable = this.template.RootNode.getBooleanByLabel('NotBlastable');\n    //END: TSL Properties\n\n    this.initialized = true\n\n  }\n\n  destroy(): void {\n    super.destroy();\n    GameState.MenuManager.InGameAreaTransition.unsetTransitionObject(this);\n    try{\n      const wmIdx = GameState.walkmeshList.indexOf(this.collisionManager.walkmesh.mesh);\n      if(wmIdx >= 0) GameState.walkmeshList.splice(wmIdx, 1);\n    }catch{ /* walkmesh cleanup */ }\n  }\n\n  save(){\n    const gff = new GFFObject();\n    gff.FileType = 'UTD ';\n\n    gff.RootNode.addField( this.actionQueueToActionList() );\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Appearance') ).setValue(this.appearance);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'AutoRemoveKey') ).setValue(this.autoRemoveKey);\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'Bearing') ).setValue(this.bearing);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'BodyBag') ).setValue(this.bodyBag);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'CloseLockDC') ).setValue(this.closeLockDC);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Commandable') ).setValue(1);\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, 'Conversation') ).setValue(this.conversation ? this.conversation.resref : '');\n    gff.RootNode.addField( new GFFField(GFFDataType.SHORT, 'CurrentHP') ).setValue(this.currentHP);\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'Description') ).setValue('');\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'DisarmDC') ).setValue(this.disarmDC);\n\n    //Effects\n    const effectList = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'EffectList') );\n    for(let i = 0; i < this.effects.length; i++){\n      effectList.addChildStruct( this.effects[i].save() );\n    }\n\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Faction') ).setValue(this.faction ? this.faction.id : this.factionId);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Fort') ).setValue(this.fort);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'GenericType') ).setValue(this.genericType);\n    gff.RootNode.addField( new GFFField(GFFDataType.SHORT, 'HP') ).setValue(this.hp);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Hardness') ).setValue(this.hardness);\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'KeyName') ).setValue(this.keyName);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'KeyRequired') ).setValue(Number(this.keyRequired));\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'LinkedTo') ).setValue(this.linkedTo);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'LinkedToFlags') ).setValue(this.linkedToFlags);\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, 'LinkedToModule') ).setValue(this.linkedToModule);\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'LocName') ).setValue(this.locName);\n    gff.RootNode.addField( new GFFField(GFFDataType.WORD, 'LoadScreenID') ).setValue(this.loadScreenID);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Lockable') ).setValue(Number(this.lockable));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Locked') ).setValue(Number(this.locked));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Min1HP') ).setValue(Number(this.min1HP));\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue(this.id);\n\n    //Scripts\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnClick) ).setValue(this.scripts[ModuleObjectScript.DoorOnClick]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnClosed) ).setValue(this.scripts[ModuleObjectScript.DoorOnClosed]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnDamaged) ).setValue(this.scripts[ModuleObjectScript.DoorOnDamaged]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnDeath) ).setValue(this.scripts[ModuleObjectScript.DoorOnDeath]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnDisarm) ).setValue(this.scripts[ModuleObjectScript.DoorOnDisarm]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnFailToOpen) ).setValue(this.scripts[ModuleObjectScript.DoorOnFailToOpen]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnHeartbeat) ).setValue(this.scripts[ModuleObjectScript.DoorOnHeartbeat]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnLock) ).setValue(this.scripts[ModuleObjectScript.DoorOnLock]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnMeleeAttacked) ).setValue(this.scripts[ModuleObjectScript.DoorOnMeleeAttacked]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnOpen) ).setValue(this.scripts[ModuleObjectScript.DoorOnOpen]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnSpellCastAt) ).setValue(this.scripts[ModuleObjectScript.DoorOnSpellCastAt]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnTrapTriggered) ).setValue(this.scripts[ModuleObjectScript.DoorOnTrapTriggered]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnUnlock) ).setValue(this.scripts[ModuleObjectScript.DoorOnUnlock]?.name || '');\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.DoorOnUserDefined) ).setValue(this.scripts[ModuleObjectScript.DoorOnUserDefined]?.name || '');\n\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'OpenLockDC') ).setValue(this.openLockDC);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'OpenState') ).setValue(this.openState);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Plot') ).setValue(Number(this.plot));\n    gff.RootNode.addField( new GFFField(GFFDataType.WORD, 'PortraitId') ).setValue(this.portraitId);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Ref') ).setValue(this.ref);\n\n    //SWVarTable\n    const swVarTable = gff.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'SWVarTable') );\n    swVarTable.addChildStruct( this.getSWVarTableSaveStruct() );\n\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'SecretDoorDC') ).setValue(0);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Static') ).setValue(Number(this.static));\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'Tag') ).setValue(this.tag);\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'TransitionDestin') ).setValue(this.transitionDestin);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetectDC') ).setValue(this.trapDetectDC);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetectable') ).setValue(Number(this.trapDetectable));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDisarmable') ).setValue(Number(this.trapDisarmable));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapFlag') ).setValue(Number(this.trapFlag));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapOneShot') ).setValue(Number(this.trapOneShot));\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapType') ).setValue(this.trapType);\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Useable') ).setValue(this.useable);\n    gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'VarTable') );\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Will') ).setValue(this.will);\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'X') ).setValue(this.position.x);\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'Y') ).setValue(this.position.y);\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'Z') ).setValue(this.position.z);\n\n    this.template = gff;\n    return gff;\n  }\n\n  animationConstantToAnimation( animation_constant = 10000 ): ITwoDAAnimation {\n    const animations2DA = GameState.TwoDAManager.datatables.get('animations');\n    if(animations2DA){\n      switch( animation_constant ){\n        case ModuleDoorAnimState.DEFAULT:       //10000, //327 -\n          return animations2DA.rows[327] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.OPENED1:       //10050, //331 -\n          return animations2DA.rows[331] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.OPENED2:       //10051, //332 -\n          return animations2DA.rows[332] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.CLOSED:        //10022, //333 -\n          return animations2DA.rows[333] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.OPENING1:      //10052, //334 -\n          return animations2DA.rows[334] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.OPENING2:      //10053, //335 -\n          return animations2DA.rows[335] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.CLOSING1:      //10054, //336 -\n          return animations2DA.rows[336] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.CLOSING2:      //10055, //337 -\n          return animations2DA.rows[337] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.BUSTED:        //10153, //366 -\n          return animations2DA.rows[366] as unknown as ITwoDAAnimation;\n        case ModuleDoorAnimState.TRANS:         //10269, //344 -\n          return animations2DA.rows[344] as unknown as ITwoDAAnimation;\n      }\n\n      return super.animationConstantToAnimation( animation_constant );\n    }\n    return super.animationConstantToAnimation( animation_constant );\n  }\n\n  static GenerateTemplate(){\n    const template = new GFFObject();\n    template.FileType = 'UTD ';\n\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'AnimationState') );\n    template.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Appearance') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'AutoRemoveKey') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'CloseLockDC') );\n    template.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'Comment') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'Conversation') );\n    template.RootNode.addField( new GFFField(GFFDataType.SHORT, 'CurrentHP') );\n    template.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'Description') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'DisarmDC') );\n    template.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Faction') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Fort') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'GenericType') );\n    template.RootNode.addField( new GFFField(GFFDataType.SHORT, 'HP') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Hardness') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Interruptable') );\n    template.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'KeyName') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'KeyRequired') );\n    template.RootNode.addField( new GFFField(GFFDataType.WORD, 'LoadScreenID') );\n    template.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'LocName') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Lockable') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Locked') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Min1HP') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnClick') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnClosed') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnDamaged') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnDeath') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnDisarm') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnHeartbeat') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnLock') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnMeleeAttacked') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnOpen') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnSpellCastAt') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnTrapTriggered') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnUnlock') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnUsed') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'OnUserDefined') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'OpenLockDC') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'PaletteId') ).setValue(6);\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Plot') );\n    template.RootNode.addField( new GFFField(GFFDataType.WORD, 'PortraidId') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Ref') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Static') );\n    template.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'Tag') );\n    template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'TemplateResRef') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetectDC') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetactable') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDisarmable') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapFlag') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapOneShot') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapType') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Type') );\n    template.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Will') );\n\n    return template;\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleEncounter.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":258,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":258,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":311,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":311,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":313,"column":13,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":313,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":313,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":313,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":313,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":313,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":313,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":313,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":313,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":313,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":314,"column":13,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":314,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":314,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":314,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":314,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":314,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":314,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":314,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":314,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":314,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":315,"column":13,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":315,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":315,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":315,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":315,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":315,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":315,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":315,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":315,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":315,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":541,"column":76,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":541,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":542,"column":76,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":542,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":543,"column":76,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":543,"endColumn":94}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\r\n\r\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { ResourceLoader } from \"@/loaders\";\r\nimport { EncounterCreatureEntry } from \"@/module/EncounterCreatureEntry\";\r\nimport { EncounterSpawnEntry } from \"@/module/EncounterSpawnEntry\";\r\nimport { EncounterSpawnPointEntry } from \"@/module/EncounterSpawnPointEntry\";\r\nimport { ModuleObject } from \"@/module/ModuleObject\";\r\nimport { NWScript } from \"@/nwscript/NWScript\";\r\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFObject } from \"@/resource/GFFObject\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { OdysseyFace3 } from \"@/three/odyssey\";\r\nimport { ConfigClient } from \"@/utility/ConfigClient\";\r\n\r\n// import { ModuleObjectManager, PartyManager, FactionManager } from \"@/managers\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\n\r\n\r\nconst log = createScopedLogger(LogScope.Module);\r\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\r\n\r\n/**\r\n* ModuleEncounter class.\r\n* \r\n* Class representing an encounter found in module areas.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file ModuleEncounter.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class ModuleEncounter extends ModuleObject {\r\n  creatureList: EncounterCreatureEntry[];\r\n  spawnPointList: EncounterSpawnPointEntry[];\r\n  spawnList: EncounterSpawnEntry[];\r\n  active: number;\r\n  difficulty: number;\r\n  difficultyIndex: number;\r\n  maxCreatures: number;\r\n  playerOnly: number;\r\n  recCreatures: number;\r\n  reset: number;\r\n  resetTime: number;\r\n  spawnOption: number;\r\n  started: number;\r\n  objectsInsideIdx: number;\r\n  lastObjectEntered: ModuleObject | null;\r\n  lastObjectExited: ModuleObject | null;\r\n  triggered: boolean;\r\n  areaPoints: number | number[];\r\n  paletteId: number;\r\n  respawns: number;\r\n  numberSpawned: number;\r\n  heartbeatDay: number;\r\n  heartbeatTime: number;\r\n  lastSpawnDay: number;\r\n  lastSpawnTime: number;\r\n  lastEntered: number;\r\n  lastLeft: number;\r\n  exhausted: boolean;\r\n  currentSpawns: number;\r\n  customScriptId: number;\r\n  areaListMaxSize: number;\r\n  spawnPoolActive: boolean;\r\n\r\n  constructor ( gff = new GFFObject() ) {\r\n    super(gff);\r\n    this.objectType |= ModuleObjectType.ModuleEncounter;\r\n    this.template = gff;\r\n    this.vertices = []; \r\n\r\n    this.creatureList = [];\r\n\r\n    this.spawnPointList = [];  \r\n\r\n    this.spawnList = [];\r\n\r\n    this.active = 1; //0: Inactive | 1: Active\r\n    this.difficulty = 1; //OBSOLETE FIELD; Should always be identical to the VALUE in encdifficulty.2da pointed to by the DifficultyIndex Field.\r\n    this.difficultyIndex = 1; //Index into encdifficulty.2da\r\n    // this.faction = 0; //Faction ID; Only spawn when entered by creatures hostile to this faction\r\n    this.localizedName = undefined;\r\n    this.maxCreatures = 1; //Maximum number of creatures this encounter can spawn; 1-8\r\n    this.playerOnly = 0; //0: Any Creature | 1: Only Player ; Can Trigger\r\n    this.recCreatures = 1; //Recommneded number of creatures; 1-8\r\n    this.reset = 0; //0: No Respawn | 1: Respawn\r\n    this.resetTime = 32000; //Seconds before encounter respawns\r\n    this.spawnOption = 0; //0: Continuous Spawn | 1: Single-Shot Spawn\r\n    this.started = 0; //0: if there are no creatures currently belonging to the encounter. | 1: if any creatures currently exist that belong to the encounter.\r\n\r\n    this.scripts = {\r\n      onEntered: undefined,\r\n      onExhausted: undefined,\r\n      onExit: undefined,\r\n      onHeartbeat: undefined,\r\n      onUserDefined: undefined\r\n    };\r\n\r\n    this.objectsInside = [];\r\n    this.objectsInsideIdx = 0;\r\n    this.lastObjectEntered = null;\r\n    this.lastObjectExited = null;\r\n\r\n  }\r\n\r\n  update(delta = 0){\r\n    \r\n    super.update(delta);\r\n    \r\n    this.getCurrentRoom();\r\n    \r\n    //Check Module Creatures\r\n    const creatureLen = GameState.module.area.creatures.length;\r\n    for(let i = 0; i < creatureLen; i++){\r\n      const creature = GameState.module.area.creatures[i];\r\n      const pos = creature.position.clone();\r\n      if(this.box.containsPoint(pos)){\r\n        if(this.objectsInside.indexOf(creature) == -1){\r\n          this.objectsInside.push(creature);\r\n          if(this.isHostile(creature)){\r\n            creature.lastTriggerEntered = this;\r\n            this.lastObjectEntered = creature;\r\n\r\n            this.onEnter(creature);\r\n            this.triggered = true;\r\n          }\r\n        }\r\n      }else{\r\n        if(this.objectsInside.indexOf(creature) >= 0){\r\n          this.objectsInside.splice(this.objectsInside.indexOf(creature), 1);\r\n          if(this.isHostile(creature)){\r\n            creature.lastTriggerExited = this;\r\n            this.lastObjectExited = creature;\r\n            this.onExit(creature);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Check Party Members\r\n    const partyLen = GameState.PartyManager.party.length;\r\n    for(let i = 0; i < partyLen; i++){\r\n      const partymember = GameState.PartyManager.party[i];\r\n      const pos = partymember.position.clone();\r\n      \r\n      if(this.box.containsPoint(pos)){\r\n        if(this.objectsInside.indexOf(partymember) == -1){\r\n          this.objectsInside.push(partymember);\r\n          if(this.isHostile(partymember)){\r\n            partymember.lastTriggerEntered = this;\r\n            this.lastObjectEntered = partymember;\r\n\r\n            this.onEnter(partymember);\r\n            this.triggered = true;\r\n          }\r\n        }\r\n      }else{\r\n        if(this.objectsInside.indexOf(partymember) >= 0){\r\n          this.objectsInside.splice(this.objectsInside.indexOf(partymember), 1);\r\n          if(this.isHostile(partymember)){\r\n            partymember.lastTriggerExited = this;\r\n            this.lastObjectExited = partymember;\r\n\r\n            this.onExit(partymember);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.mesh.visible = ConfigClient.get('Game.debug.trigger_geometry_show') ? true : false;\r\n\r\n  }\r\n\r\n  onEnter(object: ModuleObject){\r\n    const nwscript = this.scripts[ModuleObjectScript.EncounterOnEntered];\r\n    if(!nwscript){ return; }\r\n    const instance = nwscript.newInstance();\r\n    instance.enteringObject = object;\r\n    instance.run(this, 0);\r\n  }\r\n\r\n  onExit(object: ModuleObject){\r\n    const nwscript = this.scripts[ModuleObjectScript.EncounterOnExit];\r\n    if(!nwscript){ return; }\r\n    const instance = nwscript.newInstance();\r\n    instance.exitingObject = object;\r\n    instance.run(this, 0);\r\n  }\r\n\r\n  load(){\r\n    if(this.getTemplateResRef()){\r\n      //Load template and merge fields\r\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['ute'], this.getTemplateResRef());\r\n      if(buffer){\r\n        const gff = new GFFObject(buffer);\r\n        this.template.merge(gff);\r\n        this.initProperties();\r\n        this.loadScripts();\r\n        try{ this.buildGeometry(); }catch(e){log.error(e)}\r\n        //this.initObjectsInside();\r\n      }else{\r\n        log.error('Failed to load ModuleTrigger template');\r\n        if(this.template instanceof GFFObject){\r\n          this.initProperties();\r\n          this.loadScripts();\r\n          try{ this.buildGeometry(); }catch(e){log.error(e)}\r\n        }\r\n      }\r\n    }else{\r\n      //We already have the template (From SAVEGAME)\r\n      this.initProperties();\r\n      this.loadScripts();\r\n      try{ this.buildGeometry(); }catch(e){log.error(e)}\r\n    }\r\n  }\r\n\r\n  buildGeometry(){\r\n    const trigGeom = this.getGeometry();\r\n\r\n    const material = new THREE.MeshBasicMaterial({\r\n      color: new THREE.Color( 0xFFFFFF ),\r\n      side: THREE.DoubleSide\r\n    });\r\n\r\n    this.mesh = new THREE.Mesh( trigGeom, material );\r\n    this.mesh.position.copy(this.position);\r\n    this.box.setFromObject(this.mesh);\r\n    this.box.min.z -= 100;\r\n    this.box.max.z += 100;\r\n\r\n    this.mesh.userData.moduleObject = this;\r\n    this.mesh.visible = false;\r\n    GameState.group.triggers.add(this.mesh);\r\n  }\r\n\r\n  getGeometry(){\r\n    const trigGeom = new THREE.BufferGeometry();\r\n    const vertices = this.vertices.slice();\r\n    const faces: OdysseyFace3[] = [];\r\n\r\n    try{\r\n      const holes: THREE.Vector2[][] = [];\r\n      const triangles = THREE.ShapeUtils.triangulateShape ( vertices, holes );\r\n      for( let i = 0; i < triangles.length; i++ ){\r\n        faces.push( new OdysseyFace3( triangles[i][0], triangles[i][1], triangles[i][2] ));\r\n      }\r\n    }catch(e){\r\n      log.error('ModuleTrigger', 'Failed to generate faces', {\r\n        trigger: this,\r\n        error: e\r\n      })\r\n    }\r\n\r\n    // trigGeom.computeFaceNormals();\r\n    trigGeom.computeVertexNormals();\r\n    trigGeom.computeBoundingSphere();\r\n\r\n    return trigGeom;\r\n  }\r\n\r\n  loadScripts(){\r\n    const scriptKeys = [\r\n      ModuleObjectScript.EncounterOnEntered,\r\n      ModuleObjectScript.EncounterOnExhausted,\r\n      ModuleObjectScript.EncounterOnExit,\r\n      ModuleObjectScript.EncounterOnHeartbeat,\r\n      ModuleObjectScript.EncounterOnUserDefined,\r\n    ];\r\n\r\n    const scriptsNode = this.template?.RootNode;\r\n    if(!scriptsNode){ return; }\r\n    for(const scriptKey of scriptKeys){\r\n      if(scriptsNode.hasField(scriptKey)){\r\n        const resRef = scriptsNode.getFieldByLabel(scriptKey).getValue();\r\n        if(!resRef){ continue; }\r\n        const nwscript = GameState.NWScript.Load(resRef);\r\n        if(!nwscript){ \r\n          log.warn(`ModuleEncounter.loadScripts: Failed to load script [${scriptKey}]:${resRef} for object ${this.name}`);\r\n          continue; \r\n        }\r\n        nwscript.caller = this;\r\n        this.scripts[scriptKey] = nwscript;\r\n      }\r\n    }\r\n  }\r\n\r\n  initProperties(){\r\n    \r\n    if(!this.initialized){\r\n      if(this.template.RootNode.hasField('ObjectId')){\r\n        this.id = this.template.getFieldByLabel('ObjectId').getValue();\r\n      }else if(this.template.RootNode.hasField('ID')){\r\n        this.id = this.template.getFieldByLabel('ID').getValue();\r\n      }\r\n      \r\n      GameState.ModuleObjectManager.AddObjectById(this);\r\n\r\n      if(this.template.RootNode.hasField('Geometry')){\r\n        this.geometry = this.template.getFieldByLabel('Geometry').getChildStructs();\r\n\r\n        //Push verticies\r\n        for(let i = 0; i < this.geometry.length; i++){\r\n          const tgv = this.geometry[i];\r\n          this.vertices[i] = new THREE.Vector3( \r\n            tgv.getFieldByLabel('X').getValue(),\r\n            tgv.getFieldByLabel('Y').getValue(),\r\n            tgv.getFieldByLabel('Z').getValue()\r\n          );\r\n        }\r\n      }\r\n\r\n      if(this.template.RootNode.hasField('SWVarTable')){\r\n        const localBools = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('BitArray').getChildStructs();\r\n        //log.info(localBools);\r\n        for(let i = 0; i < localBools.length; i++){\r\n          const data = localBools[i].getFieldByLabel('Variable').getValue();\r\n          for(let bit = 0; bit < 32; bit++){\r\n            this._locals.Booleans[bit + (i*32)] = ( (data>>bit) % 2 != 0);\r\n          }\r\n        }\r\n      }\r\n\r\n      if(this.template.RootNode.hasField('CreatureList')){\r\n        const creatures = this.template.RootNode.getFieldByLabel('CreatureList').getChildStructs();\r\n        let entry = undefined;\r\n        for(let i = 0, len = creatures.length; i < len; i++){\r\n          entry = EncounterCreatureEntry.FromStruct(creatures[i]);\r\n          if(entry instanceof EncounterCreatureEntry){\r\n            this.creatureList.push(entry);\r\n          }\r\n        }\r\n      }\r\n\r\n      if(this.template.RootNode.hasField('SpawnPointList')){\r\n        const spawnPoints = this.template.RootNode.getFieldByLabel('SpawnPointList').getChildStructs();\r\n        let entry = undefined;\r\n        for(let i = 0, len = spawnPoints.length; i < len; i++){\r\n          entry = EncounterSpawnPointEntry.FromStruct(spawnPoints[i]);\r\n          if(entry instanceof EncounterSpawnPointEntry){\r\n            this.spawnPointList.push(entry);\r\n          }\r\n        }\r\n      }\r\n\r\n      if(this.template.RootNode.hasField('SpawnList')){\r\n        const spawns = this.template.RootNode.getFieldByLabel('SpawnList').getChildStructs();\r\n        let entry = undefined;\r\n        for(let i = 0, len = spawns.length; i < len; i++){\r\n          entry = EncounterSpawnEntry.FromStruct(spawns[i]);\r\n          if(entry instanceof EncounterSpawnEntry){\r\n            this.spawnList.push(entry);\r\n          }\r\n        }\r\n      }\r\n\r\n      if(this.template.RootNode.hasField('Active'))\r\n        this.active = this.template.getFieldByLabel('Active').getValue();\r\n\r\n      if(this.template.RootNode.hasField('AreaPoints'))\r\n        this.areaPoints = this.template.getFieldByLabel('AreaPoints').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Difficulty'))\r\n        this.difficulty = this.template.getFieldByLabel('Difficulty').getValue();\r\n\r\n      if(this.template.RootNode.hasField('DifficultyIndex'))\r\n        this.difficultyIndex = this.template.getFieldByLabel('DifficultyIndex').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Faction')){\r\n        this.factionId = this.template.getFieldByLabel('Faction').getValue();\r\n        if((this.factionId & 0xFFFFFFFF) == -1){\r\n          this.factionId = 0;\r\n        }\r\n      }\r\n      this.faction = GameState.FactionManager.factions.get(this.factionId);\r\n\r\n      if(this.template.RootNode.hasField('LocalizedName'))\r\n        this.localizedName = this.template.getFieldByLabel('LocalizedName').getValue();\r\n\r\n      if(this.template.RootNode.hasField('MaxCreatures'))\r\n        this.maxCreatures = this.template.getFieldByLabel('MaxCreatures').getValue();\r\n\r\n      if(this.template.RootNode.hasField('PaletteID'))\r\n        this.paletteId = this.template.getFieldByLabel('PaletteID').getValue();\r\n\r\n      if(this.template.RootNode.hasField('PlayerOnly'))\r\n        this.playerOnly = this.template.getFieldByLabel('PlayerOnly').getValue();\r\n\r\n      if(this.template.RootNode.hasField('RecCreatures'))\r\n        this.recCreatures = this.template.getFieldByLabel('RecCreatures').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Reset'))\r\n        this.reset = this.template.getFieldByLabel('Reset').getValue();\r\n\r\n      if(this.template.RootNode.hasField('ResetTime'))\r\n        this.resetTime = this.template.getFieldByLabel('ResetTime').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Respawns'))\r\n        this.respawns = this.template.getFieldByLabel('Respawns').getValue();\r\n\r\n      if(this.template.RootNode.hasField('SpawnOption'))\r\n        this.spawnOption = this.template.getFieldByLabel('SpawnOption').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Tag'))\r\n        this.tag = this.template.getFieldByLabel('Tag').getValue();\r\n  \r\n      if(this.template.RootNode.hasField('TemplateResRef'))\r\n        this.templateResRef = this.template.getFieldByLabel('TemplateResRef').getValue();\r\n\r\n      if(this.template.RootNode.hasField('XPosition'))\r\n        this.position.x = this.template.getFieldByLabel('XPosition').getValue();\r\n\r\n      if(this.template.RootNode.hasField('YPosition'))\r\n        this.position.y = this.template.getFieldByLabel('YPosition').getValue();\r\n  \r\n      if(this.template.RootNode.hasField('ZPosition'))\r\n        this.position.z = this.template.getFieldByLabel('ZPosition').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Commandable'))\r\n        this.commandable = this.template.getFieldByLabel('Commandable').getValue();\r\n\r\n      if(this.template.RootNode.hasField('NumberSpawned'))\r\n        this.numberSpawned = this.template.getFieldByLabel('NumberSpawned').getValue();\r\n\r\n      if(this.template.RootNode.hasField('HeartbeatDay'))\r\n        this.heartbeatDay = this.template.getFieldByLabel('HeartbeatDay').getValue();\r\n\r\n      if(this.template.RootNode.hasField('HeartbeatTime'))\r\n        this.heartbeatTime = this.template.getFieldByLabel('HeartbeatTime').getValue();\r\n\r\n      if(this.template.RootNode.hasField('LastSpawnDay'))\r\n        this.lastSpawnDay = this.template.getFieldByLabel('LastSpawnDay').getValue();\r\n\r\n      if(this.template.RootNode.hasField('LastSpawnTime'))\r\n        this.lastSpawnTime = this.template.getFieldByLabel('LastSpawnTime').getValue();\r\n\r\n      if(this.template.RootNode.hasField('LastEntered'))\r\n        this.lastEntered = this.template.getFieldByLabel('LastEntered').getValue();\r\n\r\n      if(this.template.RootNode.hasField('LastLeft'))\r\n        this.lastLeft = this.template.getFieldByLabel('LastLeft').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Started'))\r\n        this.started = this.template.getFieldByLabel('Started').getValue();\r\n\r\n      if(this.template.RootNode.hasField('Exhausted'))\r\n        this.exhausted = this.template.getFieldByLabel('Exhausted').getValue();\r\n        \r\n      if(this.template.RootNode.hasField('CurrentSpawns'))\r\n        this.currentSpawns = this.template.getFieldByLabel('CurrentSpawns').getValue();\r\n    \r\n      if(this.template.RootNode.hasField('CustomScriptId'))\r\n        this.customScriptId = this.template.getFieldByLabel('CustomScriptId').getValue();\r\n\r\n      if(this.template.RootNode.hasField('AreaListMaxSize'))\r\n        this.areaListMaxSize = this.template.getFieldByLabel('AreaListMaxSize').getValue();\r\n\r\n      if(this.template.RootNode.hasField('SpawnPoolActive'))\r\n        this.spawnPoolActive = this.template.getFieldByLabel('SpawnPoolActive').getValue();\r\n\r\n      this.initialized = true;\r\n    }\r\n\r\n  }\r\n\r\n  destroy(): void {\r\n    super.destroy();\r\n  }\r\n\r\n  save(){\r\n    const gff = new GFFObject();\r\n    gff.FileType = 'UTE ';\r\n\r\n    const actionList = gff.RootNode.addField( this.actionQueueToActionList() );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Commandable') ).setValue(this.commandable);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Active') ).setValue(this.active);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Reset') ).setValue( this.reset );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'ResetTime') ).setValue(this.resetTime);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'Respawns') ).setValue(this.respawns);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'SpawnOption') ).setValue(this.spawnOption);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'MaxCreatures') ).setValue(this.maxCreatures);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'RecCreatures') ).setValue(this.recCreatures);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'PlayerOnly') ).setValue( this.playerOnly );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Faction') ).setValue( this.faction ? this.faction.id : this.factionId );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'DifficultyIndex') ).setValue( this.difficultyIndex );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'Difficulty') ).setValue( this.difficulty );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'LocalizedName') ).setValue(this.localizedName);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'Tag') ).setValue(this.tag);\r\n\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'NumberSpawned') ).setValue(this.numberSpawned);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'HeartbeatDay') ).setValue(this.heartbeatDay);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'HeartbeatTime') ).setValue(this.heartbeatTime);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'LastSpawnDay') ).setValue(this.lastSpawnDay);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'LastSpawnTime') ).setValue(this.lastSpawnTime);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Started') ).setValue(this.started);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Exhausted') ).setValue(this.exhausted);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'CurrentSpawns') ).setValue(this.currentSpawns);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'SpawnPoolActive') ).setValue(this.spawnPoolActive);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'LastEntered') ).setValue(this.lastEntered);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'LastLeft') ).setValue(this.lastLeft);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'CustomScriptId') ).setValue(this.customScriptId);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.INT, 'AreaListMaxSize') ).setValue(this.areaListMaxSize);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'AreaPoints') ).setValue(this.areaPoints);\r\n\r\n    const creatureList = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'CreatureList') );\r\n    let creature = undefined;\r\n    for(let i = 0; i < this.creatureList.length; i++){\r\n      creature = this.creatureList[i].save();\r\n      if(creature)\r\n        creatureList.addChildStruct( creature );\r\n    }\r\n\r\n    const spawnPointList = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'SpawnPointList') );\r\n    let spawnPoint = undefined;\r\n    for(let i = 0; i < this.spawnPointList.length; i++){\r\n      spawnPoint = this.spawnPointList[i].save();\r\n      if(spawnPoint)\r\n        spawnPointList.addChildStruct( spawnPoint );\r\n    }\r\n\r\n    if(this.spawnList.length){\r\n      const spawnList = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'SpawnList') );\r\n      let spawn = undefined;\r\n      for(let i = 0; i < this.spawnList.length; i++){\r\n        spawn = this.spawnList[i].save();\r\n        if(spawn)\r\n          spawnList.addChildStruct( spawn );\r\n      }\r\n    }\r\n\r\n    const geometry = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'Geometry') );\r\n    for(let i = 0; i < this.vertices.length; i++){\r\n      const vertStruct = new GFFStruct();\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'X') ).setValue(this.vertices[i].x);\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'Y') ).setValue(this.vertices[i].y);\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'Z') ).setValue(this.vertices[i].z);\r\n      geometry.addChildStruct(vertStruct);\r\n    }\r\n\r\n    //SWVarTable\r\n    const swVarTable = gff.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'SWVarTable') );\r\n    swVarTable.addChildStruct( this.getSWVarTableSaveStruct() );\r\n\r\n    //Scripts\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.EncounterOnEntered) ).setValue(this.scripts[ModuleObjectScript.EncounterOnEntered]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.EncounterOnExit) ).setValue(this.scripts[ModuleObjectScript.EncounterOnExit]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.EncounterOnExhausted) ).setValue(this.scripts[ModuleObjectScript.EncounterOnExhausted]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.EncounterOnHeartbeat) ).setValue(this.scripts[ModuleObjectScript.EncounterOnHeartbeat]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.EncounterOnUserDefined) ).setValue(this.scripts[ModuleObjectScript.EncounterOnUserDefined]?.name || '');\r\n\r\n    gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'VarTable') );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'XPosition') ).setValue(this.position.x);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'YPosition') ).setValue(this.position.y);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'ZPosition') ).setValue(this.position.z);\r\n\r\n    this.template = gff;\r\n    return gff;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleMGGunBank.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":99,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":99,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":101,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":101,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getWorldPosition on a type that cannot be resolved.","line":101,"column":14,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":101,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":104,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":104,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getWorldDirection on a type that cannot be resolved.","line":104,"column":14,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":104,"endColumn":31}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { MDLLoader } from \"@/loaders\";\r\nimport { ModuleMGGunBullet } from \"@/module/ModuleMGGunBullet\";\r\nimport { ModuleObject } from \"@/module/ModuleObject\";\r\nimport { OdysseyModel } from \"@/odyssey\";\r\nimport { GFFObject } from \"@/resource/GFFObject\";\r\nimport { OdysseyModel3D } from \"@/three/odyssey\";\r\n\r\n\r\n/**\r\n* ModuleMGGunBank class.\r\n* \r\n* Class representing a gunbank attached to players and enemy objects found in minigame modules.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file ModuleMGGunBank.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class ModuleMGGunBank extends ModuleObject {\r\n  bullets: ModuleMGGunBullet[];\r\n  owner: ModuleObject;\r\n  isPlayer: boolean = false;\r\n  proto_bullet: ModuleMGGunBullet | undefined;\r\n  fire_sound: string | undefined;\r\n  bulletTemplate: GFFObject;\r\n  bullet_hook: THREE.Object3D | undefined;\r\n  gunModel: string;\r\n  bankID: number;\r\n  fireSound: string | undefined;\r\n  horizSpread: number;\r\n  inaccuracy: number;\r\n  sensingRadius: number;\r\n  vertSpread: number;\r\n\r\n  constructor( template: GFFObject, owner: ModuleObject, isPlayer: boolean = false ){\r\n    super();\r\n    this.objectType |= ModuleObjectType.ModuleMGGunBank;\r\n    this.template = template;\r\n    this.bullets = [];\r\n    this.owner = owner;\r\n    this.isPlayer = isPlayer;\r\n\r\n    this.proto_bullet = undefined;\r\n    \r\n  }\r\n\r\n  update(delta = 0): void {\r\n    const proto = this.proto_bullet;\r\n    if (!proto) return;\r\n    //Update the gun timer\r\n    if(proto.fire_timer > 0){\r\n      proto.fire_timer -= 1 * delta;\r\n      if(proto.fire_timer < 0){\r\n        proto.fire_timer = 0;\r\n      }\r\n    }else{\r\n      proto.fire_timer = 0;\r\n    }\r\n\r\n    if(this.model) this.model.update(delta);\r\n\r\n    const old_bullet_indexes: number[] = [];\r\n\r\n    for(let i = 0, len = this.bullets.length; i < len; i++){\r\n      if(!this.bullets[i].update(delta)){\r\n        old_bullet_indexes.push(i);\r\n      }\r\n    }\r\n\r\n    let old_bullets_index = old_bullet_indexes.length;\r\n    while(old_bullets_index--){\r\n      this.bullets.splice(old_bullet_indexes[old_bullets_index], 1);\r\n    }\r\n  }\r\n\r\n  updatePaused(_delta: number = 0): void {\r\n  }\r\n\r\n  fire(){\r\n    const proto = this.proto_bullet;\r\n    if (!proto) return;\r\n    if(!proto.fire_timer){\r\n      proto.fire_timer = proto.rate_of_fire;\r\n\r\n      if(this.fire_sound){\r\n        GameState.guiAudioEmitter.playSoundFireAndForget(this.fire_sound);\r\n      }\r\n\r\n      if(this.model instanceof OdysseyModel3D){\r\n        this.model.playAnimation('fire', false);\r\n      }\r\n\r\n      const bullet = new ModuleMGGunBullet( this.bulletTemplate, this );\r\n      bullet.load().then( () => {\r\n        const hook = this.bullet_hook;\r\n        if (!hook) return;\r\n        hook.getWorldPosition(bullet.position);\r\n        // hook.getWorldQuaternion(bullet.quaternion);\r\n        this.owner.model.getWorldQuaternion(bullet.quaternion);\r\n        hook.getWorldDirection(bullet.direction);\r\n\r\n        GameState.group.placeables.add(bullet.model);\r\n        this.bullets.push(bullet);\r\n      });\r\n    }\r\n  }\r\n\r\n  load(){\r\n    this.initProperties();\r\n    return new Promise<void>( (resolve, _reject) => {\r\n      this.loadModel().then( () => {\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  loadModel(): Promise<void> {\r\n    return new Promise<void>( (resolve, _reject) => {\r\n      const resref = this.gunModel.replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\r\n      MDLLoader.loader.load(resref).then( (mdl: OdysseyModel) => {\r\n        OdysseyModel3D.FromMDL(mdl, {\r\n          onComplete: (model: OdysseyModel3D) => {\r\n            this.model = model;\r\n            this.bullet_hook = this.model.getObjectByName('bullethook0');\r\n            resolve();\r\n          },\r\n          context: this.context,\r\n          castShadow: true,\r\n          receiveShadow: true\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  initProperties(){\r\n    if(this.template.RootNode.hasField('BankID'))\r\n      this.bankID = this.template.getFieldByLabel('BankID').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Fire_Sound'))\r\n      this.fireSound = this.template.getFieldByLabel('Fire_Sound').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Gun_Model'))\r\n      this.gunModel = this.template.getFieldByLabel('Gun_Model').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Horiz_Spread'))\r\n      this.horizSpread = this.template.getFieldByLabel('Horiz_Spread').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Inaccuracy'))\r\n      this.inaccuracy = this.template.getFieldByLabel('Inaccuracy').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Sensing_Radius'))\r\n      this.sensingRadius = this.template.getFieldByLabel('Sensing_Radius').getValue()\r\n\r\n    if(this.template.RootNode.hasField('Vert_Spread'))\r\n      this.vertSpread = this.template.getFieldByLabel('Vert_Spread').getValue()\r\n      \r\n    this.bulletTemplate = GFFObject.FromStruct(this.template.RootNode.getFieldByLabel('Bullet').getChildStructs()[0]);\r\n    this.proto_bullet = new ModuleMGGunBullet(this.bulletTemplate, this);\r\n    this.proto_bullet.initProperties();\r\n\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleMGObstacle.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":120,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":120,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":120,"column":19,"nodeType":"MemberExpression","messageId":"errorCall","endLine":120,"endColumn":79}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { ILayoutObstacle } from \"@/interface/resource/ILayoutObstacle\";\nimport { ModuleObject } from \"@/module/ModuleObject\";\nimport { NWScript } from \"@/nwscript/NWScript\";\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Module);\nimport { GameState } from \"@/GameState\";\n\n/**\n* ModuleMGObstacle class.\n*\n* Class representing a obstacle found in minigame modules.\n*\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n*\n* @file ModuleMGObstacle.ts\n* @author KobaltBlu <https://github.com/KobaltBlu>\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n* @memberof KotOR\n*/\nexport class ModuleMGObstacle extends ModuleObject {\n  invince: number;\n  hit_points: number;\n  max_hps: number = 0;\n  invince_period: number;\n  layout: ILayoutObstacle;\n\n  constructor(template: GFFObject | undefined, layout: ILayoutObstacle) {\n    super(template);\n    this.objectType |= ModuleObjectType.ModuleMGObstacle;\n    this.name = '';\n    this.invince = 0;\n    this.layout = layout;\n    if (layout?.position) this.position.copy(layout.position as { x: number; y: number; z: number });\n  }\n\n  setTemplate(template: GFFObject) {\n    this.template = template;\n    this.initProperties();\n  }\n\n  update(delta: number = 0) {\n\n    this.invince -= delta;\n    if (this.invince < 0) this.invince = 0;\n\n  }\n\n  updatePaused(delta: number = 0) {\n\n  }\n\n  damage(damage = 0) {\n\n  }\n\n  adjustHitPoints(nHP = 0, nAbsolute = 0) {\n    this.hit_points += nHP;\n  }\n\n  startInvulnerability() {\n    this.invince = this.invince_period || 0;\n  }\n\n  onAnimEvent() {\n    const onAnimEvent = this.scripts[ModuleObjectScript.MGObstacleOnAnimEvent];\n    if (!onAnimEvent) { return; }\n    onAnimEvent.run(this, 0);\n  }\n\n  onCreate() {\n    const onCreate = this.scripts[ModuleObjectScript.MGObstacleOnCreate];\n    if (!onCreate) { return; }\n    onCreate.run(this, 0);\n  }\n\n  onHitBullet() {\n    const onHitBullet = this.scripts[ModuleObjectScript.MGObstacleOnHitBullet];\n    if (!onHitBullet) { return; }\n    onHitBullet.run(this, 0);\n  }\n\n  onHitFollower() {\n    const onHitFollower = this.scripts[ModuleObjectScript.MGObstacleOnHitFollower];\n    if (!onHitFollower) { return; }\n    onHitFollower.run(this, 0);\n  }\n\n  loadScripts() {\n    if (!this.template?.RootNode) return;\n    const scriptKeys = [\n      ModuleObjectScript.MGObstacleOnAnimEvent,\n      ModuleObjectScript.MGObstacleOnCreate,\n      ModuleObjectScript.MGObstacleOnHeartbeat,\n      ModuleObjectScript.MGObstacleOnHitBullet,\n      ModuleObjectScript.MGObstacleOnHitFollower,\n    ];\n    const scriptsNode = this.template.getFieldByLabel('Scripts')?.getFieldStruct();\n    if (!scriptsNode) return;\n    for (const scriptKey of scriptKeys) {\n      if (!scriptsNode.hasField(scriptKey)) continue;\n      const resRef = scriptsNode.getFieldByLabel(scriptKey).getValue();\n      if (!resRef) continue;\n      const nwscript = GameState.NWScript.Load(resRef);\n      if (!nwscript) {\n        log.warn(`ModuleMGObstacle.loadScripts: Failed to load script [${scriptKey}]:${resRef} for object ${this.name}`);\n        continue;\n      }\n      nwscript.caller = this;\n      this.scripts[scriptKey] = nwscript;\n    }\n  }\n\n  initProperties() {\n    if (this.template?.RootNode?.hasField('Name'))\n      this.name = this.template.getFieldByLabel('Name').getValue().toLowerCase();\n    if (this.layout?.name) this.name = this.layout.name.toLowerCase();\n    if (this.layout?.position) this.position.copy(this.layout.position as { x: number; y: number; z: number });\n    this.initialized = true;\n  }\n\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleMGPlayer.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":509,"column":31,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":509,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":515,"column":59,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":515,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transition on a type that cannot be resolved.","line":516,"column":26,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":516,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":517,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":517,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":517,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":517,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":522,"column":15,"nodeType":"Property","messageId":"anyAssignment","endLine":522,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":522,"column":26,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":522,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":563,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":563,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":564,"column":29,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":564,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":564,"column":54,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":564,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":565,"column":15,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":565,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":565,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":565,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":566,"column":19,"nodeType":"MemberExpression","messageId":"errorCall","endLine":566,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .triangle on a type that cannot be resolved.","line":566,"column":24,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":566,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .surfacemat on a type that cannot be resolved.","line":566,"column":68,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":566,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":576,"column":61,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":576,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transition on a type that cannot be resolved.","line":577,"column":28,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":577,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":584,"column":17,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":584,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":584,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":584,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":585,"column":17,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":585,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":585,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":585,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":586,"column":17,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":586,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":586,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":586,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":587,"column":17,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":587,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .line on a type that cannot be resolved.","line":587,"column":22,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":587,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"The type of computed name [edge.transition] cannot be resolved.","line":590,"column":61,"nodeType":"MemberExpression","messageId":"errorComputedMemberAccess","endLine":590,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transition on a type that cannot be resolved.","line":590,"column":66,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":590,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":600,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":600,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lastGroundFace on a type that cannot be resolved.","line":600,"column":28,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":600,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":600,"column":64,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":600,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":609,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":609,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":612,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":612,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":612,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":612,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lastGroundFace on a type that cannot be resolved.","line":612,"column":62,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":612,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":650,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":650,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":650,"column":73,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":650,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":653,"column":15,"nodeType":"Property","messageId":"anyAssignment","endLine":653,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":653,"column":22,"nodeType":"MemberExpression","messageId":"errorCall","endLine":653,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":653,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":653,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":666,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":666,"endColumn":121},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":666,"column":22,"nodeType":"MemberExpression","messageId":"errorCall","endLine":666,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":666,"column":57,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":666,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":668,"column":24,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":668,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on a type that cannot be resolved.","line":669,"column":26,"nodeType":"Literal","messageId":"errorMemberExpression","endLine":669,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ModuleRoom`.","line":670,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":670,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [0] on a type that cannot be resolved.","line":670,"column":42,"nodeType":"Literal","messageId":"errorMemberExpression","endLine":670,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":688,"column":30,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":688,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":689,"column":25,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":689,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":689,"column":49,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":689,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":690,"column":11,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":690,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .walkmesh on a type that cannot be resolved.","line":690,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":690,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":691,"column":15,"nodeType":"MemberExpression","messageId":"errorCall","endLine":691,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .triangle on a type that cannot be resolved.","line":691,"column":20,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":691,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":692,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":692,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":692,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":692,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":693,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":693,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lastGroundFace on a type that cannot be resolved.","line":693,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":693,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":693,"column":68,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":693,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":694,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":694,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .surfaceId on a type that cannot be resolved.","line":694,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":694,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .groundFace on a type that cannot be resolved.","line":694,"column":63,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":694,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":696,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":696,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .triangle on a type that cannot be resolved.","line":696,"column":18,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":696,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .wm_c_point on a type that cannot be resolved.","line":696,"column":81,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":696,"endColumn":91},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":697,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":697,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .wm_c_point on a type that cannot be resolved.","line":697,"column":50,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":697,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":702,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":702,"endColumn":17}],"suppressedMessages":[],"errorCount":67,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\n// import { NWScript } from \"@/nwscript/NWScript\";\nimport { MiniGameType } from \"@/enums/engine/MiniGameType\";\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { GameState } from \"@/GameState\";\nimport { IModelListItem } from \"@/interface/module/minigame/IModelListItem\";\nimport { MDLLoader } from \"@/loaders\";\nimport type { ModuleMGEnemy } from \"@/module/ModuleMGEnemy\";\nimport { ModuleMGGunBank } from \"@/module/ModuleMGGunBank\";\nimport type { ModuleMGGunBullet } from \"@/module/ModuleMGGunBullet\";\nimport type { ModuleMGObstacle } from \"@/module/ModuleMGObstacle\";\nimport { ModuleObject } from \"@/module/ModuleObject\";\nimport type { ModuleRoom } from \"@/module/ModuleRoom\";\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { OdysseyModel, OdysseyModelAnimationManager } from \"@/odyssey\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { OdysseyModel3D, OdysseyObject3D } from \"@/three/odyssey\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n* ModuleMGPlayer class.\n*\n* Class representing the player in minigame modules.\n*\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n*\n* @file ModuleMGPlayer.ts\n* @author KobaltBlu <https://github.com/KobaltBlu>\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n* @memberof KotOR\n*/\nexport class ModuleMGPlayer extends ModuleObject {\n\n  camera: OdysseyModel3D;\n  models: OdysseyModel3D[] = [];\n  track: OdysseyObject3D;\n  animationManagers: OdysseyModelAnimationManager[];\n  lastRoom: ModuleRoom;\n  gun_hook: THREE.Object3D;\n\n  gunBanks: ModuleMGGunBank[] = [];\n  bullets: ModuleMGGunBullet[] = [];\n\n  //debug sphere\n  sphere_geom: THREE.Mesh;\n\n  modelProps: IModelListItem[] = [];\n  no_rotate: THREE.Group;\n  speed_min: number;\n  speed_max: number;\n  accel_secs: number;\n  accel_lateral_secs: number;\n  lateralForce: number;\n  invince: number;\n  gear: number;\n  gunTimer: number;\n  jumpVelcolity: number;\n  boostVelocity: number;\n  falling: boolean;\n  alive: boolean;\n  tunnel: { neg: { x: number; y: number; z: number; }; pos: { x: number; y: number; z: number; }; };\n  hit_points: number;\n  max_hps: number;\n  onCreateRun: boolean;\n  sphere_radius: number;\n  invince_period: number;\n  bump_damage: number;\n  cameraRotate: number;\n  num_loops: number;\n\n  cameraName: string = '';\n  trackName: string = '';\n\n  constructor(template: GFFObject) {\n    super();\n    this.objectType |= ModuleObjectType.ModuleMGPlayer;\n    log.debug('ModuleMGPlayer', String(template), this);\n    this.template = template;\n\n    this.camera = null;\n    this.gunBanks = [];\n    this.modelProps = [];\n    this.track = new OdysseyObject3D();\n    this.model = this.container as unknown as OdysseyModel3D;\n\n    this.bullets = [];\n\n    this.no_rotate = new THREE.Group();\n\n    this.animationManagers = [];\n\n    this.speed = 0;\n    this.speed_min = 0;\n    this.speed_max = 0;\n    this.accel_secs = 0;\n    this.accel_lateral_secs = 0;\n    this.lateralForce = 0;\n    this.invince = 0;\n\n    this.gear = -1;\n    //this.timer = 0;\n    this.gunTimer = 0;\n    this.jumpVelcolity = 0;\n    this.boostVelocity = 0;\n    this.falling = true;\n    this.alive = true;\n\n    this.tunnel = {\n      neg: { x: 0, y: 0, z: 0 },\n      pos: { x: 0, y: 0, z: 0 }\n    }\n\n    this.setTrack(this.track);\n\n    this._heartbeatTimerOffset = -2900;\n\n    const geometry = new THREE.SphereGeometry(1, 16, 16);\n    const material = new THREE.MeshBasicMaterial({ color: 0x0000FF });\n    material.transparent = true;\n    material.opacity = 0.15;\n    this.sphere_geom = new THREE.Mesh(geometry, material);\n\n  }\n\n  canMove() {\n    return false;\n  }\n\n  getHP() {\n    return this.hit_points;\n  }\n\n  getMaxHP() {\n    return this.max_hps;\n  }\n\n  setTrack(model = new OdysseyObject3D()) {\n    log.debug('setTrack', model);\n    this.track = model;\n    this.rotation.reorder('YZX');\n\n    this.rotate('x', 0);\n    this.rotate('y', 0);\n    this.rotate('z', 0);\n\n    this.container.removeFromParent();\n\n    try {\n      this.track.getObjectByName('modelhook').add(this.container);\n    } catch (e) {\n      log.error('setTrack getObjectByName(modelhook)', e);\n    }\n\n    try {\n      this.track.parent.add(this.no_rotate);\n      this.no_rotate.position.copy(this.track.position);\n      this.no_rotate.quaternion.copy(this.track.quaternion);\n    } catch (e) {\n      log.error('setTrack track.parent.add', e);\n    }\n\n    this.onCreateRun = false;\n\n    this._heartbeatTimeout = 0;\n\n  }\n\n  update(delta: number = 0) {\n\n    this.invince -= delta;\n    if (this.invince < 0) this.invince = 0;\n\n    //super.update(delta);\n    //Process the heartbeat timer\n    if (GameState.module) {\n      this.triggerHeartbeat();\n    }\n\n    this.sphere.radius = this.sphere_radius;\n    // this.model.parent.getWorldPosition(this.position);\n    this.sphere.center.copy(this.position);\n\n    this.sphere_geom.scale.setScalar(this.sphere_radius);\n    this.sphere_geom.position.copy(this.sphere.center);\n\n    for (let i = 0; i < this.animationManagers.length; i++) {\n      const aManager = this.animationManagers[i];\n      if (\n        aManager.currentAnimationState.loop ||\n        (!aManager.currentAnimationState.loop && !aManager.currentAnimationState.elapsedCount)\n      ) {\n        aManager.updateAnimation(aManager.currentAnimation, aManager.currentAnimationState, delta);\n      }\n    }\n\n    for (let i = 0; i < this.container.children.length; i++) {\n      const model = this.container.children[i];\n      if (model instanceof OdysseyModel3D && model.bonesInitialized && model.visible) {\n        model.update(delta);\n      }\n    }\n\n    //this.animationManagers\n    this.forceVector.set(0, 0, 0);\n\n    switch (GameState.module.area.miniGame.type) {\n      case 1:\n\n        if (this.speed_min || this.speed) {\n\n          if (this.speed < this.speed_min) {\n            this.speed = this.speed_min;\n          }\n\n          this.speed += (this.accel_secs * delta);\n\n          if (this.speed_max && (this.speed >= this.speed_max)) {\n            this.speed = this.speed_max;\n          }\n\n          this.forceVector.set(this.lateralForce * delta, this.speed * delta, 0);\n\n          //this.track.position.y += ;\n          //this.model.position.z = this.jumpVelcolity;\n\n        }\n\n\n        this.track.updateMatrixWorld();\n        //this.updateCollision(delta);\n        this.track.position.add(this.forceVector);\n        //this.model.box.setFromObject(this.model);\n\n        const enemies = GameState.module.area.miniGame.enemies;\n        for (let i = 0; i < enemies.length; i++) {\n          const enemy = enemies[i];\n          if (enemy.sphere.containsPoint(this.sphere.center)) {\n            if (!enemy.collided) {\n              enemy.collided = true;\n              this.onHitFollower(enemy);\n            }\n          }\n        }\n\n        const obstacles = GameState.module.area.miniGame.obstacles;\n        for (let i = 0; i < obstacles.length; i++) {\n          const obstacle = obstacles[i];\n          const dist = this.position.distanceTo(obstacle.position);\n          const obstacleRadius = (obstacle as { sphere_radius?: number }).sphere_radius ?? 1;\n          const overlapping = dist < this.sphere_radius + obstacleRadius;\n          const hit = (obstacle as { _playerCollided?: boolean })._playerCollided;\n          if (overlapping && !hit) {\n            (obstacle as { _playerCollided?: boolean })._playerCollided = true;\n            this.onHitObstacle(obstacle);\n          } else if (!overlapping) {\n            (obstacle as { _playerCollided?: boolean })._playerCollided = false;\n          }\n        }\n\n        if (this.jumpVelcolity > 0) {\n          this.jumpVelcolity -= (2 * delta);\n        } else {\n          this.jumpVelcolity = 0;\n        }\n\n        if (this.boostVelocity > 0) {\n          this.boostVelocity -= (2 * delta);\n        } else {\n          this.boostVelocity = 0;\n        }\n\n        break;\n      case 2:\n\n        break;\n    }\n\n    for (let i = 0; i < this.gunBanks.length; i++) {\n      this.gunBanks[i].update(delta);\n    }\n\n    // this.model.parent.getWorldPosition(this.position);\n\n    this.sphere.center.copy(this.position);\n    this.sphere_geom.position.copy(this.sphere.center);\n\n    if (this.camera instanceof OdysseyModel3D && this.camera.bonesInitialized && this.camera.visible) {\n      this.camera.update(delta);\n    }\n    else if (!this.camera) {\n      const camerahook = this.container.getObjectByName('camerahook');\n      if (camerahook)\n        this.camera = camerahook.parent.parent as OdysseyModel3D;\n    }\n\n  }\n\n  updatePaused(delta: number = 0) {\n\n  }\n\n  damage(damage = 0) {\n    if (this.alive) {\n      this.hit_points -= damage;\n      let model: OdysseyModel3D;\n      for (let i = 0; i < this.container.children.length; i++) {\n        model = (this.container.children[i] as OdysseyModel3D);\n        if (model instanceof OdysseyModel3D) {\n          if (model.bonesInitialized && model.visible) {\n            model.playAnimation('damage', false);\n          }\n        }\n      }\n      this.onDamaged();\n    }\n  }\n\n  adjustHitPoints(nHP = 0, nAbsolute = 0) {\n    this.hit_points += nHP;\n  }\n\n  startInvulnerability() {\n    this.invince = this.invince_period || 0;\n  }\n\n  shoot() {\n    switch (GameState.module.area.miniGame.type) {\n      case MiniGameType.SWOOPRACE:\n        this.jump();\n        break;\n      case MiniGameType.TURRET:\n        this.fire();\n        break;\n    }\n  }\n\n  jump() {\n    this.jumpVelcolity = 0.4;\n    /*if(this.gear > -1 && !this.falling){\n      this.jumpVelcolity = 0.4;\n    }else{\n      this.jumpVelcolity = 0;\n    }*/\n  }\n\n  fire() {\n    if (this.gunBanks.length) {\n      for (let i = 0; i < this.gunBanks.length; i++) {\n        this.gunBanks[i].fire();\n      }\n    }\n    this.onFire();\n  }\n\n  rotate(axis = 'x', amount = 0) {\n\n    switch (axis) {\n      case 'x':\n\n        this.rotation.x += amount;\n\n        if (this.rotation.x > this.tunnel.pos.x)\n          this.rotation.x = this.tunnel.pos.x;\n\n        if (this.rotation.x < this.tunnel.neg.x)\n          this.rotation.x = this.tunnel.neg.x;\n\n        break;\n      case 'y':\n\n        this.rotation.y += amount;\n\n        if (this.rotation.y > this.tunnel.pos.y)\n          this.rotation.y = this.tunnel.pos.y;\n\n        if (this.rotation.y < this.tunnel.neg.y)\n          this.rotation.y = this.tunnel.neg.y;\n\n        break;\n      case 'z':\n\n        this.rotation.z += amount;\n\n        if (this.rotation.z > this.tunnel.pos.z)\n          this.rotation.z = this.tunnel.pos.z;\n\n        if (this.rotation.z < this.tunnel.neg.z)\n          this.rotation.z = this.tunnel.neg.z;\n\n        break;\n    }\n\n    this.rotation.x = Utility.NormalizeRadian(this.rotation.x);\n    this.rotation.y = Utility.NormalizeRadian(this.rotation.y);\n    this.rotation.z = Utility.NormalizeRadian(this.rotation.z);\n\n  }\n\n  playAnimation(name = '', bLooping = 0, bQueue = 0, bOverlay = 0) {\n    // const padding = '                                             ';\n    //log.debug(`play: ${name}${padding}`.substring(0, 20), `bLooping: ${bLooping ? 'true' : 'false'}${padding}`.substring(0, 20), `bQueue: ${bQueue ? 'true' : 'false'}${padding}`.substring(0, 20), `bOverlay: ${bOverlay ? 'true' : 'false'}${padding}`.substring(0, 20));\n    for (let i = 0; i < this.models.length; i++) {\n      const model = this.models[i];\n      const anim = model.odysseyAnimationMap.get(name.toLowerCase().trim());\n      if (anim) {\n\n        //Check if this animation has already been applied\n        const existingIndex = this.animationManagers.findIndex(am => am?.currentAnimation?.name == name);\n        if (existingIndex >= 0) {\n          this.animationManagers.splice(existingIndex, 1);\n        }\n\n        if (bOverlay) {\n          const animManager = new OdysseyModelAnimationManager(model);\n          const state = animManager.createAnimationState();\n          state.loop = bLooping ? true : false;\n          animManager.setCurrentAnimation(anim, state);\n          this.animationManagers.push(animManager);\n        } else {\n          model.playAnimation(anim, false);\n        }\n      }\n    }\n  }\n\n  removeAnimation(name = '') {\n    // const padding = '                                             ';\n    //log.debug( `remove: ${name}${padding}`.substring(0, 20) );\n    const existingIndex = this.animationManagers.findIndex(am => am?.currentAnimation?.name == name);\n    if (existingIndex >= 0) {\n      this.animationManagers.splice(existingIndex, 1);\n    }\n  }\n\n  updateCollision(delta = 0) {\n\n    if (!GameState.module || !GameState.module.area)\n      return;\n\n    const _axisFront = this.forceVector.clone();\n    const _oPosition = this.position.clone();\n\n    //this.getCurrentRoom();\n    const hitdist = this.sphere_radius;\n    const hitdist_half = hitdist / 2;\n\n    this.box.set(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n    this.box.translate(this.position);\n    this.box.translate(_axisFront);\n\n    const box = this.box.clone();\n\n    //START Gravity\n    GameState.raycaster.far = 10;\n    const scratchVec3 = new THREE.Vector3(0, 0, 2);\n    const playerFeetRay = this.position.clone().add((scratchVec3));\n    GameState.raycaster.ray.origin.set(playerFeetRay.x, playerFeetRay.y, playerFeetRay.z);\n    GameState.raycaster.ray.direction.set(0, 0, -1);\n\n    let obj = undefined;\n\n    if (!this.room) this.getCurrentRoom();\n\n    if (this.room) {\n\n      //START: PLACEABLE COLLISION\n      this.tmpPos = this.position.clone().add(this.forceVector);\n      const plcEdgeLines = [];\n      let face;\n      let edge;\n      let line;\n      const closestPoint = new THREE.Vector3(0, 0, 0);\n      let distance;\n      const plcCollision = false;\n      /*for(let j = 0, jl = this.room.placeables.length; j < jl; j++){\n        obj = this.room.placeables[j];\n        if(obj && obj.walkmesh && obj.model && obj.model.visible){\n          obj.box.setFromObject(obj.model);\n          if(obj.box.intersectsBox(box) || obj.box.containsBox(box)){\n            for(let l = 0, ll = obj.walkmesh.edgeKeys.length; l < ll; l++){\n              edge = obj.walkmesh.edges[obj.walkmesh.edgeKeys[l]];\n              edge.line.closestPointToPoint(this.tmpPos, true, closestPoint);\n              distance = closestPoint.distanceTo(this.tmpPos);\n              if(distance < hitdist_half){\n                plcEdgeLines.push({\n                  object: obj,\n                  line: line,\n                  closestPoint: closestPoint.clone(),\n                  distance: distance,\n                  maxDistance: hitdist_half,\n                  position: this.position\n                });\n                plcCollision = true;\n              }\n            }\n          }\n        }\n      }*/\n\n      //END: PLACEABLE COLLISION\n\n      //START: ROOM COLLISION\n      if (!this.collisionData.groundFace) {\n        this.findWalkableFace();\n      }\n\n      //room walkable edge check\n      let roomCollision = false;\n      for (const [index, edge] of this.room.collisionData.walkmesh.edges) {\n        if (edge && edge.transition == -1) {\n          edge.line.closestPointToPoint(this.tmpPos, true, closestPoint);\n          distance = closestPoint.distanceTo(this.tmpPos);\n          if (distance < hitdist_half) {\n            plcEdgeLines.push({\n              object: this.room,\n              line: edge.line,\n              closestPoint: closestPoint.clone(),\n              distance: distance,\n              maxDistance: hitdist_half,\n              position: this.position\n            });\n            roomCollision = true;\n          }\n        }\n      }\n\n\n\n      if (!(plcCollision && roomCollision)) {\n        if (plcEdgeLines.length) {\n          plcEdgeLines.sort((a, b) => (a.distance > b.distance) ? -1 : 1)\n          const average = new THREE.Vector3();\n          let edgeLine = undefined;\n          let distanceOffset = 0;\n          let force: THREE.Vector3;\n          for (let i = 0, len = plcEdgeLines.length; i < len; i++) {\n            edgeLine = plcEdgeLines[i];\n            distanceOffset = edgeLine.maxDistance - edgeLine.distance;\n            force = edgeLine.closestPoint.clone().sub(edgeLine.position);\n            force.multiplyScalar(distanceOffset * 2.5);\n            force.z = 0;\n            average.add(force.negate());\n          }\n          this.position.copy(this.tmpPos);\n          this.forceVector.copy(average.divideScalar(plcEdgeLines.length));\n        }\n      } else {\n        this.forceVector.set(0, 0, 0);\n      }\n      //END: ROOM COLLISION\n\n      //Check to see if we tp'd inside of a placeable\n      if (this.forceVector.length()) {\n        this.tmpPos.copy(this.position).add(this.forceVector);\n        for (let j = 0, jl = this.room.placeables.length; j < jl; j++) {\n          obj = this.room.placeables[j];\n          if (obj && obj.collisionData.walkmesh && obj.model && obj.model.visible) {\n            for (let i = 0, iLen = obj.collisionData.walkmesh.faces.length; i < iLen; i++) {\n              face = obj.collisionData.walkmesh.faces[i];\n              if (face.triangle.containsPoint(this.tmpPos) && face.surfacemat.walk) {\n                //bail we should not be here\n                this.forceVector.set(0, 0, 0);\n                this.position.copy(_oPosition);\n              }\n            }\n          }\n        }\n\n        //DETECT: ROOM TRANSITION\n        for (const [index, edge] of this.room.collisionData.walkmesh.edges) {\n          if (edge && edge.transition >= 0) {\n            if (\n              Utility.LineLineIntersection(\n                this.position.x,\n                this.position.y,\n                this.position.x + this.forceVector.x,\n                this.position.y + this.forceVector.y,\n                edge.line.start.x,\n                edge.line.start.y,\n                edge.line.end.x,\n                edge.line.end.y\n              )\n            ) {\n              this.attachToRoom(GameState.module.area.rooms[edge.transition]);\n              break;\n            }\n          }\n        }\n\n        //update creature position\n        this.position.add(this.forceVector);\n        //DETECT: GROUND FACE\n        this.lastRoom = this.room;\n        this.collisionData.lastGroundFace = this.collisionData.groundFace;\n        //this.groundFace = undefined;\n        if (this.room) {\n          const face = this.room.findWalkableFace(this);\n          if (!face) {\n            this.findWalkableFace();\n          }\n        }\n\n        if (!this.collisionData.groundFace) {\n          this.forceVector.set(0, 0, 0);\n          this.position.copy(_oPosition);\n          this.collisionData.groundFace = this.collisionData.lastGroundFace;\n          this.attachToRoom(this.lastRoom);\n          this.forceVector.set(0, 0, 0);\n        }\n      }\n    }\n\n    //END Gravity\n    GameState.raycaster.far = Infinity;\n    this.track.updateMatrixWorld();\n\n    this.box.set(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n    this.box.translate(this.position);\n    this.box.translate(this.forceVector);\n\n  }\n\n  getCurrentRoom() {\n    if (this instanceof ModuleObject) {\n      this.room = undefined;\n      const aabbFaces = [];\n      let intersects;// = GameState.raycaster.intersectOctreeObjects( meshesSearch );\n      const box = this.box.clone();\n\n      this.rooms = [];\n      for (let i = 0; i < GameState.module.area.rooms.length; i++) {\n        const room = GameState.module.area.rooms[i];\n        const model = room.model;\n        if (model instanceof OdysseyModel3D) {\n          if (model.box.containsPoint(this.position)) {\n            this.roomIds.push(i);\n          }\n        }\n      }\n\n      if (box) {\n        for (let j = 0, jl = this.rooms.length; j < jl; j++) {\n          const room = GameState.module.area.rooms[this.roomIds[j]];\n          if (room && room.collisionData.walkmesh && room.collisionData.walkmesh.aabbNodes.length) {\n            aabbFaces.push({\n              object: room,\n              faces: room.collisionData.walkmesh.getAABBCollisionFaces(box)\n            });\n          }\n        }\n      }\n\n      const scratchVec3 = new THREE.Vector3(0, 0, 2);\n      const playerFeetRay = this.position.clone().add(scratchVec3);\n      GameState.raycaster.ray.origin.set(playerFeetRay.x, playerFeetRay.y, playerFeetRay.z);\n      GameState.raycaster.ray.direction.set(0, 0, -1);\n\n      for (let j = 0, jl = aabbFaces.length; j < jl; j++) {\n        const castableFaces = aabbFaces[j];\n        intersects = castableFaces.object.collisionData.walkmesh.raycast(GameState.raycaster, castableFaces.faces) || [];\n\n        if (intersects.length) {\n          if (intersects[0].object.userData.moduleObject) {\n            this.attachToRoom(intersects[0].object.userData.moduleObject);\n            return;\n          }\n        }\n      }\n      if (this.roomIds.length) {\n        this.attachToRoom(GameState.module.area.rooms[this.roomIds[0]]);\n        return;\n      }\n      this.findWalkableFace();\n    }\n  }\n\n  findWalkableFace() {\n    let face;\n    let room;\n    for (let i = 0, il = GameState.module.area.rooms.length; i < il; i++) {\n      room = GameState.module.area.rooms[i];\n      if (room.collisionData.walkmesh) {\n        for (let j = 0, jl = room.collisionData.walkmesh.walkableFaces.length; j < jl; j++) {\n          face = room.collisionData.walkmesh.walkableFaces[j];\n          if (face.triangle.containsPoint(this.position)) {\n            this.collisionData.groundFace = face;\n            this.collisionData.lastGroundFace = this.collisionData.groundFace;\n            this.collisionData.surfaceId = this.collisionData.groundFace.walkIndex;\n            this.attachToRoom(room);\n            face.triangle.closestPointToPoint(this.position, this.collisionData.wm_c_point);\n            this.position.z = this.collisionData.wm_c_point.z + .005;\n          }\n        }\n      }\n    }\n    return face;\n  }\n\n  load() {\n    this.initProperties();\n    this.loadScripts();\n    GameState.scene.add(this.sphere_geom);\n  }\n\n  loadCamera(onLoad?: () => void) {\n    if (this.cameraName) {\n      const resref = this.cameraName.replace(/\\0[\\s\\S]*$/g, '').toLowerCase();\n      MDLLoader.loader.load(resref).then(\n        (mdl: OdysseyModel) => {\n          OdysseyModel3D.FromMDL(mdl, {\n            onComplete: (camera: OdysseyModel3D) => {\n              try {\n                this.camera = camera;\n                camera.name = this.cameraName;\n                this.container.add(camera);\n\n                if (typeof onLoad === 'function')\n                  onLoad();\n              } catch (e) {\n                log.error('ModuleMGPlayer loadModel camera load', e);\n                if (typeof onLoad === 'function')\n                  onLoad();\n              }\n            },\n            context: this.context,\n            castShadow: true,\n            receiveShadow: true\n          });\n        }\n      );\n    } else {\n      if (typeof onLoad === 'function')\n        onLoad();\n    }\n  }\n\n  async loadModel() {\n    for (let i = 0; i < this.modelProps.length; i++) {\n      try {\n        const item = this.modelProps[i];\n        const resref = item.model.replace(/\\0[\\s\\S]*$/g, '').toLowerCase();\n        const mdl = await MDLLoader.loader.load(resref);\n        const model = await OdysseyModel3D.FromMDL(mdl, {\n          context: this.context,\n          castShadow: true,\n          receiveShadow: true\n        });\n        if (item.rotating) {\n          this.container.add(model);\n        } else {\n          this.no_rotate.add(model);\n        }\n        this.models.push(model);\n        model.name = item.model;\n\n        if (this.camera && model.name == this.camera.name)\n          model.visible = false;\n\n        (model as unknown as { addEventListener: (t: string, fn: (e: { event?: string }) => void) => void }).addEventListener?.('playEvent', (e: { event?: string }) => {\n          const mg = GameState.module?.area?.miniGame;\n          if (mg) {\n            mg.lastAnimEvent = e.event ?? '';\n            mg.lastAnimEventModelName = model.name ?? '';\n          }\n          this.onAnimEvent();\n        });\n      } catch (e) {\n        log.error('ModuleMGPlayer loadModel item load', e);\n      }\n    }\n  }\n\n  getGunHook(bankID: number): THREE.Object3D | undefined {\n    return this.container.getObjectByName('gunbank' + bankID) as THREE.Object3D;\n  }\n\n  async loadGunBanks() {\n    for (let i = 0; i < this.gunBanks.length; i++) {\n      const gunbank = this.gunBanks[i];\n      await gunbank.load();\n      this.gun_hook = this.getGunHook(gunbank.bankID);\n      if (this.gun_hook instanceof THREE.Object3D) {\n        this.gun_hook.add(gunbank.model);\n      }\n    }\n  }\n\n  onAnimEvent() {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnAnimEvent];\n    if (!instance) { return; }\n    instance.run(this, 0);\n  }\n\n  onCreate() {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnCreate];\n    if (!instance) { return; }\n    instance.run(this, 0);\n  }\n\n  onDamaged(): boolean {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnDamage];\n    if (!instance) { return true; }\n    instance.run(this, 0);\n    return true;\n  }\n\n  onFire() {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnFire];\n    if (!instance) { return; }\n    instance.run(this, 0);\n  }\n\n  onAccelerate() {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnAccelerate];\n    if (!instance) { return; }\n    instance.run(this, 0);\n  }\n\n  onHitBullet(bullet: ModuleMGGunBullet) {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnHitBullet];\n    if (!instance) { return; }\n    instance.mgBullet = bullet;\n    instance.run(this, 0);\n  }\n\n  onHitFollower(follower: ModuleMGEnemy) {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnHitFollower];\n    if (!instance) { return; }\n    instance.mgFollower = follower;\n    instance.run(this, 0);\n  }\n\n  onHitObstacle(obstacle: ModuleMGObstacle) {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnHitObstacle];\n    if (!instance) { return; }\n    instance.mgObstacle = obstacle;\n    instance.run(this, 0);\n  }\n\n  onTrackLoop() {\n    const instance = this.scripts[ModuleObjectScript.MGPlayerOnTrackLoop];\n    if (!instance) { return; }\n    instance.run(this, 0);\n  }\n\n  loadScripts() {\n    const scriptResRefs = [\n      ModuleObjectScript.MGPlayerOnAccelerate,\n      ModuleObjectScript.MGPlayerOnAnimEvent,\n      ModuleObjectScript.MGPlayerOnBrake,\n      ModuleObjectScript.MGPlayerOnCreate,\n      ModuleObjectScript.MGPlayerOnDamage,\n      ModuleObjectScript.MGPlayerOnDeath,\n      ModuleObjectScript.MGPlayerOnFire,\n      ModuleObjectScript.MGPlayerOnHeartbeat,\n      ModuleObjectScript.MGPlayerOnHitBullet,\n      ModuleObjectScript.MGPlayerOnHitFollower,\n      ModuleObjectScript.MGPlayerOnHitObstacle,\n      ModuleObjectScript.MGPlayerOnHitWorld,\n      ModuleObjectScript.MGPlayerOnTrackLoop,\n    ];\n\n    const scriptsNode = this.template.getFieldByLabel('Scripts')?.getFieldStruct();\n    if (scriptsNode) {\n      for (const scriptKey of scriptResRefs) {\n        if (scriptsNode.hasField(scriptKey)) {\n          const resRef = scriptsNode.getFieldByLabel(scriptKey).getValue();\n          if (!resRef) { continue; }\n          const nwscript = GameState.NWScript.Load(resRef);\n          if (!nwscript) {\n            log.warn(`loadScripts: Failed to load script [${scriptKey}]:${resRef} for object ${this.name}`);\n            continue;\n          }\n          nwscript.caller = this;\n          this.scripts[scriptKey] = nwscript;\n        }\n      }\n    }\n  }\n\n  initProperties() {\n    if (this.template.RootNode.hasField('Accel_Secs'))\n      this.accel_secs = this.template.getFieldByLabel('Accel_Secs').getValue();\n\n    if (this.template.RootNode.hasField('Bump_Damage'))\n      this.bump_damage = this.template.getFieldByLabel('Bump_Damage').getValue();\n\n    if (this.template.RootNode.hasField('Camera'))\n      this.cameraName = this.template.getFieldByLabel('Camera').getValue();\n\n    if (this.template.RootNode.hasField('CameraRotate'))\n      this.cameraRotate = this.template.getFieldByLabel('CameraRotate').getValue();\n\n    if (this.template.RootNode.hasField('Hit_Points'))\n      this.hit_points = this.template.getFieldByLabel('Hit_Points').getValue();\n\n    if (this.template.RootNode.hasField('Invince_Period'))\n      this.invince_period = this.template.getFieldByLabel('Invince_Period').getValue();\n\n    if (this.template.RootNode.hasField('Max_HPs'))\n      this.max_hps = this.template.getFieldByLabel('Max_HPs').getValue();\n\n    if (this.template.RootNode.hasField('Maximum_Speed'))\n      this.speed_max = this.template.getFieldByLabel('Maximum_Speed').getValue();\n\n    if (this.template.RootNode.hasField('Minimum_Speed'))\n      this.speed_min = this.template.getFieldByLabel('Minimum_Speed').getValue();\n\n    if (this.template.RootNode.hasField('Num_Loops'))\n      this.num_loops = this.template.getFieldByLabel('Num_Loops').getValue();\n\n    if (this.template.RootNode.hasField('Sphere_Radius'))\n      this.sphere_radius = this.template.getFieldByLabel('Sphere_Radius').getValue();\n\n    if (this.template.RootNode.hasField('Track'))\n      this.trackName = this.template.getFieldByLabel('Track').getValue();\n\n    if (this.template.RootNode.hasField('TunnelXNeg'))\n      this.tunnel.neg.x = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelXNeg').getValue());\n\n    if (this.template.RootNode.hasField('TunnelXPos'))\n      this.tunnel.pos.x = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelXPos').getValue());\n\n    if (this.template.RootNode.hasField('TunnelYNeg'))\n      this.tunnel.neg.y = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelYNeg').getValue());\n\n    if (this.template.RootNode.hasField('TunnelYPos'))\n      this.tunnel.pos.y = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelYPos').getValue());\n\n    if (this.template.RootNode.hasField('TunnelZNeg'))\n      this.tunnel.neg.z = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelZNeg').getValue());\n\n    if (this.template.RootNode.hasField('TunnelZPos'))\n      this.tunnel.pos.z = THREE.MathUtils.degToRad(this.template.getFieldByLabel('TunnelZPos').getValue());\n\n    if (this.template.RootNode.hasField('Models')) {\n      const models = this.template.getFieldByLabel('Models').getChildStructs();\n      for (let i = 0; i < models.length; i++) {\n        const modelStruct = models[i];\n        this.modelProps.push({\n          model: modelStruct.getFieldByLabel('Model').getValue(),\n          rotating: !!modelStruct.getFieldByLabel('RotatingModel').getValue()\n        });\n      }\n    }\n\n    if (this.template.RootNode.hasField('Gun_Banks')) {\n      const gun_banks = this.template.getFieldByLabel('Gun_Banks').getChildStructs();\n      for (let i = 0; i < gun_banks.length; i++) {\n        this.gunBanks.push(\n          new ModuleMGGunBank(\n            GFFObject.FromStruct(gun_banks[i]),\n            this,\n            true\n          )\n        );\n      }\n\n      this.initialized = true;\n    }\n\n\n    /*if(this.template.RootNode.hasField('CameraRotate'))\n      this.cameraRotate = this.template.getFieldByLabel('CameraRotate').getValue();\n\n    if(this.template.RootNode.hasField('Hit_Points'))\n      this.hit_points = this.template.getFieldByLabel('Hit_Points').getValue();\n\n    if(this.template.RootNode.hasField('Invince_Period'))\n      this.invince_period = this.template.getFieldByLabel('Invince_Period').getValue();\n\n    if(this.template.RootNode.hasField('Max_HPs'))\n      this.max_hps = this.template.getFieldByLabel('Max_HPs').getValue();\n\n    if(this.template.RootNode.hasField('Maximum_Speed'))\n      this.maximum_speed = this.template.getFieldByLabel('Maximum_Speed').getValue();*/\n\n\n\n  }\n\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleObject.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [EngineDebugType.PATH_FINDING] on a type that cannot be resolved.","line":2172,"column":28,"nodeType":"MemberExpression","messageId":"errorMemberExpression","endLine":2172,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":3422,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":3422,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":3424,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":3424,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3424,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3424,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3424,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3424,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":3424,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3424,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":3424,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3424,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":3425,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":3425,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3425,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3425,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3425,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3425,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":3425,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3425,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":3425,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3425,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":3426,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":3426,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3426,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3426,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":3426,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":3426,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":3426,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3426,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":3426,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":3426,"endColumn":49}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport type { ModuleArea, ModuleCreature, ModuleDoor, ModuleItem, ModuleRoom } from \".\";\n\nimport type { Action } from \"@/actions/Action\";\nimport { ActionQueue } from \"@/actions/ActionQueue\";\nimport { AudioEmitter } from \"@/audio/AudioEmitter\";\nimport { CombatRound, CombatRoundAction } from \"@/combat\";\nimport { CombatData } from \"@/combat/CombatData\";\nimport type { SpellCastInstance } from \"@/combat/SpellCastInstance\";\nimport type { EffectLink } from \"@/effects\";\nimport type { GameEffect } from \"@/effects/GameEffect\";\nimport { CollisionManager } from \"@/engine/CollisionManager\";\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { Faction } from \"@/engine/Faction\";\nimport { ComputedPath } from \"@/engine/pathfinding\";\nimport { SWCreatureAppearance } from \"@/engine/rules/SWCreatureAppearance\";\nimport { SWDoorAppearance } from \"@/engine/rules/SWDoorAppearance\";\nimport { SWPlaceableAppearance } from \"@/engine/rules/SWPlaceableAppearance\";\nimport type { SWPortrait } from \"@/engine/rules/SWPortrait\";\nimport type { SWRange } from \"@/engine/rules/SWRange\";\nimport { CombatActionType, EngineDebugType, ModuleObjectScript, ModuleTriggerType, SkillType, TalkVolume } from \"@/enums\";\nimport { ActionParameterType } from \"@/enums/actions/ActionParameterType\";\nimport { ActionType } from \"@/enums/actions/ActionType\";\nimport { DiceType } from \"@/enums/combat/DiceType\";\nimport { GameEffectType } from \"@/enums/effects/GameEffectType\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { PerceptionMask } from \"@/enums/engine/PerceptionMask\";\nimport { ModuleCreatureAnimState } from \"@/enums/module/ModuleCreatureAnimState\";\nimport { ModuleObjectConstant } from \"@/enums/module/ModuleObjectConstant\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { ModulePlaceableAnimState } from \"@/enums/module/ModulePlaceableAnimState\";\nimport { NWScriptEventType } from \"@/enums/nwscript/NWScriptEventType\";\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\nimport { SSFType } from \"@/enums/resource/SSFType\";\nimport { GameState } from \"@/GameState\";\nimport { IDialogAnimationState } from \"@/interface/animation/IDialogAnimationState\";\nimport type { IHeardString } from \"@/interface/dialog/IHeardString\";\nimport type { IGameContext } from \"@/interface/engine/IGameContext\";\nimport type { IPerceptionInfo } from \"@/interface/engine/IPerceptionInfo\";\nimport { IEffectIconListItem } from \"@/interface/module/IEffectIconListItem\";\nimport { ITwoDAAnimation } from \"@/interface/twoDA/ITwoDAAnimation\";\nimport { MDLLoader } from \"@/loaders\";\nimport { NWScriptEvent } from \"@/nwscript/events\";\nimport { NWScript } from \"@/nwscript/NWScript\";\nimport { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { OdysseyModel, OdysseyModelAnimation, OdysseyWalkMesh } from \"@/odyssey\";\nimport { CExoLocString } from \"@/resource/CExoLocString\";\nimport { DLGObject } from \"@/resource/DLGObject\";\nimport { GFFField } from \"@/resource/GFFField\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { GFFStruct } from \"@/resource/GFFStruct\";\nimport { LIPObject } from \"@/resource/LIPObject\";\nimport { OdysseyModel3D, OdysseyObject3D } from \"@/three/odyssey\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { Dice } from \"@/utility/Dice\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\n\n\n\nconst log = createScopedLogger(LogScope.Game);\n\n/**\n* ModuleObject class.\n*\n* Class representing is the base class for all objects found in an area.\n*\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n*\n* @file ModuleObject.ts\n* @author KobaltBlu <https://github.com/KobaltBlu>\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n* @memberof KotOR\n*/\nexport class ModuleObject {\n  helperColor: THREE.Color = new THREE.Color(0xFFFFFF);\n\n  combatOrder: number;\n  combatRoundTimer: number;\n  controlled: boolean;\n  id: number;\n  initialized: boolean;\n  isPlayer: boolean = false;\n  isPM: boolean = false;\n  name: string;\n  objectType: number = ModuleObjectType.ModuleObject;\n\n  effectIconList: IEffectIconListItem[] = [];\n\n  container: OdysseyObject3D;\n  forceVector: THREE.Vector3 = new THREE.Vector3();\n  position: THREE.Vector3 = new THREE.Vector3();\n  lastPosition: THREE.Vector3 = new THREE.Vector3();\n  rotation: THREE.Euler = new THREE.Euler();\n  quaternion: THREE.Quaternion = new THREE.Quaternion();\n  _triangle: THREE.Triangle = new THREE.Triangle();\n  wm_c_point: THREE.Vector3 = new THREE.Vector3();\n  box: THREE.Box3 = new THREE.Box3();\n  sphere: THREE.Sphere = new THREE.Sphere();\n  v20: THREE.Vector2 = new THREE.Vector2();\n  v21: THREE.Vector2 = new THREE.Vector2();\n  tmpPos: THREE.Vector3 = new THREE.Vector3();\n  openSpot: { targetVector: THREE.Vector3 } | undefined;\n\n  audioEmitter: AudioEmitter;\n  footstepEmitter: AudioEmitter;\n\n  collisionManager: CollisionManager = new CollisionManager(this);\n  invalidateCollision: boolean = false;\n  combatData: CombatData = new CombatData(this);\n  combatRound = new CombatRound(this);\n\n  facing: number;\n  wasFacing: number;\n  facingTweenTime: number;\n  force: number;\n  speed: number;\n  movementSpeed: number;\n\n  area: ModuleArea;\n\n  //Room\n  room: ModuleRoom;\n  rooms: ModuleRoom[] = [];\n  roomIds: number[] = [];\n  roomSize: THREE.Vector3;\n\n  inventory: ModuleItem[] = [];\n\n  model: OdysseyModel3D;\n  xOrientation: number;\n  yOrientation: number;\n  zOrientation: number;\n\n  dialogAnimation: {\n    animation: OdysseyModelAnimation,\n    data: ITwoDAAnimation,\n    started: boolean,\n  };\n\n  dialogAnimationState: IDialogAnimationState = {\n    animationIndex: -1,\n    animation: undefined,\n    data: undefined,\n    started: false,\n  };\n\n  templateResRef: string = '';\n  template: GFFObject;\n\n  plot: boolean = false;\n  scripts: {[key: string]: NWScriptInstance} = { };\n  tag: string = '';\n  bearing: number = 0;\n  collisionTimer: number = 0;\n  perceptionTimer: number = 0;\n  tweakColor: number = 0xFFFFFF;\n  useTweakColor: boolean = false;\n  hp: number = 0;\n  currentHP: number = 0;\n\n  factionId: number = 0;\n  faction: Faction;\n\n  effects: GameEffect[] = [];\n  casting: SpellCastInstance[] = [];\n  damageList: { delay: number; amount: number }[] = [];\n  _locals: { Booleans: boolean[]; Numbers: Record<number, number> };\n  objectsInside: ModuleObject[] = [];\n  lockDialogOrientation: boolean = false;\n  context: IGameContext;\n\n  heartbeatTimer: ReturnType<typeof setTimeout> | undefined;\n  _heartbeatTimerOffset: number;\n  _heartbeatTimeout: number;\n\n  //Perception\n  heardStrings: IHeardString[] = [];\n  perceptionList: IPerceptionInfo[] = [];\n  isListening: boolean;\n  listeningPatterns: Record<string, number> = {};\n  perceptionRange: SWRange;\n\n  spawned: boolean = false;\n  _inventoryPointer: number;\n\n  //stats\n  fortitudeSaveThrow: number;\n  reflexSaveThrow: number;\n  willSaveThrow: number;\n  min1HP: boolean;\n\n  //attributes\n  placedInWorld: boolean = false;\n  linkedToModule: string = '';\n  linkedToFlags: number = 0;\n  linkedTo: string = '';\n  transitionDestin: CExoLocString = new CExoLocString();\n  description: CExoLocString;\n  commandable: boolean;\n  autoRemoveKey: number;\n  animState: number;\n  keyName: string;\n  loadScreenID: number;\n  locName: CExoLocString;\n  localizedName: CExoLocString;\n  hasMapNote: boolean;\n  mapNote: CExoLocString;\n  mapNoteEnabled: boolean;\n  portraitId: number;\n  portrait: SWPortrait;\n  setByPlayerParty: boolean;\n  highlightHeight: number;\n  appearance: number = -1;\n  cursor: number;\n  isDeadSelectable: boolean = true;\n  isDestroyable: boolean = true;\n  isRaisable: boolean = true;\n  playerCreated: boolean = false;\n\n  //complex animation varaibles\n  fp_push_played: boolean;\n  fp_land_played: boolean;\n  fp_getup_played: boolean;\n\n  deferEventUpdate: (() => void) | undefined;\n  distanceToCamera: number;\n  facingAnim: boolean;\n  mesh: THREE.Mesh;\n  /** Animation/geometry data; may be BufferGeometry or 2DA row data depending on context. */\n  geometry: THREE.BufferGeometry | Record<string, string | number> | null;\n  vertices: Float32Array | number[] | undefined;\n  /** Object type or animation type depending on context. */\n  type: number | string;\n  isReady: boolean = false;\n\n  //Actions\n  actionQueue: ActionQueue;\n  action: Action;\n\n  #computedPath: ComputedPath;\n\n  lipObject: LIPObject;\n  lookAtObject: ModuleObject;\n\n  //last object effected\n  lastTriggerEntered: ModuleObject;\n  lastTriggerExited: ModuleObject;\n  lastAreaEntered: ModuleObject;\n  lastAreaExited: ModuleObject;\n  lastModuleEntered: ModuleObject;\n  lastModuleExited: ModuleObject;\n  lastDoorEntered: ModuleDoor;\n  lastDoorExited: ModuleDoor;\n  lastPlaceableEntered: ModuleObject;\n  lastPlaceableExited: ModuleObject;\n  lastAoeEntered: ModuleObject;\n  lastAoeExited: ModuleObject;\n\n  conversation: DLGObject;\n  cutsceneMode: boolean;\n\n  trapDetectable: boolean;\n  trapDetectDC: number;\n  trapDisarmable: boolean;\n  trapDisarmDC: number;\n  trapOneShot: boolean;\n  trapType: number;\n  trapFlag: boolean;\n  ownerDemolitions: number = -1;\n\n  notBlastable: boolean = false;\n\n  fadeOnDestory: boolean = false;\n  fadeOutTimer: number = 3000;\n  linkedToObject: ModuleObject;\n\n  constructor (gff = new GFFObject) {\n    this.helperColor.setHex( Math.random() * 0xFFFFFF );\n    this.initialized = false;\n\n    //this.moduleObject = null;\n    this.forceVector = new THREE.Vector3();\n    this.container = new OdysseyObject3D();\n    this.container.userData.moduleObject = this;\n    this.position = this.container.position;\n    this.rotation = this.container.rotation;\n    this.quaternion = this.container.quaternion;\n    this._triangle = new THREE.Triangle();\n    // this.wm_c_point = new THREE.Vector3();\n\n    this.box = new THREE.Box3();\n    this.sphere = new THREE.Sphere();\n    this.facing = 0;\n    this.wasFacing = 0;\n    this.facingTweenTime = 0;\n    this.force = 0;\n    this.speed = 0;\n    this.movementSpeed = 1;\n    this.room = undefined;\n    this.rooms = [];\n    this.roomSize = new THREE.Vector3();\n    this.model = null;\n    this.dialogAnimation = null;\n    this.template = undefined;\n    this.plot = false;\n    this.inventory = [];\n    this.scripts = {\n      onAttacked: undefined,\n      onDamaged: undefined,\n      onDeath: undefined,\n      onDialog: undefined,\n      onDisturbed: undefined,\n      onEndDialog: undefined,\n      onEndRound: undefined,\n      onHeartbeat: undefined,\n      onBlocked: undefined,\n      onNotice: undefined,\n      onRested: undefined,\n      onSpawn: undefined,\n      onSpellAt: undefined,\n      onUserDefined: undefined\n    };\n\n    this.tag = '';\n    this.templateResRef = '';\n\n    this.xOrientation = 0;\n    this.yOrientation = 0;\n    this.zOrientation = 0;\n    this.bearing = 0;\n    this.collisionTimer = 0;\n    this.perceptionTimer = 0;\n\n    this.tweakColor = 0;\n    this.useTweakColor = false;\n\n    this.hp = 0;\n    this.currentHP = 0;\n\n    this.actionQueue = new ActionQueue();\n    this.actionQueue.setOwner( this );\n    this.effects = [];\n    this.casting = [];\n    this.damageList = [];\n\n    this._locals = {\n      Booleans: [],\n      Numbers: {}\n    };\n\n    this.objectsInside = [];\n    this.lockDialogOrientation = false;\n\n    this.context = GameState;\n    this._heartbeatTimerOffset = Math.floor(Math.random() * 600) + 100;\n    this._heartbeatTimeout = 0 + this._heartbeatTimerOffset;\n\n    //Combat Info\n    this.combatData.initialize();\n\n    //Always add the object to it's own perceptionList\n    this.perceptionList = [\n      {\n        object: this,\n        objectId: this.id,\n        data: PerceptionMask.SEEN_AND_HEARD\n      }\n    ];\n\n    this.isListening = false;\n    this.listeningPatterns = {};\n    this.combatData.initiative = 0;\n\n    this.spawned = false;\n\n    //Pointers\n    this._inventoryPointer = 0;\n\n    this.v20 = new THREE.Vector2();\n    this.v21 = new THREE.Vector2();\n\n    this.fortitudeSaveThrow = 0;\n    this.reflexSaveThrow = 0;\n    this.willSaveThrow = 0;\n\n  }\n\n  getScriptInstance(scriptKey: ModuleObjectScript): NWScriptInstance | undefined {\n    const script = this.scripts[scriptKey];\n    if(!script || !script.nwscript){ return undefined; }\n    return this.scripts[scriptKey].newInstance();\n  }\n\n  /**\n   * Attach to room\n   * @param room\n   */\n  attachToRoom(room: ModuleRoom){\n    this.detachFromRoom(this.room);\n    this.room = room;\n    this.room.attachChildObject(this);\n  }\n\n  /**\n   * Detach from room\n   * @param room\n   */\n  detachFromRoom(room: ModuleRoom){\n    if(!room) return;\n    room.removeChildObject(this);\n    this.room = undefined;\n  }\n\n  /**\n   * Set the context\n   * @param ctx\n   */\n  setContext(ctx = GameState){\n    this.context = ctx;\n    if(this.model instanceof OdysseyModel3D){\n      this.model.emitters.forEach( (emitter) => {\n        emitter.context = this.context;\n      });\n    }\n  }\n\n  /**\n   * Get the model\n   * @returns\n   */\n  getModel(){\n    if(this.model instanceof THREE.Object3D)\n      return this.model;\n    else\n      return this.model = new OdysseyModel3D();\n  }\n\n  /**\n   * Check if the object is visible\n   * @returns\n   */\n  isVisible(){\n    return this.getModel().visible;\n  }\n\n  /**\n   * Get the hit distance\n   * @returns\n   */\n  getHitDistance(){\n    return 1;\n  }\n\n  /**\n   * Update the movement speed\n   */\n  updateMovementSpeed(){\n    let movementSpeed = 1.0;\n\n    for(let i = 0, len = this.effects.length; i < len; i++){\n      const effect = this.effects[i];\n      let rate = 0;\n      if(effect.type == GameEffectType.EffectMovementSpeedIncrease){\n        rate = (effect.getInt(0) / 100);\n      }else if(effect.type == GameEffectType.EffectMovementSpeedDecrease){\n        rate = (effect.getInt(0) / -100);\n      }\n      movementSpeed += rate;\n    }\n\n    this.movementSpeed = movementSpeed;\n  }\n\n  /**\n   * Update the object\n   * @param delta\n   */\n  update(delta = 0){\n\n    //Process the heartbeat timer\n    if(this._heartbeatTimeout <= 0){\n      if(GameState.module){\n        this.triggerHeartbeat();\n      }\n      this._heartbeatTimeout = 3000;\n    }else{\n      this._heartbeatTimeout -= 1000*delta;\n    }\n\n    //Loop through and update the effects\n    if(!this.deferEventUpdate){\n      for(let i = 0, len = this.effects.length; i < len; i++){\n        this.effects[i].update(delta);\n      }\n    }\n\n    if(GameState.currentCamera){\n      this.distanceToCamera = this.position.distanceTo(GameState.currentCameraPosition);\n    }\n\n    if(this.spawned){\n      this.collisionManager.roomCheck(delta);\n    }\n\n\n    this.sphere.center.copy(this.position);\n    this.sphere.radius = this.getHitDistance() * 2;\n\n  }\n\n  /**\n   * Update the paused state\n   * @param delta\n   */\n  updatePaused(delta: number = 0){\n    // this.force = 0;\n    // this.forceVector.set(0, 0, 0);\n    if(this.spawned){\n      this.updateModelVisibility();\n    }\n  }\n\n  /**\n   * Update the model visibility\n   */\n  updateModelVisibility(){\n    if(!this.model){ return; }\n    this.model.wasOffscreen = !this.model.visible;\n\n    if(GameState.Mode == EngineMode.INGAME){\n      if(!this.room){\n        this.model.visible = true;\n        return;\n      }else{\n        this.model.visible = !!this.room?.model?.visible;\n      }\n\n      //Check to see if the model is inside the current camera's frustum\n      if(!this.isOnScreen()){\n        this.model.visible = false;\n      }\n      return;\n    }\n\n    if(GameState.Mode == EngineMode.DIALOG || GameState.Mode == EngineMode.MINIGAME){\n      this.model.visible = true;\n    }\n  }\n\n  /**\n   * Clear all actions\n   * @param skipUnclearable\n   */\n  clearAllActions(skipUnclearable = false){\n    this.combatRound.clearActions();\n    this.setComputedPath(undefined);\n    //Reset the anim state\n    //this.animState = 0;\n    //this.actionQueue.clear();\n    if(skipUnclearable){\n      let i = this.actionQueue.length;\n      while(i--){\n        const action = this.actionQueue[i];\n        if(action.type == ActionType.ActionDialogObject){ continue; }\n        if(typeof action.clearable !== 'undefined'){\n          if(action.clearable){\n            this.actionQueue.splice(i , 1);\n          }\n        }else{\n          this.actionQueue.splice(i , 1);\n        }\n      }\n    }else{\n      this.actionQueue.clear();\n    }\n\n    this.combatData.reset();\n    //this.clearTarget();\n  }\n\n  /**\n   * Clear the combat action\n   * @param combatAction\n   * @returns\n   */\n  clearCombatAction(combatAction: CombatRoundAction = undefined){\n    return this.combatRound.clearAction(combatAction);\n  }\n\n  /**\n   * Clear the combat action at index\n   * @param index\n   * @returns\n   */\n  clearCombatActionAtIndex(index: number = 0): boolean {\n    if(index <= 0) return;\n    return !!this.combatRound.scheduledActionList.splice(index, 1).length;\n  }\n\n  /**\n   * Action play animation\n   * @param anim\n   * @param speed\n   * @param time\n   */\n  actionPlayAnimation(anim = 0, speed = 1, time = 1){\n    if(typeof anim === 'string')\n      throw 'anim cannot be a string!';\n\n    const animConstant = this.getAnimationNameById(anim);\n    if(animConstant >= 10000){\n      const action = new GameState.ActionFactory.ActionPlayAnimation();\n      action.setParameter(0, ActionParameterType.INT, animConstant);\n      action.setParameter(1, ActionParameterType.FLOAT, speed || 1);\n      action.setParameter(2, ActionParameterType.FLOAT, time);\n      this.actionQueue.add(action);\n    }else{\n      log.error('actionPlayAnimation', animConstant, anim);\n    }\n  }\n\n  /**\n   * Action dialog object\n   * @param target\n   * @param dialogResRef\n   * @param ignoreStartRange\n   * @param bPrivate\n   * @param nConvoType\n   * @param clearable\n   */\n  actionDialogObject( target: ModuleObject, dialogResRef = '', ignoreStartRange = true, bPrivate = 0, nConvoType = 1, clearable = false ){\n    const action = new GameState.ActionFactory.ActionDialogObject();\n    action.setParameter(0, ActionParameterType.DWORD, target.id);\n    action.setParameter(1, ActionParameterType.STRING, dialogResRef);\n    action.setParameter(2, ActionParameterType.INT, bPrivate ? 1 : 0);\n    action.setParameter(3, ActionParameterType.INT, nConvoType);\n    action.setParameter(4, ActionParameterType.INT, ignoreStartRange ? 1 : 0);\n    action.setParameter(5, ActionParameterType.DWORD, ModuleObjectConstant.OBJECT_INVALID);\n    action.clearable = clearable;\n    log.debug('ModuleObject.actionDialogObject', action);\n    this.actionQueue.add(action);\n  }\n\n  /**\n   * Action use object\n   * @param object\n   */\n  actionUseObject( object: ModuleObject ){\n    const action = new GameState.ActionFactory.ActionUseObject();\n    action.setParameter(0, ActionParameterType.DWORD, object.id);\n    this.actionQueue.add(action);\n  }\n\n  /**\n   * Action open door\n   * @param door\n   */\n  actionOpenDoor( door: ModuleObject ){\n    const action = new GameState.ActionFactory.ActionOpenDoor();\n    action.setParameter(0, ActionParameterType.DWORD, door.id);\n    action.setParameter(1, ActionParameterType.INT, 0);\n    this.actionQueue.add(action);\n  }\n\n  /**\n   * Action close door\n   * @param door\n   */\n  actionCloseDoor( door: ModuleObject ){\n    const action = new GameState.ActionFactory.ActionCloseDoor();\n    action.setParameter(0, ActionParameterType.DWORD, door.id);\n    action.setParameter(1, ActionParameterType.INT, 0);\n    this.actionQueue.add(action);\n  }\n\n  /**\n   * Action wait\n   * @param time\n   */\n  actionWait( time = 0 ){\n    const action = new GameState.ActionFactory.ActionWait();\n    action.setParameter(0, ActionParameterType.FLOAT, time);\n    this.actionQueue.add(action);\n  }\n\n  isSimpleCreature(){\n    return false;\n  }\n\n  /**\n   * Gets the length (duration) of an animation state in seconds\n   *\n   * @param animationState - The animation state constant (e.g., ModuleCreatureAnimState.WALKING)\n   * @returns The animation length in seconds, or 0 if not found\n   */\n  getAnimationLength(animationState: number): number {\n    if (!this.model || !(this.model instanceof OdysseyModel3D)) {\n      return 0;\n    }\n\n    // Get the animation data from the 2DA table\n    const animationData = this.animationConstantToAnimation(animationState);\n    if (!animationData || !animationData.name) {\n      return 0;\n    }\n\n    // Find the animation in the model's animation list\n    const animation = this.model.odysseyAnimationMap.get(animationData.name.toLowerCase().trim());\n    if (!animation) {\n      return 0;\n    }\n\n    return animation.length;\n  }\n\n  /**\n   * Gets the length (duration) of an animation by name in seconds\n   *\n   * @param animationName - The name of the animation (e.g., \"walking\", \"attack\")\n   * @returns The animation length in seconds, or 0 if not found\n   */\n  getAnimationLengthByName(animationName: string): number {\n    if (!this.model || !(this.model instanceof OdysseyModel3D)) {\n      return 0;\n    }\n\n    // Find the animation in the model's animation list\n    const animation = this.model.odysseyAnimationMap.get(animationName.toLowerCase().trim());\n    if (!animation) {\n      return 0;\n    }\n\n    return animation.length;\n  }\n\n  /**\n   * Gets the current playing animation length in seconds\n   *\n   * @returns The current animation length in seconds, or 0 if no animation is playing\n   */\n  getCurrentAnimationLength(): number {\n    if (!this.model || !(this.model instanceof OdysseyModel3D)) {\n      return 0;\n    }\n\n    const currentAnimation = this.model.animationManager.currentAnimation;\n    if (!currentAnimation) {\n      return 0;\n    }\n\n    return currentAnimation.length;\n  }\n\n  /**\n   * Get the animation name by id\n   * @param id\n   * @returns\n   */\n  getAnimationNameById(id = -1){\n\n    if(typeof id === 'string')\n      throw 'getAnimation id cannot be a string';\n\n    if(id >= 10000)\n      return id;\n\n    switch(id){\n      case 0:  //PAUSE\n        return ModuleCreatureAnimState.PAUSE;\n      case 1:  //PAUSE2\n        return ModuleCreatureAnimState.PAUSE2;\n      case 2:  //LISTEN\n        return ModuleCreatureAnimState.LISTEN;\n      case 3:  //MEDITATE\n        return ModuleCreatureAnimState.MEDITATE;\n      case 4:  //WORSHIP\n        return ModuleCreatureAnimState.WORSHIP;\n      case 5:  //TALK_NORMAL\n        return ModuleCreatureAnimState.TALK_NORMAL;\n      case 6:  //TALK_PLEADING\n        return ModuleCreatureAnimState.TALK_PLEADING;\n      case 7:  //TALK_FORCEFUL\n        return ModuleCreatureAnimState.TALK_FORCEFUL;\n      case 8:  //TALK_LAUGHING\n        return ModuleCreatureAnimState.TALK_LAUGHING;\n      case 9:  //TALK_SAD\n        return ModuleCreatureAnimState.TALK_SAD;\n      case 10: //GET_LOW\n        return ModuleCreatureAnimState.GET_LOW;\n      case 11: //GET_MID\n        return ModuleCreatureAnimState.GET_MID;\n      case 12: //PAUSE_TIRED\n        return ModuleCreatureAnimState.PAUSE_TIRED;\n      case 13: //PAUSE_DRUNK\n        return ModuleCreatureAnimState.PAUSE_DRUNK;\n      case 14: //FLIRT\n        return ModuleCreatureAnimState.FLIRT;\n      case 15: //USE_COMPUTER\n        return ModuleCreatureAnimState.USE_COMPUTER;\n      case 16: //DANCE\n        return ModuleCreatureAnimState.DANCE;\n      case 17: //DANCE1\n        return ModuleCreatureAnimState.DANCE1;\n      case 18: //HORROR\n        return ModuleCreatureAnimState.HORROR;\n      case 19: //READY\n        return ModuleCreatureAnimState.READY;\n      case 20: //DEACTIVATE\n        return ModuleCreatureAnimState.DEACTIVATE;\n      case 21: //SPASM\n        return ModuleCreatureAnimState.SPASM;\n      case 22: //SLEEP\n        return ModuleCreatureAnimState.SLEEP;\n      case 23: //PRONE\n        return ModuleCreatureAnimState.PRONE;\n      case 24: //PAUSE3\n        return ModuleCreatureAnimState.PAUSE3;\n      case 25: //WELD\n        return ModuleCreatureAnimState.WELD;\n      case 26: //DEAD\n        return ModuleCreatureAnimState.DEAD;\n      case 27: //TALK_INJURED\n        return ModuleCreatureAnimState.TALK_INJURED;\n      case 28: //LISTEN_INJURED\n        return ModuleCreatureAnimState.LISTEN_INJURED;\n      case 29: //TREAT_INJURED\n        return ModuleCreatureAnimState.TREAT_INJURED_LP;\n      case 30: //DEAD_PRONE\n        return ModuleCreatureAnimState.DEAD_PRONE;\n      case 31: //KNEEL_TALK_ANGRY\n        return ModuleCreatureAnimState.KNEEL_TALK_ANGRY;\n      case 32: //KNEEL_TALK_SAD\n        return ModuleCreatureAnimState.KNEEL_TALK_SAD;\n      case 35: //MEDITATE LOOP\n        return ModuleCreatureAnimState.MEDITATE;\n      case 100: //HEAD_TURN_LEFT\n        return ModuleCreatureAnimState.HEAD_TURN_LEFT;\n      case 101: //HEAD_TURN_RIGHT\n        return ModuleCreatureAnimState.HEAD_TURN_RIGHT;\n      case 102: //PAUSE_SCRATCH_HEAD\n        return ModuleCreatureAnimState.PAUSE_SCRATCH_HEAD;\n      case 103: //PAUSE_BORED\n        return ModuleCreatureAnimState.PAUSE_BORED;\n      case 104: //SALUTE\n        return ModuleCreatureAnimState.SALUTE;\n      case 105: //BOW\n        return ModuleCreatureAnimState.BOW;\n      case 106: //GREETING\n        return ModuleCreatureAnimState.GREETING;\n      case 107: //TAUNT\n        return ModuleCreatureAnimState.TAUNT;\n      case 108: //VICTORY1\n        return ModuleCreatureAnimState.VICTORY;\n      case 109: //VICTORY2\n        return ModuleCreatureAnimState.VICTORY;\n      case 110: //VICTORY3\n        return ModuleCreatureAnimState.VICTORY;\n      case 112: //INJECT\n        return ModuleCreatureAnimState.INJECT;\n      case 113: //USE_COMPUTER\n        return ModuleCreatureAnimState.USE_COMPUTER;\n      case 114: //PERSUADE\n        return ModuleCreatureAnimState.PERSUADE;\n      case 115: //ACTIVATE\n        return ModuleCreatureAnimState.ACTIVATE_ITEM;\n      case 116: //CHOKE\n        return ModuleCreatureAnimState.CHOKE;\n      case 117: //THROW_HIGH\n        return ModuleCreatureAnimState.THROW_HIGH;\n      case 118: //THROW_LOW\n        return ModuleCreatureAnimState.THROW_LOW;\n      case 119: //CUSTOM01\n        return ModuleCreatureAnimState.CUSTOM01;\n      case 120: //TREAT_INJURED\n        return ModuleCreatureAnimState.TREAT_INJURED;\n      case 123: //DIVE_ROLL\n        return ModuleCreatureAnimState.DIVE_ROLL;\n\n      // Placeable animation constants\n      case 200:\n        return ModulePlaceableAnimState.ACTIVATE;\n      case 201:\n        return ModulePlaceableAnimState.DEACTIVATE;\n      case 202:\n        return ModulePlaceableAnimState.OPEN;\n      case 203:\n        return ModulePlaceableAnimState.CLOSE;\n      case 204:\n        return ModulePlaceableAnimState.ANIMLOOP01;\n      case 205:\n        return ModulePlaceableAnimState.ANIMLOOP02;\n      case 206:\n        return ModulePlaceableAnimState.ANIMLOOP03;\n      case 207:\n        return ModulePlaceableAnimState.ANIMLOOP04;\n      case 208:\n        return ModulePlaceableAnimState.ANIMLOOP05;\n      case 209:\n        return ModulePlaceableAnimState.ANIMLOOP06;\n      case 210:\n        return ModulePlaceableAnimState.ANIMLOOP07;\n      case 211:\n        return ModulePlaceableAnimState.ANIMLOOP08;\n      case 212:\n        return ModulePlaceableAnimState.ANIMLOOP09;\n      case 213:\n        return ModulePlaceableAnimState.ANIMLOOP10;\n    }\n\n    //log.error('Animation case missing', id);\n    return ModuleCreatureAnimState.PAUSE;\n  }\n\n  /**\n   * Get the animation constant to animation\n   * @param animation_constant\n   * @returns\n   */\n  animationConstantToAnimation( animation_constant = 10000 ): ITwoDAAnimation{\n\n    const animations2DA = GameState.TwoDAManager.datatables.get('animations');\n    if(animations2DA){\n      // Animations 2DA rows from game data match ITwoDAAnimation shape; index keys are numeric\n      const rows = animations2DA.rows as Record<number, ITwoDAAnimation>;\n\n      const debilitatedEffect = this.effects.find( e => e.type == GameEffectType.EffectSetState );\n      if(debilitatedEffect){\n        switch(debilitatedEffect.getInt(0)){\n          case 1: //Confused\n            return rows[15];\n          case 2: //Frightened\n            return rows[73];\n          case 3: //Droid Stun\n            return rows[270];\n          case 4: //Stunned\n            return rows[78];\n          case 5: //Paralyzed\n            return rows[78];\n          case 6: //Sleep\n            return rows[76];\n          case 7: //Choke\n            if(this.isSimpleCreature()){\n              return rows[264];\n            }else{\n              return rows[72];\n            }\n          break;\n          case 8: //Horrified\n            return rows[74];\n          case 9: //Force Pushed\n            if(!this.fp_push_played)\n              return rows[84];\n            if(!this.fp_land_played)\n              return rows[85];\n            if(!this.fp_getup_played)\n              return rows[86];\n          break;\n          case 10: //Whirlwind\n            return rows[75];\n        }\n      }\n\n      switch( animation_constant ){\n        case ModuleCreatureAnimState.PAUSE:\n        case ModuleCreatureAnimState.PAUSE_ALT:\n          if(this.isPoisoned() || this.isDiseased()) return rows[15];\n          if(this.isSimpleCreature()){\n            return rows[256];\n          }else{\n            if(this.getHP()/this.getMaxHP() > .20){\n              return rows[6];\n            }else{\n              return rows[8];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.PAUSE2:\n          if(this.isPoisoned() || this.isDiseased()) return rows[15];\n          if(this.isSimpleCreature()){\n            return rows[257];\n          }else{\n            if(this.getHP()/this.getMaxHP() > .20){\n              return rows[7];\n            }else{\n              return rows[8];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.PAUSE3:\n          if(this.isPoisoned() || this.isDiseased()) return rows[15];\n          if(this.getHP()/this.getMaxHP() > .20){\n            return rows[359];\n          }else{\n            return rows[8];\n          }\n        break;\n        case ModuleCreatureAnimState.PAUSE4:\n          if(this.isPoisoned() || this.isDiseased()) return rows[15];\n          if(this.getHP()/this.getMaxHP() > .20){\n            return rows[357];\n          }else{\n            return rows[8];\n          }\n        break;\n        case ModuleCreatureAnimState.PAUSE_SCRATCH_HEAD:\n          if(this.isPoisoned()) return rows[15];\n          if(this.isSimpleCreature()){\n            return rows[12];\n          }else{\n            if(this.getHP()/this.getMaxHP() > .20){\n              return rows[7];\n            }else{\n              return rows[8];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.PAUSE_BORED:\n          return rows[13];\n        break;\n        case ModuleCreatureAnimState.PAUSE_TIRED:\n          return rows[14];\n        break;\n        case ModuleCreatureAnimState.PAUSE_DRUNK:\n          return rows[15];\n        break;\n        case ModuleCreatureAnimState.PAUSE_INJ:\n          return rows[8];\n        break;\n        case ModuleCreatureAnimState.DEAD:\n          if(this.isSimpleCreature()){\n            return rows[275];\n          }else{\n            return rows[81];\n          }\n        break;\n        case ModuleCreatureAnimState.DEAD1:\n          if(this.isSimpleCreature()){\n            return rows[275];\n          }else{\n            return rows[83];\n          }\n        break;\n        case ModuleCreatureAnimState.DIE:\n          if(this.isSimpleCreature()){\n            return rows[274];\n          }else{\n            return rows[80];\n          }\n        break;\n        case ModuleCreatureAnimState.DIE1:\n          return rows[82];\n        break;\n        case ModuleCreatureAnimState.GET_UP_DEAD:\n          return rows[381];\n        break;\n        case ModuleCreatureAnimState.GET_UP_DEAD1:\n          return rows[382];\n        break;\n        case ModuleCreatureAnimState.WALK_INJ:\n          if(this.isSimpleCreature()){\n            return rows[254];\n          }else{\n            return rows[1];\n          }\n        break;\n        case ModuleCreatureAnimState.WALKING:\n          if(this.isSimpleCreature()){\n            if(this.getHP()/this.getMaxHP() > .20){\n              return rows[253];\n            }else{\n              return rows[254];\n            }\n          }else{\n            if(this.getHP()/this.getMaxHP() > .20){\n              switch(this.getCombatAnimationWeaponType()){\n                case 2:\n                  return rows[338];\n                case 3:\n                  return rows[341];\n                case 4:\n                  return rows[339];\n                case 7:\n                  return rows[340];\n                case 9:\n                  return rows[340];\n                default:\n                  return rows[0];\n              }\n            }else{\n              return rows[1];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.RUNNING:\n          if(this.isSimpleCreature()){\n            return rows[255];\n          }else{\n            if(this.getHP()/this.getMaxHP() > .20){\n              switch(this.getCombatAnimationWeaponType()){\n                case 1:\n                  return rows[343];\n                case 2:\n                  return rows[345];\n                case 3:\n                  return rows[345];\n                case 4:\n                  return rows[3];\n                case 7:\n                  return rows[340];\n                case 9:\n                  return rows[340];\n                default:\n                  return rows[2];\n              }\n            }else{\n              return rows[4];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.RUN_INJ:\n          return rows[4];\n        break;\n        //COMBAT READY\n        case ModuleCreatureAnimState.READY:\n        case ModuleCreatureAnimState.READY_ALT:\n          if(this.isSimpleCreature()){\n            return rows[278];\n          }else{\n            switch(this.getCombatAnimationWeaponType()){\n              case 1:\n                return rows[92];\n              case 2:\n                return rows[133];\n              case 3:\n                return rows[174];\n              case 4:\n                return rows[215];\n              case 5:\n                return rows[223];\n              case 6:\n                return rows[237];\n              case 7:\n                return rows[245];\n              case 9:\n                return rows[84]; //84 == pushed | 85 == hit ground prone back | 86 == get up from ground prone\n              default:\n                return rows[249];\n            }\n          }\n        break;\n        case ModuleCreatureAnimState.DODGE:\n          if(this.isSimpleCreature()){\n            return rows[281];\n          }else{\n            return rows[302];\n          }\n        break;\n        case ModuleCreatureAnimState.SPASM:\n          if(this.isSimpleCreature()){\n            return rows[268];\n          }else{\n            return rows[77];\n          }\n        break;\n        case ModuleCreatureAnimState.TAUNT:\n          if(this.isSimpleCreature()){\n            return rows[263];\n          }else{\n            return rows[33];\n          }\n        break;\n        case ModuleCreatureAnimState.GREETING:\n          return rows[31];\n        break;\n        case ModuleCreatureAnimState.LISTEN:\n          return rows[18];\n        break;\n        case ModuleCreatureAnimState.LISTEN_INJURED:\n          return rows[371];\n        break;\n        case ModuleCreatureAnimState.TALK_NORMAL:\n          return rows[25];\n        break;\n        case ModuleCreatureAnimState.TALK_PLEADING:\n          return rows[27];\n        break;\n        case ModuleCreatureAnimState.TALK_FORCEFUL:\n          return rows[26];\n        break;\n        case ModuleCreatureAnimState.TALK_LAUGHING:\n          return rows[29];\n        break;\n        case ModuleCreatureAnimState.TALK_SAD:\n          return rows[28];\n        break;\n        case ModuleCreatureAnimState.TALK_INJURED:\n          return rows[370];\n        break;\n        case ModuleCreatureAnimState.SALUTE:\n          return rows[16];\n        break;\n        case ModuleCreatureAnimState.BOW:\n          return rows[19];\n        break;\n        case ModuleCreatureAnimState.VICTORY:\n          if(this.isSimpleCreature()){\n            return rows[260];\n          }else{\n            return rows[17];\n          }\n        break;\n        case ModuleCreatureAnimState.HEAD_TURN_LEFT:\n          if(this.isSimpleCreature()){\n            return rows[258];\n          }else{\n            return rows[11];\n          }\n        break;\n        case ModuleCreatureAnimState.HEAD_TURN_RIGHT:\n          if(this.isSimpleCreature()){\n            return rows[259];\n          }else{\n            return rows[10];\n          }\n        break;\n        case ModuleCreatureAnimState.GET_LOW:\n          return rows[40];\n        break;\n        case ModuleCreatureAnimState.GET_MID:\n          return rows[41];\n        break;\n        case ModuleCreatureAnimState.INJECT:\n          return rows[37];\n        break;\n        case ModuleCreatureAnimState.DAMAGE:\n          return rows[303];\n        break;\n        case ModuleCreatureAnimState.USE_COMPUTER_LP:\n          return rows[44];\n        break;\n        case ModuleCreatureAnimState.WHIRLWIND:\n          return rows[75];\n        break;\n        case ModuleCreatureAnimState.DEACTIVATE:\n          return rows[270];\n        break;\n        case ModuleCreatureAnimState.FLIRT:\n          return rows[32];\n        break;\n        case ModuleCreatureAnimState.USE_COMPUTER:\n          return rows[43];\n        break;\n        case ModuleCreatureAnimState.DANCE:\n          return rows[53];\n        break;\n        case ModuleCreatureAnimState.DANCE1:\n          return rows[54];\n        break;\n        case ModuleCreatureAnimState.HORROR:\n          return rows[74];\n        break;\n        case ModuleCreatureAnimState.USE_COMPUTER2:\n          return rows[43];\n        break;\n        case ModuleCreatureAnimState.PERSUADE:\n          return rows[68];\n        break;\n        case ModuleCreatureAnimState.ACTIVATE_ITEM:\n          return rows[38];\n        break;\n        case ModuleCreatureAnimState.UNLOCK_DOOR:\n          return rows[47];\n        break;\n        case ModuleCreatureAnimState.THROW_HIGH:\n          return rows[57];\n        break;\n        case ModuleCreatureAnimState.THROW_LOW:\n          return rows[58];\n        break;\n        case ModuleCreatureAnimState.UNLOCK_CONTAINER:\n          return rows[48];\n        break;\n        case ModuleCreatureAnimState.DISABLE_MINE:\n          return rows[51];\n        break;\n        case ModuleCreatureAnimState.WALK_STEALTH:\n          return rows[5];\n        break;\n        case ModuleCreatureAnimState.UNLOCK_DOOR2:\n          return rows[47];\n        break;\n        case ModuleCreatureAnimState.UNLOCK_CONTAINER2:\n          return rows[48];\n        break;\n        case ModuleCreatureAnimState.ACTIVATE_ITEM2:\n          return rows[38];\n        break;\n        case ModuleCreatureAnimState.SLEEP:\n          return rows[76];\n        break;\n        case ModuleCreatureAnimState.PARALYZED:\n          return rows[78];\n        break;\n        case ModuleCreatureAnimState.PRONE:\n          return rows[79];\n        break;\n        case ModuleCreatureAnimState.SET_MINE:\n          return rows[52];\n        break;\n        case ModuleCreatureAnimState.DISABLE_MINE2:\n          return rows[51];\n        break;\n        case ModuleCreatureAnimState.CUSTOM01:\n          return rows[346];\n        break;\n        case ModuleCreatureAnimState.FBLOCK:\n          return rows[355];\n        break;\n        case ModuleCreatureAnimState.CHOKE:\n          if(this.isSimpleCreature()){\n            return rows[264];\n          }else{\n            return rows[72];\n          }\n        break;\n        case ModuleCreatureAnimState.WELD:\n          return rows[360];\n        break;\n        case ModuleCreatureAnimState.TREAT_INJURED:\n          return rows[34];\n        break;\n        case ModuleCreatureAnimState.TREAT_INJURED_LP:\n          return rows[35];\n        break;\n        case ModuleCreatureAnimState.CATCH_SABER:\n          return rows[71];\n        break;\n        case ModuleCreatureAnimState.THROW_SABER_LP:\n          return rows[70];\n        break;\n        case ModuleCreatureAnimState.THROW_SABER:\n          return rows[69];\n        break;\n        case ModuleCreatureAnimState.KNEEL_TALK_ANGRY:\n          return rows[384];\n        break;\n        case ModuleCreatureAnimState.KNEEL_TALK_SAD:\n          return rows[385];\n        break;\n        case ModuleCreatureAnimState.KNOCKED_DOWN:\n          return rows[85];\n        break;\n        case ModuleCreatureAnimState.KNOCKED_DOWN2:\n          return rows[85];\n        break;\n        case ModuleCreatureAnimState.DEAD_PRONE:\n          return rows[375];\n        break;\n        case ModuleCreatureAnimState.KNEEL:\n          return rows[23];\n        break;\n        case ModuleCreatureAnimState.KNEEL1:\n          return rows[23];\n        break;\n        case ModuleCreatureAnimState.FLOURISH:\n          switch( this.getCombatAnimationWeaponType() ){\n            case 1:\n              return rows[91];\n            case 2:\n              return rows[132];\n            case 3:\n              return rows[173];\n            case 4:\n              return rows[214];\n            case 5:\n              return rows[222];\n            case 6:\n              return rows[136];\n            case 7:\n              return rows[244];\n            case 8:\n              return rows[373];\n            case 9:\n              return rows[244];\n            default:\n              return rows[373];\n          }\n        break;\n\n        //BEGIN TSL ANIMATIONS\n        case ModuleCreatureAnimState.TOUCH_HEART:\n          return rows[462];\n        break;\n        case ModuleCreatureAnimState.ROLL_EYES:\n          return rows[463];\n        break;\n        case ModuleCreatureAnimState.USE_ITEM_ON_OTHER:\n          return rows[464];\n        break;\n        case ModuleCreatureAnimState.STAND_ATTENTION:\n          return rows[465];\n        break;\n        case ModuleCreatureAnimState.NOD_YES:\n          return rows[466];\n        break;\n        case ModuleCreatureAnimState.NOD_NO:\n          return rows[467];\n        break;\n        case ModuleCreatureAnimState.POINT:\n          return rows[468];\n        break;\n        case ModuleCreatureAnimState.POINT_LP:\n          return rows[469];\n        break;\n        case ModuleCreatureAnimState.POINT_DOWN:\n          return rows[470];\n        break;\n        case ModuleCreatureAnimState.SCANNING:\n          return rows[471];\n        break;\n        case ModuleCreatureAnimState.SHRUG:\n          return rows[472];\n        break;\n        case ModuleCreatureAnimState.SIT_CHAIR:\n          return rows[316];\n        break;\n        case ModuleCreatureAnimState.SIT_CHAIR_DRUNK:\n          return rows[317];\n        break;\n        case ModuleCreatureAnimState.SIT_CHAIR_PAZAAK:\n          return rows[318];\n        break;\n        case ModuleCreatureAnimState.SIT_CHAIR_COMP1:\n          return rows[316];\n        break;\n        case ModuleCreatureAnimState.SIT_CHAIR_COMP2:\n          return rows[316];\n        break;\n        case ModuleCreatureAnimState.CUT_HANDS:\n          return rows[557];\n        break;\n        case ModuleCreatureAnimState.L_HAND_CHOP:\n          return rows[558];\n        break;\n        case ModuleCreatureAnimState.COLLAPSE:\n          return rows[559];\n        break;\n        case ModuleCreatureAnimState.COLLAPSE_LP:\n          return rows[560];\n        break;\n        case ModuleCreatureAnimState.COLLAPSE_STAND:\n          return rows[561];\n        break;\n        case ModuleCreatureAnimState.BAO_DUR_POWER_PUNCH:\n          return rows[562];\n        break;\n        case ModuleCreatureAnimState.POINT_UP:\n          return rows[563];\n        break;\n        case ModuleCreatureAnimState.POINT_UP_LOWER:\n          return rows[564];\n        break;\n        case ModuleCreatureAnimState.HOOD_OFF:\n          return rows[565];\n        break;\n        case ModuleCreatureAnimState.HOOD_ON:\n          return rows[566];\n        break;\n        case ModuleCreatureAnimState.DIVE_ROLL:\n          return rows[567];\n        break;\n        //END TSL ANIMATIONS\n\n      }\n\n    }\n\n  }\n\n  /**\n   * Set the facing\n   * @param facing\n   * @param instant\n   */\n  setFacing(facing = 0, instant = false){\n    const diff = this.rotation.z - facing;\n    this.wasFacing = Utility.NormalizeRadian(this.rotation.z);\n    this.facing = Utility.NormalizeRadian(facing);//Utility.NormalizeRadian(this.rotation.z - diff);\n    this.facingTweenTime = 0;\n    this.facingAnim = true;\n\n    if(instant){\n      this.rotation.z = this.wasFacing = Utility.NormalizeRadian(this.facing);\n      this.facingAnim = false;\n    }\n  }\n\n  /**\n   * On hover input event\n   */\n  onHover(){\n\n  }\n\n  /**\n   * On click input event\n   * @param callee\n   */\n  onClick(callee: ModuleObject){\n\n  }\n\n  /**\n   * Trigger the user defined event\n   * @param event\n   */\n  triggerUserDefinedEvent( event: NWScriptEvent ){\n    if(!(event instanceof NWScriptEvent)){ return; }\n\n    let onUserDefined: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onUserDefined = this.scripts[ModuleObjectScript.CreatureOnUserDefined];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlaceable)){\n      onUserDefined = this.scripts[ModuleObjectScript.PlaceableOnUserDefined];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleDoor)){\n      onUserDefined = this.scripts[ModuleObjectScript.DoorOnUserDefined];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleTrigger)){\n      onUserDefined = this.scripts[ModuleObjectScript.TriggerOnUserDefined];\n    }\n\n    if(!onUserDefined){ return; }\n    onUserDefined.run(this, parseInt(event.getInt(0)));\n  }\n\n  /**\n   * Trigger the spell cast at event\n   * @param event\n   */\n  triggerSpellCastAtEvent( event: NWScriptEvent ){\n    if(!(event instanceof NWScriptEvent)){ return; }\n\n    let onSpellAt: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onSpellAt = this.scripts[ModuleObjectScript.CreatureOnSpellAt];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlaceable)){\n      onSpellAt = this.scripts[ModuleObjectScript.PlaceableOnSpellCastAt];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleDoor)){\n      onSpellAt = this.scripts[ModuleObjectScript.DoorOnSpellCastAt];\n    }\n\n    if(!onSpellAt){ return; }\n    const instance = onSpellAt.nwscript.newInstance();\n    instance.lastSpellCaster = event.getObject(0);\n    instance.lastSpell = event.getInt(0);\n    instance.lastSpellHarmful = event.getInt(1) ? true : false;\n    instance.run(this);\n  }\n\n  /**\n   * Script event handler\n   * @param event\n   */\n  scriptEventHandler( event: NWScriptEvent ){\n    // log.info('scriptEventHandler', this.tag, event);\n    if(event instanceof NWScriptEvent){\n      switch(event.type){\n        case NWScriptEventType.EventUserDefined:\n          this.triggerUserDefinedEvent( event );\n        break;\n        case NWScriptEventType.EventSpellCastAt:\n          this.triggerSpellCastAtEvent( event );\n        break;\n        default:\n          log.error('scriptEventHandler', 'Unhandled Event', event, this);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Trigger the heartbeat\n   */\n  triggerHeartbeat(){\n    //Only allow the heartbeat script to run after the onspawn is called\n    if(!(this.spawned === true && GameState.module.readyToProcessEvents)){\n      return;\n    }\n\n    let onHeartbeat: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onHeartbeat = this.scripts[ModuleObjectScript.CreatureOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlaceable)){\n      onHeartbeat = this.scripts[ModuleObjectScript.PlaceableOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleDoor)){\n      onHeartbeat = this.scripts[ModuleObjectScript.DoorOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleTrigger)){\n      onHeartbeat = this.scripts[ModuleObjectScript.TriggerOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleEncounter)){\n      onHeartbeat = this.scripts[ModuleObjectScript.EncounterOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleMGObstacle)){\n      onHeartbeat = this.scripts[ModuleObjectScript.MGObstacleOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleMGEnemy)){\n      onHeartbeat = this.scripts[ModuleObjectScript.MGEnemyOnHeartbeat];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleMGPlayer)){\n      onHeartbeat = this.scripts[ModuleObjectScript.MGPlayerOnHeartbeat];\n    }\n    if(!onHeartbeat){ return; }\n\n    onHeartbeat.run(this);\n  }\n\n  /**\n   * Get the appearance\n   * @returns\n   */\n  getAppearance(): SWPlaceableAppearance|SWCreatureAppearance|SWDoorAppearance {\n    return;\n  }\n\n  /**\n   * On spawn\n   * @param runScript\n   */\n  onSpawn(runScript = true){\n\n    let onSpawn: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onSpawn = this.scripts[ModuleObjectScript.CreatureOnSpawn];\n    }\n\n    if(runScript && onSpawn){\n      onSpawn.run(this, 0);\n      log.debug('spawned', this.getName());\n    }\n\n    this.spawned = true;\n\n    this.initEffects();\n    this.computeBoundingBox();\n  }\n\n  /**\n   * Get the name\n   * @returns\n   */\n  getName(): string {\n    log.warn(\"Method not implemented.\", this.tag);\n    return '';\n  }\n\n  /**\n   * Get the race\n   * @returns\n   */\n  getRace(): number {\n    log.warn(\"Method not implemented.\", this.tag);\n    return 0;\n  }\n\n  //----------------------//\n  // INVENTORY MANAGEMENT\n  //----------------------//\n\n  /**\n   * Check if the object has the item by tag\n   * @param sTag\n   * @returns\n   */\n  hasItemByTag(sTag=''){\n    sTag = sTag.toLowerCase();\n    if(this.isPartyMember()){\n      return !!GameState.InventoryManager.getItemByTag(sTag);\n    }\n\n    for(let i = 0; i < this.inventory.length; i++){\n      const cItem = this.inventory[i];\n      if(cItem.tag.toLocaleLowerCase() == sTag)\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add the item\n   * @param item\n   * @returns\n   */\n  addItem(item: ModuleItem){\n    item.load();\n\n    const eItem = this.getItemByTag(item.getTag());\n    if(eItem){\n      eItem.setStackSize(eItem.getStackSize() + item.getStackSize());\n      return eItem;\n    }else{\n      this.inventory.push(item);\n      return item;\n    }\n  }\n\n  /**\n   * Remove the item\n   * @param item\n   * @param nCount\n   * @returns\n   */\n  removeItem(item: ModuleItem, nCount = 1): ModuleItem {\n    const eItem = this.getItemByTag(item.getTag());\n\n    if(!eItem){\n      return undefined;\n    }\n\n    const idx = this.inventory.indexOf(eItem);\n\n    if(nCount < eItem.getStackSize()){\n      eItem.setStackSize(eItem.getStackSize() - nCount);\n    }else{\n      this.inventory.splice(idx, 1);\n    }\n\n    return eItem.clone();\n  }\n\n  /**\n   * Remove the item by tag\n   * @param sTag\n   * @param nCount\n   * @returns\n   */\n  removeItemByTag(sTag = '', nCount = 1): ModuleItem {\n    const eItem = this.getItemByTag(sTag);\n\n    if(!eItem){\n      return undefined;\n    }\n\n    const idx = this.inventory.indexOf(eItem);\n\n    if(nCount < eItem.getStackSize()){\n      eItem.setStackSize(eItem.getStackSize() - nCount);\n    }else{\n      this.inventory.splice(idx, 1);\n    }\n\n    return eItem.clone();\n  }\n\n  /**\n   * Get the item\n   * @param oItem\n   * @returns\n   */\n  getItem(oItem: ModuleItem): ModuleItem {\n    if(!oItem){ return undefined; }\n\n    for(let i = 0; i < this.inventory.length; i++){\n      const cItem = this.inventory[i];\n      if(cItem == oItem)\n        return cItem;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the item by tag\n   * @param sTag\n   * @returns\n   */\n  getItemByTag(sTag = ''): ModuleItem {\n    if(this.isPartyMember()){\n      return GameState.InventoryManager.getItemByTag(sTag) as ModuleItem;\n    }\n\n    for(let i = 0; i < this.inventory.length; i++){\n      const item = this.inventory[i];\n      if(item.getTag() == sTag)\n        return item;\n    }\n    return;\n  }\n\n  /**\n   * Get the gold\n   * @returns\n   */\n  getGold(): number {\n    if(this.isPartyMember()){\n      return GameState.PartyManager.Gold;\n    }\n    return 0;\n  }\n\n  /**\n   * Add gold\n   * @param nGold\n   */\n  addGold(nGold = 0): void {\n    if(this.isPartyMember()){\n      GameState.PartyManager.AddGold(nGold);\n      return;\n    }\n  }\n\n  /**\n   * Remove gold\n   * @param nGold\n   */\n  removeGold(nGold = 0): void {\n    if(this.isPartyMember()){\n      GameState.PartyManager.AddGold(-Math.abs(nGold));\n      return;\n    }\n  }\n\n  /**\n   * Update the collision\n   * @param delta\n   */\n  updateCollision(delta: number = 0){\n    //stub\n  }\n\n  /**\n   * Do a command\n   * @param script\n   */\n  doCommand(script: NWScriptInstance){\n    //log.info('doCommand', this.getTag(), script, action, instruction);\n    const action = new GameState.ActionFactory.ActionDoCommand();\n    action.setParameter(0, ActionParameterType.SCRIPT_SITUATION, script);\n    this.actionQueue.add(action);\n  }\n\n  /**\n   * Add a trap\n   * @param nTrapId\n   * @param owner\n   */\n  addTrap(nTrapId: number = -1, owner: ModuleObject){\n    const trap = GameState.TwoDAManager.datatables.get('traps')?.rows[nTrapId];\n    if(!trap){ return; }\n    log.debug('addTrap', trap);\n\n    if(trap.trapscript?.length && trap.trapscript != '****'){\n      const nwscript = NWScript.Load(trap.trapscript);\n      nwscript.caller = this;\n      if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleTrigger)){\n        this.scripts[ModuleObjectScript.TriggerOnTrapTriggered] = nwscript;\n      }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlaceable)){\n        this.scripts[ModuleObjectScript.PlaceableOnTrapTriggered] = nwscript;\n      }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleDoor)){\n        this.scripts[ModuleObjectScript.DoorOnTrapTriggered] = nwscript;\n      }\n    }\n\n    this.trapType = nTrapId;\n\n    this.ownerDemolitions = owner.getSkillLevel(SkillType.DEMOLITIONS);\n    const d20 = 20;\n\n    const nDetectDC = !isNaN(parseInt(trap.detectdcmod)) ? parseInt(trap.detectdcmod) : 0;\n    this.trapDetectDC = nDetectDC + d20 + this.ownerDemolitions;\n    this.trapDetectable = true;\n\n    const nDisarmDC = !isNaN(parseInt(trap.disarmdcmod)) ? parseInt(trap.disarmdcmod) : 0;\n    this.trapDisarmDC = nDisarmDC + d20 + this.ownerDemolitions;\n    this.trapDisarmable = false;\n\n    const trigger = new GameState.Module.ModuleArea.ModuleTrigger();\n    trigger.initialized = true;\n    trigger.name = GameState.TLKManager.GetStringById(parseInt(trap.name))?.Value;\n    trigger.factionId = owner.factionId;\n    trigger.type = ModuleTriggerType.TRAP;\n    trigger.trapType = nTrapId;\n    trigger.setByPlayerParty = owner.isPartyMember();\n    trigger.trapDetectDC = this.trapDetectDC;\n    trigger.trapDisarmDC = this.trapDisarmDC\n    trigger.trapDetectable = false;\n    trigger.trapDisarmable = false;\n    trigger.ownerDemolitions = -1;\n    trigger.position.copy(this.position);\n\n    trigger.linkedToObject = this;\n    this.linkedToObject = trigger;\n\n    //Trigger Geomerty\n    trigger.vertices[0] = new THREE.Vector3(-2,  2, 0);\n    trigger.vertices[1] = new THREE.Vector3(-2, -2, 0);\n    trigger.vertices[2] = new THREE.Vector3( 2,  2, 0);\n    trigger.vertices[3] = new THREE.Vector3( 2,  2, 0);\n\n    trigger.load();\n\n    this.area.triggers.push(trigger);\n  }\n\n  //---------------//\n  // STATUS CHECKS\n  //---------------//\n\n  /**\n   * Check if the object is in conversation\n   * @returns\n   */\n  isInConversation(){\n    return (GameState.Mode == EngineMode.DIALOG) && (GameState.CutsceneManager.owner == this || GameState.CutsceneManager.listener == this);\n  }\n\n  /**\n   * Check if the object is dead\n   * @returns\n   */\n  isDead(){\n    return this.getHP() <= 0;\n  }\n\n  /**\n   * Check if the object is debilitated\n   * @returns\n   */\n  isDebilitated() {\n    return false;\n  }\n\n  /**\n   * Check if the object is stunned\n   * @returns\n   */\n  isStunned() {\n    return false;\n  }\n\n  /**\n   * Check if the object is paralyzed\n   * @returns\n   */\n  isParalyzed() {\n    return false;\n  }\n\n  /**\n   * Check if the object is poisoned\n   * @returns\n   */\n  isPoisoned() {\n    return false;\n  }\n\n  /**\n   * Check if the object is diseased\n   * @returns\n   */\n  isDiseased(): boolean {\n    return false;\n  }\n\n  /**\n   * Get the combat animation weapon type\n   * @returns\n   */\n  getCombatAnimationWeaponType() {\n    return 0\n  }\n\n  /**\n   * Check if the object is dueling\n   * @returns\n   */\n  isDueling(): boolean {\n    return false;\n  }\n\n  /**\n   * Check if the action is in range\n   * @param action\n   * @returns\n   */\n  actionInRange(action: Action){\n    return true;\n  }\n\n  //---------------//\n  // SCRIPT EVENTS\n  //---------------//\n\n  /**\n   * On damaged\n   */\n  onDamaged(){\n    if(this.isDead())\n      return true;\n\n    let onDamaged: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onDamaged = this.scripts[ModuleObjectScript.CreatureOnDamaged];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModulePlaceable)){\n      onDamaged = this.scripts[ModuleObjectScript.PlaceableOnDamaged];\n    }else if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleDoor)){\n      onDamaged = this.scripts[ModuleObjectScript.DoorOnDamaged];\n    }\n\n    if(onDamaged){\n      onDamaged.run(this);\n    }\n  }\n\n  /**\n   * On death\n   */\n  onDeath(){\n    //stub\n  }\n\n  /**\n   * On combat round end\n   */\n  onCombatRoundEnd() {\n    //stub\n  }\n\n  /**\n   * On dialog\n   * @param oSpeaker\n   * @param listenPatternNumber\n   * @param conversation\n   * @returns\n   */\n  onDialog(oSpeaker: ModuleObject, listenPatternNumber = -1, conversation: DLGObject = undefined): boolean {\n    //stub\n    return false;\n  }\n\n  /**\n   * On attacked\n   */\n  onAttacked(attackType: CombatActionType){\n    //stub\n  }\n\n  /**\n   * On blocked\n   */\n  onBlocked(){\n    //stub\n  }\n\n  speakString(str: string, volume: TalkVolume){\n    //https://nwnlexicon.com/index.php?title=SpeakString\n    let notifyCreatures = false;\n    let notifyPCs = false;\n    const talkVolume = volume;\n\n    let range = 5;\n    switch(talkVolume){\n      case TalkVolume.TALK:\n\n      break;\n      case TalkVolume.WHISPER:\n\n      break;\n      case TalkVolume.SHOUT:\n\n      break;\n      case TalkVolume.SILENT_TALK:\n        range = 20;\n        notifyCreatures = true;\n      break;\n      case TalkVolume.SILENT_SHOUT:\n        range = 1000;\n        notifyCreatures = true;\n        notifyPCs = true;\n      break;\n    }\n\n    const rangeSquared = range * range;\n    let cDistanceSquared = 0;\n    // log.info('SpeakString', this.getName(), str, volume, range);\n    const speakString = str.toLowerCase();\n\n    if(notifyPCs){\n      for(let i = 0, len = GameState.PartyManager.party.length; i < len; i++){\n        const creature = GameState.PartyManager.party[i];\n        if(creature !== (this as ModuleObject) && !creature.isDead()){\n          cDistanceSquared = this.position.distanceToSquared(creature.position);\n          if(cDistanceSquared > rangeSquared){ continue; }\n          creature.heardStrings.push({\n            speaker: this,\n            string: speakString,\n            volume: talkVolume\n          });\n        }\n      }\n    }\n\n    if(notifyCreatures){\n      for(let i = 0, len = GameState.module.area.creatures.length; i < len; i++){\n        const creature = GameState.module.area.creatures[i];\n        if(creature !== (this as ModuleObject) && !creature.isDead()){\n          cDistanceSquared = this.position.distanceToSquared(creature.position);\n          if(cDistanceSquared > rangeSquared){ continue; }\n\n          creature.heardStrings.push({\n            speaker: this,\n            string: speakString,\n            volume: talkVolume\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Reset the excited duration\n   */\n  resetExcitedDuration() {\n    log.warn(\"Method not implemented.\", this.tag);\n  }\n\n  /**\n   * Set the commadable\n   * @param arg0\n   */\n  setCommadable(arg0: boolean | number) {\n    log.warn(\"Method not implemented.\", this.tag);\n  }\n\n  /**\n   * Damage the object\n   * @param amount\n   * @param oAttacker\n   * @param delayTime\n   */\n  damage(amount = 0, oAttacker?: ModuleObject, delayTime = 0){\n    this.subtractHP(amount);\n    this.combatData.lastDamager = oAttacker;\n    this.combatData.lastAttacker = oAttacker;\n    this.onDamaged();\n  }\n\n  /**\n   * Get the current room\n   * @returns\n   */\n  getCurrentRoom(){\n    this.collisionManager.findWalkableFace();\n  }\n\n  /**\n   * Get the computed path\n   * @returns\n   */\n  getComputedPath(){\n    return this.#computedPath;\n  }\n\n  /**\n   * Set the computed path\n   * @param computedPath\n   */\n  setComputedPath(computedPath: ComputedPath){\n    if(this.#computedPath){\n      this.#computedPath.dispose();\n    }\n    this.#computedPath = computedPath;\n    if(!this.#computedPath) return;\n\n    this.#computedPath.owner = this;\n    if(this.context?.debug[EngineDebugType.PATH_FINDING]){\n      this.#computedPath.enableHelper = true;\n    }\n    this.#computedPath.buildHelperLine();\n  }\n\n  #tmpLIOVec3 = new THREE.Vector3();\n  /**\n   * Check if a line intersects the object\n   * @param line\n   * @returns\n   */\n  checkLineIntersectsObject(line: THREE.Line3){\n    line.closestPointToPoint(this.position, true, this.#tmpLIOVec3);\n    // Check if the closest point is within the radius of the point\n    return this.#tmpLIOVec3.distanceTo(this.position) <= this.getHitDistance();\n  }\n\n  // findWalkableFace(object?: ModuleObject){\n  //   let face;\n  //   let room;\n  //   for(let i = 0, il = this.area.rooms.length; i < il; i++){\n  //     room = this.area.rooms[i];\n  //     if(room.walkmesh){\n  //       for(let j = 0, jl = room.walkmesh.walkableFaces.length; j < jl; j++){\n  //         face = room.walkmesh.walkableFaces[j];\n  //         if(face.triangle.containsPoint(this.position)){\n  //           this.groundFace = face;\n  //           this.lastGroundFace = this.groundFace;\n  //           this.surfaceId = this.groundFace.walkIndex;\n  //           this.attachToRoom(room);\n  //           face.triangle.closestPointToPoint(this.position, this.collisionManager.wm_c_point);\n  //           this.position.z = this.collisionManager.wm_c_point.z + .005;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return face;\n  // }\n\n  #tmpCHVec3 = new THREE.Vector3();\n\n  /**\n   * Get the camera hook position\n   * @returns\n   */\n  getCameraHookPosition(){\n    if(this.model && this.model.camerahook){\n      this.model.camerahook.getWorldPosition(this.#tmpCHVec3);\n      return this.#tmpCHVec3;\n    }\n\n    this.#tmpCHVec3.copy(this.position)\n    this.#tmpCHVec3.z += 1.5;\n    return this.#tmpCHVec3;\n  }\n\n  /**\n   * Get the camera height\n   * @returns\n   */\n  getCameraHeight(){\n    if(this.model && this.model.camerahook){\n      this.model.camerahook.getWorldPosition(this.#tmpCHVec3);\n      return this.#tmpCHVec3.z;\n    }\n    return 1.5;\n  }\n\n  /**\n   * Set the cutscene mode\n   * @param state\n   */\n  setCutsceneMode(state: boolean = false){\n    log.debug('setCutsceneMode', this.getTag(), state);\n    this.cutsceneMode = state;\n    if(this.model && this.model.skins){\n      for(let i = 0, len = this.model.skins.length; i < len; i++){\n        this.model.skins[i].frustumCulled = !state;\n      }\n    }\n  }\n\n  /**\n   * Apply a visual effect\n   * @param resref\n   */\n  applyVisualEffect(resref = 'v_light'){\n    if(this.model instanceof OdysseyModel3D){\n      MDLLoader.loader.load(resref).then( (mdl: OdysseyModel) => {\n        OdysseyModel3D.FromMDL(mdl, {\n          context: this.context,\n          // manageLighting: false\n        }).then( (effectMDL: OdysseyModel3D) => {\n          if(this.model instanceof OdysseyModel3D){\n            this.model.effects.push(effectMDL);\n            this.model.add(effectMDL);\n            const anim = effectMDL.playAnimation(0, false);\n            setTimeout(() => {\n              effectMDL.stopAnimation();\n              this.model.remove(effectMDL);\n              effectMDL.disableEmitters();\n              setTimeout( () => {\n                if(this.model instanceof OdysseyModel3D){\n                  const index = this.model.effects.indexOf(effectMDL);\n                  effectMDL.dispose();\n                  this.model.effects.splice(index, 1);\n                }\n              }, 5000);\n            }, (anim ? anim.length * 1000 : 1500) )\n          }\n        }).catch(() => {\n\n        });\n      }).catch(() => {\n\n      });\n    }\n  }\n\n  /**\n   * Set the position\n   * @param x\n   * @param y\n   * @param z\n   */\n  setPosition(x: THREE.Vector3|number = 0, y = 0, z = 0){\n    if(x instanceof THREE.Vector3){\n      z = x.z;\n      y = x.y;\n      x = x.x;\n    }\n\n    try{\n      this.position.set(x, y, z);\n      this.computeBoundingBox();\n      this.updateCollision();\n    }catch(e){\n      log.error('ModuleObject.setPosition failed', e as Error);\n    }\n  }\n\n  /**\n   * Get the position\n   * @returns\n   */\n  getPosition(){\n    return this.position;\n  }\n\n  /**\n   * Get the orientation\n   * @returns\n   */\n  getOrientation(){\n    return this.rotation;\n  }\n\n  /**\n   * Get the facing\n   * @returns\n   */\n  getFacing(){\n    return this.rotation.z;\n  }\n\n  /**\n   * Set the facing object\n   * @param target\n   */\n  setFacingObject( target: ModuleObject ){\n\n  }\n\n  /**\n   * Get the rotation\n   * @returns\n   */\n  getRotation(){\n    return Math.floor(this.getFacing() * 180) + 180;\n  }\n\n  /**\n   * Get the location\n   * @returns\n   */\n  getLocation(){\n    const rotation = this.getRotationFromBearing();\n\n    const location = new EngineLocation(\n      this.position.x, this.position.y, this.position.z,\n      rotation.x, rotation.y, rotation.z,\n      GameState?.module?.area\n    );\n\n    return location;\n  }\n\n  /**\n   * Get the rotation from bearing\n   * @param bearing\n   * @returns\n   */\n  getRotationFromBearing( bearing: number = undefined ){\n    const theta = (typeof bearing == 'number') ? bearing : this.rotation.z;\n\n    return new THREE.Vector3(\n      Math.cos(theta),\n      Math.sin(theta),\n      0\n    );\n  }\n\n  /**\n   * Look at an object\n   * @param oObject\n   */\n  lookAt(oObject: ModuleObject){\n    return;\n  }\n\n  /**\n   * Check if the object is static\n   * @returns\n   */\n  isStatic(){\n    return false;\n  }\n\n  /**\n   * Check if the object is useable\n   * @returns\n   */\n  isUseable(){\n    return false;\n  }\n\n  /**\n   * Get the conversation\n   * @returns\n   */\n  getConversation(): DLGObject {\n    return this.conversation;\n  }\n\n  /**\n   * Get the fortitude save\n   * @returns\n   */\n  getFortitudeSave(){\n    return this.fortitudeSaveThrow;\n  }\n\n  /**\n   * Get the reflex save\n   * @returns\n   */\n  getReflexSave(){\n    return this.reflexSaveThrow;\n  }\n\n  /**\n   * Fortitude save\n   * @param nDC\n   * @param nSaveType\n   * @param oVersus\n   * @returns\n   */\n  fortitudeSave(nDC = 0, nSaveType = 0, oVersus?: ModuleObject){\n    const roll = Dice.roll(1, DiceType.d20);\n    const bonus = CombatRound.GetMod(this.getCON());\n\n    if((roll + this.getFortitudeSave() + bonus) > nDC){\n      return 1\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get the CON\n   * @returns\n   */\n  getCON(): number {\n    return 0;\n  }\n\n  /**\n   * Reflex save\n   * @param nDC\n   * @param nSaveType\n   * @param oVersus\n   * @returns\n   */\n  reflexSave(nDC = 0, nSaveType = 0, oVersus?: ModuleObject){\n    const roll = Dice.roll(1, DiceType.d20);\n    const bonus = CombatRound.GetMod(this.getDEX());\n\n    if((roll + this.getReflexSave() + bonus) > nDC){\n      return 1\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get the DEX\n   * @returns\n   */\n  getDEX(): number {\n    return 0;\n  }\n\n  /**\n   * Get the will save\n   * @returns\n   */\n  getWillSave(){\n    return this.willSaveThrow;\n  }\n\n  /**\n   * Will save\n   * @param nDC\n   * @param nSaveType\n   * @param oVersus\n   * @returns\n   */\n  willSave(nDC = 0, nSaveType = 0, oVersus?: ModuleObject){\n    const roll = Dice.roll(1, DiceType.d20);\n    const bonus = CombatRound.GetMod(this.getWIS());\n\n    if((roll + this.getWillSave() + bonus) > nDC){\n      return 1\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get the WIS\n   * @returns\n   */\n  getWIS(): number {\n    return 0;\n  }\n\n  /**\n   * Get the skill level\n   * @param value\n   * @returns\n   */\n  getSkillLevel(value: number = 0): number {\n    return 0;\n  }\n\n  /**\n   * Resist force\n   * @param oCaster\n   * @returns\n   */\n  resistForce(oCaster: ModuleObject){\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature) && BitWise.InstanceOfObject(oCaster, ModuleObjectType.ModuleCreature)){\n      //https://gamefaqs.gamespot.com/boards/516675-star-wars-knights-of-the-old-republic/62811657\n      //1d20 + their level vs. a DC of your level plus 10\n      const roll = Dice.roll(1, DiceType.d20, (this as ModuleCreature as ModuleObject & { getTotalClassLevel(): number }).getTotalClassLevel());\n      return (roll > 10 + (oCaster as ModuleObject & { getTotalClassLevel(): number }).getTotalClassLevel());\n    }\n    return 0;\n  }\n\n  /**\n   * Initialize all effects for the object\n   */\n  initEffects(){\n    for(let i = 0, len = this.effects.length; i < len; i++){\n      const effect = this.effects[i];\n      if(!effect ){ continue; }\n\n      effect.initialize();\n      //effect.setCreator(this);\n      effect.setAttachedObject(this);\n      effect.onApply(this);\n    }\n  }\n\n  /**\n   * Add an effect to the object\n   * @param effect - The effect to add\n   * @param type - The type of effect\n   * @param duration - The duration of the effect\n   */\n  addEffect(effect: GameEffect, type = 0, duration = 0){\n    if(!effect){\n      log.warn('AddEffect', 'Invalid GameEffect', effect);\n      return;\n    }\n\n    if(effect.type == GameEffectType.EffectLink){\n      const e1 = (effect as EffectLink).effect1;\n      const e2 = (effect as EffectLink).effect2;\n      //EFFECT LEFT\n      if(e1){\n        e1.setDurationType(type);\n        e1.setDuration(duration);\n        this.addEffect(e1, type, duration);\n      }\n\n      //EFFECT RIGHT\n      if(e2){\n        e2.setDurationType(type);\n        e2.setDuration(duration);\n        this.addEffect(e2, type, duration);\n      }\n      return;\n    }\n\n    effect.setAttachedObject(this);\n    effect.loadModel();\n    effect.onApply(this);\n    this.effects.push(effect);\n  }\n\n  /**\n   * Get an effect by type\n   * @param type\n   * @returns\n   */\n  getEffect(type = -1){\n    for(let i = 0; i < this.effects.length; i++){\n      if(this.effects[i].type == type){\n        return this.effects[i];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if the object has an effect by type\n   * @param type\n   * @returns\n   */\n  hasEffect(type = -1){\n    return this.getEffect(type) ? true : false;\n  }\n\n  /**\n   * Remove all effects by creator\n   * @param oCreator\n   */\n  removeEffectsByCreator( oCreator: ModuleObject ){\n    if(!(oCreator instanceof ModuleObject)){\n      return;\n    }\n    let eIndex = this.effects.length - 1;\n    let effect = this.effects[eIndex];\n    while(effect){\n      if(effect.getCreator() == oCreator){\n        const index = this.effects.indexOf(effect);\n        if(index >= 0){\n          this.effects.splice(index, 1)[0].onRemove();\n        }\n      }\n      effect = this.effects[--eIndex];\n    }\n  }\n\n  /**\n   * Remove all effects by type\n   * @param type\n   */\n  removeEffectsByType(type: number = -1){\n    let effect = this.getEffect(type);\n    while(effect){\n      const index = this.effects.indexOf(effect);\n      if(index >= 0){\n        this.effects.splice(index, 1)[0].onRemove();\n      }\n      effect = this.getEffect(type);\n    }\n  }\n\n  /**\n   * Remove an effect by type or GameEffect\n   * @param type\n   */\n  removeEffect(effect: GameEffect){\n    if(!effect){ return; }\n    const arrIdx = this.effects.indexOf(effect);\n    if(arrIdx == -1){ return; }\n    this.effects.splice(arrIdx, 1)[0].onRemove();\n  }\n\n  /**\n   * Jump to an EngineLocation\n   * @param lLocation\n   */\n  JumpToLocation(lLocation: EngineLocation){\n    if(lLocation){\n      this.position.set( lLocation.position.x, lLocation.position.y, lLocation.position.z );\n      this.computeBoundingBox();\n\n      this.setFacing(-Math.atan2(lLocation.rotation.x, lLocation.rotation.y) + Math.PI/2, true);\n      this.collisionManager.groundFace = undefined;\n      this.collisionManager.lastGroundFace = undefined;\n    }\n  }\n\n  /**\n   * Face a point\n   * @param vPoint\n   */\n  FacePoint(vPoint=new THREE.Vector3){\n    const tangent = vPoint.clone().sub(this.position.clone());\n    const atan = Math.atan2(-tangent.y, -tangent.x);\n    this.setFacing(atan + Math.PI/2, true);\n  }\n\n  /**\n   * Get the x orientation\n   * @returns\n   */\n  getXOrientation(){\n    if(this.template.RootNode.hasField('XOrientation')){\n      return this.template.RootNode.getFieldByLabel('XOrientation').getValue();\n    }\n    return 0;\n  }\n\n  /**\n   * Get the y orientation\n   * @returns\n   */\n  getYOrientation(){\n    if(this.template.RootNode.hasField('XOrientation')){\n      return this.template.RootNode.getFieldByLabel('XOrientation').getValue();\n    }\n    return 0;\n  }\n\n  /**\n   * Get the z orientation\n   * @returns\n   */\n  getZOrientation(){\n    if(this.template.RootNode.hasField('ZOrientation')){\n      return this.template.RootNode.getFieldByLabel('ZOrientation').getValue();\n    }\n    return 0;\n  }\n\n  /**\n   * Get the linked to module\n   * @returns\n   */\n  getLinkedToModule(){\n    return this.linkedToModule;\n  }\n\n  /**\n   * Get the linked to flags\n   * @returns\n   */\n  getLinkedToFlags(){\n    return this.linkedToFlags;\n  }\n\n  /**\n   * Get the linked to\n   * @returns\n   */\n  getLinkedTo(){\n    return this.linkedTo;\n  }\n\n  /**\n   * Get the transition destin\n   * @returns\n   */\n  getTransitionDestin(){\n    if(this.transitionDestin instanceof CExoLocString){\n      return this.transitionDestin.getValue();\n    }\n    return '';\n  }\n\n  /**\n   * Get the portrait id\n   * @returns\n   */\n  getPortraitId(){\n    if(this.template.RootNode.hasField('PortraitId')){\n      return this.template.RootNode.getFieldByLabel('PortraitId').getValue();\n    }\n    return 0;\n  }\n\n  /**\n   * Get the key name\n   * @returns\n   */\n  getKeyName(){\n    if(this.template.RootNode.hasField('KeyName')){\n      return this.template.RootNode.getFieldByLabel('KeyName').getValue();\n    }\n    return null;\n  }\n\n  /**\n   * Get the tag\n   * @returns\n   */\n  getTag(){\n    if(this.tag){\n      return this.tag\n    }\n\n    if(this.template && this.template.RootNode && this.template.RootNode.hasField('Tag')){\n      return this.template.RootNode.getFieldByLabel('Tag').getValue()\n    }\n\n    return '';\n  }\n\n  /**\n   * Get the template resref\n   * @returns\n   */\n  getTemplateResRef(){\n    if(this.template.RootNode.hasField('TemplateResRef')){\n      return this.template.RootNode.getFieldByLabel('TemplateResRef').getValue()\n    }\n    return null;\n  }\n\n  /**\n   * Get the resref\n   * @returns\n   */\n  getResRef(){\n    if(this.template.RootNode.hasField('ResRef')){\n      return this.template.RootNode.getFieldByLabel('ResRef').getValue()\n    }\n    return null;\n  }\n\n  /**\n   * Set the template resref\n   * @param sRef\n   */\n  setTemplateResRef(sRef=''){\n    if(this.template.RootNode.hasField('TemplateResRef')){\n      this.template.RootNode.getFieldByLabel('TemplateResRef').setValue(sRef)\n    }else{\n      this.template.RootNode.addField( new GFFField(GFFDataType.RESREF, 'TemplateResRef') ).setValue(sRef)\n    }\n\n  }\n\n  /**\n   * Set the HP\n   * @param value\n   */\n  setHP(value = 0){\n    this.currentHP = value;\n  }\n\n  /**\n   * Add HP\n   * @param value\n   * @param ignoreMaxHitPoints\n   */\n  addHP(value = 0, ignoreMaxHitPoints = false){\n    this.currentHP = (this.getHP() + value);\n  }\n\n  /**\n   * Subtract HP\n   * @param value\n   */\n  subtractHP(value = 0){\n    this.setHP(this.getHP() - value);\n  }\n\n  /**\n   * Get the HP\n   * @returns\n   */\n  getHP(){\n    return this.currentHP;\n  }\n\n  /**\n   * Get the max HP\n   * @returns\n   */\n  getMaxHP(){\n    return this.hp;\n  }\n\n  /**\n   * Set the max HP\n   * @param value\n   */\n  setMaxHP(value = 0){\n    return this.hp = value;\n  }\n\n  /**\n   * Set the min one HP\n   * @param value\n   */\n  setMinOneHP(value: boolean = false){\n    this.min1HP = value;\n  }\n\n  /**\n   * Add FP\n   * @param nAmount\n   * @param ignoreMaxForcePoints\n   */\n  addFP(nAmount = 0, ignoreMaxForcePoints = false){}\n\n  /**\n   * Subtract FP\n   * @param nAmount\n   */\n  subtractFP(nAmount = 0){}\n\n  /**\n   * Get the AC\n   * @returns\n   */\n  getAC(){\n    return 10;\n  }\n\n  /**\n   * Check if the object is a party member\n   * @returns\n   */\n  isPartyMember(){\n    return this.isPM; // GameState.PartyManager.party.indexOf(this) >= 0;\n  }\n\n  /**\n   * Compute the bounding box\n   * @param force\n   */\n  computeBoundingBox(force: boolean = false){\n    if(this.container){\n      this.container.updateMatrixWorld(true);\n      this.container.updateMatrix();\n      if(force){\n        this.container.traverse( n => {\n          n.updateMatrixWorld(true);\n          n.updateMatrix();\n        })\n      }\n    }\n\n    if(this.model){\n      this.model.updateMatrixWorld(true);\n      this.model.updateMatrix();\n    }\n\n    if(this.model instanceof THREE.Object3D)\n      this.box.setFromObject(this.model);\n  }\n\n  /**\n   * Check if the object is on screen\n   * @param frustum\n   * @returns\n   */\n  isOnScreen(frustum = GameState.viewportFrustum){\n    if(this.area && this.area.fog){\n      if(this.distanceToCamera >= this.area.fog.far){\n        return false;\n      }\n    }\n\n    this.box.getBoundingSphere(this.sphere);\n    return frustum.intersectsSphere(this.sphere);\n  }\n\n  /**\n   * Get the reticle node\n   * @returns\n   */\n  getReticleNode(){\n    if(!this.model){ return; }\n\n    if(this.model.talkdummy){\n      return this.model.talkdummy;\n    }\n\n    if(this.model.camerahook){\n      return this.model.camerahook;\n    }\n\n    if(this.model.lookathook){\n      return this.model.lookathook;\n    }\n\n    if(this.model.headhook){\n      return this.model.headhook;\n    }\n\n    return this.model;\n  }\n\n  /**\n   * Set the listening state\n   * @param bListenting\n   */\n  setListening(bListenting = false){\n    this.isListening = bListenting ? true : false;\n  }\n\n  /**\n   * Set the listening pattern\n   * @param sString\n   * @param iNum\n   */\n  setListeningPattern(sString = '', iNum = 0){\n    this.listeningPatterns[sString] = iNum;\n  }\n\n  /**\n   * Get the listening state\n   * @returns\n   */\n  getIsListening(){\n    return this.isListening ? true : false;\n  }\n\n  /**\n   * Get the local boolean\n   * @param index\n   * @returns\n   */\n  getLocalBoolean(index: number){\n    return !!this._locals.Booleans[index];\n  }\n\n  /**\n   * Get the local number\n   * @param index\n   * @returns\n   */\n  getLocalNumber(index: number){\n    return this._locals.Numbers[index] ?? 0;\n  }\n\n  /**\n   * Set the local boolean\n   * @param index\n   * @param bool\n   */\n  setLocalBoolean(index: number, bool: boolean){\n    this._locals.Booleans[index] = !!bool;\n  }\n\n  /**\n   * Set the local number\n   * @param index\n   * @param value\n   */\n  setLocalNumber(index: number, value: number){\n    this._locals.Numbers[index] = value;\n  }\n\n  /**\n   * Check if the object is hostile to another object\n   * @param target\n   * @returns\n   */\n  isHostile(target: ModuleObject){\n    return GameState.FactionManager.IsHostile(this, target);\n  }\n\n  /**\n   * Check if the object is neutral to another object\n   * @param target\n   * @returns\n   */\n  isNeutral(target: ModuleObject){\n    return GameState.FactionManager.IsNeutral(this, target);\n  }\n\n  /**\n   * Check if the object is friendly to another object\n   * @param target\n   * @returns\n   */\n  isFriendly(target: ModuleObject){\n    return GameState.FactionManager.IsFriendly(this, target);\n  }\n\n  /**\n   * Get the reputation of the object with another object\n   * @param target\n   * @returns\n   */\n  getReputation(target: ModuleObject){\n    return GameState.FactionManager.GetReputation(this, target);\n  }\n\n  /**\n   * Get the primary perception range\n   * @returns\n   */\n  getPerceptionRangePrimary(){\n    if(!this.perceptionRange){ return 1; }\n    return this.perceptionRange.primaryRange;\n  }\n\n  /**\n   * Get the secondary perception range\n   * @returns\n   */\n  getPerceptionRangeSecondary(){\n    if(!this.perceptionRange){ return 1; }\n    return this.perceptionRange.secondaryRange;\n  }\n\n  /**\n   * Initialize the perception list\n   */\n  initPerceptionList(){\n    let length = this.perceptionList.length;\n    while(length--){\n      const perceptionObject = this.perceptionList[length];\n      if(perceptionObject){\n        if(typeof perceptionObject.object == 'undefined' && perceptionObject.objectId){\n          perceptionObject.object = GameState.ModuleObjectManager.GetObjectById(perceptionObject.objectId);\n          if(!(perceptionObject.object instanceof ModuleObject)){\n            this.perceptionList.splice(length, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Notify the object that it has been heard by another object\n   * @param object\n   * @param heard\n   * @returns\n   */\n  notifyPerceptionHeardObject(object: ModuleObject, heard = false){\n    if(!object) return;\n\n    let triggerOnNotice = false;\n    let perceptionObject;\n    const exists = this.perceptionList.filter( (o) => o.object == object );\n    if(exists.length){\n      const existingObject = exists[0];\n      triggerOnNotice = (!!(existingObject.data & 0x02) != heard);\n      existingObject.data |= 0x02;\n      perceptionObject = existingObject;\n    }else{\n      if(heard){\n        const newObject = {\n          object: object,\n          objectId: object.id,\n          data: 0x02\n        };\n        this.perceptionList.push(newObject);\n        perceptionObject = newObject;\n        triggerOnNotice = true;\n        if(object.isPlayer && this.isHostile(object)){\n          this.area.subtractStealthXP();\n        }\n      }else{\n        if(object.isPlayer && this.isHostile(object)){\n          this.area.addStealthXP();\n        }\n      }\n    }\n\n    let onNotice: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onNotice = this.scripts[ModuleObjectScript.CreatureOnNotice];\n    }\n\n    if(triggerOnNotice && onNotice){\n      const instance = onNotice.nwscript.newInstance();\n      instance.lastPerceived = perceptionObject;\n      instance.run(this);\n      return true;\n    }\n  }\n\n  /**\n   * Notify the object that it has been seen by another object\n   * @param object\n   * @param seen\n   * @returns\n   */\n  notifyPerceptionSeenObject(object: ModuleObject, seen = false){\n    if(!object) return;\n\n    let triggerOnNotice = false;\n    let perceptionObject;\n    const exists = this.perceptionList.filter( (o) => o.object == object );\n    if(exists.length){\n      const existingObject = exists[0];\n      triggerOnNotice = (!!(existingObject.data & 0x01) != seen);\n      perceptionObject = existingObject;\n    }else{\n      if(seen){\n        const newObject = {\n          object: object,\n          objectId: object.id,\n          data: 0x01\n        };\n        this.perceptionList.push(newObject);\n        perceptionObject = newObject;\n        triggerOnNotice = true;\n        if(object.isPlayer && this.isHostile(object)){\n          this.area.subtractStealthXP();\n        }\n      }else{\n        if(object.isPlayer && this.isHostile(object)){\n          this.area.addStealthXP();\n        }\n      }\n    }\n\n    let onNotice: NWScriptInstance;\n    if(BitWise.InstanceOfObject(this, ModuleObjectType.ModuleCreature)){\n      onNotice = this.scripts[ModuleObjectScript.CreatureOnNotice];\n    }\n\n    if(triggerOnNotice && onNotice){\n      const instance = onNotice.nwscript.newInstance();\n      instance.lastPerceived = perceptionObject;\n      instance.run(this);\n      return true;\n    }\n  }\n\n  /**\n   * Check if the object has line of sight to another object\n   * @param oTarget\n   * @param max_distance\n   * @returns\n   */\n  hasLineOfSight(oTarget: ModuleObject, max_distance = 30){\n    if(!this.spawned || !GameState.module.readyToProcessEvents)\n      return false;\n\n    if(!(oTarget instanceof ModuleObject)){\n      return false;\n    }\n\n    const position_a = this.position.clone();\n    const position_b = oTarget.position.clone();\n    position_a.z += 1;\n    position_b.z += 1;\n    const direction = position_b.clone().sub(position_a).normalize();\n    const distance = position_a.distanceTo(position_b);\n\n    if(this.perceptionRange){\n      if(distance > this.getPerceptionRangePrimary()){\n        return;\n      }\n      max_distance = this.getPerceptionRangePrimary();\n    }else{\n      if(distance > 50)\n        return;\n    }\n\n    GameState.raycaster.ray.origin.copy(position_a);\n    GameState.raycaster.ray.direction.copy(direction);\n    GameState.raycaster.far = max_distance;\n\n    const aabbFaces = [];\n    let intersects;// = GameState.raycaster.intersectOctreeObjects( meshesSearch );\n\n    for(let j = 0, jl = this.area.rooms.length; j < jl; j++){\n      const room = this.area.rooms[j];\n      if(room && room.collisionManager.walkmesh && room.collisionManager.walkmesh.aabbNodes.length){\n        aabbFaces.push({\n          object: room,\n          faces: room.collisionManager.walkmesh.faces\n        });\n      }\n    }\n\n    for(let j = 0, jl = this.area.doors.length; j < jl; j++){\n      const door = this.area.doors[j];\n      if(door && door !== (this as ModuleObject) && !door.isOpen()){\n        const box3 = door.box;\n        if(box3){\n          if(GameState.raycaster.ray.intersectsBox(box3) || box3.containsPoint(position_a)){\n            return false;\n          }\n        }\n      }\n    }\n\n\n    for(let i = 0, il = aabbFaces.length; i < il; i++){\n      const castableFaces = aabbFaces[i];\n      intersects = castableFaces.object.collisionManager.walkmesh.raycast(GameState.raycaster, castableFaces.faces);\n      if (intersects && intersects.length > 0 ) {\n        for(let j = 0; j < intersects.length; j++){\n          if(intersects[j].distance < distance){\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Set the animation state\n   * @param animState\n   */\n  setAnimationState(animState: number){\n    this.animState = animState;\n  }\n\n  /**\n   * Play an animation\n   * @param anim\n   */\n  dialogPlayAnimation(anim: ITwoDAAnimation = {} as ITwoDAAnimation){\n    log.debug('dialogPlayAnimation', anim);\n    if(!this.model){\n      log.warn('dialogPlayAnimation failed');\n      log.debug('dialogPlayAnimation this, anim', this, anim);\n      return;\n    }\n\n    const odysseyAnimation = this.model.odysseyAnimations.find( (a) => a.name.toLocaleLowerCase() == anim.name.toLocaleLowerCase() );\n    if(!odysseyAnimation){\n      return;\n    }\n\n    this.dialogAnimation = {\n      animation: odysseyAnimation,\n      data: anim,\n      started: false,\n    };\n  }\n\n  /**\n   * Reset the dialog animation state\n   */\n  dialogResetAnimationState(){\n    this.dialogAnimationState = {\n      animationIndex: -1,\n      animation: undefined,\n      data: undefined,\n      started: false,\n    };\n  }\n\n  /**\n   * Use an object\n   * @param object\n   */\n  use(object: ModuleObject){\n    log.warn(\"Method not implemented.\", this.tag);\n  }\n\n  /**\n   * Attack a creature\n   * @param target\n   * @param feat\n   * @param isCutsceneAttack\n   * @param attackDamage\n   * @param attackAnimation\n   * @param attackResult\n   */\n  attackCreature(target: ModuleObject, _feat?: number | import(\"../talents/TalentFeat\").TalentFeat, isCutsceneAttack: boolean = false, _attackDamage: number = 0, _attackAnimation?: number | string, _attackResult?: number | import(\"../enums/combat/AttackResult\").AttackResult) {\n    log.warn(\"Method not implemented.\", this.tag, target);\n  }\n  /**\n   * Set the commandable state\n   * @param arg0\n   */\n  setCommandable(arg0: boolean) {\n    log.warn(\"Method not implemented.\", this.tag);\n  }\n\n  /**\n   * Play a sound set\n   * @param ssfType\n   */\n  playSoundSet(ssfType: SSFType){\n    log.warn(\"Method not implemented.\", this.tag);\n  }\n\n  /**\n   * Initialize the properties\n   */\n  initProperties(){\n\n    if(!this.initialized){\n      if(this.template.RootNode.hasField('ObjectId')){\n        this.id = this.template.getFieldByLabel('ObjectId').getValue();\n      }else if(this.template.RootNode.hasField('ID')){\n        this.id = this.template.getFieldByLabel('ID').getValue();\n      }\n\n      GameState.ModuleObjectManager.AddObjectById(this);\n    }\n\n    if(this.template.RootNode.hasField('Animation'))\n      this.animState = this.template.getFieldByLabel('Animation').getValue();\n\n    if(this.template.RootNode.hasField('Appearance')){\n      this.appearance = this.template.getFieldByLabel('Appearance').getValue();\n    }\n\n    if(this.template.RootNode.hasField('Description'))\n      this.description = this.template.getFieldByLabel('Description').getCExoLocString();\n\n    if(this.template.RootNode.hasField('ObjectId'))\n      this.id = this.template.getFieldByLabel('ObjectId').getValue();\n\n    if(this.template.RootNode.hasField('AutoRemoveKey'))\n      this.autoRemoveKey = this.template.getFieldByLabel('AutoRemoveKey').getValue();\n\n    if(this.template.RootNode.hasField('Commandable'))\n      this.commandable = this.template.getFieldByLabel('Commandable').getValue();\n\n    if(this.template.RootNode.hasField('Cursor'))\n      this.cursor = this.template.getFieldByLabel('Cursor').getValue();\n\n    if(this.template.RootNode.hasField('Faction')){\n      this.factionId = this.template.getFieldByLabel('Faction').getValue();\n      if((this.factionId & 0xFFFFFFFF) == -1){\n        this.factionId = 0;\n      }\n      this.faction = GameState.FactionManager.factions.get(this.factionId);\n    }\n\n    if(this.template.RootNode.hasField('Geometry')){\n      this.geometry = this.template.getFieldByLabel('Geometry').getChildStructs();\n\n      //Push verticies\n      for(let i = 0; i < this.geometry.length; i++){\n        const tgv = this.geometry[i];\n        this.vertices[i] = new THREE.Vector3(\n          tgv.getFieldByLabel('PointX').getValue(),\n          tgv.getFieldByLabel('PointY').getValue(),\n          tgv.getFieldByLabel('PointZ').getValue()\n        );\n      }\n    }\n\n    if(this.template.RootNode.hasField('HasMapNote'))\n      this.hasMapNote = this.template.getFieldByLabel('HasMapNote').getValue();\n\n    if(this.template.RootNode.hasField('HighlightHeight'))\n      this.highlightHeight = this.template.getFieldByLabel('HighlightHeight').getValue();\n\n    if(this.template.RootNode.hasField('KeyName'))\n      this.keyName = this.template.getFieldByLabel('KeyName').getValue();\n\n    if(this.template.RootNode.hasField('LinkedTo'))\n      this.linkedTo = this.template.getFieldByLabel('LinkedTo').getValue();\n\n    if(this.template.RootNode.hasField('LinkedToFlags'))\n      this.linkedToFlags = this.template.getFieldByLabel('LinkedToFlags').getValue();\n\n    if(this.template.RootNode.hasField('LinkedToModule'))\n      this.linkedToModule = this.template.RootNode.getFieldByLabel('LinkedToModule').getValue();\n\n    if(this.template.RootNode.hasField('LoadScreenID'))\n      this.loadScreenID = this.template.getFieldByLabel('LoadScreenID').getValue();\n\n    if(this.template.RootNode.hasField('LocName'))\n      this.locName = this.template.getFieldByLabel('LocName').getCExoLocString();\n\n    if(this.template.RootNode.hasField('LocalizedName'))\n      this.localizedName = this.template.getFieldByLabel('LocalizedName').getCExoLocString();\n\n    if(this.template.RootNode.hasField('MapNote'))\n      this.mapNote = this.template.getFieldByLabel('MapNote').getCExoLocString();\n\n    if(this.template.RootNode.hasField('MapNoteEnabled'))\n      this.mapNoteEnabled = this.template.getFieldByLabel('MapNoteEnabled').getValue();\n\n    if(this.template.RootNode.hasField('PortraidId')){\n      this.portraitId = this.template.getFieldByLabel('PortraidId').getValue();\n      this.portrait = GameState.SWRuleSet.portraits[this.portraitId];\n    }\n\n    if(this.template.RootNode.hasField('SetByPlayerParty'))\n      this.setByPlayerParty = this.template.getFieldByLabel('SetByPlayerParty').getValue();\n\n    if(this.template.RootNode.hasField('Tag'))\n      this.tag = this.template.getFieldByLabel('Tag').getValue();\n\n    if(this.template.RootNode.hasField('TemplateResRef'))\n      this.templateResRef = this.template.getFieldByLabel('TemplateResRef').getValue();\n\n    if(this.template.RootNode.hasField('TransitionDestin'))\n      this.transitionDestin = this.template.getFieldByLabel('TransitionDestin').getCExoLocString();\n\n    if(this.template.RootNode.hasField('TrapDetectable'))\n      this.trapDetectable = this.template.RootNode.getFieldByLabel('TrapDetectable').getValue();\n\n    if(this.template.RootNode.hasField('TrapDisarmable'))\n      this.trapDisarmable = this.template.RootNode.getFieldByLabel('TrapDisarmable').getValue();\n\n    if(this.template.RootNode.hasField('TrapOneShot'))\n      this.trapOneShot = this.template.getFieldByLabel('TrapOneShot').getValue();\n\n    if(this.template.RootNode.hasField('TrapType'))\n      this.trapType = this.template.getFieldByLabel('TrapType').getValue();\n\n    if(this.template.RootNode.hasField('Type'))\n      this.type = this.template.getFieldByLabel('Type').getValue();\n\n    if(this.template.RootNode.hasField('XPosition'))\n      this.position.x = this.template.RootNode.getFieldByLabel('XPosition').getValue();\n\n    if(this.template.RootNode.hasField('YPosition'))\n      this.position.y = this.template.RootNode.getFieldByLabel('YPosition').getValue();\n\n    if(this.template.RootNode.hasField('ZPosition'))\n      this.position.z = this.template.RootNode.getFieldByLabel('ZPosition').getValue();\n\n    if(this.template.RootNode.hasField('XOrientation'))\n      this.xOrientation = this.template.RootNode.getFieldByLabel('XOrientation').getValue();\n\n    if(this.template.RootNode.hasField('YOrientation'))\n      this.yOrientation = this.template.RootNode.getFieldByLabel('YOrientation').getValue();\n\n    if(this.template.RootNode.hasField('ZOrientation'))\n      this.zOrientation = this.template.RootNode.getFieldByLabel('ZOrientation').getValue();\n\n    if(this.template.RootNode.hasField('FortSaveThrow'))\n      this.fortitudeSaveThrow = this.template.RootNode.getFieldByLabel('FortSaveThrow').getValue();\n\n    if(this.template.RootNode.hasField('RefSaveThrow'))\n      this.reflexSaveThrow = this.template.RootNode.getFieldByLabel('RefSaveThrow').getValue();\n\n    if(this.template.RootNode.hasField('WillSaveThrow'))\n      this.willSaveThrow = this.template.RootNode.getFieldByLabel('WillSaveThrow').getValue();\n\n    if(this.template.RootNode.hasField('SWVarTable')){\n      const swVarTableStruct = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0];\n      if(swVarTableStruct){\n        if(swVarTableStruct.hasField('BitArray')){\n          const localBools = swVarTableStruct.getFieldByLabel('BitArray').getChildStructs();\n          for(let i = 0; i < localBools.length; i++){\n            const data = localBools[i].getFieldByLabel('Variable').getValue();\n            for(let bit = 0; bit < 32; bit++){\n              this._locals.Booleans[bit + (i*32)] = ( (data>>bit) % 2 != 0);\n            }\n          }\n        }\n\n        if(swVarTableStruct.hasField('ByteArray')){\n          const localNumbers = swVarTableStruct.getFieldByLabel('ByteArray').getChildStructs();\n          for(let i = 0; i < localNumbers.length; i++){\n            const data = localNumbers[i].getFieldByLabel('Variable').getValue();\n            this.setLocalNumber(i, data);\n          }\n        }\n      }\n    }\n\n    this.initialized = true;\n\n  }\n\n  /**\n   * Save the object\n   */\n  Save(){\n    //TODO\n\n    const gff = new GFFObject();\n\n    return gff;\n\n  }\n\n  /**\n   * Get the SWVarTable save struct\n   * @returns\n   */\n  getSWVarTableSaveStruct(){\n    const swVarTableStruct = new GFFStruct();\n\n    const swVarTableBitArray = swVarTableStruct.addField( new GFFField(GFFDataType.LIST, 'BitArray') );\n\n    for(let i = 0; i < 3; i++){\n      const varStruct = new GFFStruct();\n      let value = 0;\n      const offset = 32 * i;\n      for(let j = 0; j < 32; j++){\n        if(this.getLocalBoolean(offset + j) == true){\n          value |= 1 << j;\n        }\n      }\n      value = value >>> 0;\n      varStruct.addField( new GFFField(GFFDataType.DWORD, 'Variable') ).setValue( value );\n      swVarTableBitArray.addChildStruct(varStruct);\n    }\n\n    const swVarTableByteArray = swVarTableStruct.addField( new GFFField(GFFDataType.LIST, 'ByteArray') );\n\n    for(let i = 0; i < 8; i++){\n      const varStruct = new GFFStruct();\n      varStruct.addField( new GFFField(GFFDataType.BYTE, 'Variable') ).setValue( Number(this.getLocalNumber(i)) );\n      swVarTableByteArray.addChildStruct(varStruct);\n    }\n    return swVarTableStruct;\n  }\n\n  /**\n   * Convert the action queue to an action list\n   * @returns\n   */\n  actionQueueToActionList(){\n    const actionList = new GFFField(GFFDataType.LIST, 'ActionList');\n\n    for(let i = 0, len = this.actionQueue.length; i < len; i++){\n      const action = this.actionQueue[i] as Action;\n      if(!action){ continue; }\n      const struct = new GFFStruct(0);\n      struct.addField(new GFFField(GFFDataType.DWORD, 'ActionId', action.type));\n      struct.addField(new GFFField(GFFDataType.WORD, 'GroupActionId', action.groupId));\n      struct.addField(new GFFField(GFFDataType.WORD, 'NumParams', action.parameters.length));\n\n      const params = struct.addField(new GFFField(GFFDataType.LIST, 'Paramaters'));\n      for(let j = 0, len2 = action.parameters.length; j < len2; j++){\n        params.addChildStruct(action.parameters[j].toStruct());\n      }\n\n      actionList.addChildStruct(struct);\n    }\n\n    return actionList;\n  }\n\n  /**\n   * Destroy the object\n   */\n  destroy(){\n    try{ log.debug('destroy', this.getTag(), this); }catch(e){ /* no-op */ }\n    try{\n      this.container.removeFromParent();\n\n      if(this.model instanceof OdysseyModel3D){\n        this.model.removeFromParent();\n        this.model.dispose();\n        this.model = undefined;\n      }\n\n      if(this.mesh instanceof THREE.Mesh){\n        this.mesh.removeFromParent();\n\n        (this.mesh.material as THREE.Material).dispose();\n        this.mesh.geometry.dispose();\n\n        this.mesh.material = undefined;\n        this.mesh.geometry = undefined;\n        this.mesh = undefined;\n      }\n\n      //cleanup audio emitter\n      if(this.audioEmitter){\n        this.audioEmitter.destroy();\n        this.audioEmitter = undefined;\n      }\n\n      if(this.footstepEmitter){\n        this.footstepEmitter.destroy();\n        this.footstepEmitter = undefined;\n      }\n\n      // Dispose all game effects\n      if(this.effects && this.effects.length > 0){\n        for(let i = this.effects.length - 1; i >= 0; i--){\n          if(this.effects[i]){\n            this.effects[i].onRemove();\n          }\n        }\n        this.effects.length = 0;\n      }\n\n      //Cleanup scripts\n      Object.keys(this.scripts).forEach( (key) => {\n        if(this.scripts[key] instanceof NWScriptInstance){\n          this.scripts[key].dispose();\n        }\n        this.scripts = {};\n      });\n\n      //Clear action queue\n      if(this.actionQueue){\n        this.actionQueue.clear();\n        this.actionQueue = undefined;\n      }\n\n      //Clear computed path\n      if(this.#computedPath){\n        this.#computedPath.dispose();\n        this.#computedPath = undefined;\n      }\n\n      //Clear perception list\n      if(this.perceptionList){\n        this.perceptionList.length = 0;\n      }\n\n      //Clear inventory\n      if(this.inventory){\n        for(let i = this.inventory.length - 1; i >= 0; i--){\n          if(this.inventory[i]){\n            this.inventory[i].destroy();\n          }\n        }\n        this.inventory.length = 0;\n      }\n\n      //Clear rooms array\n      if(this.rooms){\n        this.rooms.length = 0;\n      }\n\n      //Clear objects inside\n      if(this.objectsInside){\n        this.objectsInside.length = 0;\n      }\n\n      //Dispose Three.js utility objects\n      if(this.forceVector){\n        this.forceVector = undefined;\n      }\n      if(this.position){\n        this.position = undefined;\n      }\n      if(this.rotation){\n        this.rotation = undefined;\n      }\n      if(this.quaternion){\n        this.quaternion = undefined;\n      }\n      if(this.box){\n        this.box = undefined;\n      }\n      if(this.sphere){\n        this.sphere = undefined;\n      }\n      if(this.v20){\n        this.v20 = undefined;\n      }\n      if(this.v21){\n        this.v21 = undefined;\n      }\n\n      if(this.area){\n        this.area.detachObject(this);\n      }\n\n      //Clear references to prevent circular references\n      this.area = undefined;\n      this.room = undefined;\n      this.lookAtObject = undefined;\n      this.lastTriggerEntered = undefined;\n      this.lastTriggerExited = undefined;\n      this.lastAreaEntered = undefined;\n      this.lastAreaExited = undefined;\n      this.lastModuleEntered = undefined;\n      this.lastModuleExited = undefined;\n      this.lastDoorEntered = undefined;\n      this.lastDoorExited = undefined;\n      this.lastPlaceableEntered = undefined;\n      this.lastPlaceableExited = undefined;\n      this.lastAoeEntered = undefined;\n      this.lastAoeExited = undefined;\n      this.conversation = undefined;\n      this.linkedToObject = undefined;\n\n      GameState.ModuleObjectManager.RemoveObject(this);\n      GameState.CursorManager.notifyObjectDestroyed(this);\n    }catch(e){\n      log.error('ModuleObject.destroy', e as Error);\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModulePath.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `PathPoint`.","line":109,"column":31,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":109,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":217,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":217,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":217,"column":20,"nodeType":"MemberExpression","messageId":"errorCall","endLine":217,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Vector3`.","line":235,"column":27,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":235,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .position on a type that cannot be resolved.","line":235,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":235,"endColumn":42}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { ComputedPath } from \"@/engine/pathfinding/ComputedPath\";\r\nimport { PathPoint } from \"@/engine/pathfinding/PathPoint\";\r\nimport { EngineDebugType } from \"@/enums\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { IClosestPathPointData } from \"@/interface/engine/pathfinding/IClosestPathPointData\";\nimport { ResourceLoader } from \"@/loaders\";\r\nimport type { ModuleArea } from \"@/module/ModuleArea\";\nimport type { ModuleObject } from \"@/module/ModuleObject\";\r\nimport type { WalkmeshEdge } from \"@/odyssey/WalkmeshEdge\";\nimport { GFFObject } from \"@/resource/GFFObject\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\n\r\n\n\nconst log = createScopedLogger(LogScope.Module);\n\r\n/**\r\n* ModulePath class.\r\n* \r\n* Class representing all of the points and connections fro pathfinding in a module area.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file ModulePath.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class ModulePath {\r\n  area: ModuleArea;\r\n  _tmpVector: THREE.Vector3;\r\n  points: PathPoint[];\r\n  template: GFFObject;\r\n  name: string;\r\n  initialized: boolean;\r\n\r\n  walkEdges: WalkmeshEdge[] = [];\r\n\r\n  pointCount: number = 0;\r\n  connectionCount: number = 0;\r\n\r\n  helperColors: THREE.Float32BufferAttribute;\r\n  helperPositions: THREE.Float32BufferAttribute;\r\n  helperGeometry = new THREE.BufferGeometry();\r\n  helperMaterial = new THREE.LineBasicMaterial({\r\n    color: 0xFFFFFF,\r\n    vertexColors: true\r\n  });\r\n  helperMesh: THREE.LineSegments;\r\n\r\n  constructor(area: ModuleArea){\r\n    this._tmpVector = new THREE.Vector3(0, 0, 0);\r\n    this.points = [];\r\n    this.template = new GFFObject();\r\n    this.area = area;\r\n    this.name = area.name;\r\n  }\r\n\r\n  async load(){\r\n    const buffer = ResourceLoader.loadCachedResource(ResourceTypes['pth'], this.name);\r\n    if(buffer){\r\n      this.template = new GFFObject(buffer);\r\n    }else{\r\n      log.error('Failed to load ModulePath template');\r\n    }\r\n\r\n    if(this.template instanceof GFFObject){\r\n      this.initProperties();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  initProperties(){\r\n    this.initialized = true;\r\n    if(!(this.template instanceof GFFObject)){\r\n      return;\r\n    }\r\n    \r\n    /**\r\n     * Parse the Path Points\r\n     */\r\n    if(this.template.RootNode.hasField('Path_Points')){\r\n      const pathPoints = this.template.getFieldByLabel('Path_Points').getChildStructs();\r\n      this.pointCount = pathPoints.length;\r\n      for(let i = 0, len = pathPoints.length; i < len; i++){\r\n        this.points[i] = PathPoint.FromGFFStruct(pathPoints[i]);\r\n        this.points[i].id = i;\r\n        this.points[i].setArea(this.area);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Parse the Path Connections\r\n     */\r\n    if(this.template.RootNode.hasField('Path_Conections')){\r\n      const pathConnections = this.template.getFieldByLabel('Path_Conections').getChildStructs();\r\n      this.connectionCount = pathConnections.length;\r\n      for(let i = 0, len = this.points.length; i < len; i++){\r\n        const point = this.points[i];\r\n        if(!point.num_connections) continue;\r\n        \r\n        const connIdx = point.first_connection;\r\n        for(let j = 0; j < point.num_connections; j++){\r\n          const pointIdx = pathConnections[connIdx + j].getFieldByLabel('Destination').getValue();\r\n          point.addConnection(this.points[pointIdx]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.connectionCount = this.points.reduce((sum, p) => {\r\n      return sum + p.connections.length;\r\n    }, 0);\r\n\r\n    try{\r\n      this.generatePathHelper();\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n\r\n    this.setPathHelpersVisibility(GameState.GetDebugState(EngineDebugType.PATH_FINDING));\r\n  }\r\n\r\n  /**\r\n   * Build line segments for the visual helper geometry\r\n   */\r\n  generatePathHelper(){\r\n    const numPoints = this.points.length;\r\n    const pointDataSize = 6;\r\n    const connDataSize = 6;\r\n    const bufferSize = (this.pointCount * pointDataSize) + (this.connectionCount * connDataSize);\r\n\r\n    const pointDataStart = 0;\r\n    let connectionIndexStart = (numPoints * 2);\r\n\r\n    if(!this.helperColors){\r\n      this.helperColors = new THREE.Float32BufferAttribute( (new Array(bufferSize)).fill(0), 3 );\r\n    }\r\n\r\n    if(!this.helperPositions){\r\n      this.helperPositions = new THREE.Float32BufferAttribute( (new Array(bufferSize)).fill(0), 3 );\r\n    }\r\n\r\n    for(let i = 0; i < this.points.length; i++){\r\n      const point = this.points[i];\r\n\r\n      const idx = i * 2;\r\n      const idx2 = idx + 1;\r\n\r\n      this.helperPositions.setX(idx, point.vector.x);\r\n      this.helperPositions.setY(idx, point.vector.y);\r\n      this.helperPositions.setZ(idx, point.nearestWalkableVector.z);\r\n      \r\n      this.helperPositions.setX(idx2, point.vector.x);\r\n      this.helperPositions.setY(idx2, point.vector.y);\r\n      this.helperPositions.setZ(idx2, point.nearestWalkableVector.z + 0.5);\r\n      this.helperPositions.needsUpdate = true;\r\n\r\n      this.helperColors.setX(idx, 1);\r\n      this.helperColors.setY(idx, 0);\r\n      this.helperColors.setZ(idx, 1);\r\n\r\n      this.helperColors.setX(idx2, 0);\r\n      this.helperColors.setY(idx2, 0);\r\n      this.helperColors.setZ(idx2, 1);\r\n      this.helperColors.needsUpdate = true;\r\n\r\n      for(let j = 0; j < point.connections.length; j++){\r\n        const cPoint = point.connections[j];\r\n        const idx3 = connectionIndexStart;\r\n        const idx4 = idx3 + 1;\r\n\r\n        this.helperPositions.setX(idx3, point.vector.x);\r\n        this.helperPositions.setY(idx3, point.vector.y);\r\n        this.helperPositions.setZ(idx3, point.nearestWalkableVector.z + 0.5);\r\n        \r\n        this.helperPositions.setX(idx4, cPoint.vector.x);\r\n        this.helperPositions.setY(idx4, cPoint.vector.y);\r\n        this.helperPositions.setZ(idx4, cPoint.nearestWalkableVector.z + 0.5);\r\n        this.helperPositions.needsUpdate = true;\r\n  \r\n        this.helperColors.setX(idx3, 0);\r\n        this.helperColors.setY(idx3, 0);\r\n        this.helperColors.setZ(idx3, 1);\r\n  \r\n        this.helperColors.setX(idx4, 0);\r\n        this.helperColors.setY(idx4, 0);\r\n        this.helperColors.setZ(idx4, 1);\r\n        this.helperColors.needsUpdate = true;\r\n        connectionIndexStart += 2;\r\n      }\r\n    }\r\n\r\n    if(!this.helperMesh){\r\n      this.helperGeometry.setAttribute( 'position', this.helperPositions );\r\n      this.helperGeometry.setAttribute( 'color', this.helperColors );\r\n      \r\n      this.helperMesh = new THREE.LineSegments( this.helperGeometry, this.helperMaterial );\r\n      GameState.scene.add( this.helperMesh );\r\n    }\r\n  }\r\n\r\n  updateTimer: number = 0;\r\n  update(delta: number){\r\n    this.updateTimer -= delta;\r\n    if(this.updateTimer > 0){\r\n      return;\r\n    }\r\n    this.updateTimer = 1;\r\n\r\n    if(!this.area || !this.helperMesh?.visible)\r\n      return;\r\n\r\n    const player = this.area.context.getCurrentPlayer();\r\n    const numPoints = this.points.length;\r\n    let connectionIndexStart = (numPoints * 2);\r\n    for(let i = 0; i < this.points.length; i++){\r\n      const point = this.points[i];\r\n\r\n      const idx = i * 2;\r\n      const idx2 = idx + 1;\r\n\r\n      this.helperPositions.setX(idx, point.vector.x);\r\n      this.helperPositions.setY(idx, point.vector.y);\r\n      this.helperPositions.setZ(idx, point.nearestWalkableVector.z);\r\n      \r\n      this.helperPositions.setX(idx2, point.vector.x);\r\n      this.helperPositions.setY(idx2, point.vector.y);\r\n      this.helperPositions.setZ(idx2, point.nearestWalkableVector.z + 0.5);\r\n      this.helperPositions.needsUpdate = true;\r\n\r\n      if(this.checkLOSP2P(player.position, point.vector)){\r\n        this.helperColors.setX(idx, 0);\r\n        this.helperColors.setY(idx, 1);\r\n        this.helperColors.setZ(idx, 0);\r\n      }else{\r\n        this.helperColors.setX(idx, 1);\r\n        this.helperColors.setY(idx, 0);\r\n        this.helperColors.setZ(idx, 1);\r\n      }\r\n\r\n      this.helperColors.setX(idx2, 0);\r\n      this.helperColors.setY(idx2, 0);\r\n      this.helperColors.setZ(idx2, 1);\r\n      this.helperColors.needsUpdate = true;\r\n\r\n      for(let j = 0; j < point.connections.length; j++){\r\n        const cPoint = point.connections[j];\r\n        const idx3 = connectionIndexStart;\r\n        const idx4 = idx3 + 1;\r\n\r\n        this.helperPositions.setX(idx3, point.vector.x);\r\n        this.helperPositions.setY(idx3, point.vector.y);\r\n        this.helperPositions.setZ(idx3, point.nearestWalkableVector.z + 0.5);\r\n        \r\n        this.helperPositions.setX(idx4, cPoint.vector.x);\r\n        this.helperPositions.setY(idx4, cPoint.vector.y);\r\n        this.helperPositions.setZ(idx4, cPoint.nearestWalkableVector.z + 0.5);\r\n        this.helperPositions.needsUpdate = true;\r\n  \r\n        this.helperColors.setX(idx3, 0);\r\n        this.helperColors.setY(idx3, 0);\r\n        this.helperColors.setZ(idx3, 1);\r\n  \r\n        this.helperColors.setX(idx4, 0);\r\n        this.helperColors.setY(idx4, 0);\r\n        this.helperColors.setZ(idx4, 1);\r\n        this.helperColors.needsUpdate = true;\r\n        connectionIndexStart += 2;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  #tmpLine = new THREE.Line3();\r\n  checkLOSP2P(origin: THREE.Vector3, target: THREE.Vector3): boolean {\r\n    let has_los = true;\r\n\r\n    if(!this.area)\r\n      return has_los;\r\n\r\n    this.#tmpLine.start.copy(origin);\r\n    this.#tmpLine.end.copy(target);\r\n    for(let j = 0, len = this.area.walkEdges.length; j < len; j++){\r\n      const edge = this.area.walkEdges[j];\r\n\r\n      //Ignore transition edges\r\n      if(edge.transition != -1)\r\n        continue;\r\n      \r\n      if(Utility.LineLineIntersection(this.#tmpLine.start.x, this.#tmpLine.start.y, this.#tmpLine.end.x, this.#tmpLine.end.y, edge.line.start.x, edge.line.start.y, edge.line.end.x, edge.line.end.y)){\r\n        has_los = false;\r\n        break;\r\n      }\r\n    }\r\n    return has_los;\r\n  }\r\n\r\n  dispose(){\r\n    this.helperGeometry.dispose();\r\n    this.helperMaterial.dispose();\r\n    this.helperMesh.removeFromParent();\r\n\r\n    this.helperPositions = undefined;\r\n    this.helperColors = undefined;\r\n    this.helperMesh = undefined;\r\n    this.helperGeometry = undefined;\r\n    this.helperMaterial = undefined;\r\n  }\r\n\r\n  setPathHelpersVisibility(state = false){\r\n    if(!this.helperMesh) return;\r\n    this.helperMesh.visible = state;\r\n  }\r\n\r\n  cleanupConnections(){\r\n    for(let i = 0; i < this.points.length; i++){\r\n      const point = this.points[i];\r\n      const toPrune: PathPoint[] = [];\r\n      for(let j = 0; j < point.connections.length; j++){\r\n        const con = point.connections[j];\r\n        if(!point.hasLOS(con)){\r\n          toPrune.push(con);\r\n        }\r\n      }\r\n      while(toPrune.length){\r\n        const con = toPrune.pop();\r\n        log.info('los', 'pruning connection', point, con);\r\n        point.removeConnection(con);\r\n        con.removeConnection(point);\r\n      }\r\n    }\r\n  }\r\n\r\n  getClosestPathPointData(target = new THREE.Vector3): IClosestPathPointData {\r\n    const targetPoint = new THREE.Vector3().copy(target);\r\n    targetPoint.z = 0;\r\n    const line3 = new THREE.Line3();\r\n    const closest_position_on_line = new THREE.Vector3(0, 0, 0);\r\n    let point_a: PathPoint;\r\n    let point_b: PathPoint;\r\n    let distance = Infinity;\r\n    let pDistance = 0;\r\n\r\n    const _tempPoint = new THREE.Vector3(0, 0, 0);\r\n    for(let i = 0; i < this.points.length; i++){\r\n      const point = this.points[i];\r\n      for(let j = 0; j < point.num_connections; j++){\r\n        const connection = point.connections[j];\r\n        line3.set(point.vector, connection.vector);\r\n        line3.closestPointToPoint(targetPoint, true, _tempPoint);\r\n        pDistance = targetPoint.distanceTo(_tempPoint);\r\n        if(pDistance < distance){\r\n          distance = pDistance;\r\n          point_a = point;\r\n          point_b = connection;\r\n          closest_position_on_line.copy(_tempPoint);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return { \r\n      point_a: point_a, \r\n      point_b: point_b, \r\n      closest_position_on_line: closest_position_on_line \r\n    };\r\n  }\r\n\r\n  getClosestPathPoint(origin: THREE.Vector3): PathPoint{\r\n    let point: PathPoint;\r\n    let distance = Infinity;\r\n    for(let i = 0; i < this.points.length; i++){\r\n      const p = this.points[i];\r\n      const d = origin.distanceTo(p.vector);\r\n      if(d < distance){\r\n        point = p;\r\n        distance = d;\r\n      }\r\n    }\r\n    return point;\r\n  }\r\n\r\n  traverseToPoint(owner: ModuleObject, origin: THREE.Vector3, dest: THREE.Vector3, smooth: boolean = true): ComputedPath {\r\n    this.reset();\r\n\r\n    const originPoint = PathPoint.FromVector3(origin);\r\n    originPoint.setArea(this.area);\r\n\r\n    const destPoint = PathPoint.FromVector3(dest);\r\n    destPoint.setArea(this.area);\r\n\r\n    const fallbackPath = ComputedPath.FromPointsList([originPoint, destPoint]);\r\n    if(!this.points.length) return fallbackPath;\r\n\r\n    if(originPoint.hasLOS(destPoint, owner)) return fallbackPath;\r\n\r\n    const closest_origin_point = this.getClosestPathPoint(origin);\r\n    const closest_destination_point = this.getClosestPathPoint(dest);\r\n\r\n    //origin\r\n    originPoint.addConnection(closest_origin_point);\r\n    closest_origin_point.addConnection(originPoint);\r\n\r\n    //dest\r\n    closest_destination_point.addConnection(destPoint);\r\n    destPoint.addConnection(closest_destination_point);\r\n\r\n    originPoint.connections = this.points.slice(0).filter( (p) => {\r\n      return p.hasLOS(originPoint, owner);\r\n    });\r\n\r\n    const path = new ComputedPath(owner, originPoint, destPoint);\r\n    path.setOwner(owner);\r\n    path.search();\r\n\r\n    //clean up tmp point refs\r\n    for(let i = 0, len = this.points.length; i < len; i++){\r\n      const p = this.points[i];\r\n      p.removeConnection(originPoint);\r\n      p.removeConnection(destPoint);\r\n    }\r\n\r\n    if(path.points.length){\r\n      if(smooth)\r\n        path.smooth();\r\n      return path;\r\n    }\r\n    \r\n    return fallbackPath;\r\n\r\n  }\r\n\r\n  reset(){\r\n    this.points.map( (p) => {\r\n      p.reset();\r\n    })\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleRoom.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":196,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":196,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":196,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":196,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":652,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":652,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":653,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":653,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .image on an `any` value.","line":653,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":653,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":654,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":654,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .image on an `any` value.","line":654,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":654,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":658,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":658,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [i + 3] on an `any` value.","line":659,"column":12,"nodeType":"BinaryExpression","messageId":"unsafeMemberExpression","endLine":659,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [pixelIndex] on an `any` value.","line":667,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":667,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [pixelIndex + 1] on an `any` value.","line":668,"column":12,"nodeType":"BinaryExpression","messageId":"unsafeMemberExpression","endLine":668,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [pixelIndex + 2] on an `any` value.","line":669,"column":12,"nodeType":"BinaryExpression","messageId":"unsafeMemberExpression","endLine":669,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [pixelIndex + 3] on an `any` value.","line":670,"column":12,"nodeType":"BinaryExpression","messageId":"unsafeMemberExpression","endLine":670,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .needsUpdate on an `any` value.","line":674,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":674,"endColumn":24}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleObject } from \"@/module/ModuleObject\";\n\r\n\r\nimport * as THREE from \"three\";\nimport * as BufferGeometryUtils from \"three/examples/jsm/utils/BufferGeometryUtils\";\n\nimport type { ModuleArea, ModuleCreature, ModuleDoor, ModuleEncounter, ModulePlaceable, ModuleSound, ModuleTrigger } from \".\";\n\r\n// import { ShaderManager } from \"@/managers\";\r\n\n\nconst log = createScopedLogger(LogScope.Module);\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\r\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { IVISRoom } from \"@/interface\";\r\nimport { MDLLoader, ResourceLoader, TextureLoader } from \"@/loaders\";\r\nimport { OdysseyModelNodeAABB, OdysseyWalkMesh } from \"@/odyssey\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { VISObject } from \"@/resource/VISObject\";\r\nimport { OdysseyFace3, OdysseyModel3D } from \"@/three/odyssey\";\r\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\r\nimport { BinaryReader } from \"@/utility/binary/BinaryReader\";\r\nimport { BitWise } from \"@/utility/BitWise\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\r\n\r\n/**\r\n* ModuleRoom class.\r\n* \r\n* Class representing rooms found in modules areas.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file ModuleRoom.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class ModuleRoom extends ModuleObject {\r\n  ambientScale: number = 0;\r\n  envAudio: number = 0;\r\n  roomName: string;\r\n  visObject: VISObject;\r\n\r\n  doors: ModuleDoor[] = [];\r\n  placeables: ModulePlaceable[] = [];\r\n  creatures: ModuleCreature[] = [];\r\n  triggers: ModuleTrigger[] = [];\r\n  encounters: ModuleEncounter[] = [];\r\n  sounds: ModuleSound[] = [];\r\n  grass: THREE.InstancedMesh<THREE.BufferGeometry, THREE.ShaderMaterial>;\r\n\r\n  linkedRoomData: IVISRoom[] = [];\r\n  linkedRoomNames: string[] = [];\r\n  linkedRooms: Map<string, ModuleRoom> = new Map<string, ModuleRoom>();\r\n\r\n  constructor( roomName: string, area: ModuleArea ){\r\n    super();\r\n    this.objectType |= ModuleObjectType.ModuleRoom;\r\n\r\n    this.id = -1;\r\n    this.roomName = roomName?.toLocaleLowerCase();\r\n    this.area = area;\r\n  }\r\n\r\n  setAmbientScale(scale: number){\r\n    this.ambientScale = scale;\r\n  }\r\n\r\n  setEnvAudio(audio: number){\r\n    this.envAudio = audio;\r\n  }\r\n\r\n  #boxSize: THREE.Vector3 = new THREE.Vector3();\r\n  detectChildObjects(){\r\n    this.box.getSize(this.#boxSize);\r\n    const box = this.box.clone().expandByVector(this.#boxSize);\r\n    this.doors = [];\r\n    this.placeables = [];\r\n    this.sounds = [];\r\n    \r\n    for(let i = 0, len = this.area.doors.length; i < len; i++){\r\n      const object = this.area.doors[i] as ModuleDoor;\r\n      if(object && (box.containsBox(object.box) || box.containsPoint(object.position) || box.intersectsSphere(object.sphere))){\r\n        this.attachChildObject(object);\r\n      }\r\n    }\r\n\r\n    for(let i = 0, len = this.area.placeables.length; i < len; i++){\r\n      const object = this.area.placeables[i] as ModulePlaceable;\r\n      if(object && (box.containsBox(object.box) || box.containsPoint(object.position) || box.intersectsSphere(object.sphere))){\r\n        this.attachChildObject(object);\r\n      }\r\n    }\r\n\r\n    for(let i = 0, len = this.area.sounds.length; i < len; i++){\r\n      const object = this.area.sounds[i] as ModuleSound;\r\n      if(!object.positional){ continue; }\r\n\r\n      if(object && (box.containsBox(object.box) || box.containsPoint(object.position) || box.intersectsSphere(object.sphere))){\r\n        this.attachChildObject(object);\r\n      }\r\n    }\r\n  }\r\n\r\n  attachChildObject(object: ModuleObject){\r\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\r\n      if(this.creatures.indexOf(object as ModuleCreature) >= 0) return;\r\n      this.creatures.push(object as ModuleCreature);\r\n    }else if (BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModulePlaceable)){\r\n      if(this.placeables.indexOf(object as ModulePlaceable) >= 0) return;\r\n      this.placeables.push(object as ModulePlaceable);\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleDoor)){\r\n      if(this.doors.indexOf(object as ModuleDoor) >= 0) return;\r\n      this.doors.push(object as ModuleDoor);\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleTrigger)){\r\n      if(this.triggers.indexOf(object as ModuleTrigger) >= 0) return;\r\n      this.triggers.push(object as ModuleTrigger);\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleEncounter)){\r\n      if(this.encounters.indexOf(object as ModuleEncounter) >= 0) return;\r\n      this.encounters.push(object as ModuleEncounter);\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleSound)){\r\n      if(this.sounds.indexOf(object as ModuleSound) >= 0) return;\r\n      this.sounds.push(object as ModuleSound);\r\n    }\r\n  }\r\n\r\n  removeChildObject(object: ModuleObject){\r\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleCreature)){\r\n      const idx = this.creatures.indexOf(object as ModuleCreature);\r\n      if(idx >= 0){\r\n        this.creatures.splice(idx, 1);\r\n      }\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModulePlaceable)){\r\n      const idx = this.placeables.indexOf(object as ModulePlaceable);\r\n      if(idx >= 0){\r\n        this.placeables.splice(idx, 1);\r\n      }\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleDoor)){\r\n      const idx = this.doors.indexOf(object as ModuleDoor);\r\n      if(idx >= 0){\r\n        this.doors.splice(idx, 1);\r\n      }\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleTrigger)){\r\n      const idx = this.triggers.indexOf(object as ModuleTrigger);\r\n      if(idx >= 0){\r\n        this.triggers.splice(idx, 1);\r\n      }\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleEncounter)){\r\n      const idx = this.encounters.indexOf(object as ModuleEncounter);\r\n      if(idx >= 0){\r\n        this.encounters.splice(idx, 1);\r\n      }\r\n    }else if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleSound)){\r\n      const idx = this.sounds.indexOf(object as ModuleSound);\r\n      if(idx >= 0){\r\n        this.sounds.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  setLinkedRooms(array: IVISRoom[] = []){\r\n    this.linkedRoomData = array;\r\n    this.linkedRoomNames = array.map(room => room.name);\r\n  }\r\n\r\n  setPosition(x = 0, y = 0, z = 0){\r\n    this.position.set(x, y, z);\r\n  }\r\n\r\n  getVisisbleNeighbors(){  }\r\n\r\n  update(delta: number = 0){\r\n    if(this.model instanceof OdysseyModel3D){\r\n      //BEGIN: Animation Optimization\r\n      this.model.animateFrame = true;\r\n      if(!BitWise.InstanceOf(this.objectType, ModuleObjectType.ModuleRoom)){\r\n        if(!this.model.visible){\r\n          this.model.animateFrame = false;\r\n        }\r\n      }\r\n      //END: Animation Optimization\r\n\r\n      this.model.update(delta);\r\n    }\r\n\r\n    if(this.grass){\r\n      this.grass.material.uniforms.time.value += delta;\r\n      \r\n      // Update camera position for distance fade and player position for trample\r\n      if(GameState.getCurrentPlayer()?.position){\r\n        this.grass.material.uniforms.playerPosition.value.copy(GameState.getCurrentPlayer()?.position);\r\n        this.grass.material.uniforms.useDistanceFade.value = (GameState.Mode == EngineMode.DIALOG) ? false : true;\r\n      }\r\n      \r\n      // Update entity positions in texture for multi-entity trample\r\n      this.updatePositionDataTexture();\r\n      \r\n      this.grass.material.uniformsNeedUpdate = true;\r\n    }\r\n  }\r\n\r\n  show(showLinkedRooms = false){\r\n    if(this.model){\r\n      this.model.visible = true;\r\n    }\r\n\r\n    if(this.grass){\r\n      this.grass.visible = true;\r\n    }\r\n\r\n    if(showLinkedRooms){\r\n      const linkedRooms = Array.from(this.linkedRooms.values());\r\n      for(let i = 0, rLen = linkedRooms.length; i < rLen; i++){\r\n        const room = linkedRooms[i];\r\n        if(room.grass){\r\n          room.grass.visible = true;\r\n        }\r\n        if(typeof room.model === 'object'){\r\n          room.model.visible = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    //Add the walkmesh back to the scene\r\n    if(this.collisionManager.walkmesh && !this.collisionManager.walkmesh.mesh.parent){\r\n      GameState.group.room_walkmeshes.add(this.collisionManager.walkmesh.mesh);\r\n    }else if(this.collisionManager.walkmesh && this.collisionManager.walkmesh.mesh.parent){\r\n      this.collisionManager.walkmesh.mesh.parent.remove(this.collisionManager.walkmesh.mesh);\r\n      GameState.group.room_walkmeshes.add(this.collisionManager.walkmesh.mesh);\r\n    }\r\n\r\n    if(this.collisionManager.walkmesh){\r\n      this.collisionManager.walkmesh.buildEdgeNormalHelpers();\r\n    }\r\n\r\n    for(let i = 0, sLen = this.sounds.length; i < sLen; i++){\r\n      this.sounds[i].audioEmitter.setDisabled(false);\r\n    }\r\n  }\r\n\r\n  hide(hideLinkedRooms = false){\r\n    if(this.model){\r\n      this.model.visible = false;\r\n    }\r\n\r\n    if(this.grass){\r\n      this.grass.visible = false;\r\n    }\r\n\r\n    if(hideLinkedRooms){\r\n      const linkedRooms = Array.from(this.linkedRooms.values());\r\n      for(let i = 0, rLen = linkedRooms.length; i < rLen; i++){\r\n        if(typeof linkedRooms[i].model != 'object'){\r\n          continue;\r\n        }\r\n        linkedRooms[i].model.visible = false;\r\n      }\r\n    }\r\n    \r\n    //Remove the walkmesh back to the scene\r\n    if(this.collisionManager.walkmesh && this.collisionManager.walkmesh.mesh.parent){\r\n      this.collisionManager.walkmesh.mesh.parent.remove(this.collisionManager.walkmesh.mesh);\r\n    }\r\n\r\n    for(let i = 0, sLen = this.sounds.length; i < sLen; i++){\r\n      this.sounds[i].audioEmitter.setDisabled(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Link the rooms\r\n   * @param rooms - The rooms to link\r\n   */\r\n  linkRooms(){\r\n    for(let i = 0, iLen = this.linkedRoomData.length; i < iLen; i++){\r\n      this.linkedRooms.set(this.linkedRoomData[i].name, this.area.visObject.getRoomByName(this.linkedRoomData[i].name));\r\n    }\r\n  }\r\n\r\n  async loadModel(): Promise<OdysseyModel3D> {\r\n    //Check if the room name is NULL\r\n    if(Utility.is2daNULL(this.roomName)){\r\n      return this.model;\r\n    }\r\n\r\n    //Load the model\r\n    const roomFile = await MDLLoader.loader.load(this.roomName);\r\n    const room: OdysseyModel3D = await OdysseyModel3D.FromMDL(roomFile, {\r\n      context: this.context,\r\n      castShadow: false,\r\n      receiveShadow: true,\r\n      //Merge Static Geometry *Experimental*\r\n      mergeStatic: !this.area.miniGame ? true : false\r\n    });\r\n\r\n    //Remove the old model\r\n    if(this.model instanceof OdysseyModel3D){\r\n      this.model.removeFromParent();\r\n      try{ this.model.dispose(); }catch(e){}\r\n    }\r\n\r\n    this.model = room;\r\n    this.model.userData.moduleObject = this;\r\n    this.container.add(this.model);\r\n    this.box.setFromObject(this.container);\r\n\r\n    //Load the animations\r\n    if(this.model.odysseyAnimations.length){\r\n      for(let animI = 0; animI < this.model.odysseyAnimations.length; animI++){\r\n        if(this.model.odysseyAnimations[animI].name.indexOf('animloop') >= 0){\r\n          this.model.animLoops.push(\r\n            this.model.odysseyAnimations[animI]\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    //Load the walkmesh\r\n    try{\r\n      if(!(this.collisionManager.walkmesh instanceof OdysseyWalkMesh)){\r\n        const wok = await this.loadWalkmesh(this.roomName);\r\n        if(wok){\r\n          this.collisionManager.setWalkmesh(wok);\r\n          wok.mesh.position.z += 0.001;\r\n        }\r\n      }\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n\r\n    //Disable matrix update for static objects\r\n    //room.disableMatrixUpdate();\r\n\r\n    try{\r\n      this.buildGrass();\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n\r\n    return this.model;\r\n  }\r\n\r\n  async loadWalkmesh(resRef = ''): Promise<OdysseyWalkMesh> {\r\n    try {\r\n      const buffer = await ResourceLoader.loadResource(ResourceTypes['wok'], resRef);\r\n      const wok = new OdysseyWalkMesh(new BinaryReader(buffer));\r\n      wok.name = resRef;\r\n      wok.moduleObject = this;\r\n      this.model.wok = wok;\r\n      return wok;\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n  buildGrass(){\r\n    if(!this.area.grass.textureName){\r\n      // log.warn('ModuleRoom.buildGrass: No grass texture found for room', this.roomName);\r\n      return;\r\n    }\r\n\r\n    const density = this.area.grass.density;\r\n    const quadOffsetZ = this.area.grass.quadSize/2;\r\n    if(!this.model){\r\n      // log.warn('ModuleRoom.buildGrass: No model found for room', this.roomName);\r\n      return;\r\n    }\r\n\r\n    const aabb = this.model.aabb;\r\n    if(!(aabb instanceof OdysseyModelNodeAABB)){\r\n      // log.warn('ModuleRoom.buildGrass: No grass faces found for room', this.roomName);\r\n      return;\r\n    }\r\n\r\n    if(!aabb.grassFaces.length){\r\n      // log.warn('ModuleRoom.buildGrass: No grass faces found for room', this.roomName);\r\n      return;\r\n    }\r\n\r\n    // Pre-calculate grass blade geometry once\r\n    const grassGeometry = this.createGrassBladeGeometry();\r\n    \r\n    const geometry = new THREE.InstancedBufferGeometry();\r\n    geometry.index = grassGeometry.index;\r\n    geometry.attributes.position = grassGeometry.attributes.position;\r\n    geometry.attributes.normal = grassGeometry.attributes.normal;\r\n    geometry.attributes.constraint = grassGeometry.attributes.constraint;\r\n    geometry.attributes.quadIdx = grassGeometry.attributes.quadIdx;\r\n    geometry.attributes.uv = grassGeometry.attributes.uv;\r\n\r\n    // Create position data texture for multi-entity trample\r\n    const positionTexture = this.createPositionDataTexture(64); // 64 entities max\r\n\r\n    const grass_material = new THREE.ShaderMaterial({\r\n      uniforms: THREE.UniformsUtils.merge([\r\n        THREE.UniformsLib[\"common\"],\r\n        {\r\n          map: { value: null },\r\n          lightMap: { value: null },\r\n          positionMap: { value: positionTexture },\r\n          positionMapSize: { value: new THREE.Vector2(8, 8) }, // 8x8 texture = 64 entities\r\n          maxEntities: { value: 64 },\r\n          time: { value: 0 },\r\n          ambientColor: { value: new THREE.Color().setHex(parseInt('0x'+(this.area.sun.fogColor).toString(16))) },\r\n          windPower: { value: this.area.windPower },\r\n          playerPosition: { value: new THREE.Vector3 },\r\n          alphaTest: { value: this.area.alphaTest },\r\n          probability: { value: new THREE.Vector4(\r\n            this.area.grass.probability.lowerLeft,\r\n            this.area.grass.probability.lowerRight,\r\n            this.area.grass.probability.upperLeft,\r\n            this.area.grass.probability.upperRight\r\n          ) },\r\n          // Fade distance uniforms\r\n          fadeStartDistance: { value: 25.0 },\r\n          fadeEndDistance: { value: 100.0 },\r\n          useDistanceFade: { value: true },\r\n          // Trample effect uniforms\r\n          trampleRadius: { value: 3.0 },    // Radius around player where grass gets trampled\r\n          trampleStrength: { value: 1.0 }   // Strength of the trample effect\r\n        }\r\n      ]),\r\n      vertexShader: GameState.ShaderManager.Shaders.get('grass').getVertex(),\r\n      fragmentShader: GameState.ShaderManager.Shaders.get('grass').getFragment(),\r\n      visible: true,\r\n      side: THREE.DoubleSide\r\n    });\r\n\r\n    // Pre-calculate face data and grass counts\r\n    const faceData = this.precalculateFaceData(aabb, density);\r\n    const totalGrassCount = faceData.totalGrassCount;\r\n    \r\n    if(totalGrassCount === 0){\r\n      // log.warn('ModuleRoom.buildGrass: No grass instances to create for room', this.roomName);\r\n      return;\r\n    }\r\n\r\n    this.grass = new THREE.InstancedMesh(geometry, grass_material, totalGrassCount);\r\n    this.grass.frustumCulled = false;\r\n    \r\n    // Pre-allocate reusable objects\r\n    const objForMatrix = new THREE.Object3D();\r\n    const tmpVec3 = new THREE.Vector3();\r\n    const FA = new THREE.Vector3();\r\n    const FB = new THREE.Vector3();\r\n    const FC = new THREE.Vector3();\r\n    const uvA = new THREE.Vector2();\r\n    const uvB = new THREE.Vector2();\r\n    const uvC = new THREE.Vector2();\r\n\r\n\r\n    const lm_texture = aabb.textureMap2;\r\n\r\n    // Pre-allocate arrays\r\n    const instanceIndices = new Float32Array(totalGrassCount);\r\n    const lightmapUV = new Float32Array(totalGrassCount * 2);\r\n    \r\n    // Initialize instance indices\r\n    for(let i = 0; i < totalGrassCount; i++){\r\n      instanceIndices[i] = i;\r\n    }\r\n\r\n    // Pre-cache model data for UV calculation\r\n    const pos = aabb.vertices;\r\n    const uv2 = aabb.tvectors[1];\r\n\r\n    let instanceIndex = 0;\r\n    \r\n    // Process each face\r\n    for(let k = 0; k < aabb.grassFaces.length; k++){\r\n      const face = aabb.grassFaces[k];\r\n      const grassCount = faceData.faceGrassCounts[k];\r\n      \r\n      if(grassCount < 1) continue;\r\n\r\n      // Set face vertices\r\n      FA.set(pos[face.a * 3], pos[(face.a * 3) + 1], pos[(face.a * 3) + 2]);\r\n      FB.set(pos[face.b * 3], pos[(face.b * 3) + 1], pos[(face.b * 3) + 2]);\r\n      FC.set(pos[face.c * 3], pos[(face.c * 3) + 1], pos[(face.c * 3) + 2]);\r\n\r\n      // Set UV coordinates\r\n      const tvI1 = face.a * 2;\r\n      const tvI2 = face.b * 2;\r\n      const tvI3 = face.c * 2;\r\n      \r\n      uvA.set(uv2[tvI1], uv2[tvI1 + 1]);\r\n      uvB.set(uv2[tvI2], uv2[tvI2 + 1]);\r\n      uvC.set(uv2[tvI3], uv2[tvI3 + 1]);\r\n\r\n      // Generate grass instances for this face\r\n      for(let j = 0; j < grassCount; j++){\r\n        // Generate random barycentric coordinates\r\n        let a = Math.random();\r\n        let b = Math.random();\r\n\r\n        if (a + b > 1) {\r\n          a = 1 - a;\r\n          b = 1 - b;\r\n        }\r\n\r\n        const c = 1 - a - b;\r\n\r\n        // Calculate position\r\n        tmpVec3.x = (a * FA.x) + (b * FB.x) + (c * FC.x);\r\n        tmpVec3.y = (a * FA.y) + (b * FB.y) + (c * FC.y);\r\n        tmpVec3.z = (a * FA.z) + (b * FB.z) + (c * FC.z);\r\n\r\n        // Set matrix\r\n        objForMatrix.rotation.z = Math.floor(Math.random() * 360);\r\n        objForMatrix.position.copy(tmpVec3);\r\n        objForMatrix.position.z += quadOffsetZ * 0.90;\r\n        objForMatrix.updateMatrix();\r\n\r\n        // Calculate lightmap UV using current face's barycentric coordinates\r\n        if(lm_texture){\r\n          // Use the barycentric coordinates (a, b, c) we already calculated for positioning\r\n          // to interpolate the UV coordinates from the current face\r\n          const uv = new THREE.Vector2()\r\n            .addScaledVector(uvA, a)\r\n            .addScaledVector(uvB, b)\r\n            .addScaledVector(uvC, c);\r\n          \r\n          lightmapUV[(instanceIndex * 2) + 0] = uv.x;\r\n          lightmapUV[(instanceIndex * 2) + 1] = uv.y; \r\n        }\r\n\r\n        this.grass.setMatrixAt(instanceIndex, objForMatrix.matrix);\r\n        instanceIndex++;\r\n      }\r\n    }\r\n    \r\n    this.grass.instanceMatrix.needsUpdate = true;\r\n    geometry.setAttribute('instanceID', new THREE.InstancedBufferAttribute(instanceIndices, 1));\r\n    geometry.setAttribute('lightmapUV', new THREE.InstancedBufferAttribute(lightmapUV, 2));\r\n\r\n    this.grass.position.copy(this.position).add(aabb.position);\r\n    GameState.group.grass.add(this.grass);\r\n\r\n    // Load textures asynchronously\r\n    this.loadGrassTextures(grass_material, lm_texture);\r\n  }\r\n\r\n  /**\r\n   * Create the grass blade geometry with all four orientations\r\n   */\r\n  private createGrassBladeGeometry(): THREE.BufferGeometry {\r\n    let grassGeometry: THREE.BufferGeometry | undefined = undefined;\r\n    \r\n    for(let i = 0; i < 4; i++){\r\n      const blade = new THREE.PlaneGeometry(this.area.grass.quadSize, this.area.grass.quadSize, 1, 1);\r\n      blade.rotateX(Math.PI/2);\r\n      blade.rotateZ(Math.PI/4 * i);\r\n\r\n      if(!grassGeometry){\r\n        grassGeometry = blade;\r\n        continue;\r\n      }\r\n      \r\n      grassGeometry = BufferGeometryUtils.mergeBufferGeometries([grassGeometry, blade]);\r\n    }\r\n\r\n    // Set constraint array for wind effect\r\n    const constraint = new Float32Array([\r\n      1, 1, 0, 0, \r\n      1, 1, 0, 0, \r\n      1, 1, 0, 0,\r\n      1, 1, 0, 0\r\n    ]);\r\n    grassGeometry.setAttribute('constraint', new THREE.BufferAttribute(constraint, 1));\r\n\r\n    // Set quad index for vertex shader\r\n    const quadIdx = new Float32Array([\r\n      0, 0, 0, 0,\r\n      1, 1, 1, 1,\r\n      2, 2, 2, 2,\r\n      3, 3, 3, 3,\r\n    ]);\r\n    grassGeometry.setAttribute('quadIdx', new THREE.BufferAttribute(quadIdx, 1));\r\n    \r\n    return grassGeometry;\r\n  }\r\n\r\n  /**\r\n   * Pre-calculate face data and grass counts\r\n   */\r\n  private precalculateFaceData(aabb: OdysseyModelNodeAABB, density: number): { totalGrassCount: number, faceGrassCounts: number[] } {\r\n    const faceGrassCounts: number[] = [];\r\n    let totalGrassCount = 0;\r\n    \r\n    const FA = new THREE.Vector3();\r\n    const FB = new THREE.Vector3();\r\n    const FC = new THREE.Vector3();\r\n    \r\n    for(let i = 0; i < aabb.grassFaces.length; i++){\r\n      const face = aabb.grassFaces[i];\r\n\r\n      FA.set(aabb.vertices[face.a * 3], aabb.vertices[(face.a * 3) + 1], aabb.vertices[(face.a * 3) + 2]);\r\n      FB.set(aabb.vertices[face.b * 3], aabb.vertices[(face.b * 3) + 1], aabb.vertices[(face.b * 3) + 2]);\r\n      FC.set(aabb.vertices[face.c * 3], aabb.vertices[(face.c * 3) + 1], aabb.vertices[(face.c * 3) + 2]);\r\n\r\n      const triangle = new THREE.Triangle(FA, FB, FC);\r\n      const tArea = triangle.getArea();\r\n      const grassCount = Math.max(1, Math.floor((tArea * density) * 0.50));\r\n\r\n      totalGrassCount += grassCount;\r\n      faceGrassCounts.push(grassCount);\r\n    }\r\n    \r\n    return { totalGrassCount, faceGrassCounts };\r\n  }\r\n\r\n  /**\r\n   * Create a data texture to store entity positions for trample effects\r\n   */\r\n  private createPositionDataTexture(maxEntities: number = 64): THREE.DataTexture {\r\n    // Create a texture to store entity positions\r\n    // Format: RGBA where R=X, G=Y, B=Z, A=active flag\r\n    const textureSize = Math.ceil(Math.sqrt(maxEntities));\r\n    const data = new Float32Array(textureSize * textureSize * 4);\r\n    \r\n    // Initialize all positions to (0,0,0,0) - inactive\r\n    for (let i = 0; i < data.length; i += 4) {\r\n      data[i] = 0;     // X\r\n      data[i + 1] = 0; // Y  \r\n      data[i + 2] = 0; // Z\r\n      data[i + 3] = 0; // Active flag (0 = inactive, 1 = active)\r\n    }\r\n    \r\n    const texture = new THREE.DataTexture(\r\n      data,\r\n      textureSize,\r\n      textureSize,\r\n      THREE.RGBAFormat,\r\n      THREE.FloatType\r\n    );\r\n    \r\n    texture.needsUpdate = true;\r\n    return texture;\r\n  }\r\n\r\n  /**\r\n   * Update entity positions in the position data texture\r\n   */\r\n  private updatePositionDataTexture(): void {\r\n    if (!this.grass || !this.grass.material.uniforms.positionMap.value) return;\r\n    \r\n    const texture = this.grass.material.uniforms.positionMap.value;\r\n    const data = texture.image.data;\r\n    const textureSize = texture.image.width;\r\n    let entityIndex = 0;\r\n    \r\n    // Clear all positions\r\n    for (let i = 0; i < data.length; i += 4) {\r\n      data[i + 3] = 0; // Set all to inactive\r\n    }\r\n    \r\n    // Add creature positions\r\n    for (const creature of this.creatures) {\r\n      if (entityIndex >= textureSize * textureSize) break;\r\n      \r\n      const pixelIndex = entityIndex * 4;\r\n      data[pixelIndex] = creature.position.x;\r\n      data[pixelIndex + 1] = creature.position.y;\r\n      data[pixelIndex + 2] = creature.position.z;\r\n      data[pixelIndex + 3] = 1.0; // Active\r\n      entityIndex++;\r\n    }\r\n    \r\n    texture.needsUpdate = true;\r\n  }\r\n\r\n  /**\r\n   * Load grass textures asynchronously\r\n   */\r\n  private loadGrassTextures(grass_material: THREE.ShaderMaterial, lm_texture: THREE.Texture): void {\r\n    if(!this.area.grass.textureName){\r\n      // log.warn('ModuleRoom.buildGrass: No grass texture found for room ' + this.roomName);\r\n      return;\r\n    }\r\n    \r\n    TextureLoader.Load(this.area.grass.textureName).then((diffuseMap: OdysseyTexture) => {\r\n      if(!diffuseMap) return;\r\n      \r\n      diffuseMap.minFilter = THREE.LinearFilter;\r\n      diffuseMap.magFilter = THREE.LinearFilter;\r\n      grass_material.uniforms.map.value = diffuseMap;\r\n      grass_material.uniformsNeedUpdate = true;\r\n      grass_material.defines.USE_MAP = '';\r\n      grass_material.defines.USE_UV = '';\r\n      grass_material.needsUpdate = true;\r\n      \r\n      if(!lm_texture){\r\n        // log.warn('ModuleRoom.buildGrass: No grass lightmap found for room ' + this.roomName);\r\n        return;\r\n      }\r\n      \r\n      // Load lightmap texture\r\n      TextureLoader.Load(lm_texture).then((lightMap: OdysseyTexture) => {\r\n        if(!lightMap) return;\r\n        \r\n        lightMap.minFilter = THREE.LinearFilter;\r\n        lightMap.magFilter = THREE.LinearFilter;\r\n        grass_material.uniforms.lightMap.value = lightMap;\r\n        grass_material.uniformsNeedUpdate = true;\r\n        grass_material.defines.USE_LIGHTMAP = '';\r\n        grass_material.needsUpdate = true;\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  \r\n  containsPoint2d(point: THREE.Vector2 | { x: number; y: number }) {\r\n\r\n    if (!this.model)\r\n      return false;\r\n\r\n    return point.x < this.model.box.min.x || point.x > this.model.box.max.x ||\r\n      point.y < this.model.box.min.y || point.y > this.model.box.max.y ? false : true;\r\n  }\r\n  \r\n  containsPoint3d(point: THREE.Vector3 | { x: number; y: number; z: number }){\r\n\r\n    if(!this.model)\r\n      return false;\r\n\r\n    return point.x < this.model.box.min.x || point.x > this.model.box.max.x ||\r\n      point.y < this.model.box.min.y || point.y > this.model.box.max.y ||\r\n      point.z < this.model.box.min.z || point.z > this.model.box.max.z ? false : true;\r\n  }\r\n\r\n  findWalkableFace( object?: ModuleObject ) : OdysseyFace3 {\r\n    let face;\r\n    if(BitWise.InstanceOf(object?.objectType, ModuleObjectType.ModuleObject) && this.collisionManager.walkmesh){\r\n      for(let j = 0, jl = this.collisionManager.walkmesh.walkableFaces.length; j < jl; j++){\r\n        face = this.collisionManager.walkmesh.walkableFaces[j];\r\n        if(face.triangle.containsPoint(object.position)){\r\n          object.collisionManager.groundFace = face;\r\n          object.collisionManager.lastGroundFace = object.collisionManager.groundFace;\r\n          object.collisionManager.surfaceId = object.collisionManager.groundFace.walkIndex;\r\n          object.room = this;\r\n\r\n          face.triangle.closestPointToPoint(object.position, object.collisionManager.wm_c_point);\r\n          object.position.z = object.collisionManager.wm_c_point.z + .005;\r\n          return face;\r\n        }\r\n      }\r\n    }\r\n    return face;\r\n  }\r\n\r\n  destroy(): void {\r\n    super.destroy();\r\n      \r\n    if(this.collisionManager.walkmesh)\r\n      this.collisionManager.walkmesh.dispose();\r\n\r\n    try{\r\n      const wmIdx = GameState.walkmeshList.indexOf(this.collisionManager.walkmesh.mesh);\r\n      GameState.walkmeshList.splice(wmIdx, 1);\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n\r\n    try{\r\n      if(this.grass){\r\n        this.grass.geometry.dispose();\r\n        this.grass.material.dispose();\r\n        this.grass.removeFromParent();\r\n      }\r\n    }catch(e){\r\n      log.error(e);\r\n    }\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\module\\ModuleTrigger.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number | ArrayBuffer | ArrayLike<number> | Iterable<number>`.","line":150,"column":76,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":150,"endColumn":132},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":150,"column":76,"nodeType":"MemberExpression","messageId":"errorCall","endLine":150,"endColumn":130},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":154,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":154,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":529,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":529,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":531,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":531,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":531,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":531,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":531,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":531,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":531,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":531,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":531,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":531,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":532,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":532,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":532,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":532,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":532,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":532,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":532,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":532,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":532,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":532,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":533,"column":11,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":533,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":533,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":533,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":533,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":533,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getFieldByLabel on a type that cannot be resolved.","line":533,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":533,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .getValue on a type that cannot be resolved.","line":533,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":533,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":675,"column":81,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":675,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":676,"column":81,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":676,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":677,"column":81,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":677,"endColumn":99}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleObject } from \"@/module/ModuleObject\";\r\nimport { GFFObject } from \"@/resource/GFFObject\";\r\n\r\nimport * as THREE from \"three\";\r\n\r\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\r\nimport { ModuleDoorAnimState, SignalEventType } from \"@/enums\";\r\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\r\n\r\n\r\nconst log = createScopedLogger(LogScope.Module);\r\nimport { ModuleObjectScript } from \"@/enums/module/ModuleObjectScript\";\r\nimport { ModuleTriggerType } from \"@/enums/module/ModuleTriggerType\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport { MDLLoader, ResourceLoader } from \"@/loaders\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\r\nimport { OdysseyModel3D, OdysseyObject3D } from \"@/three/odyssey\";\r\nimport { ConfigClient } from \"@/utility/ConfigClient\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\n\r\nconst OBJECTS_INSIDE_UPDATE_THRESHOLD = 15; // 15 frame ticks\r\n\r\n/**\r\n* ModuleTrigger class.\r\n* \r\n* Class representing a trigger object found in modules areas.\r\n* \r\n* KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n* \r\n* @file ModuleTrigger.ts\r\n* @author KobaltBlu <https://github.com/KobaltBlu>\r\n* @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n* @memberof KotOR\r\n*/\r\nexport class ModuleTrigger extends ModuleObject {\r\n  objectsInsideIdx: number;\r\n  lastObjectEntered: ModuleObject;\r\n  lastObjectExited: ModuleObject;\r\n  triggered: boolean;\r\n\r\n  trapModel: OdysseyModel3D;\r\n  trapAnimationState: ModuleDoorAnimState = ModuleDoorAnimState.DEFAULT;\r\n  trapName: string = '';\r\n\r\n  reticleNode: OdysseyObject3D = new OdysseyObject3D();\r\n  trapModelResRef: string;\r\n  trapExplosionSound: string;\r\n  trapTriggered: boolean;\r\n  trapResRef: string;\r\n  trapDetected: boolean = false;\r\n  /** Trap creator object id (for auto-disarm when disarmer placed the trap or party trap). */\r\n  creatorId: number = 0x7f000000; // OBJECT_INVALID\r\n  declare type: ModuleTriggerType;\r\n\r\n  constructor ( gff = new GFFObject() ) {\r\n    super(gff);\r\n    this.objectType |= ModuleObjectType.ModuleTrigger;\r\n\r\n    this.template = gff;\r\n    this.objectsInside = [];\r\n    this.objectsInsideIdx = 0;\r\n    this.lastObjectEntered = null;\r\n    this.lastObjectExited = null;\r\n\r\n    this.setByPlayerParty = 0;\r\n\r\n    this.tag = '';\r\n    this.vertices = [];\r\n    this.box = new THREE.Box3();\r\n\r\n    this.triggered = false;\r\n    this.highlightHeight = 0.10000000149011612;\r\n    this.initProperties();\r\n\r\n    this.container.add(this.reticleNode);\r\n    this.reticleNode.position.z = this.highlightHeight;\r\n\r\n  }\r\n\r\n  getReticleNode(){\r\n    return this.reticleNode;\r\n  }\r\n\r\n  getName(){\r\n    if(this.type == ModuleTriggerType.TRAP){\r\n      return this.trapName;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  getType(){\r\n    return this.type;\r\n  }\r\n\r\n  getTag(){\r\n    return this.tag;\r\n  }\r\n\r\n  getTemplateResRef(){\r\n    return this.templateResRef;\r\n  }\r\n\r\n  getXOrientation(){\r\n    return this.xOrientation;\r\n  }\r\n\r\n  getYOrientation(){\r\n    return this.yOrientation;\r\n  }\r\n\r\n  getZOrientation(){\r\n    return this.zOrientation;\r\n  }\r\n\r\n  isDead(){\r\n    return false;\r\n  }\r\n\r\n  getCurrentRoom(){\r\n    let _distance = 1000000000;\r\n    for(let i = 0; i < GameState.module.area.rooms.length; i++){\r\n      const room = GameState.module.area.rooms[i];\r\n      const model = room.model;\r\n      if(model instanceof OdysseyModel3D){\r\n        const pos = this.position.clone();\r\n        if(model.box.containsPoint(pos)){\r\n          const roomCenter = model.box.getCenter(new THREE.Vector3()).clone();\r\n          const distance = pos.distanceTo(roomCenter);\r\n          if(distance < _distance){\r\n            _distance = distance;\r\n            this.attachToRoom(room);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getGeometry(){\r\n    const trigGeom = new THREE.BufferGeometry();\r\n\r\n    try{\r\n      const vertices = this.vertices.slice();\r\n      const holes: THREE.Vector2[][] = [];\r\n      const triangles = THREE.ShapeUtils.triangulateShape ( vertices, holes );\r\n      trigGeom.setIndex(triangles.flat());\r\n      trigGeom.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices.map( (v: THREE.Vector3) => v.toArray() ).flat(), 3 ) );\r\n    }catch(e){\r\n      log.error('ModuleTrigger', 'Failed to generate faces', {\r\n        trigger: this,\r\n        error: e\r\n      })\r\n    }\r\n\r\n    // trigGeom.computeFaceNormals();\r\n    trigGeom.computeVertexNormals();\r\n    trigGeom.computeBoundingSphere();\r\n\r\n    return trigGeom;\r\n  }\r\n\r\n  load( onLoad?: () => void ){\r\n    if(this.getTemplateResRef()){\r\n      //Load template and merge fields\r\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['utt'], this.getTemplateResRef());\r\n      if(buffer){\r\n        const gff = new GFFObject(buffer);\r\n        this.template.merge(gff);\r\n        this.initProperties();\r\n        this.loadScripts()\r\n        this.buildGeometry();\r\n        this.initObjectsInside();\r\n        this.loadTrap();\r\n      }else{\r\n        log.error('Failed to load ModuleTrigger template');\r\n        if(this.template instanceof GFFObject){\r\n          this.initProperties();\r\n          this.loadScripts();\r\n          this.buildGeometry();\r\n          this.initObjectsInside();\r\n          this.loadTrap();\r\n        }\r\n      }\r\n\r\n    }else{\r\n      //We already have the template (From SAVEGAME)\r\n      this.initProperties();\r\n      this.loadScripts()\r\n      this.buildGeometry();\r\n      this.initObjectsInside();\r\n      this.loadTrap();\r\n    }\r\n  }\r\n\r\n  loadTrap(){\r\n    if(this.type == 2 && this.trapModelResRef && this.trapModelResRef != '***'){\r\n      MDLLoader.loader.load(this.trapModelResRef).then( (trapMDL) => {\r\n        OdysseyModel3D.FromMDL(trapMDL, {\r\n          context: this.context,\r\n          castShadow: false,\r\n          receiveShadow: false,\r\n          mergeStatic: false\r\n        }).then( (model: OdysseyModel3D) => {\r\n          this.trapModel = model;\r\n          this.container.add(model);\r\n          if(this.trapDetected){\r\n            this.model.playAnimation('detect', false);\r\n          }else{\r\n            this.model.playAnimation('default', false);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  buildGeometry(){\r\n    const trigGeom = this.getGeometry();\r\n\r\n    const material = new THREE.MeshBasicMaterial({\r\n      color: new THREE.Color( 0xFFFFFF ),\r\n      side: THREE.DoubleSide\r\n    });\r\n\r\n    switch(this.getType()){\r\n      case ModuleTriggerType.GENERIC:\r\n        material.color.setHex(0xFF0000)\r\n      break;\r\n      case ModuleTriggerType.TRANSITION:\r\n        material.color.setHex(0x00FF00)\r\n      break;\r\n      case ModuleTriggerType.TRAP:\r\n        material.color.setHex(0xFFEB00)\r\n      break;\r\n    }\r\n\r\n    this.mesh = new THREE.Mesh( trigGeom, material );\r\n    this.mesh.position.copy(this.position);\r\n    this.box.setFromObject(this.mesh);\r\n    this.box.min.z -= 100;\r\n    this.box.max.z += 100;\r\n    //this.box = this.mesh.box;\r\n\r\n    /*\r\n     * Orientation values are wrong in savegames. If rotation is not set they are always placed correctly\r\n     * // this.mesh.rotation.set(this.getXOrientation(), this.getYOrientation(), this.getZOrientation());\r\n     */\r\n\r\n    this.mesh.userData.moduleObject = this;\r\n    this.mesh.visible = false;\r\n    this.container.add(this.mesh);\r\n    GameState.group.triggers.add(this.container);\r\n  }\r\n\r\n  detectTrap(){\r\n    if(this.trapDetected){ return; }\r\n    this.trapDetected = true;\r\n\r\n    if(this.trapDetected){\r\n      this.model.playAnimation('detect', false);\r\n    }else{\r\n      this.model.playAnimation('default', false);\r\n    }\r\n  }\r\n\r\n  //Some modules have exit triggers that are placed in the same location that the player spawns into\r\n  //This is my way of keeping the player from immediately activating the trigger\r\n  //They will be added to the objectsInside array without triggering the onEnter script\r\n  //If they leave the trigger and then return it will then fire normally\r\n  initObjectsInside(){\r\n    //Check to see if this trigger is linked to another module\r\n    if(this.linkedToModule && this.type == 1){\r\n      //Check Party Members\r\n      const partyLen = GameState.PartyManager.party.length;\r\n      for(let i = 0; i < partyLen; i++){\r\n        const partymember = GameState.PartyManager.party[i];\r\n        const pos = partymember.position;\r\n        if(!this.box.containsPoint(pos)){ continue; }\r\n        const added = this.addObjectInside(partymember);\r\n        if(!added){ continue; }\r\n        \r\n        partymember.lastTriggerEntered = this;\r\n        this.lastObjectEntered = partymember;\r\n      }\r\n    }else{\r\n      //Check Creatures\r\n      const creatureLen = GameState.module.area.creatures.length;\r\n      for(let i = 0; i < creatureLen; i++){\r\n        const creature = GameState.module.area.creatures[i];\r\n        const pos = creature.position;\r\n        if(!this.box.containsPoint(pos)){ continue; }\r\n\r\n        const added = this.addObjectInside(creature);\r\n        if(!added){ continue; }\r\n        creature.lastTriggerEntered = this;\r\n        this.lastObjectEntered = creature;\r\n      }\r\n    }\r\n  }\r\n\r\n  isInsideBoundingBox(object: ModuleObject): boolean {\r\n    return this.box.containsPoint(object.position);\r\n  }\r\n\r\n  isInside(object: ModuleObject): boolean {\r\n    return this.objectsInside.indexOf(object) >= 0;\r\n  }\r\n\r\n  addObjectInside(object: ModuleObject): boolean {\r\n    const isInside = this.isInside(object);\r\n    if(isInside){ return false; }\r\n    this.objectsInside.push(object);\r\n    return true;\r\n  }\r\n\r\n  removeObjectInside(object: ModuleObject): boolean {\r\n    const isInside = this.isInside(object);\r\n    if(!isInside){ return false; }\r\n    this.objectsInside.splice(this.objectsInside.indexOf(object), 1);\r\n    return true;\r\n  }\r\n\r\n  isUseable(): boolean {\r\n    return this.type == ModuleTriggerType.TRAP;\r\n  }\r\n\r\n  canTrigger(object: ModuleObject): boolean {\r\n    return this.isHostile(object) && (!this.triggered || !this.trapOneShot);\r\n  }\r\n\r\n  update(delta = 0){\r\n    \r\n    super.update(delta);\r\n    \r\n    if(!this.room) this.getCurrentRoom();\r\n    try{\r\n      if(!this.room.model.visible)\r\n        return;\r\n    }catch(e){}\r\n\r\n    this.action = this.actionQueue[0];\r\n    this.actionQueue.process( delta );\r\n\r\n    if(this.trapModel){\r\n      this.trapModel.update(delta);\r\n      if(this.trapDetected && this.trapModel.animationManager.currentAnimation?.name != 'detect'){\r\n        this.trapModel.playAnimation('detect', false);\r\n      }else if(!this.trapDetected && this.trapModel.animationManager.currentAnimation?.name != 'default'){\r\n        this.trapModel.playAnimation('default', false);\r\n      }\r\n    }\r\n    \r\n    //Call the function to update the objectsInside array\r\n    //this.autoUpdateObjectsInside();\r\n\r\n    if(this.mesh){\r\n      this.mesh.visible = ConfigClient.get('Game.debug.trigger_geometry_show') ? true : false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Timer for the objectsInside array update\r\n   * If the timer is less than the OBJECTS_INSIDE_UPDATE_THRESHOLD, ignore the update\r\n   */\r\n  #autoObjectsInsideTimer = 0;\r\n\r\n  /**\r\n   * Update the objectsInside array\r\n   * @deprecated - use the positionChanged event inside ModuleCreature instead\r\n   * @param delta \r\n   * @returns \r\n   */\r\n  autoUpdateObjectsInside(){\r\n    this.#autoObjectsInsideTimer += 1;\r\n    if(this.#autoObjectsInsideTimer < OBJECTS_INSIDE_UPDATE_THRESHOLD){ return; }\r\n    this.#autoObjectsInsideTimer = 0;\r\n\r\n    const creaturesToCheck = [\r\n      ...GameState.module.area.creatures.filter(object => this.box.containsPoint(object.position)), \r\n      ...GameState.PartyManager.party.filter(object => this.box.containsPoint(object.position))\r\n    ];\r\n\r\n    //Check Creatures in Area\r\n    const creatureLen = creaturesToCheck.length;\r\n    for(let i = 0; i < creatureLen; i++){\r\n      const creature = creaturesToCheck[i];\r\n      this.updateObjectInside(creature);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the objectsInside array\r\n   * @param object \r\n   * @returns \r\n   */\r\n  updateObjectInside(object: ModuleObject){\r\n    //Check if the creature is inside the bounding box\r\n    const isInside = this.isInsideBoundingBox(object);  \r\n    if(isInside){\r\n      //If the creature is inside the bounding box, attempt to add it to the objectsInside array\r\n      const added = this.addObjectInside(object);\r\n      if(!added){ return; }\r\n      if(!this.triggered && this.isHostile(object)){\r\n        object.lastTriggerEntered = this;\r\n        this.lastObjectEntered = object;\r\n\r\n        this.onEnter(object);\r\n        this.triggered = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    //If the creature is not inside the bounding box, attempt to remove it from the objectsInside array\r\n    const removed = this.removeObjectInside(object);\r\n    if(!removed){ return; }\r\n    if(!this.triggered && this.isHostile(object)){\r\n      object.lastTriggerExited = this;\r\n      this.lastObjectExited = object;\r\n      this.onExit(object);\r\n    }\r\n  }\r\n\r\n  onEnter(object?: ModuleObject){\r\n    if(!object){ return; }\r\n    log.info('ModuleTrigger.onEnter', this.type,  this.getTag());\r\n    if(this.type == ModuleTriggerType.TRAP && !this.trapTriggered){\r\n      if(object.isHostile(this)){\r\n        this.trapTriggered = true;\r\n        log.info('ModuleTrigger.onEnter', 'Trap Triggered')\r\n        const event = new GameState.GameEventFactory.EventSignalEvent();\r\n        event.setCaller(object);\r\n        event.setObject(this);\r\n        event.setDay(GameState.module.timeManager.pauseDay);\r\n        event.setTime(GameState.module.timeManager.pauseTime);\r\n        event.eventType = SignalEventType.OnTrapTriggered;\r\n        GameState.module.addEvent(event);\r\n      }\r\n    }else if(this.linkedToModule && (GameState.Mode != EngineMode.DIALOG)){\r\n      if(object == GameState.getCurrentPlayer()){\r\n        GameState.LoadModule(this.linkedToModule.toLowerCase(), this.linkedTo.toLowerCase());\r\n      }\r\n      return;\r\n    }\r\n\r\n    log.info('ModuleTrigger', this.getTag(), 'enter 1')\r\n    const event = new GameState.GameEventFactory.EventSignalEvent();\r\n    event.setCaller(object);\r\n    event.setObject(this);\r\n    event.setDay(GameState.module.timeManager.pauseDay);\r\n    event.setTime(GameState.module.timeManager.pauseTime);\r\n    event.eventType = SignalEventType.OnObjectEnter;\r\n    GameState.module.addEvent(event);\r\n  }\r\n\r\n  onExit(object?: ModuleObject){\r\n    if(!object){ return; }\r\n    log.info('ModuleTrigger', this.getTag(), 'exit')\r\n    const event = new GameState.GameEventFactory.EventSignalEvent();\r\n    event.setCaller(object);\r\n    event.setObject(this);\r\n    event.setDay(GameState.module.timeManager.pauseDay);\r\n    event.setTime(GameState.module.timeManager.pauseTime);\r\n    event.eventType = SignalEventType.OnObjectExit;\r\n    GameState.module.addEvent(event);\r\n  }\r\n\r\n  loadScripts(){\r\n    const scriptKeys = [\r\n      ModuleObjectScript.TriggerOnClick,\r\n      ModuleObjectScript.TriggerOnDisarm,\r\n      ModuleObjectScript.TriggerOnTrapTriggered,\r\n      ModuleObjectScript.TriggerOnHeartbeat,\r\n      ModuleObjectScript.TriggerOnEnter,\r\n      ModuleObjectScript.TriggerOnExit,\r\n      ModuleObjectScript.TriggerOnUserDefined,\r\n    ];\r\n\r\n    const scriptsNode = this.template?.RootNode;\r\n    if(!scriptsNode){ return; }\r\n    \r\n    for(const scriptKey of scriptKeys){\r\n      if(scriptsNode.hasField(scriptKey)){\r\n        const resRef = scriptsNode.getFieldByLabel(scriptKey).getValue();\r\n        if(!resRef){ continue; }\r\n        const nwscript = GameState.NWScript.Load(resRef);\r\n        if(!nwscript){ continue; }\r\n        nwscript.caller = this;\r\n        this.scripts[scriptKey] = nwscript;\r\n      }\r\n    }\r\n  }\r\n\r\n  initProperties(){\r\n    \r\n    if(!this.initialized){\r\n      if(this.template.RootNode.hasField('ObjectId')){\r\n        this.id = this.template.getFieldByLabel('ObjectId').getValue();\r\n      }else if(this.template.RootNode.hasField('ID')){\r\n        this.id = this.template.getFieldByLabel('ID').getValue();\r\n      }\r\n      \r\n      GameState.ModuleObjectManager.AddObjectById(this);\r\n    }\r\n\r\n    if(this.template.RootNode.hasField('AutoRemoveKey'))\r\n      this.autoRemoveKey = this.template.getFieldByLabel('AutoRemoveKey').getValue();\r\n\r\n    if(this.template.RootNode.hasField('Commandable'))\r\n      this.commandable = this.template.getFieldByLabel('Commandable').getValue();\r\n\r\n    if(this.template.RootNode.hasField('Cursor'))\r\n      this.cursor = this.template.getFieldByLabel('Cursor').getValue();\r\n\r\n    if(this.template.RootNode.hasField('Faction')){\r\n      this.factionId = this.template.getFieldByLabel('Faction').getValue();\r\n      if((this.factionId & 0xFFFFFFFF) == -1){\r\n        this.factionId = 0;\r\n      }\r\n    }\r\n    this.faction = GameState.FactionManager.factions.get(this.factionId);\r\n\r\n    if(this.template.RootNode.hasField('Geometry')){\r\n      this.geometry = this.template.getFieldByLabel('Geometry').getChildStructs();\r\n\r\n      //Push verticies\r\n      for(let i = 0; i < this.geometry.length; i++){\r\n        const tgv = this.geometry[i];\r\n        this.vertices[i] = new THREE.Vector3( \r\n          tgv.getFieldByLabel('PointX').getValue(),\r\n          tgv.getFieldByLabel('PointY').getValue(),\r\n          tgv.getFieldByLabel('PointZ').getValue()\r\n        );\r\n      }\r\n    }\r\n\r\n    if(this.template.RootNode.hasField('HighlightHeight'))\r\n      this.highlightHeight = this.template.getFieldByLabel('HighlightHeight').getValue();\r\n\r\n    if(this.template.RootNode.hasField('KeyName'))\r\n      this.keyName = this.template.getFieldByLabel('KeyName').getValue();\r\n\r\n    if(this.template.RootNode.hasField('LinkedTo'))\r\n      this.linkedTo = this.template.getFieldByLabel('LinkedTo').getValue();\r\n\r\n    if(this.template.RootNode.hasField('LinkedToFlags'))\r\n      this.linkedToFlags = this.template.getFieldByLabel('LinkedToFlags').getValue();\r\n  \r\n    if(this.template.RootNode.hasField('LinkedToModule'))\r\n      this.linkedToModule = this.template.RootNode.getFieldByLabel('LinkedToModule').getValue();\r\n        \r\n    if(this.template.RootNode.hasField('LoadScreenID'))\r\n      this.loadScreenID = this.template.getFieldByLabel('LoadScreenID').getValue();\r\n\r\n    if(this.template.RootNode.hasField('LocalizedName'))\r\n      this.localizedName = this.template.getFieldByLabel('LocalizedName').getCExoLocString();\r\n\r\n    if(this.template.RootNode.hasField('PortraidId')){\r\n      this.portraitId = this.template.getFieldByLabel('PortraidId').getValue();\r\n      this.portrait = GameState.SWRuleSet.portraits[this.portraitId];\r\n    }\r\n\r\n    if(this.template.RootNode.hasField('SetByPlayerParty'))\r\n      this.setByPlayerParty = this.template.getFieldByLabel('SetByPlayerParty').getValue();\r\n\r\n    if(this.setByPlayerParty){\r\n      this.trapFlag = this.setByPlayerParty;\r\n    }\r\n\r\n    if(this.template.RootNode.hasField('Tag'))\r\n      this.tag = this.template.getFieldByLabel('Tag').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TemplateResRef'))\r\n      this.templateResRef = this.template.getFieldByLabel('TemplateResRef').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TransitionDestin'))\r\n      this.transitionDestin = this.template.getFieldByLabel('TransitionDestin').getCExoLocString();\r\n\r\n    if(this.template.RootNode.hasField('TrapDetectable'))\r\n      this.trapDetectable = this.template.RootNode.getFieldByLabel('TrapDetectable').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapDisarmable'))\r\n      this.trapDisarmable = this.template.RootNode.getFieldByLabel('TrapDisarmable').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapOneShot'))\r\n      this.trapOneShot = this.template.getFieldByLabel('TrapOneShot').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapDetectDC'))\r\n      this.trapDetectDC = this.template.getFieldByLabel('TrapDetectDC').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapDisarmDC'))\r\n      this.trapDisarmDC = this.template.getFieldByLabel('TrapDisarmDC').getValue();\r\n\r\n    if(this.template.RootNode.hasField('CreatorId'))\r\n      this.creatorId = this.template.getFieldByLabel('CreatorId').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapFlag'))\r\n      this.trapFlag = this.template.getFieldByLabel('TrapFlag').getValue();\r\n\r\n    if(this.template.RootNode.hasField('TrapType'))\r\n      this.trapType = this.template.getFieldByLabel('TrapType').getValue();\r\n\r\n    if(this.template.RootNode.hasField('Type'))\r\n      this.type = this.template.getFieldByLabel('Type').getValue();\r\n\r\n    if(this.template.RootNode.hasField('XPosition'))\r\n      this.position.x = this.template.RootNode.getFieldByLabel('XPosition').getValue();\r\n\r\n    if(this.template.RootNode.hasField('YPosition'))\r\n      this.position.y = this.template.RootNode.getFieldByLabel('YPosition').getValue();\r\n\r\n    if(this.template.RootNode.hasField('ZPosition'))\r\n      this.position.z = this.template.RootNode.getFieldByLabel('ZPosition').getValue();\r\n\r\n    if(this.template.RootNode.hasField('XOrientation'))\r\n      this.xOrientation = this.template.RootNode.getFieldByLabel('XOrientation').getValue();\r\n\r\n    if(this.template.RootNode.hasField('YOrientation'))\r\n      this.yOrientation = this.template.RootNode.getFieldByLabel('YOrientation').getValue();\r\n\r\n    if(this.template.RootNode.hasField('ZOrientation'))\r\n      this.zOrientation = this.template.RootNode.getFieldByLabel('ZOrientation').getValue();\r\n\r\n    if(this.template.RootNode.hasField('SWVarTable')){\r\n      const localBools = this.template.RootNode.getFieldByLabel('SWVarTable').getChildStructs()[0].getFieldByLabel('BitArray').getChildStructs();\r\n      //log.info(localBools);\r\n      for(let i = 0; i < localBools.length; i++){\r\n        const data = localBools[i].getFieldByLabel('Variable').getValue();\r\n        for(let bit = 0; bit < 32; bit++){\r\n          this._locals.Booleans[bit + (i*32)] = ( (data>>bit) % 2 != 0);\r\n        }\r\n      }\r\n    }\r\n    \r\n    this.initialized = true;\r\n\r\n    if(this.type == ModuleTriggerType.TRAP){\r\n      const trap = GameState.TwoDAManager.datatables.get('traps')?.rows[this.trapType];\r\n      if(trap){\r\n        this.trapName = GameState.TLKManager.GetStringById(trap.name).Value;\r\n        this.trapModelResRef = trap.model;\r\n        this.trapExplosionSound = trap.explosionsound;\r\n        this.trapResRef = trap.resref;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  destroy(): void {\r\n    super.destroy();\r\n\r\n    if(this.trapModel){\r\n      this.trapModel.removeFromParent();\r\n      this.trapModel.dispose();\r\n    }\r\n\r\n    if(this.area) this.area.detachObject(this);\r\n  }\r\n\r\n  save(){\r\n    const gff = new GFFObject();\r\n    gff.FileType = 'UTT ';\r\n\r\n    const actionList = gff.RootNode.addField( this.actionQueueToActionList() );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'AutoRemoveKey') ).setValue(this.autoRemoveKey);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Commandable') ).setValue( this.commandable );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'CreatorId') ).setValue(this.creatorId ?? 0x7f000000);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Cursor') ).setValue(this.cursor);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'Faction') ).setValue(this.faction ? this.faction.id : this.factionId);\r\n\r\n    const geometry = gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'Geometry') );\r\n    for(let i = 0; i < this.vertices.length; i++){\r\n      const vertStruct = new GFFStruct();\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'PointX') ).setValue(this.vertices[i].x);\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'PointY') ).setValue(this.vertices[i].y);\r\n      vertStruct.addField( new GFFField(GFFDataType.FLOAT, 'PointZ') ).setValue(this.vertices[i].z);\r\n      geometry.addChildStruct(vertStruct);\r\n    }\r\n\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'HighlightHeight') ).setValue(this.highlightHeight);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'KeyName') ).setValue(this.keyName);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'LinkedTo') ).setValue(this.linkedTo);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'LinkedToFlags') ).setValue(this.linkedToFlags);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, 'LinkedToModule') ).setValue(this.linkedToModule);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.WORD, 'LoadscreenID') ).setValue(this.loadScreenID);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'LocName') ).setValue(this.locName);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.DWORD, 'ObjectId') ).setValue(this.id);\r\n\r\n    //Scripts\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnClick) ).setValue(this.scripts[ModuleObjectScript.TriggerOnClick]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnDisarm) ).setValue(this.scripts[ModuleObjectScript.TriggerOnDisarm]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnTrapTriggered) ).setValue(this.scripts[ModuleObjectScript.TriggerOnTrapTriggered]?.name || '');\r\n    \r\n    gff.RootNode.addField( new GFFField(GFFDataType.WORD, 'PortraitId') ).setValue(this.portraitId);\r\n\r\n    //SWVarTable\r\n    const swVarTable = gff.RootNode.addField( new GFFField(GFFDataType.STRUCT, 'SWVarTable') );\r\n    swVarTable.addChildStruct( this.getSWVarTableSaveStruct() );\r\n\r\n    //Scripts\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnHeartbeat) ).setValue(this.scripts[ModuleObjectScript.TriggerOnHeartbeat]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnEnter) ).setValue(this.scripts[ModuleObjectScript.TriggerOnEnter]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnExit) ).setValue(this.scripts[ModuleObjectScript.TriggerOnExit]?.name || '');\r\n    gff.RootNode.addField( new GFFField(GFFDataType.RESREF, ModuleObjectScript.TriggerOnUserDefined) ).setValue(this.scripts[ModuleObjectScript.TriggerOnUserDefined]?.name || '');\r\n\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'SetByPartyPlayer') ).setValue(this.setByPlayerParty);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOSTRING, 'Tag') ).setValue(this.tag);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.CEXOLOCSTRING, 'TransitionDestin') ).setValue(this.transitionDestin);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetectDC') ).setValue(this.trapDetectDC);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDetectable') ).setValue(this.trapDetectable);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDisarmDC') ).setValue(this.trapDisarmDC ?? 0);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapDisarmable') ).setValue(this.trapDisarmable);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapFlag') ).setValue(this.trapFlag);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapOneShot') ).setValue(this.trapOneShot);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'TrapType') ).setValue(this.trapType);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.BYTE, 'Type') ).setValue(this.type);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.LIST, 'VarTable') );\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'XOrientation') ).setValue(this.template.RootNode.getFieldByLabel('XOrientation').getValue());\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'XPosition') ).setValue(this.position.x);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'YOrientation') ).setValue(this.template.RootNode.getFieldByLabel('YOrientation').getValue());\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'YPosition') ).setValue(this.position.y);\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'ZOrientation') ).setValue(this.template.RootNode.getFieldByLabel('ZOrientation').getValue());\r\n    gff.RootNode.addField( new GFFField(GFFDataType.FLOAT, 'ZPosition') ).setValue(this.position.z);\r\n\r\n    this.template = gff;\r\n    return gff;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\NWScriptDefK1.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":1165,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":1165,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":4467,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":4467,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":4714,"column":7,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":4714,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":4714,"column":14,"nodeType":"MemberExpression","messageId":"errorCall","endLine":4714,"endColumn":65},{"ruleId":"no-duplicate-case","severity":2,"message":"Duplicate case label.","line":6164,"column":13,"nodeType":"SwitchCase","messageId":"unexpected","endLine":6164,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":6567,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":6567,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":8129,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":8129,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":8396,"column":9,"nodeType":"MemberExpression","messageId":"errorCall","endLine":8396,"endColumn":32}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { CombatRound } from \"@/combat/CombatRound\";\nimport type { GameEffect } from \"@/effects/GameEffect\";\nimport EngineLocation from \"@/engine/EngineLocation\";\nimport { Planetary } from \"@/engine/Planetary\";\nimport { VideoPlayer } from \"@/engine/VideoPlayer\";\nimport { ActionParameterType } from \"@/enums/actions/ActionParameterType\";\nimport { ActionType } from \"@/enums/actions/ActionType\";\nimport { AttackResult } from \"@/enums/combat/AttackResult\";\nimport { WeaponWield } from \"@/enums/combat/WeaponWield\";\nimport { GameEffectDurationType } from \"@/enums/effects/GameEffectDurationType\";\nimport { GameEffectType } from \"@/enums/effects/GameEffectType\";\nimport { EngineMode } from \"@/enums/engine/EngineMode\";\nimport { ExperienceType } from \"@/enums/engine/ExperienceType\";\nimport { PerceptionMask } from \"@/enums/engine/PerceptionMask\";\nimport { TalentObjectType } from \"@/enums/engine/TalentObjectType\";\nimport { TalkVolume } from \"@/enums/engine/TalkVolume\";\nimport { UIIconTimerType } from \"@/enums/engine/UIIconTimerType\";\nimport { ModuleCreatureArmorSlot } from \"@/enums/module/ModuleCreatureArmorSlot\";\nimport { ModuleObjectType } from \"@/enums/module/ModuleObjectType\";\nimport { ModuleTriggerType } from \"@/enums/module/ModuleTriggerType\";\nimport { CreatureClassType } from \"@/enums/nwscript/CreatureClassType\";\nimport { NWModuleObjectType } from \"@/enums/nwscript/NWModuleObjectType\";\nimport { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\nimport type { GameEvent } from \"@/events/GameEvent\";\nimport { GameState } from \"@/GameState\";\nimport type { INWScriptStoreState } from \"@/interface/nwscript/INWScriptStoreState\";\nimport { ResourceLoader } from \"@/loaders\";\nimport type { ModuleCreature, ModuleObject, ModuleArea, ModuleDoor, ModuleEncounter, ModuleItem, ModuleMGEnemy, ModuleMGObstacle, ModuleMGPlayer, ModulePlaceable, ModuleSound, ModuleStore, ModuleTrigger } from \"@/module\";\nimport { EventConversation, EventSpellCastAt, EventUserDefined, NWScriptEvent } from \"@/nwscript/events\";\nimport { NW_FALSE, NW_TRUE } from \"@/nwscript/NWScriptConstants\";\nimport { NWScriptDef } from \"@/nwscript/NWScriptDef\";\nimport type { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport { NWScriptSubroutine } from \"@/nwscript/NWScriptSubroutine\";\nimport type { OdysseyWalkMesh } from \"@/odyssey/OdysseyWalkMesh\";\nimport { DLGObject } from \"@/resource/DLGObject\";\nimport { GFFObject } from \"@/resource/GFFObject\";\nimport { ResourceTypes } from \"@/resource/ResourceTypes\";\nimport type { TalentObject } from \"@/talents/TalentObject\";\nimport type { OdysseyModel3D } from \"@/three/odyssey\";\nimport { BitWise } from \"@/utility/BitWise\";\nimport { Dice } from \"@/utility/Dice\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { Utility } from \"@/utility/Utility\";\n\n\n\n\nconst log = createScopedLogger(LogScope.NWScript);\n\n/**\n * NWScriptDefK1 class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file NWScriptDefK1.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class NWScriptDefK1 extends NWScriptDef { }\nNWScriptDefK1.Actions = {\n  0: {\n    comment: \"0: Get an integer between 0 and nMaxInteger-1.\\nReturn value on error: 0\\n\",\n    name: \"Random\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.round(Math.random() * (args[0] - 1));\n    }\n  },\n  1: {\n    comment: \"1: Output sString to the log file.\\n\",\n    name: \"PrintString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      // log.info('PrintString', args[0]);\n    }\n  },\n  2: {\n    comment: \"2: Output a formatted float to the log file.\\n- nWidth should be a value from 0 to 18 inclusive.\\n- nDecimals should be a value from 0 to 9 inclusive.\\n\",\n    name: \"PrintFloat\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const output = args[0].toFixed(args[2]);\n      // log.info(output);\n    }\n  },\n  3: {\n    comment: \"3: Convert fFloat into a string.\\n- nWidth should be a value from 0 to 18 inclusive.\\n- nDecimals should be a value from 0 to 9 inclusive.\\n\",\n    name: \"FloatToString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const output = ('0000000000000000000' + parseInt(args[0].toString())).substr(-args[1]) + (args[2] ? (((args[0] % 1) + '00000000000').substr(1, args[2])) : '');\n      return output;\n    }\n  },\n  4: {\n    comment: \"4: Output nInteger to the log file.\\n\",\n    name: \"PrintInteger\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      // log.info(args[0]);\n    }\n  },\n  5: {\n    comment: \"5: Output oObject's ID to the log file.\\n\",\n    name: \"PrintObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      // log.info(args[0]?.id);\n    }\n  },\n  6: {\n    comment: \"6: Assign aActionToAssign to oActionSubject.\\n* No return value, but if an error occurs, the log file will contain\\n'AssignCommand failed.'\\n(If the object doesn't exist, nothing happens.)\\n\",\n    name: \"AssignCommand\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.ACTION],\n    action: function (this: NWScriptInstance, args: [ModuleObject, INWScriptStoreState]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        if (typeof args[1] === 'object') {\n          args[1].script.caller = args[0];\n          args[1].script.seekTo(args[1].offset);\n          args[1].script.runScript();\n        } else {\n          log.error('AssignCommand', args);\n        }\n      } else {\n        log.error('AssignCommand', args);\n      }\n    }\n  },\n  7: {\n    comment: \"7: Delay aActionToDelay by fSeconds.\\n* No return value, but if an error occurs, the log file will contain\\n'DelayCommand failed.'.\\n\",\n    name: \"DelayCommand\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.ACTION],\n    action: function (this: NWScriptInstance, args: [number, INWScriptStoreState]) {\n\n      const futureTime = GameState.module.timeManager.getFutureTimeFromSeconds(args[0])\n      const timedEvent = new GameState.GameEventFactory.EventTimedEvent();\n      timedEvent.setCaller(this.caller);\n      timedEvent.setObject(this.caller);\n      timedEvent.setDay(futureTime.pauseDay);\n      timedEvent.setTime(futureTime.pauseTime);\n      timedEvent.setNWScript(args[1].script);\n      timedEvent.setInstructionPtr(args[1].offset);\n\n      if (this.subRoutine instanceof NWScriptSubroutine) {\n        this.delayCommands.push(timedEvent);\n      } else {\n        this.delayCommands.push(timedEvent);\n        //log.error('tried to call DelayCommand outside of a NWScript Subroutine');\n      }\n\n    }\n  },\n  8: {\n    comment: \"8: Make oTarget run sScript and then return execution to the calling script.\\nIf sScript does not specify a compiled script, nothing happens.\\n- nScriptVar: This value will be returned by calls to GetRunScriptVar.\\n\",\n    name: \"ExecuteScript\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, ModuleObject, number]) {\n      if (args[0]) {\n        const scriptInstance = GameState.NWScript.Load(args[0], undefined, this);\n        if (scriptInstance) {\n          this.executeScript(scriptInstance, this, args);\n        } else {\n          log.warn('NWScript.ExecuteScript failed to find', args[0]);\n        }\n      } else {\n        log.warn(`NWScript.ExecuteScript (${this.name}) failed because a script name wasn't supplied -> ${args[0]}`);\n      }\n    }\n  },\n  9: {\n    comment: \"9: Clear all the actions of the caller. (This will only work on Creatures)\\n* No return value, but if an error occurs, the log file will contain\\n'ClearAllActions failed.'.\\n\",\n    name: \"ClearAllActions\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))\n        this.caller.clearAllActions(true);\n    }\n  },\n  10: {\n    comment: \"10: Cause the caller to face fDirection.\\n- fDirection is expressed as anticlockwise degrees from Due East.\\nDIRECTION_EAST, DIRECTION_NORTH, DIRECTION_WEST and DIRECTION_SOUTH are\\npredefined. (0.0f=East, 90.0f=North, 180.0f=West, 270.0f=South)\\n\",\n    name: \"SetFacing\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      this.caller.setFacing(args[0]);\n    }\n  },\n  11: {\n    comment: \"11: Switches the main character to a specified NPC\\n-1 specifies to switch back to the original PC\\n\",\n    name: \"SwitchPlayerCharacter\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const creature = GameState.PartyManager.SwitchPlayerCharacter(args[0]);\n      if (creature) return true;\n      return false;\n    }\n  },\n  12: {\n    comment: \"12: Set the time to the time specified.\\n- nHour should be from 0 to 23 inclusive\\n- nMinute should be from 0 to 59 inclusive\\n- nSecond should be from 0 to 59 inclusive\\n- nMillisecond should be from 0 to 999 inclusive\\n1) Time can only be advanced forwards; attempting to set the time backwards\\nwill result in the day advancing and then the time being set to that\\nspecified, e.g. if the current hour is 15 and then the hour is set to 3,\\nthe day will be advanced by 1 and the hour will be set to 3.\\n2) If values larger than the max hour, minute, second or millisecond are\\nspecified, they will be wrapped around and the overflow will be used to\\nadvance the next field, e.g. specifying 62 hours, 250 minutes, 10 seconds\\nand 10 milliseconds will result in the calendar day being advanced by 2\\nand the time being set to 18 hours, 10 minutes, 10 milliseconds.\\n\",\n    name: \"SetTime\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number, number]) {\n      GameState.module.timeManager.setTime(args[0], args[1], args[2], args[3]);\n    }\n  },\n  13: {\n    comment: \"13: Sets (by NPC constant) which party member should be the controlled\\ncharacter\\n\",\n    name: \"SetPartyLeader\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const pm = GameState.PartyManager.GetPMByNPCId(args[0]);\n      if (!pm) { return NW_FALSE; }\n\n      return GameState.PartyManager.party.unshift(\n        GameState.PartyManager.party.splice(\n          GameState.PartyManager.party.indexOf(pm),\n          1\n        )[0]\n      ) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  14: {\n    comment: \"14: Sets whether the current area is escapable or not\\nTRUE means you can not escape the area\\nFALSE means you can escape the area\\n\",\n    name: \"SetAreaUnescapable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.module.area.unescapable = args[0] ? true : false;\n    }\n  },\n  15: {\n    comment: \"15: Returns whether the current area is escapable or not\\nTRUE means you can not escape the area\\nFALSE means you can escape the area\\n\",\n    name: \"GetAreaUnescapable\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.unescapable ? NW_TRUE : NW_FALSE;\n    }\n  },\n  16: {\n    comment: \"16: Get the current hour.\\n\",\n    name: \"GetTimeHour\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.timeManager.hour | 0;\n    }\n  },\n  17: {\n    comment: \"17: Get the current minute\\n\",\n    name: \"GetTimeMinute\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.timeManager.minute | 0;\n    }\n  },\n  18: {\n    comment: \"18: Get the current second\\n\",\n    name: \"GetTimeSecond\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.timeManager.second | 0;\n    }\n  },\n  19: {\n    comment: \"19: Get the current millisecond\\n\",\n    name: \"GetTimeMillisecond\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.timeManager.milisecond | 0;\n    }\n  },\n  20: {\n    comment: \"20: The action subject will generate a random location near its current location\\nand pathfind to it.  All commands will remove a RandomWalk() from the action\\nqueue if there is one in place.\\n* No return value, but if an error occurs the log file will contain\\n'ActionRandomWalk failed.'\\n\",\n    name: \"ActionRandomWalk\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        const action = new GameState.ActionFactory.ActionRandomWalk();\n        this.caller.actionQueue.add(action);\n      }\n    }\n  },\n  21: {\n    comment: \"21: The action subject will move to lDestination.\\n- lDestination: The object will move to this location.  If the location is\\ninvalid or a path cannot be found to it, the command does nothing.\\n- bRun: If this is TRUE, the action subject will run rather than walk\\n* No return value, but if an error occurs the log file will contain\\n'MoveToPoint failed.'\\n\",\n    name: \"ActionMoveToLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [EngineLocation, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        (this.caller as ModuleCreature).moveToLocation(args[0], !!args[1]);\n      }\n    }\n  },\n  22: {\n    comment: \"22: Cause the action subject to move to a certain distance from oMoveTo.\\nIf there is no path to oMoveTo, this command will do nothing.\\n- oMoveTo: This is the object we wish the action subject to move to\\n- bRun: If this is TRUE, the action subject will run rather than walk\\n- fRange: This is the desired distance between the action subject and oMoveTo\\n* No return value, but if an error occurs the log file will contain\\n'ActionMoveToObject failed.'\\n\",\n    name: \"ActionMoveToObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        (this.caller as ModuleCreature).moveToObject(args[0], !!args[1], args[2]);\n      }\n    }\n  },\n  23: {\n    comment: \"23: Cause the action subject to move to a certain distance away from oFleeFrom.\\n- oFleeFrom: This is the object we wish the action subject to move away from.\\nIf oFleeFrom is not in the same area as the action subject, nothing will\\nhappen.\\n- bRun: If this is TRUE, the action subject will run rather than walk\\n- fMoveAwayRange: This is the distance we wish the action subject to put\\nbetween themselves and oFleeFrom\\n* No return value, but if an error occurs the log file will contain\\n'ActionMoveAwayFromObject failed.'\\n\",\n    name: \"ActionMoveAwayFromObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n  },\n  24: {\n    comment: \"24: Get the area that oTarget is currently in\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetArea\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return GameState.module.area;\n    }\n  },\n  25: {\n    comment: \"25: The value returned by this function depends on the object type of the caller:\\n1) If the caller is a door or placeable it returns the object that last\\ntriggered it.\\n2) If the caller is a trigger, area of effect, module, area or encounter it\\nreturns the object that last entered it.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetEnteringObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.enteringObject;\n    }\n  },\n  26: {\n    comment: \"26: Get the object that last left the caller.  This function works on triggers,\\nareas of effect, modules, areas and encounters.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetExitingObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.exitingObject;\n    }\n  },\n  27: {\n    comment: \"27: Get the position of oTarget\\n* Return value on error: vector (0.0f, 0.0f, 0.0f)\\n\",\n    name: \"GetPosition\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].position.clone();\n      }\n      return { x: 0.0, y: 0.0, z: 0.0 };\n    }\n  },\n  28: {\n    comment: \"28: Get the direction in which oTarget is facing, expressed as a float between\\n0.0f and 360.0f\\n* Return value on error: -1.0f\\n\",\n    name: \"GetFacing\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].rotation.z;\n      } else {\n        return 0.0;\n      }\n    }\n  },\n  29: {\n    comment: \"29: Get the possessor of oItem\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetItemPossessor\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  30: {\n    comment: \"30: Get the object possessed by oCreature with the tag sItemTag\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetItemPossessedBy\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [ModuleObject, string]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getItemByTag(args[1]);\n      } else {\n        return undefined;\n      }\n    }\n  },\n  31: {\n    comment: \"31: Create an item with the template sItemTemplate in oTarget's inventory.\\n- nStackSize: This is the stack size of the item to be created\\n* Return value: The object that has been created.  On error, this returns\\nOBJECT_INVALID.\\n\",\n    name: \"CreateItemOnObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: async function (this: NWScriptInstance, args: [string, ModuleObject, number]) {\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes['uti'], args[0]);\n      if (buffer) {\n        const item = new GameState.Module.ModuleArea.ModuleItem(new GFFObject(buffer));\n        item.initProperties();\n        item.setStackSize(args[2]);\n        if (GameState.PartyManager.party.indexOf(args[1]) > -1) {\n          GameState.InventoryManager.addItem(item);\n        } else {\n          args[1].addItem(item);\n        }\n        return item;\n      }\n      return undefined;\n    }\n  },\n  32: {\n    comment: \"32: Equip oItem into nInventorySlot.\\n- nInventorySlot: INVENTORY_SLOT_*\\n* No return value, but if an error occurs the log file will contain\\n'ActionEquipItem failed.'\\n\",\n    name: \"ActionEquipItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      let slot = args[1];\n      const obj = this.caller as ModuleCreature;\n      switch (args[1]) {\n        case 0:\n          slot = ModuleCreatureArmorSlot.HEAD;\n          break;\n        case 1:\n          slot = ModuleCreatureArmorSlot.ARMOR;\n          break;\n        case 2:\n          slot = ModuleCreatureArmorSlot.ARMS;\n          break;\n        case 3:\n          slot = ModuleCreatureArmorSlot.RIGHTHAND;\n          break;\n        case 4:\n          slot = ModuleCreatureArmorSlot.LEFTHAND;\n          break;\n        case 5:\n          slot = ModuleCreatureArmorSlot.LEFTARMBAND;\n          break;\n        case 6:\n          slot = ModuleCreatureArmorSlot.RIGHTARMBAND;\n          break;\n        case 7:\n          slot = ModuleCreatureArmorSlot.IMPLANT;\n          break;\n        case 8:\n          slot = ModuleCreatureArmorSlot.BELT;\n          break;\n        case 9:\n          slot = ModuleCreatureArmorSlot.CLAW1;\n          break;\n        case 10:\n          slot = ModuleCreatureArmorSlot.CLAW2;\n          break;\n        case 14:\n          slot = ModuleCreatureArmorSlot.CLAW3;\n          break;\n        case 15:\n          slot = ModuleCreatureArmorSlot.HIDE;\n          break;\n        case 16:\n          slot = ModuleCreatureArmorSlot.HEAD;\n          break;\n        case 17:\n          slot = ModuleCreatureArmorSlot.ARMOR; //Creature Armor\n          break;\n      }\n      const action = new GameState.ActionFactory.ActionEquipItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      action.setParameter(1, ActionParameterType.INT, slot);\n      action.setParameter(2, ActionParameterType.INT, args[2] ? NW_TRUE : NW_FALSE);\n      obj.actionQueue.addFront(action);\n    }\n  },\n  33: {\n    comment: \"33: Unequip oItem from whatever slot it is currently in.\\n\",\n    name: \"ActionUnequipItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (typeof args[0] !== 'object') {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const obj = this.caller as ModuleCreature;\n\n      const action = new GameState.ActionFactory.ActionUnequipItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      action.setParameter(1, ActionParameterType.DWORD, undefined);\n      action.setParameter(2, ActionParameterType.INT, args[1] ? NW_TRUE : NW_FALSE);\n\n      obj.actionQueue.add(action);\n    }\n  },\n  34: {\n    comment: \"34: Pick up oItem from the ground.\\n* No return value, but if an error occurs the log file will contain\\n'ActionPickUpItem failed.'\\n\",\n    name: \"ActionPickUpItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (typeof args[0] !== 'object') {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const obj = this.caller as ModuleCreature;\n\n      const action = new GameState.ActionFactory.ActionPickUpItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n\n      obj.actionQueue.add(action);\n    }\n  },\n  35: {\n    comment: \"35: Put down oItem on the ground.\\n* No return value, but if an error occurs the log file will contain\\n'ActionPutDownItem failed.'\\n\",\n    name: \"ActionPutDownItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (typeof args[0] !== 'object') {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const obj = this.caller as ModuleCreature;\n\n      const action = new GameState.ActionFactory.ActionDropItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n\n      obj.actionQueue.add(action);\n    }\n  },\n  36: {\n    comment: \"36: Get the last attacker of oAttackee.  This should only be used ONLY in the\\nOnAttacked events for creatures, placeables and doors.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetLastAttacker\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].combatData.lastAttacker;\n      } else {\n        return undefined;\n      }\n    }\n  },\n  37: {\n    comment: \"37: Attack oAttackee.\\n- bPassive: If this is TRUE, attack is in passive mode.\\n\",\n    name: \"ActionAttack\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        this.caller.attackCreature(args[0]);\n      } else {\n        log.error('ActionAttack target undefined')\n      }\n    }\n  },\n  38: {\n    comment: \"38: Get the creature nearest to oTarget, subject to all the criteria specified.\\n- nFirstCriteriaType: CREATURE_TYPE_*\\n- nFirstCriteriaValue:\\n-> CLASS_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_CLASS\\n-> SPELL_* if nFirstCriteriaType was CREATURE_TYPE_DOES_NOT_HAVE_SPELL_EFFECT\\nor CREATURE_TYPE_HAS_SPELL_EFFECT\\n-> TRUE or FALSE if nFirstCriteriaType was CREATURE_TYPE_IS_ALIVE\\n-> PERCEPTION_* if nFirstCriteriaType was CREATURE_TYPE_PERCEPTION\\n-> PLAYER_CHAR_IS_PC or PLAYER_CHAR_NOT_PC if nFirstCriteriaType was\\nCREATURE_TYPE_PLAYER_CHAR\\n-> RACIAL_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_RACIAL_TYPE\\n-> REPUTATION_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_REPUTATION\\nFor example, to get the nearest PC, use:\\n(CREATURE_TYPE_PLAYER_CHAR, PLAYER_CHAR_IS_PC)\\n- oTarget: We're trying to find the creature of the specified type that is\\nnearest to oTarget\\n- nNth: We don't have to find the first nearest: we can find the Nth nearest...\\n- nSecondCriteriaType: This is used in the same way as nFirstCriteriaType to\\nfurther specify the type of creature that we are looking for.\\n- nSecondCriteriaValue: This is used in the same way as nFirstCriteriaValue\\nto further specify the type of creature that we are looking for.\\n- nThirdCriteriaType: This is used in the same way as nFirstCriteriaType to\\nfurther specify the type of creature that we are looking for.\\n- nThirdCriteriaValue: This is used in the same way as nFirstCriteriaValue to\\nfurther specify the type of creature that we are looking for.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNearestCreature\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, ModuleObject, number, number, number, number, number]) {\n      return GameState.ModuleObjectManager.GetNearestCreature(\n        args[0], args[1], args[2],\n        args[3], args[4], args[5], args[6],\n      );\n    }\n  },\n  39: {\n    comment: \"39: Add a speak action to the action subject.\\n- sStringToSpeak: String to be spoken\\n- nTalkVolume: TALKVOLUME_*\\n\",\n    name: \"ActionSpeakString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionSpeak();\n      action.setParameter(0, ActionParameterType.STRING, args[0]);\n      action.setParameter(1, ActionParameterType.INT, args[1]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  40: {\n    comment: \"40: Cause the action subject to play an animation\\n- nAnimation: ANIMATION_*\\n- fSpeed: Speed of the animation\\n- fDurationSeconds: Duration of the animation (this is not used for Fire and\\nForget animations) If a time of -1.0f is specified for a looping animation\\nit will loop until the next animation is applied.\\n\",\n    name: \"ActionPlayAnimation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionPlayAnimation();\n      action.setParameter(0, ActionParameterType.INT, this.caller.getAnimationNameById(args[0]));\n      action.setParameter(1, ActionParameterType.FLOAT, args[1] || 1.0);\n      action.setParameter(2, ActionParameterType.FLOAT, args[2]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  41: {\n    comment: \"41: Get the distance from the caller to oObject in metres.\\n* Return value on error: -1.0f\\n\",\n    name: \"GetDistanceToObject\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject) && BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return this.caller.position.distanceTo(args[0].position);\n      }\n      return -1.0;\n    }\n  },\n  42: {\n    comment: \"42: * Returns TRUE if oObject is a valid object.\\n\",\n    name: \"GetIsObjectValid\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  43: {\n    comment: \"43: Cause the action subject to open oDoor\\n\",\n    name: \"ActionOpenDoor\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionOpenDoor();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      action.setParameter(1, ActionParameterType.INT, 0);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  44: {\n    comment: \"44: Cause the action subject to close oDoor\\n\",\n    name: \"ActionCloseDoor\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionCloseDoor();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      action.setParameter(1, ActionParameterType.INT, 0);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  45: {\n    comment: \"45: Change the direction in which the camera is facing\\n- fDirection is expressed as anticlockwise degrees from Due East.\\n(0.0f=East, 90.0f=North, 180.0f=West, 270.0f=South)\\nThis can be used to change the way the camera is facing after the player\\nemerges from an area transition.\\n\",\n    name: \"SetCameraFacing\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT]\n  },\n  46: {\n    comment: \"46: Play sSoundName\\n- sSoundName: TBD - SS\\n\",\n    name: \"PlaySound\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      try {\n        const oSound = GameState.ModuleObjectManager.GetObjectByTag(args[0], 0, NWModuleObjectType.SOUND) as ModuleSound;\n        if (!oSound) { return; }\n        oSound.audioEmitter.playNextSound();\n      } catch (e) { log.error(e); }\n    }\n  },\n  47: {\n    comment: \"47: Get the object at which the caller last cast a spell\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetSpellTargetObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return this.caller.combatData.lastSpellTarget;\n      }\n    }\n  },\n  48: {\n    comment: \"48: This action casts a spell at oTarget.\\n- nSpell: SPELL_*\\n- oTarget: Target for the spell\\n- nMetamagic: METAMAGIC_*\\n- bCheat: If this is TRUE, then the executor of the action doesn't have to be\\nable to cast the spell.\\n- nDomainLevel: TBD - SS\\n- nProjectilePathType: PROJECTILE_PATH_TYPE_*\\n- bInstantSpell: If this is TRUE, the spell is cast immediately. This allows\\nthe end-user to simulate a high-level magic-user having lots of advance\\nwarning of impending trouble\\n\",\n    name: \"ActionCastSpellAtObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject, number, number, number, number, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionCastSpell();\n      action.setParameter(0, ActionParameterType.INT, args[0]); //Spell Id\n      action.setParameter(1, ActionParameterType.INT, -1);\n      action.setParameter(2, ActionParameterType.INT, args[4]); //DomainLevel\n      action.setParameter(3, ActionParameterType.INT, 0);\n      action.setParameter(4, ActionParameterType.INT, 0);\n      action.setParameter(5, ActionParameterType.DWORD, args[1].id); //Target Object\n      action.setParameter(6, ActionParameterType.FLOAT, args[1].position.x); //Target X\n      action.setParameter(7, ActionParameterType.FLOAT, args[1].position.y); //Target Y\n      action.setParameter(8, ActionParameterType.FLOAT, args[1].position.z); //Target Z\n      action.setParameter(9, ActionParameterType.INT, args[5]); //ProjectilePath\n      action.setParameter(10, ActionParameterType.INT, -1);\n      action.setParameter(11, ActionParameterType.INT, -1);\n      this.caller.actionQueue.add(action);\n\n    }\n  },\n  49: {\n    comment: \"49: Get the current hitpoints of oObject\\n* Return value on error: 0\\n\",\n    name: \"GetCurrentHitPoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return 0;\n      return args[0].getHP();\n    }\n  },\n  50: {\n    comment: \"50: Get the maximum hitpoints of oObject\\n* Return value on error: 0\\n\",\n    name: \"GetMaxHitPoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return 0;\n      return args[0].getMaxHP();\n    }\n  },\n  51: {\n    comment: \"51: EffectAssuredHit\\nCreate an Assured Hit effect, which guarantees that all attacks are successful\\n\",\n    name: \"EffectAssuredHit\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectAssuredHit();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  52: {\n    comment: \"52:\\nReturns the last item that was equipped by a creature.\\n\",\n    name: \"GetLastItemEquipped\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  53: {\n    comment: \"53:\\nReturns the ID of the subscreen that is currently onscreen.  This will be one of the\\nSUBSCREEN_ID_* constant values.\\n\",\n    name: \"GetSubScreenID\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n\n      //SUBSCREEN_ID_EQUIP = 1;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuEquipment).length) {\n        return 1;\n      }\n\n      //SUBSCREEN_ID_ITEM = 2;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuInventory).length) {\n        return 2;\n      }\n\n      //SUBSCREEN_ID_CHARACTER_RECORD = 3;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuCharacter).length) {\n        return 3;\n      }\n\n      //SUBSCREEN_ID_ABILITY = 4;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuAbilities).length) {\n        return 4;\n      }\n\n      //SUBSCREEN_ID_MAP = 5;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuMap).length) {\n        return 5;\n      }\n\n      //SUBSCREEN_ID_QUEST = 6;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuJournal).length) {\n        return 6;\n      }\n\n      //SUBSCREEN_ID_OPTIONS = 7;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuOptions).length) {\n        return 7;\n      }\n\n      //SUBSCREEN_ID_MESSAGES = 8;\n      if (GameState.MenuManager.activeMenus.filter((menu) => menu == GameState.MenuManager.MenuMessages).length) {\n        return 8;\n      }\n\n      //SUBSCREEN_ID_NONE = 0;\n      return 0;\n\n    }\n  },\n  54: {\n    comment: \"54:\\nCancels combat for the specified creature.\\n\",\n    name: \"CancelCombat\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if (GameState.PartyManager.party.indexOf(args[0] as ModuleCreature) >= 0) {\n          for (let i = 0, len = GameState.PartyManager.party.length; i < len; i++) {\n            GameState.PartyManager.party[i].cancelCombat();\n          }\n        } else {\n          (args[0] as ModuleCreature).cancelCombat();\n        }\n      }\n    }\n  },\n  55: {\n    comment: \"55:\\nreturns the current force points for the creature\\n\",\n    name: \"GetCurrentForcePoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return (args[0] as ModuleCreature).getFP()\n      }\n      return 0;\n    }\n  },\n  56: {\n    comment: \"56:\\nreturns the Max force points for the creature\\n\",\n    name: \"GetMaxForcePoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return (args[0] as ModuleCreature).getMaxFP()\n      }\n      return 0;\n    }\n  },\n  57: {\n    comment: \"57:\\nPauses the game if bPause is TRUE.  Unpauses if bPause is FALSE.\\n\",\n    name: \"PauseGame\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      if (args[0]) {\n        GameState.AutoPauseManager.SignalAutoPauseEvent(0);\n      } else {\n        GameState.AutoPauseManager.Unpause();\n      }\n    }\n  },\n  58: {\n    comment: \"58: SetPlayerRestrictMode\\nSets whether the player is currently in 'restricted' mode\\n\",\n    name: \"SetPlayerRestrictMode\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      if (BitWise.InstanceOfObject(GameState.module.area, ModuleObjectType.ModuleArea)) {\n        GameState.module.area.setRestrictMode(args[0]);\n      }\n    }\n  },\n  59: {\n    comment: \"59: Get the length of sString\\n* Return value on error: -1\\n\",\n    name: \"GetStringLength\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return args[0].length;\n    }\n  },\n  60: {\n    comment: \"60: Convert sString into upper case\\n* Return value on error: ''\\n\",\n    name: \"GetStringUpperCase\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return args[0].toUpperCase();\n    }\n  },\n  61: {\n    comment: \"61: Convert sString into lower case\\n* Return value on error: ''\\n\",\n    name: \"GetStringLowerCase\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return args[0].toLowerCase();\n    }\n  },\n  62: {\n    comment: \"62: Get nCount characters from the right end of sString\\n* Return value on error: ''\\n\",\n    name: \"GetStringRight\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      return args[0].substr(-args[1], args[1]);\n    }\n  },\n  63: {\n    comment: \"63: Get nCounter characters from the left end of sString\\n* Return value on error: ''\\n\",\n    name: \"GetStringLeft\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      return args[0].substr(0, args[1]);\n    }\n  },\n  64: {\n    comment: \"64: Insert sString into sDestination at nPosition\\n* Return value on error: ''\\n\",\n    name: \"InsertString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, string, number]) {\n      return [\n        args[0].slice(0, args[2]),\n        args[1],\n        args[0].slice(args[2])\n      ].join('');\n    }\n  },\n  65: {\n    comment: \"65: Get nCount characters from sString, starting at nStart\\n* Return value on error: ''\\n\",\n    name: \"GetSubString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number, number]) {\n      return args[0].substr(args[1], args[2]);\n    }\n  },\n  66: {\n    comment: \"66: Find the position of sSubstring inside sString\\n* Return value on error: -1\\n\",\n    name: \"FindSubString\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string, string]) {\n      return args[0].indexOf(\n        args[1]\n      );\n    }\n  },\n  67: {\n    comment: \"67: Maths operation: absolute value of fValue\\n\",\n    name: \"fabs\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.abs(args[0]);\n    }\n  },\n  68: {\n    comment: \"68: Maths operation: cosine of fValue\\n\",\n    name: \"cos\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.cos(args[0]);\n    }\n  },\n  69: {\n    comment: \"69: Maths operation: sine of fValue\\n\",\n    name: \"sin\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.sin(args[0]);\n    }\n  },\n  70: {\n    comment: \"70: Maths operation: tan of fValue\\n\",\n    name: \"tan\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.tan(args[0]);\n    }\n  },\n  71: {\n    comment: \"71: Maths operation: arccosine of fValue\\n* Returns zero if fValue > 1 or fValue < -1\\n\",\n    name: \"acos\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.acos(args[0]);\n    }\n  },\n  72: {\n    comment: \"72: Maths operation: arcsine of fValue\\n* Returns zero if fValue >1 or fValue < -1\\n\",\n    name: \"asin\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.asin(args[0]);\n    }\n  },\n  73: {\n    comment: \"73: Maths operation: arctan of fValue\\n\",\n    name: \"atan\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.atan(args[0]);\n    }\n  },\n  74: {\n    comment: \"74: Maths operation: log of fValue\\n* Returns zero if fValue <= zero\\n\",\n    name: \"log\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.log(args[0]);\n    }\n  },\n  75: {\n    comment: \"75: Maths operation: fValue is raised to the power of fExponent\\n* Returns zero if fValue ==0 and fExponent <0\\n\",\n    name: \"pow\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      return Math.pow(args[0], args[1]);\n    }\n  },\n  76: {\n    comment: \"76: Maths operation: square root of fValue\\n* Returns zero if fValue <0\\n\",\n    name: \"sqrt\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.sqrt(args[0]);\n    }\n  },\n  77: {\n    comment: \"77: Maths operation: integer absolute value of nValue\\n* Return value on error: 0\\n\",\n    name: \"abs\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.abs(args[0]);\n    }\n  },\n  78: {\n    comment: \"78: Create a Heal effect. This should be applied as an instantaneous effect.\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nDamageToHeal < 0.\\n\",\n    name: \"EffectHeal\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectHeal();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  79: {\n    comment: \"79: Create a Damage effect\\n- nDamageAmount: amount of damage to be dealt. This should be applied as an\\ninstantaneous effect.\\n- nDamageType: DAMAGE_TYPE_*\\n- nDamagePower: DAMAGE_POWER_*\\n\",\n    name: \"EffectDamage\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamage();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n\n      const damageTypeIndex = Math.log2(args[1]);\n      effect.setInt(damageTypeIndex, args[0]);\n\n      effect.setInt(14, args[0]);\n      effect.setInt(16, 1000);\n      effect.setInt(17, args[1]);\n      effect.setInt(18, args[2]);\n\n      return effect.initialize();\n    }\n  },\n  80: {\n    comment: \"80: Create an Ability Increase effect\\n- bAbilityToIncrease: ABILITY_*\\n\",\n    name: \"EffectAbilityIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectAbilityIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  81: {\n    comment: \"81: Create a Damage Resistance effect that removes the first nAmount points of\\ndamage of type nDamageType, up to nLimit (or infinite if nLimit is 0)\\n- nDamageType: DAMAGE_TYPE_*\\n- nAmount\\n- nLimit\\n\",\n    name: \"EffectDamageResistance\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageResistance();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      effect.setInt(2, args[2]);\n      return effect.initialize();\n    }\n  },\n  82: {\n    comment: \"82: Create a Resurrection effect. This should be applied as an instantaneous effect.\\n\",\n    name: \"EffectResurrection\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectResurrection();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  83: {\n    comment: \"83: GetPlayerRestrictMode\\nreturns the current player 'restricted' mode\\n\",\n    name: \"GetPlayerRestrictMode\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(GameState.module.area, ModuleObjectType.ModuleArea)) {\n        GameState.module.area.restrictMode ? NW_TRUE : NW_FALSE;\n      }\n      return 0;\n    }\n  },\n  84: {\n    comment: \"84: Get the Caster Level of oCreature.\\n* Return value on error: 0;\\n\",\n    name: \"GetCasterLevel\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  85: {\n    comment: \"85: Get the first in-game effect on oCreature.\\n\",\n    name: \"GetFirstEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        this.creatureEffectIndex.set(args[0].id, 0);\n        return args[0].effects[0];\n      } else {\n        return undefined;\n      }\n    }\n  },\n  86: {\n    comment: \"86: Get the next in-game effect on oCreature.\\n\",\n    name: \"GetNextEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const nextId = this.creatureEffectIndex.get(args[0].id) + 1;\n        this.creatureEffectIndex.set(args[0].id, nextId);\n        return args[0].effects[nextId];\n      } else {\n        return undefined;\n      }\n    }\n  },\n  87: {\n    comment: \"87: Remove eEffect from oCreature.\\n* No return value\\n\",\n    name: \"RemoveEffect\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, GameEffect]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature) && typeof args[1] === 'object') {\n        args[0].removeEffect(args[1]);\n      }\n    }\n  },\n  88: {\n    comment: \"88: * Returns TRUE if eEffect is a valid effect.\\n\",\n    name: \"GetIsEffectValid\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      return args[0] ? NW_TRUE : NW_FALSE;\n    }\n  },\n  89: {\n    comment: \"89: Get the duration type (DURATION_TYPE_*) of eEffect.\\n* Return value if eEffect is not valid: -1\\n\",\n    name: \"GetEffectDurationType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      if (args[0]) {\n        return args[0].getDurationType() & 7;\n      }\n      return -1;\n    }\n  },\n  90: {\n    comment: \"90: Get the subtype (SUBTYPE_*) of eEffect.\\n* Return value on error: 0\\n\",\n    name: \"GetEffectSubType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      if (args[0]) {\n        return args[0].getSubType() & 24;\n      }\n      return 0;\n    }\n  },\n  91: {\n    comment: \"91: Get the object that created eEffect.\\n* Returns OBJECT_INVALID if eEffect is not a valid effect.\\n\",\n    name: \"GetEffectCreator\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      if (args[0]) {\n        return args[0].creator;\n      }\n      return undefined;\n    }\n  },\n  92: {\n    comment: \"92: Convert nInteger into a string.\\n* Return value on error: ''\\n\",\n    name: \"IntToString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return String(Number(args[0]));\n    }\n  },\n  93: {\n    comment: \"93: Get the first object in oArea.\\nIf no valid area is specified, it will use the caller's area.\\n- oArea\\n- nObjectFilter: OBJECT_TYPE_*\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetFirstObjectInArea\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleArea, number]) {\n      return GameState.ModuleObjectManager.GetFirstObjectInArea(args[0], args[1]);\n    }\n  },\n  94: {\n    comment: \"94: Get the next object in oArea.\\nIf no valid area is specified, it will use the caller's area.\\n- oArea\\n- nObjectFilter: OBJECT_TYPE_*\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNextObjectInArea\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleArea, number]) {\n      return GameState.ModuleObjectManager.GetNextObjectInArea(args[0], args[1]);\n    }\n  },\n  95: {\n    comment: \"95: Get the total from rolling (nNumDice x d2 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d2\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD2(args[0] || 1);\n    }\n  },\n  96: {\n    comment: \"96: Get the total from rolling (nNumDice x d3 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d3\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD3(args[0] || 1);\n    }\n  },\n  97: {\n    comment: \"97: Get the total from rolling (nNumDice x d4 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d4\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD4(args[0] || 1);\n    }\n  },\n  98: {\n    comment: \"98: Get the total from rolling (nNumDice x d6 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d6\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD6(args[0] || 1);\n    }\n  },\n  99: {\n    comment: \"99: Get the total from rolling (nNumDice x d8 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d8\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD8(args[0] || 1);\n    }\n  },\n  100: {\n    comment: \"100: Get the total from rolling (nNumDice x d10 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d10\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD10(args[0] || 1);\n    }\n  },\n  101: {\n    comment: \"101: Get the total from rolling (nNumDice x d12 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d12\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD12(args[0] || 1);\n    }\n  },\n  102: {\n    comment: \"102: Get the total from rolling (nNumDice x d20 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d20\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD20(args[0] || 1);\n    }\n  },\n  103: {\n    comment: \"103: Get the total from rolling (nNumDice x d100 dice).\\n- nNumDice: If this is less than 1, the value 1 will be used.\\n\",\n    name: \"d100\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Dice.rollD100(args[0] || 1);\n    }\n  },\n  104: {\n    comment: \"104: Get the magnitude of vVector; this can be used to determine the\\ndistance between two points.\\n* Return value on error: 0.0f\\n\",\n    name: \"VectorMagnitude\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.VECTOR]\n  },\n  105: {\n    comment: \"105: Get the metamagic type (METAMAGIC_*) of the last spell cast by the caller\\n* Return value if the caster is not a valid object: -1\\n\",\n    name: \"GetMetaMagicFeat\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  106: {\n    comment: \"106: Get the object type (OBJECT_TYPE_*) of oTarget\\n* Return value if oTarget is not a valid object: -1\\n\",\n    name: \"GetObjectType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  107: {\n    comment: \"107: Get the racial type (RACIAL_TYPE_*) of oCreature\\n* Return value if oCreature is not a valid creature: RACIAL_TYPE_INVALID\\n\",\n    name: \"GetRacialType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (typeof args[0] === 'undefined')\n        return undefined;\n\n      return args[0].getRace();\n    }\n  },\n  108: {\n    comment: \"108: Do a Fortitude Save check for the given DC\\n- oCreature\\n- nDC: Difficulty check\\n- nSaveType: SAVING_THROW_TYPE_*\\n- oSaveVersus\\nReturns: 0 if the saving throw roll failed\\nReturns: 1 if the saving throw roll succeeded\\nReturns: 2 if the target was immune to the save type specified\\n\",\n    name: \"FortitudeSave\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        return args[0].fortitudeSave(args[1], args[2], args[3]);\n\n      return 0;\n    }\n  },\n  109: {\n    comment: \"109: Does a Reflex Save check for the given DC\\n- oCreature\\n- nDC: Difficulty check\\n- nSaveType: SAVING_THROW_TYPE_*\\n- oSaveVersus\\nReturns: 0 if the saving throw roll failed\\nReturns: 1 if the saving throw roll succeeded\\nReturns: 2 if the target was immune to the save type specified\\n\",\n    name: \"ReflexSave\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        return args[0].reflexSave(args[1], args[2], args[3]);\n\n      return 0;\n    }\n  },\n  110: {\n    comment: \"110: Does a Will Save check for the given DC\\n- oCreature\\n- nDC: Difficulty check\\n- nSaveType: SAVING_THROW_TYPE_*\\n- oSaveVersus\\nReturns: 0 if the saving throw roll failed\\nReturns: 1 if the saving throw roll succeeded\\nReturns: 2 if the target was immune to the save type specified\\n\",\n    name: \"WillSave\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        return args[0].willSave(args[1], args[2], args[3]);\n\n      return 0;\n    }\n  },\n  111: {\n    comment: \"111: Get the DC to save against for a spell (10 + spell level + relevant ability\\nbonus).  This can be called by a creature or by an Area of Effect object.\\n\",\n    name: \"GetSpellSaveDC\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        (this.caller as ModuleCreature).getSpellSaveDC();\n      }\n\n      return 10;\n    }\n  },\n  112: {\n    comment: \"112: Set the subtype of eEffect to Magical and return eEffect.\\n(Effects default to magical if the subtype is not set)\\n\",\n    name: \"MagicalEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT]\n  },\n  113: {\n    comment: \"113: Set the subtype of eEffect to Supernatural and return eEffect.\\n(Effects default to magical if the subtype is not set)\\n\",\n    name: \"SupernaturalEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT]\n  },\n  114: {\n    comment: \"114: Set the subtype of eEffect to Extraordinary and return eEffect.\\n(Effects default to magical if the subtype is not set)\\n\",\n    name: \"ExtraordinaryEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT]\n  },\n  115: {\n    comment: \"115: Create an AC Increase effect\\n- nValue: size of AC increase\\n- nModifyType: AC_*_BONUS\\n- nDamageType: DAMAGE_TYPE_*\\n* Default value for nDamageType should only ever be used in this function prototype.\\n\",\n    name: \"EffectACIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectACIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[1]);\n      effect.setInt(1, args[0]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      effect.setInt(5, args[2]);\n      return effect.initialize();\n    }\n  },\n  116: {\n    comment: \"116: If oObject is a creature, this will return that creature's armour class\\nIf oObject is an item, door or placeable, this will return zero.\\n- nForFutureUse: this parameter is not currently used\\n* Return value if oObject is not a creature, item, door or placeable: -1\\n\",\n    name: \"GetAC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature))\n        return args[0].getAC();\n\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable))\n        return 0;\n\n      return -1;\n    }\n  },\n  117: {\n    comment: \"117: Create an AC Decrease effect\\n- nSave: SAVING_THROW_* (not SAVING_THROW_TYPE_*)\\n- nValue: size of AC decrease\\n- nSaveType: SAVING_THROW_TYPE_*\\n\",\n    name: \"EffectSavingThrowIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectSavingThrowIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[1]);\n      effect.setInt(1, args[0]);\n      effect.setInt(2, args[2]);\n      effect.setInt(3, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  118: {\n    comment: \"118: Create an Attack Increase effect\\n- nBonus: size of attack bonus\\n- nModifierType: ATTACK_BONUS_*\\n\",\n    name: \"EffectAttackIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectAttackIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]); //nBonus\n      effect.setInt(1, args[1]); //nModifierType\n      return effect.initialize();\n    }\n  },\n  119: {\n    comment: \"119: Create a Damage Reduction effect\\n- nAmount: amount of damage reduction\\n- nDamagePower: DAMAGE_POWER_*\\n- nLimit: How much damage the effect can absorb before disappearing.\\nSet to zero for infinite\\n\",\n    name: \"EffectDamageReduction\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageReduction();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]); //nAmount\n      effect.setInt(1, args[1]); //nDamagePower\n      effect.setInt(2, args[2]); //nLimit\n      return effect.initialize();\n    }\n  },\n  120: {\n    comment: \"120: Create a Damage Increase effect\\n- nBonus: DAMAGE_BONUS_*\\n- nDamageType: DAMAGE_TYPE_*\\n\",\n    name: \"EffectDamageIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  121: {\n    comment: \"121: Convert nRounds into a number of seconds\\nA round is always 6.0 seconds\\n\", //This is actually 3.0 seconds in KotOR & TSL\n    name: \"RoundsToSeconds\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return (args[0] * 3.0);\n    }\n  },\n  122: {\n    comment: \"122: Convert nHours into a number of seconds\\nThe result will depend on how many minutes there are per hour (game-time)\\n\",\n    name: \"HoursToSeconds\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return (args[0] * 60.0);\n    }\n  },\n  123: {\n    comment: \"123: Convert nTurns into a number of seconds\\nA turn is always 60.0 seconds\\n\",\n    name: \"TurnsToSeconds\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return (args[0] * 3.0) * 10.0;\n    }\n  },\n  124: {\n    comment: \"124. SoundObjectSetFixedVariance\\nSets the constant variance at which to play the sound object\\nThis variance is a multiplier of the original sound\\n\",\n    name: \"SoundObjectSetFixedVariance\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).setFixedVariance(args[1]);\n      }\n    }\n  },\n  125: {\n    comment: \"125: Get an integer between 0 and 100 (inclusive) to represent oCreature's\\nGood/Evil alignment\\n(100=good, 0=evil)\\n* Return value if oCreature is not a valid creature: -1\\n\",\n    name: \"GetGoodEvilValue\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      if (typeof args[0] === 'undefined')\n        return -1;\n\n      return args[0].getGoodEvil();\n    }\n  },\n  126: {\n    comment: \"126: GetPartyMemberCount\\nReturns a count of how many members are in the party including the player character\\n\",\n    name: \"GetPartyMemberCount\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.PartyManager.party.length;\n    }\n  },\n  127: {\n    comment: \"127: Return an ALIGNMENT_* constant to represent oCreature's good/evil alignment\\n* Return value if oCreature is not a valid creature: -1\\n\",\n    name: \"GetAlignmentGoodEvil\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n\n      if (args[0].getGoodEvil() < 25) {\n        return 3;\n      } else if (args[0].getGoodEvil() < 75) {\n        return 0;\n      } else {\n        return 2;\n      }\n\n    }\n  },\n  128: {\n    comment: \"128: Get the first object in nShape\\n- nShape: SHAPE_*\\n- fSize:\\n-> If nShape == SHAPE_SPHERE, this is the radius of the sphere\\n-> If nShape == SHAPE_SPELLCYLINDER, this is the radius of the cylinder\\n-> If nShape == SHAPE_CONE, this is the widest radius of the cone\\n-> If nShape == SHAPE_CUBE, this is half the length of one of the sides of\\nthe cube\\n- lTarget: This is the centre of the effect, usually GetSpellTargetPosition(),\\nor the end of a cylinder or cone.\\n- bLineOfSight: This controls whether to do a line-of-sight check on the\\nobject returned.\\n(This can be used to ensure that spell effects do not go through walls.)\\n- nObjectFilter: This allows you to filter out undesired object types, using\\nbitwise 'or'.\\nFor example, to return only creatures and doors, the value for this\\nparameter would be ModuleObjectType.CREATURE | ModuleObjectType.DOOR\\n- vOrigin: This is only used for cylinders and cones, and specifies the\\norigin of the effect(normally the spell-caster's position).\\nReturn value on error: OBJECT_INVALID\\n\",\n    name: \"GetFirstObjectInShape\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [number, number, EngineLocation, number, number, THREE.Vector3]) {\n      this.objectInSphapeIndex.set(args[0], 0);\n      const ls = GameState.ModuleObjectManager.GetObjectsInShape(args[0], args[1], args[2], !!args[3], args[4], args[5], 0);\n      log.info('GetFirstObjectInShape', ls, args);\n      return ls;\n    }\n  },\n  129: {\n    comment: \"129: Get the next object in nShape\\n- nShape: SHAPE_*\\n- fSize:\\n-> If nShape == SHAPE_SPHERE, this is the radius of the sphere\\n-> If nShape == SHAPE_SPELLCYLINDER, this is the radius of the cylinder\\n-> If nShape == SHAPE_CONE, this is the widest radius of the cone\\n-> If nShape == SHAPE_CUBE, this is half the length of one of the sides of\\nthe cube\\n- lTarget: This is the centre of the effect, usually GetSpellTargetPosition(),\\nor the end of a cylinder or cone.\\n- bLineOfSight: This controls whether to do a line-of-sight check on the\\nobject returned. (This can be used to ensure that spell effects do not go\\nthrough walls.)\\n- nObjectFilter: This allows you to filter out undesired object types, using\\nbitwise 'or'. For example, to return only creatures and doors, the value for\\nthis parameter would be ModuleObjectType.CREATURE | ModuleObjectType.DOOR\\n- vOrigin: This is only used for cylinders and cones, and specifies the origin\\nof the effect (normally the spell-caster's position).\\nReturn value on error: OBJECT_INVALID\\n\",\n    name: \"GetNextObjectInShape\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [number, number, EngineLocation, number, number, THREE.Vector3]) {\n      const nextId = this.objectInSphapeIndex.get(args[0]) + 1;\n      this.objectInSphapeIndex.set(args[0], nextId);\n      const ls = GameState.ModuleObjectManager.GetObjectsInShape(args[0], args[1], args[2], !!args[3], args[4], args[5], nextId);\n      log.info('GetNextObjectInShape', ls, args, nextId);\n      return ls;\n    }\n  },\n  130: {\n    comment: \"130: Create an Entangle effect\\nWhen applied, this effect will restrict the creature's movement and apply a\\n(-2) to all attacks and a -4 to AC.\\n\",\n    name: \"EffectEntangle\",\n    type: NWScriptDataType.EFFECT,\n    args: []\n  },\n  131: {\n    comment: \"131: Cause oObject to run evToRun\\n\",\n    name: \"SignalEvent\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.EVENT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, GameEvent]) {\n      //This needs to happen once the script has completed\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) {\n        args[0] = GameState.module.area;\n      }\n\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        if (args[1] instanceof NWScriptEvent) {\n          args[0].scriptEventHandler(args[1]);\n        } else {\n          log.warn('SignalEvent', 'Invalid event argument', args);\n        }\n      } else {\n        log.info('SignalEvent', 'ObjectType Mismatch', args, this, this.caller);\n      }\n    }\n  },\n  132: {\n    comment: \"132: Create an event of the type nUserDefinedEventNumber\\n\",\n    name: \"EventUserDefined\",\n    type: NWScriptDataType.EVENT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const event = new EventUserDefined();\n      event.setInt(0, args[0]);\n      return event;\n    }\n  },\n  133: {\n    comment: \"133: Create a Death effect\\n- nSpectacularDeath: if this is TRUE, the creature to which this effect is\\napplied will die in an extraordinary fashion\\n- nDisplayFeedback\\n\",\n    name: \"EffectDeath\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDeath();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  134: {\n    comment: \"134: Create a Knockdown effect\\nThis effect knocks creatures off their feet, they will sit until the effect\\nis removed. This should be applied as a temporary effect with a 3 second\\nduration minimum (1 second to fall, 1 second sitting, 1 second to get up).\\n\",\n    name: \"EffectKnockdown\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectKnockdown();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  135: {\n    comment: \"135: Give oItem to oGiveTo\\nIf oItem is not a valid item, or oGiveTo is not a valid object, nothing will\\nhappen.\\n\",\n    name: \"ActionGiveItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionGiveItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0].id); //oItem\n      action.setParameter(1, ActionParameterType.DWORD, args[1].id); //oGiveTo\n      this.caller.actionQueue.add(action);\n    }\n  },\n  136: {\n    comment: \"136: Take oItem from oTakeFrom\\nIf oItem is not a valid item, or oTakeFrom is not a valid object, nothing\\nwill happen.\\n\",\n    name: \"ActionTakeItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return;\n      }\n\n      if (!BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionTakeItem();\n      action.setParameter(0, ActionParameterType.DWORD, args[0].id); //oItem\n      action.setParameter(1, ActionParameterType.DWORD, args[1].id); //oTakeFrom\n      this.caller.actionQueue.add(action);\n    }\n  },\n  137: {\n    comment: \"137: Normalize vVector\\n\",\n    name: \"VectorNormalize\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3]) {\n      return new THREE.Vector3(args[0].x, args[0].y, args[0].z).normalize();\n    }\n  },\n  138: {\n    comment: \"138:\\nGets the stack size of an item.\\n\",\n    name: \"GetItemStackSize\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        const obj = args[0] as ModuleItem;\n        return obj.getStackSize();\n      }\n\n      return 0;\n    }\n  },\n  139: {\n    comment: \"139: Get the ability score of type nAbility for a creature (otherwise 0)\\n- oCreature: the creature whose ability score we wish to find out\\n- nAbilityType: ABILITY_*\\nReturn value on error: 0\\n\",\n    name: \"GetAbilityScore\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  140: {\n    comment: \"140: * Returns TRUE if oCreature is a dead NPC, dead PC or a dying PC.\\n\",\n    name: \"GetIsDead\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].isDead() ? NW_TRUE : NW_FALSE;\n      } else {\n        return 1;\n      }\n    }\n  },\n  141: {\n    comment: \"141: Output vVector to the logfile.\\n- vVector\\n- bPrepend: if this is TRUE, the message will be prefixed with 'PRINTVECTOR:'\\n\",\n    name: \"PrintVector\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR, NWScriptDataType.INTEGER]\n  },\n  142: {\n    comment: \"142: Create a vector with the specified values for x, y and z\\n\",\n    name: \"Vector\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      return { x: args[0], y: args[1], z: args[2] };\n    }\n  },\n  143: {\n    comment: \"143: Cause the caller to face vTarget\\n\",\n    name: \"SetFacingPoint\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        this.caller.FacePoint(args[0]);\n      }\n    }\n  },\n  144: {\n    comment: \"144: Convert fAngle to a vector\\n\",\n    name: \"AngleToVector\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.FLOAT]\n  },\n  145: {\n    comment: \"145: Convert vVector to an angle\\n\",\n    name: \"VectorToAngle\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.VECTOR]\n  },\n  146: {\n    comment: \"146: The caller will perform a Melee Touch Attack on oTarget\\nThis is not an action, and it assumes the caller is already within range of\\noTarget\\n* Returns 0 on a miss, 1 on a hit and 2 on a critical hit\\n\",\n    name: \"TouchAttackMelee\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  147: {\n    comment: \"147: The caller will perform a Ranged Touch Attack on oTarget\\n* Returns 0 on a miss, 1 on a hit and 2 on a critical hit\\n\",\n    name: \"TouchAttackRanged\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  148: {\n    comment: \"148: Create a Paralyze effect\\n\",\n    name: \"EffectParalyze\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 5); // Sleep State\n      return effect.initialize();\n    }\n  },\n  149: {\n    comment: \"149: Create a Spell Immunity effect.\\nThere is a known bug with this function. There *must* be a parameter specified\\nwhen this is called (even if the desired parameter is SPELL_ALL_SPELLS),\\notherwise an effect of type EFFECT_TYPE_INVALIDEFFECT will be returned.\\n- nImmunityToSpell: SPELL_*\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nImmunityToSpell is\\ninvalid.\\n\",\n    name: \"EffectSpellImmunity\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectSpellImmunity();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  150: {\n    comment: \"150:\\nSet the stack size of an item.\\nNOTE: The stack size will be clamped to between 1 and the max stack size (as\\nspecified in the base item).\\n\",\n    name: \"SetItemStackSize\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        const obj = args[0] as ModuleItem;\n        obj.setStackSize(args[1] || 1);\n      }\n    }\n  },\n  151: {\n    comment: \"151: Get the distance in metres between oObjectA and oObjectB.\\n* Return value if either object is invalid: 0.0f\\n\",\n    name: \"GetDistanceBetween\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject) && BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        return args[0].position.distanceTo(args[1].position);\n      } else {\n        return 0.00;\n      }\n    }\n  },\n  152: {\n    comment: \"152: SetReturnStrref\\nThis function will turn on/off the display of the 'return to ebon hawk' option\\non the map screen and allow the string to be changed to an arbitrary string ref\\nsrReturnQueryStrRef is the string ref that will be displayed in the query pop\\nup confirming that you wish to return to the specified location.\\n\",\n    name: \"SetReturnStrref\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      GameState.module.setReturnStrRef(!!args[0], args[1], args[2]);\n    }\n  },\n  153: {\n    comment: \"153: EffectForceJump\\nThe effect required for force jumping\\n\",\n    name: \"EffectForceJump\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const effect = new GameState.GameEffectFactory.EffectForceJump();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[1]);\n      effect.setObject(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  154: {\n    comment: \"154: Create a Sleep effect\\n\",\n    name: \"EffectSleep\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 6); // Sleep State\n      return effect.initialize();\n    }\n  },\n  155: {\n    comment: \"155: Get the object which is in oCreature's specified inventory slot\\n- nInventorySlot: INVENTORY_SLOT_*\\n- oCreature\\n* Returns OBJECT_INVALID if oCreature is not a valid creature or there is no\\nitem in nInventorySlot.\\n\",\n    name: \"GetItemInSlot\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        const obj = args[1] as ModuleCreature;\n        switch (args[0]) {\n          case 0:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.HEAD);\n          case 1:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.ARMOR);\n          case 3:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.ARMS);\n          case 4:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.RIGHTHAND);\n          case 5:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.LEFTHAND);\n          case 7:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.LEFTARMBAND);\n          case 8:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.RIGHTARMBAND);\n          case 9:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.IMPLANT);\n          case 10:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.BELT);\n          case 14:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.CLAW1);\n          case 15:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.CLAW2);\n          case 16:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.CLAW2);\n          case 17:\n            return obj.getItemInSlot(ModuleCreatureArmorSlot.HIDE);\n        }\n      }\n\n      return undefined;\n\n    }\n  },\n  156: {\n    comment: \"156: This was previously EffectCharmed();\\n\",\n    name: \"EffectTemporaryForcePoints\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      if (args[0] < 0) return undefined;\n      const effect = new GameState.GameEffectFactory.EffectTemporaryForce();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  157: {\n    comment: \"157: Create a Confuse effect\\n\",\n    name: \"EffectConfused\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 1); // Confused State\n      return effect.initialize();\n    }\n  },\n  158: {\n    comment: \"158: Create a Frighten effect\\n\",\n    name: \"EffectFrightened\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 2); // Frightened State\n      return effect.initialize();\n    }\n  },\n  159: {\n    comment: \"159: Choke the bugger...\\n\",\n    name: \"EffectChoke\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 7); // Choke State\n      return effect.initialize();\n    }\n  },\n  160: {\n    comment: \"160: Sets a global string with the specified identifier.  This is an EXTREMELY\\nrestricted function - do not use without expilicit permission.\\nThis means if you are not Preston.  Then go see him if you're even thinking\\nabout using this.\\n\",\n    name: \"SetGlobalString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string, string]) {\n      GameState.GlobalVariableManager.SetGlobalString(args[0], args[1]);\n    }\n  },\n  161: {\n    comment: \"161: Create a Stun effect\\n\",\n    name: \"EffectStunned\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 4); // Stunned State\n      return effect.initialize();\n    }\n  },\n  162: {\n    comment: \"162: Set whether oTarget's action stack can be modified\\n\",\n    name: \"SetCommandable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        args[1].setCommadable(\n          args[0]\n        );\n      }\n    }\n  },\n  163: {\n    comment: \"163: Determine whether oTarget's action stack can be modified.\\n\",\n    name: \"GetCommandable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const obj = args[0] as ModuleCreature;\n        return obj.getCommadable() ? NW_TRUE : NW_FALSE;\n      }\n      return 0;\n    }\n  },\n  164: {\n    comment: \"164: Create a Regenerate effect.\\n- nAmount: amount of damage to be regenerated per time interval\\n- fIntervalSeconds: length of interval in seconds\\n\",\n    name: \"EffectRegenerate\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectRegenerate();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, Math.floor(args[1] * 1000));\n      return effect.initialize();\n    }\n  },\n  165: {\n    comment: \"165: Create a Movement Speed Increase effect.\\n- nNewSpeedPercent: This works in a dodgy way so please read this notes carefully.\\nIf you supply an integer under 100, 100 gets added to it to produce the final speed.\\ne.g. if you supply 50, then the resulting speed is 150% of the original speed.\\nIf you supply 100 or above, then this is used directly as the resulting speed.\\ne.g. if you specify 100, then the resulting speed is 100% of the original speed that is,\\nit is unchanged.\\nHowever if you specify 200, then the resulting speed is double the original speed.\\n\",\n    name: \"EffectMovementSpeedIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectMovementSpeedIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  166: {\n    comment: \"166: Get the number of hitdice for oCreature.\\n* Return value if oCreature is not a valid creature: 0\\n\",\n    name: \"GetHitDice\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const obj = args[0] as ModuleCreature;\n        return obj.getTotalClassLevel();\n      }\n\n      return 0;\n    }\n  },\n  167: {\n    comment: \"167: The action subject will follow oFollow until a ClearAllActions() is called.\\n- oFollow: this is the object to be followed\\n- fFollowDistance: follow distance in metres\\n* No return value\\n\",\n    name: \"ActionForceFollowObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionForceFollowObject();\n      action.setParameter(0, ActionParameterType.DWORD, args[0].id); //oFollow\n      action.setParameter(1, ActionParameterType.FLOAT, args[1]); //fFollowDistance\n      this.caller.actionQueue.add(action);\n    }\n  },\n  168: {\n    comment: \"168: Get the Tag of oObject\\n* Return value if oObject is not a valid object: ''\\n\",\n    name: \"GetTag\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getTag();\n      } else {\n        return '';\n      }\n    }\n  },\n  169: {\n    comment: \"169: Do a Force Resistance check between oSource and oTarget, returning TRUE if\\nthe force was resisted.\\n* Return value if oSource or oTarget is an invalid object: FALSE\\n\",\n    name: \"ResistForce\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      return args[1].resistForce(args[0]);\n    }\n  },\n  170: {\n    comment: \"170: Get the effect type (EFFECT_TYPE_*) of eEffect.\\n* Return value if eEffect is invalid: EFFECT_INVALIDEFFECT\\n\",\n    name: \"GetEffectType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      if (typeof args[0] != 'undefined') {\n        return args[0].type || GameEffectType.EffectInvalidEffect;\n      } else {\n        return GameEffectType.EffectInvalidEffect;\n      }\n    }\n  },\n  171: {\n    comment: \"171: Create an Area Of Effect effect in the area of the creature it is applied to.\\nIf the scripts are not specified, default ones will be used.\\n\",\n    name: \"EffectAreaOfEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [number, string, string, string]) {\n      const effect = new GameState.GameEffectFactory.EffectAreaOfEffect();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setString(0, args[1]);\n      effect.setString(1, args[2]);\n      effect.setString(2, args[3]);\n      return effect.initialize();\n    }\n  },\n  172: {\n    comment: \"172: * Returns TRUE if the Faction Ids of the two objects are the same\\n\",\n    name: \"GetFactionEqual\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature) && BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return args[0].faction == args[1].faction;\n      }\n      return false;\n    }\n  },\n  173: {\n    comment: \"173: Make oObjectToChangeFaction join the faction of oMemberOfFactionToJoin.\\nNB. ** This will only work for two NPCs **\\n\",\n    name: \"ChangeFaction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature) && BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        args[0].faction = args[1].faction;\n        GameState.FactionManager.AddCreatureToFaction(args[0]);\n      }\n    }\n  },\n  174: {\n    comment: \"174: * Returns TRUE if oObject is listening for something\\n\",\n    name: \"GetIsListening\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return args[0].getIsListening();\n    }\n  },\n  175: {\n    comment: \"175: Set whether oObject is listening.\\n\",\n    name: \"SetListening\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        args[0].setListening(args[1] ? true : false);\n      } else {\n        log.info('SetListening', this.name, this.caller, args[0], args[1]);\n      }\n    }\n  },\n  176: {\n    comment: \"176: Set the string for oObject to listen for.\\nNote: this does not set oObject to be listening.\\n\",\n    name: \"SetListenPattern\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, string, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        args[0].setListeningPattern(args[1], args[2]);\n      } else {\n        log.info('SetListenPattern', this.name, this.caller, args[0], args[1], args[2]);\n      }\n    }\n  },\n  177: {\n    comment: \"177: * Returns TRUE if sStringToTest matches sPattern.\\n\",\n    name: \"TestStringAgainstPattern\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING, NWScriptDataType.STRING]\n  },\n  178: {\n    comment: \"178: Get the appropriate matched string (this should only be used in\\nOnConversation scripts).\\n* Returns the appropriate matched string, otherwise returns ''\\n\",\n    name: \"GetMatchedSubstring\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.INTEGER]\n  },\n  179: {\n    comment: \"179: Get the number of string parameters available.\\n* Returns -1 if no string matched (this could be because of a dialogue event)\\n\",\n    name: \"GetMatchedSubstringsCount\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  180: {\n    comment: \"180: * Create a Visual Effect that can be applied to an object.\\n- nVisualEffectId\\n- nMissEffect: if this is TRUE, a random vector near or past the target will\\nbe generated, on which to play the effect\\n\",\n    name: \"EffectVisualEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectVisualEffect();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(2, args[1] ? NW_TRUE : NW_FALSE);\n      return effect.initialize();\n    }\n  },\n  181: {\n    comment: \"181: Get the weakest member of oFactionMember's faction.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionWeakestMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getWeakestMember(!!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  182: {\n    comment: \"182: Get the strongest member of oFactionMember's faction.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionStrongestMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getStrongestMember(!!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  183: {\n    comment: \"183: Get the member of oFactionMember's faction that has taken the most hit points\\nof damage.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionMostDamagedMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getMostDamagedMember(!!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  184: {\n    comment: \"184: Get the member of oFactionMember's faction that has taken the fewest hit\\npoints of damage.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionLeastDamagedMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getLeastDamagedMember(!!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  185: {\n    comment: \"185: Get the amount of gold held by oFactionMember's faction.\\n* Returns -1 if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionGold\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getMemberGold();\n        }\n      }\n\n      return -1;\n    }\n  },\n  186: {\n    comment: \"186: Get an integer between 0 and 100 (inclusive) that represents how\\noSourceFactionMember's faction feels about oTarget.\\n* Return value on error: -1\\n\",\n    name: \"GetFactionAverageReputation\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getAverageReputation(args[1]);\n        }\n      }\n\n      return -1;\n    }\n  },\n  187: {\n    comment: \"187: Get an integer between 0 and 100 (inclusive) that represents the average\\ngood/evil alignment of oFactionMember's faction.\\n* Return value on error: -1\\n\",\n    name: \"GetFactionAverageGoodEvilAlignment\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getAverageGoodEvilAlignment();\n        }\n      }\n\n      return -1;\n    }\n  },\n  188: {\n    comment: \"188. SoundObjectGetFixedVariance\\nGets the constant variance at which to play the sound object\\n\",\n    name: \"SoundObjectGetFixedVariance\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        return (args[0] as ModuleSound).fixedVariance;\n      }\n      return 0;\n    }\n  },\n  189: {\n    comment: \"189: Get the average level of the members of the faction.\\n* Return value on error: -1\\n\",\n    name: \"GetFactionAverageLevel\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getAverageLevel();\n        }\n      }\n\n      return -1;\n    }\n  },\n  190: {\n    comment: \"190: Get the average XP of the members of the faction.\\n* Return value on error: -1\\n\",\n    name: \"GetFactionAverageXP\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getAverageExperience();\n        }\n      }\n\n      return -1;\n    }\n  },\n  191: {\n    comment: \"191: Get the most frequent class in the faction - this can be compared with the\\nconstants CLASS_TYPE_*.\\n* Return value on error: -1\\n\",\n    name: \"GetFactionMostFrequentClass\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getMostFrequestClass();\n        }\n      }\n\n      return -1;\n    }\n  },\n  192: {\n    comment: \"192: Get the object faction member with the lowest armour class.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionWorstAC\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getWorstACMember(!!args[1]);\n        }\n      }\n\n      return undefined;\n    }\n  },\n  193: {\n    comment: \"193: Get the object faction member with the highest armour class.\\n* Returns OBJECT_INVALID if oFactionMember's faction is invalid.\\n\",\n    name: \"GetFactionBestAC\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          return faction.getBestACMember(!!args[1]);\n        }\n      }\n\n      return undefined;\n    }\n  },\n  194: {\n    comment: \"194: Get a global string with the specified identifier\\nThis is an EXTREMELY restricted function.  Use only with explicit permission.\\nThis means if you are not Preston.  Then go see him if you're even thinking\\nabout using this.\\n\",\n    name: \"GetGlobalString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.GlobalVariableManager.GetGlobalString(args[0]);\n    }\n  },\n  195: {\n    comment: \"195: In an onConversation script this gets the number of the string pattern\\nmatched (the one that triggered the script).\\n* Returns -1 if no string matched\\n\",\n    name: \"GetListenPatternNumber\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.listenPatternNumber;\n    }\n  },\n  196: {\n    comment: \"196: Jump to an object ID, or as near to it as possible.\\n\",\n    name: \"ActionJumpToObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      log.info('ActionJumpToObject')\n      if (!(BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))) return;\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return;\n\n      const action = new GameState.ActionFactory.ActionJumpToObject();\n      action.setParameter(0, ActionParameterType.DWORD, args[0].id);\n      action.setParameter(1, ActionParameterType.INT, 0);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  197: {\n    comment: \"197: Get the first waypoint with the specified tag.\\n* Returns OBJECT_INVALID if the waypoint cannot be found.\\n\",\n    name: \"GetWaypointByTag\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.ModuleObjectManager.GetObjectByTag(args[0], 0, NWModuleObjectType.WAYPOINT);\n    }\n  },\n  198: {\n    comment: \"198: Get the destination (a waypoint or a door) for a trigger or a door.\\n* Returns OBJECT_INVALID if oTransition is not a valid trigger or door.\\n\",\n    name: \"GetTransitionTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  199: {\n    comment: \"199: Link the two supplied effects, returning eChildEffect as a child of\\neParentEffect.\\nNote: When applying linked effects if the target is immune to all valid\\neffects all other effects will be removed as well. This means that if you\\napply a visual effect and a silence effect (in a link) and the target is\\nimmune to the silence effect that the visual effect will get removed as well.\\nVisual Effects are not considered 'valid' effects for the purposes of\\ndetermining if an effect will be removed or not and as such should never be\\npackaged *only* with other visual effects in a link.\\n\",\n    name: \"EffectLinkEffects\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT, NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect, GameEffect]) {\n      const effect = new GameState.GameEffectFactory.EffectLink(args[0], args[1]);\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  200: {\n    comment: \"200: Get the nNth object with the specified tag.\\n- sTag\\n- nNth: the nth object with this tag may be requested\\n* Returns OBJECT_INVALID if the object cannot be found.\\n\",\n    name: \"GetObjectByTag\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      return GameState.ModuleObjectManager.GetObjectByTag(args[0], args[1]);\n    }\n  },\n  201: {\n    comment: \"201: Adjust the alignment of oSubject.\\n- oSubject\\n- nAlignment:\\n-> ALIGNMENT_LIGHT_SIDE/ALIGNMENT_DARK_SIDE: oSubject's\\nalignment will be shifted in the direction specified\\n-> ALIGNMENT_NEUTRAL: nShift is applied to oSubject's dark side/light side\\nalignment value in the direction which is towards neutrality.\\ne.g. If oSubject has an alignment value of 80 (i.e. light side)\\nthen if nShift is 15, the alignment value will become (80-15)=65\\nFurthermore, the shift will at most take the alignment value to 50 and\\nnot beyond.\\ne.g. If oSubject has an alignment value of 40 then if nShift is 15,\\nthe aligment value will become 50\\n- nShift: this is the desired shift in alignment\\n* No return value\\n\",\n    name: \"AdjustAlignment\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleCreature, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        args[0].adjustAlignment(args[2], args[1]);\n      }\n    }\n  },\n  202: {\n    comment: \"202: Do nothing for fSeconds seconds.\\n\",\n    name: \"ActionWait\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionWait();\n      action.setParameter(0, ActionParameterType.FLOAT, args[0]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  203: {\n    comment: \"203: Set the transition bitmap of a player; this should only be called in area\\ntransition scripts. This action should be run by the person 'clicking' the\\narea transition via AssignCommand.\\n- nPredefinedAreaTransition:\\n-> To use a predefined area transition bitmap, use one of AREA_TRANSITION_*\\n-> To use a custom, user-defined area transition bitmap, use\\nAREA_TRANSITION_USER_DEFINED and specify the filename in the second\\nparameter\\n- sCustomAreaTransitionBMP: this is the filename of a custom, user-defined\\narea transition bitmap\\n\",\n    name: \"SetAreaTransitionBMP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING]\n  },\n  204: {\n    comment: \"AMF: APRIL 28, 2003 - I HAVE CHANGED THIS FUNCTION AS PER DAN'S REQUEST\\n204: Starts a conversation with oObjectToConverseWith - this will cause their\\nOnDialog event to fire.\\n- oObjectToConverseWith\\n- sDialogResRef: If this is blank, the creature's own dialogue file will be used\\n- bPrivateConversation: If this is blank, the default is FALSE.\\n- nConversationType - If this is blank the default will be Cinematic, ie. a normal conversation type\\nother choices inclue: CONVERSATION_TYPE_COMPUTER\\nUPDATE:  nConversationType actually has no meaning anymore.  This has been replaced by a flag in the dialog editor.  However\\nfor backwards compatability it has been left here.  So when using this command place CONVERSATION_TYPE_CINEMATIC in here. - DJF\\n- bIgnoreStartRange - If this is blank the default will be FALSE, ie. Start conversation ranges are in effect\\nSetting this to TRUE will cause creatures to start a conversation without requiring to close\\nthe distance between the two object in dialog.\\n- sNameObjectToIgnore1-6 - Normally objects in the animation list of the dialog editor have to be available for animations on that node to work\\nthese 6 strings are to indicate 6 objects that dont need to be available for things to proceed.  The string should be EXACTLY\\nthe same as the string that it represents in the dialog editor.\\n\",\n    name: \"ActionStartConversation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [ModuleObject, string, number, number, number, string, string, string, string, string, string]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        //I'm hardcoding ignoreStartRange to true because i'm finding instances where it's causing the player to move halfway across the map to start a conversation\n        //even in ones that have nothing to do with the PC. Perhaps it was always meant to work this way?\n        this.caller.actionDialogObject(args[0], args[1], true, args[2], args[3]);\n      } else {\n        log.error('ActionStartConversation', 'Caller is not an instance of ModuleObject');\n      }\n    }\n  },\n  205: {\n    comment: \"205: Pause the current conversation.\\n\",\n    name: \"ActionPauseConversation\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        this.caller.actionQueue.add(new GameState.ActionFactory.ActionPauseDialog());\n      }\n      log.info('script', this.name, 'PauseConversation', this.caller);\n    }\n  },\n  206: {\n    comment: \"206: Resume a conversation after it has been paused.\\n\",\n    name: \"ActionResumeConversation\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        this.caller.actionQueue.add(new GameState.ActionFactory.ActionResumeDialog());\n      }\n      log.info('script', this.name, 'ResumeConversation', this.caller);\n    }\n  },\n  207: {\n    comment: \"207: Create a Beam effect.\\n- nBeamVisualEffect: VFX_BEAM_*\\n- oEffector: the beam is emitted from this creature\\n- nBodyPart: BODY_NODE_*\\n- bMissEffect: If this is TRUE, the beam will fire to a random vector near or\\npast the target\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nBeamVisualEffect is\\nnot valid.\\n\",\n    name: \"EffectBeam\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectBeam();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[2]);\n      effect.setInt(2, args[3]);\n      effect.setObject(0, args[1]);\n      return effect.initialize();\n    }\n  },\n  208: {\n    comment: \"208: Get an integer between 0 and 100 (inclusive) that represents how oSource\\nfeels about oTarget.\\n-> 0-10 means oSource is hostile to oTarget\\n-> 11-89 means oSource is neutral to oTarget\\n-> 90-100 means oSource is friendly to oTarget\\n* Returns -1 if oSource or oTarget does not identify a valid object\\n\",\n    name: \"GetReputation\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature) && BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return GameState.FactionManager.GetReputation(args[0], args[1]);\n      }\n      return -1;\n    }\n  },\n  209: {\n    comment: \"209: Adjust how oSourceFactionMember's faction feels about oTarget by the\\nspecified amount.\\nNote: This adjusts Faction Reputation, how the entire faction that\\noSourceFactionMember is in, feels about oTarget.\\n* No return value\\n\",\n    name: \"AdjustReputation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject, number]) {\n      GameState.FactionManager.AdjustFactionReputation(args[0], args[1], args[2]);\n    }\n  },\n  210: {\n    comment: \"210: Gets the actual file name of the current module\\n\",\n    name: \"GetModuleFileName\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.filename;\n    }\n  },\n  211: {\n    comment: \"211: Get the creature that is going to attack oTarget.\\nNote: This value is cleared out at the end of every combat round and should\\nnot be used in any case except when getting a 'going to be attacked' shout\\nfrom the master creature (and this creature is a henchman)\\n* Returns OBJECT_INVALID if oTarget is not a valid creature.\\n\",\n    name: \"GetGoingToBeAttackedBy\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  212: {\n    comment: \"212: Create a Force Resistance Increase effect.\\n- nValue: size of Force Resistance increase\\n\",\n    name: \"EffectForceResistanceIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectForceResistanceIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  213: {\n    comment: \"213: Get the location of oObject.\\n\",\n    name: \"GetLocation\",\n    type: NWScriptDataType.LOCATION,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getLocation();\n      }\n      return new EngineLocation();\n    }\n  },\n  214: {\n    comment: \"214: The subject will jump to lLocation instantly (even between areas).\\nIf lLocation is invalid, nothing will happen.\\n\",\n    name: \"ActionJumpToLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation]) {\n      log.info('ActionJumpToLocation', args, this.caller);\n      if (!(BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))) return;\n\n      if (!(args[0] instanceof EngineLocation)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionJumpToPoint();\n      action.setParameter(0, ActionParameterType.FLOAT, args[0].position.x);\n      action.setParameter(1, ActionParameterType.FLOAT, args[0].position.y);\n      action.setParameter(2, ActionParameterType.FLOAT, args[0].position.z);\n      action.setParameter(3, ActionParameterType.DWORD, args[0].area.id);\n      action.setParameter(4, ActionParameterType.INT, 0);\n      action.setParameter(5, ActionParameterType.FLOAT, 20.0);\n      action.setParameter(6, ActionParameterType.FLOAT, args[0].rotation.x);\n      action.setParameter(7, ActionParameterType.FLOAT, args[0].rotation.y);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  215: {\n    comment: \"215: Create a location.\\n\",\n    name: \"Location\",\n    type: NWScriptDataType.LOCATION,\n    args: [NWScriptDataType.VECTOR, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3, number]) {\n      const location = new EngineLocation(\n        args[0].x, args[0].y, args[0].z\n      );\n      location.setBearing(args[1]);\n      return location;\n    }\n  },\n  216: {\n    comment: \"216: Apply eEffect at lLocation.\\n\",\n    name: \"ApplyEffectAtLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.EFFECT, NWScriptDataType.LOCATION, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, GameEffect, EngineLocation, number]) {\n      args[1].setDurationType(args[0]);\n      args[1].setDuration(args[3]);\n      GameState.module.addEffect(args[1], args[2]);\n    }\n  },\n  217: {\n    comment: \"217: * Returns TRUE if oCreature is a Player Controlled character.\\n\",\n    name: \"GetIsPC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return (GameState.PartyManager.party.indexOf(args[0]) >= 0 || GameState.PartyManager.Player == args[0]) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  218: {\n    comment: \"218: Convert fFeet into a number of meters.\\n\",\n    name: \"FeetToMeters\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return args[0] * 0.3048;\n    }\n  },\n  219: {\n    comment: \"219: Convert fYards into a number of meters.\\n\",\n    name: \"YardsToMeters\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return args[0] * 0.9144;\n    }\n  },\n  220: {\n    comment: \"220: Apply eEffect to oTarget.\\n\",\n    name: \"ApplyEffectToObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.EFFECT, NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, GameEffect, ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[2], ModuleObjectType.ModuleObject)) {\n        if (args[1]) {\n          args[1].setDurationType(args[0]);\n          args[1].setDuration(args[3]);\n          if (args[0] == GameEffectDurationType.TEMPORARY) {\n            const future = GameState.module.timeManager.getFutureTimeFromSeconds(args[3]);\n            args[1].setExpireDay(future.pauseDay);\n            args[1].setExpireTime(future.pauseTime);\n          }\n          // log.info('ApplyEffectToObject', args[2], args[1], args[0], args[3]);\n          args[2].addEffect(args[1], args[0], args[3]);\n        } else {\n          log.error('ApplyEffectToObject', 'Expected a GameEffect', args);\n        }\n      } else {\n        log.error('ApplyEffectToObject', 'GameEffects must be applied to ModuleObjects');\n      }\n    }\n  },\n  221: {\n    comment: \"221: The caller will immediately speak sStringToSpeak (this is different from\\nActionSpeakString)\\n- sStringToSpeak\\n- nTalkVolume: TALKVOLUME_*\\n\",\n    name: \"SpeakString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      this.caller.speakString(args[0], args[1]);\n    }\n  },\n  222: {\n    comment: \"222: Get the location of the caller's last spell target.\\n\",\n    name: \"GetSpellTargetLocation\",\n    type: NWScriptDataType.LOCATION,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.talent, TalentObjectType.TalentObject) && BitWise.InstanceOfObject(this.talent.oTarget, ModuleObjectType.ModuleObject)) {\n        this.talent.oTarget.getLocation();\n      }\n      return new EngineLocation();\n    }\n  },\n  223: {\n    comment: \"223: Get the position vector from lLocation.\\n\",\n    name: \"GetPositionFromLocation\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation]) {\n      if (args[0]) {\n        return args[0].position.clone();\n      }\n      return new THREE.Vector3();\n    }\n  },\n  224: {\n    comment: \"224: the effect of body fule.. convers HP -> FP i think\\n\",\n    name: \"EffectBodyFuel\",\n    type: NWScriptDataType.EFFECT,\n    args: []\n  },\n  225: {\n    comment: \"225: Get the orientation value from lLocation.\\n\",\n    name: \"GetFacingFromLocation\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation]) {\n      if (location instanceof EngineLocation) {\n        return location.getFacing();\n      }\n      return 0;\n    }\n  },\n  226: {\n    comment: \"226: Get the creature nearest to lLocation, subject to all the criteria specified.\\n- nFirstCriteriaType: CREATURE_TYPE_*\\n- nFirstCriteriaValue:\\n-> CLASS_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_CLASS\\n-> SPELL_* if nFirstCriteriaType was CREATURE_TYPE_DOES_NOT_HAVE_SPELL_EFFECT\\nor CREATURE_TYPE_HAS_SPELL_EFFECT\\n-> TRUE or FALSE if nFirstCriteriaType was CREATURE_TYPE_IS_ALIVE\\n-> PERCEPTION_* if nFirstCriteriaType was CREATURE_TYPE_PERCEPTION\\n-> PLAYER_CHAR_IS_PC or PLAYER_CHAR_NOT_PC if nFirstCriteriaType was\\nCREATURE_TYPE_PLAYER_CHAR\\n-> RACIAL_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_RACIAL_TYPE\\n-> REPUTATION_TYPE_* if nFirstCriteriaType was CREATURE_TYPE_REPUTATION\\nFor example, to get the nearest PC, use\\n(CREATURE_TYPE_PLAYER_CHAR, PLAYER_CHAR_IS_PC)\\n- lLocation: We're trying to find the creature of the specified type that is\\nnearest to lLocation\\n- nNth: We don't have to find the first nearest: we can find the Nth nearest....\\n- nSecondCriteriaType: This is used in the same way as nFirstCriteriaType to\\nfurther specify the type of creature that we are looking for.\\n- nSecondCriteriaValue: This is used in the same way as nFirstCriteriaValue\\nto further specify the type of creature that we are looking for.\\n- nThirdCriteriaType: This is used in the same way as nFirstCriteriaType to\\nfurther specify the type of creature that we are looking for.\\n- nThirdCriteriaValue: This is used in the same way as nFirstCriteriaValue to\\nfurther specify the type of creature that we are looking for.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNearestCreatureToLocation\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  227: {\n    comment: \"227: Get the Nth object nearest to oTarget that is of the specified type.\\n- nObjectType: OBJECT_TYPE_*\\n- oTarget\\n- nNth\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNearestObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject, number]) {\n      return GameState.ModuleObjectManager.GetNearestObject(args[0], args[1], args[2] - 1);\n    }\n  },\n  228: {\n    comment: \"228: Get the nNth object nearest to lLocation that is of the specified type.\\n- nObjectType: OBJECT_TYPE_*\\n- lLocation\\n- nNth\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNearestObjectToLocation\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER]\n  },\n  229: {\n    comment: \"229: Get the nth Object nearest to oTarget that has sTag as its tag.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetNearestObjectByTag\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, ModuleObject, number]) {\n      return GameState.ModuleObjectManager.GetNearestObjectByTag(args[0], args[1], args[2] - 1);\n    }\n  },\n  230: {\n    comment: \"230: Convert nInteger into a floating point number.\\n\",\n    name: \"IntToFloat\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Number(args[0]);\n    }\n  },\n  231: {\n    comment: \"231: Convert fFloat into the nearest integer.\\n\",\n    name: \"FloatToInt\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Math.round(Number(args[0]));\n    }\n  },\n  232: {\n    comment: \"232: Convert sNumber into an integer.\\n\",\n    name: \"StringToInt\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return parseInt(args[0]);\n    }\n  },\n  233: {\n    comment: \"233: Convert sNumber into a floating point number.\\n\",\n    name: \"StringToFloat\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return parseFloat(args[0]);\n    }\n  },\n  234: {\n    comment: \"234: Cast spell nSpell at lTargetLocation.\\n- nSpell: SPELL_*\\n- lTargetLocation\\n- nMetaMagic: METAMAGIC_*\\n- bCheat: If this is TRUE, then the executor of the action doesn't have to be\\nable to cast the spell.\\n- nProjectilePathType: PROJECTILE_PATH_TYPE_*\\n- bInstantSpell: If this is TRUE, the spell is cast immediately; this allows\\nthe end-user to simulate\\na high-level magic user having lots of advance warning of impending trouble.\\n\",\n    name: \"ActionCastSpellAtLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject, number, number, number, number, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionCastSpell();\n      action.setParameter(0, ActionParameterType.INT, args[0]); //Spell Id\n      action.setParameter(1, ActionParameterType.INT, -1);\n      action.setParameter(2, ActionParameterType.INT, args[4]); //DomainLevel\n      action.setParameter(3, ActionParameterType.INT, 0);\n      action.setParameter(4, ActionParameterType.INT, 0);\n      action.setParameter(5, ActionParameterType.DWORD, -1); //Target Object\n      action.setParameter(6, ActionParameterType.FLOAT, args[1].position.x); //Target X\n      action.setParameter(7, ActionParameterType.FLOAT, args[1].position.y); //Target Y\n      action.setParameter(8, ActionParameterType.FLOAT, args[1].position.z); //Target Z\n      action.setParameter(9, ActionParameterType.INT, args[5]); //ProjectilePath\n      action.setParameter(10, ActionParameterType.INT, -1);\n      action.setParameter(11, ActionParameterType.INT, -1);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  235: {\n    comment: \"235: * Returns TRUE if oSource considers oTarget as an enemy.\\n\",\n    name: \"GetIsEnemy\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[1].isHostile(args[0]) ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  236: {\n    comment: \"236: * Returns TRUE if oSource considers oTarget as a friend.\\n\",\n    name: \"GetIsFriend\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if ((GameState.PartyManager.party.indexOf(args[0]) >= 0 ? NW_TRUE : NW_FALSE) && (GameState.PartyManager.party.indexOf(args[1]) >= 0 ? NW_TRUE : NW_FALSE)) {\n          return NW_TRUE;\n        }\n        return args[1].isFriendly(args[0]) ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  237: {\n    comment: \"237: * Returns TRUE if oSource considers oTarget as neutral.\\n\",\n    name: \"GetIsNeutral\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if ((GameState.PartyManager.party.indexOf(args[0]) >= 0 ? NW_TRUE : NW_FALSE) && (GameState.PartyManager.party.indexOf(args[1]) >= 0 ? NW_TRUE : NW_FALSE)) {\n          return NW_TRUE;\n        }\n        return args[1].isFriendly(args[0]) || args[1].isNeutral(args[0]) ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  238: {\n    comment: \"238: Get the PC that is involved in the conversation.\\n* Returns OBJECT_INVALID on error.\\n\",\n    name: \"GetPCSpeaker\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.PartyManager.party[0];\n    }\n  },\n  239: {\n    comment: \"239: Get a string from the talk table using nStrRef.\\n\",\n    name: \"GetStringByStrRef\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return GameState.TLKManager.GetStringById(args[0]).Value;\n    }\n  },\n  240: {\n    comment: \"240: Causes the creature to speak a translated string.\\n- nStrRef: Reference of the string in the talk table\\n- nTalkVolume: TALKVOLUME_*\\n\",\n    name: \"ActionSpeakStringByStrRef\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionSpeakStrRef();\n      action.setParameter(0, ActionParameterType.INT, args[0]); //Spell Id\n      action.setParameter(1, ActionParameterType.INT, args[1]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  241: {\n    comment: \"241: Destroy oObject (irrevocably).\\nThis will not work on modules and areas.\\nThe bNoFade and fDelayUntilFade are for creatures and placeables only\\n\",\n    name: \"DestroyObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        args[0].destroy();\n    }\n  },\n  242: {\n    comment: \"242: Get the module.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetModule\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module;\n    }\n  },\n  243: {\n    comment: \"243: Create an object of the specified type at lLocation.\\n- nObjectType: ModuleObjectType.ITEM, ModuleObjectType.CREATURE, ModuleObjectType.PLACEABLE,\\nModuleObjectType.STORE\\n- sTemplate\\n- lLocation\\n- bUseAppearAnimation\\nWaypoints can now also be created using the CreateObject function.\\nnObjectType is: ModuleObjectType.WAYPOINT\\nsTemplate will be the tag of the waypoint\\nlLocation is where the waypoint will be placed\\nbUseAppearAnimation is ignored\\n\",\n    name: \"CreateObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, string, EngineLocation, number]) {\n      let buffer: Uint8Array;\n      switch (args[0]) {\n        case 1:\n          buffer = ResourceLoader.loadCachedResource(ResourceTypes['utc'], args[1]);\n          if (buffer) {\n            const creature = new GameState.Module.ModuleArea.ModuleCreature(new GFFObject(buffer));\n            creature.load();\n            creature.clearAllActions();\n            creature.position.copy(args[2].position);\n            creature.setFacing(args[2].getFacing(), true);\n            args[2].area.attachObject(creature);\n\n            creature.loadModel().then((model: OdysseyModel3D) => {\n              model.userData.moduleObject = creature;\n              model.hasCollision = true;\n              model.name = creature.getTag();\n              GameState.group.creatures.add(creature.container);\n              creature.getCurrentRoom();\n              creature.onSpawn();\n            });\n            return creature;\n          } else {\n            log.error('Failed to load character template', args);\n            return undefined;\n          }\n          break;\n        case 64: //Placeable\n          buffer = ResourceLoader.loadCachedResource(ResourceTypes['utp'], args[1]);\n          if (buffer) {\n            const plc = new GameState.Module.ModuleArea.ModulePlaceable(new GFFObject(buffer));\n            plc.load();\n            plc.position.copy(args[2].position);\n            plc.rotation.set(0, 0, args[2].getFacing());\n\n            plc.loadModel().then((model: OdysseyModel3D) => {\n              plc.loadWalkmesh(model.name).then((pwk: OdysseyWalkMesh) => {\n                plc.model.userData.moduleObject = plc;\n\n                model.hasCollision = true;\n                model.name = plc.getTag();\n                GameState.group.placeables.add(model);\n                args[2].area.attachObject(plc);\n\n                try {\n                  if (pwk.mesh instanceof THREE.Object3D)\n                    model.add(pwk.mesh);\n\n                  model.userData.walkmesh = pwk;\n                  GameState.walkmeshList.push(pwk.mesh);\n                } catch (e) {\n                  log.error('Failed to add pwk', model.name, pwk);\n                }\n\n                plc.getCurrentRoom();\n                plc.onSpawn();\n\n              });\n            });\n\n            return plc;\n          } else {\n            log.error('Failed to load character template', args);\n            return undefined;\n          }\n          break;\n      }\n      return undefined;\n    }\n  },\n  244: {\n    comment: \"244: Create an event which triggers the 'SpellCastAt' script\\n\",\n    name: \"EventSpellCastAt\",\n    type: NWScriptDataType.EVENT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const event = new EventSpellCastAt();\n      event.setObject(0, args[0]);\n      event.setInt(0, args[1]);\n      event.setInt(1, args[2]);\n\n      return event;\n    }\n  },\n  245: {\n    comment: \"245: This is for use in a 'Spell Cast' script, it gets who cast the spell.\\nThe spell could have been cast by a creature, placeable or door.\\n* Returns OBJECT_INVALID if the caller is not a creature, placeable or door.\\n\",\n    name: \"GetLastSpellCaster\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.lastSpellAttacker;\n    }\n  },\n  246: {\n    comment: \"246: This is for use in a 'Spell Cast' script, it gets the ID of the spell that\\nwas cast.\\n\",\n    name: \"GetLastSpell\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.lastSpell?.id ? this.lastSpell.id : 0;\n    }\n  },\n  247: {\n    comment: \"247: This is for use in a user-defined script, it gets the event number.\\n\",\n    name: \"GetUserDefinedEventNumber\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.scriptVar;\n    }\n  },\n  248: {\n    comment: \"248: This is for use in a Spell script, it gets the ID of the spell that is being\\ncast (SPELL_*).\\n\",\n    name: \"GetSpellId\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.getSpellId();\n    }\n  },\n  249: {\n    comment: \"249: Generate a random name.\\n\",\n    name: \"RandomName\",\n    type: NWScriptDataType.STRING,\n    args: []\n  },\n  250: {\n    comment: \"250: Create a Poison effect.\\n- nPoisonType: POISON_*\\n\",\n    name: \"EffectPoison\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectPoison();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  251: {\n    comment: \"251: Returns whether this script is being run\\nwhile a load game is in progress\\n\",\n    name: \"GetLoadFromSaveGame\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.isLoadingSave ? NW_TRUE : NW_FALSE\n    }\n  },\n  252: {\n    comment: \"252: Assured Deflection\\nThis effect ensures that all projectiles shot at a jedi will be deflected\\nwithout doing an opposed roll.  It takes an optional parameter to say whether\\nthe deflected projectile will return to the attacker and cause damage\\n\",\n    name: \"EffectAssuredDeflection\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectAssuredDeflection();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  253: {\n    comment: \"253: Get the name of oObject.\\n\",\n    name: \"GetName\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getName();\n      } else {\n        return '';\n      }\n    }\n  },\n  254: {\n    comment: \"254: Use this in a conversation script to get the person with whom you are conversing.\\n* Returns OBJECT_INVALID if the caller is not a valid creature.\\n\",\n    name: \"GetLastSpeaker\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.listenPatternSpeaker;\n    }\n  },\n  255: {\n    comment: \"255: Use this in an OnDialog script to start up the dialog tree.\\n- sResRef: if this is not specified, the default dialog file will be used\\n- oObjectToDialog: if this is not specified the person that triggered the\\nevent will be used\\n\",\n    name: \"BeginConversation\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [string, ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject))) {\n        args[1] = this.listenPatternSpeaker;\n      }\n\n      if (!BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        log.warn('BeginConversation', 'args[1] is not an instanceof ModuleObject');\n        return NW_FALSE;\n      }\n\n      if (args[0] != '') {\n        const dlg = DLGObject.FromResRef(args[0]);\n        if (!dlg) { return NW_FALSE; }\n        GameState.CutsceneManager.startConversation(dlg, this.caller, args[1]);\n        return NW_TRUE;\n      } else if (this.conversation) {\n        GameState.CutsceneManager.startConversation(this.conversation, this.caller, args[1]);\n        return NW_TRUE;\n      } else if (this.caller.conversation) {\n        GameState.CutsceneManager.startConversation(this.caller.conversation, this.caller, args[1]);\n        return NW_TRUE;\n      } else if (this.listenPatternSpeaker.conversation) {\n        GameState.CutsceneManager.startConversation(this.listenPatternSpeaker.conversation, this.caller, this.listenPatternSpeaker);\n        return NW_TRUE;\n      } else {\n        log.warn('BeginConversation', 'no dialog condition met');\n        return NW_FALSE;\n      }\n    }\n  },\n  256: {\n    comment: \"256: Use this in an OnPerception script to get the object that was perceived.\\n* Returns OBJECT_INVALID if the caller is not a valid creature.\\n\",\n    name: \"GetLastPerceived\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.lastPerceived.object, ModuleObjectType.ModuleCreature)) {\n        return this.lastPerceived.object;\n      }\n      return undefined;\n    }\n  },\n  257: {\n    comment: \"257: Use this in an OnPerception script to determine whether the object that was\\nperceived was heard.\\n\",\n    name: \"GetLastPerceptionHeard\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.lastPerceived.object, ModuleObjectType.ModuleObject)) {\n        return !this.lastPerceived.object.isDead() || !!(this.lastPerceived.data & PerceptionMask.HEARD);\n      } else {\n        return 0;\n      }\n    }\n  },\n  258: {\n    comment: \"258: Use this in an OnPerception script to determine whether the object that was\\nperceived has become inaudible.\\n\",\n    name: \"GetLastPerceptionInaudible\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.lastPerceived.object, ModuleObjectType.ModuleObject)) {\n        return this.lastPerceived.object.isDead() || !!(this.lastPerceived.data & PerceptionMask.INAUDIBLE);\n      } else {\n        return 0;\n      }\n    }\n  },\n  259: {\n    comment: \"259: Use this in an OnPerception script to determine whether the object that was\\nperceived was seen.\\n\",\n    name: \"GetLastPerceptionSeen\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.lastPerceived.object, ModuleObjectType.ModuleCreature))\n        return !this.lastPerceived.object.isDead() || !!(this.lastPerceived.data & PerceptionMask.SEEN);\n      else\n        return 0;\n    }\n  },\n  260: {\n    comment: \"260: Use this in an OnClosed script to get the object that closed the door or placeable.\\n* Returns OBJECT_INVALID if the caller is not a valid door or placeable.\\n\",\n    name: \"GetLastClosedBy\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  261: {\n    comment: \"261: Use this in an OnPerception script to determine whether the object that was\\nperceived has vanished.\\n\",\n    name: \"GetLastPerceptionVanished\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.lastPerceived.object, ModuleObjectType.ModuleObject)) {\n        return this.lastPerceived.object.isDead() || !!(this.lastPerceived.data & PerceptionMask.INVISIBLE);\n      } else {\n        return 0;\n      }\n    }\n  },\n  262: {\n    comment: \"262: Get the first object within oPersistentObject.\\n- oPersistentObject\\n- nResidentObjectType: OBJECT_TYPE_*\\n- nPersistentZone: PERSISTENT_ZONE_ACTIVE. [This could also take the value\\nPERSISTENT_ZONE_FOLLOW, but this is no longer used.]\\n* Returns OBJECT_INVALID if no object is found.\\n\",\n    name: \"GetFirstInPersistentObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleTrigger)) {\n        this.persistentObjectIndex.set(args[0].id, 0)\n        return args[0].objectsInside[0];\n      } else {\n        return undefined;\n      }\n    }\n  },\n  263: {\n    comment: \"263: Get the next object within oPersistentObject.\\n- oPersistentObject\\n- nResidentObjectType: OBJECT_TYPE_*\\n- nPersistentZone: PERSISTENT_ZONE_ACTIVE. [This could also take the value\\nPERSISTENT_ZONE_FOLLOW, but this is no longer used.]\\n* Returns OBJECT_INVALID if no object is found.\\n\",\n    name: \"GetNextInPersistentObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleTrigger)) {\n        const nextId = this.persistentObjectIndex.get(args[0].id) + 1;\n        this.persistentObjectIndex.set(args[0].id, nextId)\n        return args[0].objectsInside[nextId];\n      } else {\n        return undefined;\n      }\n    }\n  },\n  264: {\n    comment: \"264: This returns the creator of oAreaOfEffectObject.\\n* Returns OBJECT_INVALID if oAreaOfEffectObject is not a valid Area of Effect object.\\n\",\n    name: \"GetAreaOfEffectCreator\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  265: {\n    comment: \"265: Brings up the level up GUI for the player.  The GUI will only show up\\nif the player has gained enough experience points to level up.\\n* Returns TRUE if the GUI was successfully brought up; FALSE if not.\\n\",\n    name: \"ShowLevelUpGUI\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  266: {\n    comment: \"266: Flag the specified item as being non-equippable or not.  Set bNonEquippable\\nto TRUE to prevent this item from being equipped, and FALSE to allow\\nthe normal equipping checks to determine if the item can be equipped.\\nNOTE: This will do nothing if the object passed in is not an item.  Items that\\nare already equipped when this is called will not automatically be\\nunequipped.  These items will just be prevented from being re-equipped\\nshould they be unequipped.\\n\",\n    name: \"SetItemNonEquippable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  267: {\n    comment: \"267: GetButtonMashCheck\\nThis function returns whether the button mash check, used for the combat tutorial, is on\\n\",\n    name: \"GetButtonMashCheck\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  268: {\n    comment: \"268: SetButtonMashCheck\\nThis function sets the button mash check variable, and is used for turning the check on and off\\n\",\n    name: \"SetButtonMashCheck\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  269: {\n    comment: \"269: EffectForcePushTargeted\\nThis effect is exactly the same as force push, except it takes a location parameter that specifies\\nwhere the location of the force push is to be done from.  All orientations are also based on this location.\\nAMF:  The new ignore test direct line variable should be used with extreme caution\\nIt overrides geometry checks for force pushes, so that the object that the effect is applied to\\nis guaranteed to move that far, ignoring collisions.  It is best used for cutscenes.\\n\",\n    name: \"EffectForcePushTargeted\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [EngineLocation, number]) {\n      const effect = new GameState.GameEffectFactory.EffectForcePushed();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 1);\n      effect.setInt(1, args[1]);\n      effect.setFloat(0, args[0].position.x);\n      effect.setFloat(1, args[0].position.y);\n      effect.setFloat(2, args[0].position.z);\n      return effect.initialize();\n    }\n  },\n  270: {\n    comment: \"270: Create a Haste effect.\\n\",\n    name: \"EffectHaste\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectHaste();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  271: {\n    comment: \"271: Give oItem to oGiveTo (instant; for similar Action use ActionGiveItem)\\nIf oItem is not a valid item, or oGiveTo is not a valid object, nothing will\\nhappen.\\n\",\n    name: \"GiveItem\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  272: {\n    comment: \"272: Convert oObject into a hexadecimal string.\\n\",\n    name: \"ObjectToString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getName();\n      } else {\n        return 'OBJECT_INVALID';\n      }\n    }\n  },\n  273: {\n    comment: \"273: Create an Immunity effect.\\n- nImmunityType: IMMUNITY_TYPE_*\\n\",\n    name: \"EffectImmunity\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectImmunity();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  274: {\n    comment: \"274: - oCreature\\n- nImmunityType: IMMUNITY_TYPE_*\\n- oVersus: if this is specified, then we also check for the race and\\nalignment of oVersus\\n* Returns TRUE if oCreature has immunity of type nImmunity versus oVersus.\\n\",\n    name: \"GetIsImmune\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT]\n  },\n  275: {\n    comment: \"275: Creates a Damage Immunity Increase effect.\\n- nDamageType: DAMAGE_TYPE_*\\n- nPercentImmunity\\n\",\n    name: \"EffectDamageImmunityIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageImmunityIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  276: {\n    comment: \"276: Determine whether oEncounter is active.\\n\",\n    name: \"GetEncounterActive\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleEncounter)) {\n        return (args[0] as ModuleEncounter).active;\n      }\n    }\n  },\n  277: {\n    comment: \"277: Set oEncounter's active state to nNewValue.\\n- nNewValue: TRUE/FALSE\\n- oEncounter\\n\",\n    name: \"SetEncounterActive\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleEncounter)) {\n        (args[1] as ModuleEncounter).active = (args[0] ? NW_TRUE : NW_FALSE);\n      }\n    }\n  },\n  278: {\n    comment: \"278: Get the maximum number of times that oEncounter will spawn.\\n\",\n    name: \"GetEncounterSpawnsMax\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleEncounter)) {\n        return (args[0] as ModuleEncounter).maxCreatures;\n      }\n    }\n  },\n  279: {\n    comment: \"279: Set the maximum number of times that oEncounter can spawn\\n\",\n    name: \"SetEncounterSpawnsMax\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleEncounter)) {\n        (args[1] as ModuleEncounter).maxCreatures = args[0];\n      }\n    }\n  },\n  280: {\n    comment: \"280: Get the number of times that oEncounter has spawned so far\\n\",\n    name: \"GetEncounterSpawnsCurrent\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleEncounter)) {\n        return (args[0] as ModuleEncounter).currentSpawns;\n      }\n    }\n  },\n  281: {\n    comment: \"281: Set the number of times that oEncounter has spawned so far\\n\",\n    name: \"SetEncounterSpawnsCurrent\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleEncounter)) {\n        (args[1] as ModuleEncounter).currentSpawns = args[0];\n      }\n    }\n  },\n  282: {\n    comment: \"282: Use this in an OnItemAcquired script to get the item that was acquired.\\n* Returns OBJECT_INVALID if the module is not valid.\\n\",\n    name: \"GetModuleItemAcquired\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  283: {\n    comment: \"283: Use this in an OnItemAcquired script to get the creatre that previously\\npossessed the item.\\n* Returns OBJECT_INVALID if the item was picked up from the ground.\\n\",\n    name: \"GetModuleItemAcquiredFrom\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  284: {\n    comment: \"284: Set the value for a custom token.\\n\",\n    name: \"SetCustomToken\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [number, string]) {\n      GameState.module.setCustomToken(args[0], args[1]);\n    }\n  },\n  285: {\n    comment: \"285: Determine whether oCreature has nFeat, and nFeat is useable.\\n- nFeat: FEAT_*\\n- oCreature\\n\",\n    name: \"GetHasFeat\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      return 0;\n    }\n  },\n  286: {\n    comment: \"286: Determine whether oCreature has nSkill, and nSkill is useable.\\n- nSkill: SKILL_*\\n- oCreature\\n\",\n    name: \"GetHasSkill\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      return 0;\n    }\n  },\n  287: {\n    comment: \"287: Use nFeat on oTarget.\\n- nFeat: FEAT_*\\n- oTarget\\n\",\n    name: \"ActionUseFeat\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT]\n  },\n  288: {\n    comment: \"288: Runs the action 'UseSkill' on the current creature\\nUse nSkill on oTarget.\\n- nSkill: SKILL_*\\n- oTarget\\n- nSubSkill: SUBSKILL_*\\n- oItemUsed: Item to use in conjunction with the skill\\n\",\n    name: \"ActionUseSkill\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT]\n  },\n  289: {\n    comment: \"289: Determine whether oSource sees oTarget.\\n\",\n    name: \"GetObjectSeen\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        let perception;\n        for (let i = 0, len = args[1].perceptionList.length; i < len; i++) {\n          perception = args[1].perceptionList[i];\n          if (perception.object == args[0] && !!(perception.data & PerceptionMask.SEEN)) {\n            return NW_TRUE;\n          }\n        }\n      }\n      return NW_FALSE;\n    }\n  },\n  290: {\n    comment: \"290: Determine whether oSource hears oTarget.\\n\",\n    name: \"GetObjectHeard\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        let perception;\n        for (let i = 0, len = args[1].perceptionList.length; i < len; i++) {\n          perception = args[1].perceptionList[i];\n          if (perception.object == args[0] && !!(perception.data & PerceptionMask.HEARD)) {\n            return NW_TRUE;\n          }\n        }\n      }\n      return NW_FALSE;\n    }\n  },\n  291: {\n    comment: \"291: Use this in an OnPlayerDeath module script to get the last player that died.\\n\",\n    name: \"GetLastPlayerDied\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  292: {\n    comment: \"292: Use this in an OnItemLost script to get the item that was lost/dropped.\\n* Returns OBJECT_INVALID if the module is not valid.\\n\",\n    name: \"GetModuleItemLost\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  293: {\n    comment: \"293: Use this in an OnItemLost script to get the creature that lost the item.\\n* Returns OBJECT_INVALID if the module is not valid.\\n\",\n    name: \"GetModuleItemLostBy\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  294: {\n    comment: \"294: Do aActionToDo.\\n\",\n    name: \"ActionDoCommand\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.ACTION],\n    action: function (this: NWScriptInstance, args: [INWScriptStoreState]) {\n      this.caller.doCommand(args[0].script);\n    }\n  },\n  295: {\n    comment: \"295: Conversation event.\\n\",\n    name: \"EventConversation\",\n    type: NWScriptDataType.EVENT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const event = new EventConversation();\n      return event;\n    }\n  },\n  296: {\n    comment: \"296: Set the difficulty level of oEncounter.\\n- nEncounterDifficulty: ENCOUNTER_DIFFICULTY_*\\n- oEncounter\\n\",\n    name: \"SetEncounterDifficulty\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleEncounter)) {\n        (args[1] as ModuleEncounter).difficultyIndex = args[0];\n      }\n    }\n  },\n  297: {\n    comment: \"297: Get the difficulty level of oEncounter.\\n\",\n    name: \"GetEncounterDifficulty\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleEncounter)) {\n        return (args[0] as ModuleEncounter).difficultyIndex;\n      }\n    }\n  },\n  298: {\n    comment: \"298: Get the distance between lLocationA and lLocationB.\\n\",\n    name: \"GetDistanceBetweenLocations\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation, EngineLocation]) {\n      if (args[0] instanceof EngineLocation && args[1] instanceof EngineLocation) {\n        return args[0].position.distanceTo(args[1].position);\n      }\n      return 0;\n    }\n  },\n  299: {\n    comment: \"299: Use this in spell scripts to get nDamage adjusted by oTarget's reflex and\\nevasion saves.\\n- nDamage\\n- oTarget\\n- nDC: Difficulty check\\n- nSaveType: SAVING_THROW_TYPE_*\\n- oSaveVersus\\n\",\n    name: \"GetReflexAdjustedDamage\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [EngineLocation, EngineLocation]) {\n      //todo: currently passing back unmodified damage\n      return args[0];\n    }\n  },\n  300: {\n    comment: \"300: Play nAnimation immediately.\\n- nAnimation: ANIMATION_*\\n- fSpeed\\n- fSeconds: Duration of the animation (this is not used for Fire and\\nForget animations) If a time of -1.0f is specified for a looping animation\\nit will loop until the next animation is applied.\\n\",\n    name: \"PlayAnimation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        const action = new GameState.ActionFactory.ActionPlayAnimation();\n        action.setParameter(0, ActionParameterType.INT, this.caller.getAnimationNameById(args[0]))\n        action.setParameter(1, ActionParameterType.FLOAT, args[1])\n        action.setParameter(2, ActionParameterType.FLOAT, args[2])\n        this.caller.actionQueue.addFront(action);\n      }\n    }\n  },\n  301: {\n    comment: \"301: Create a Spell Talent.\\n- nSpell: SPELL_*\\n\",\n    name: \"TalentSpell\",\n    type: NWScriptDataType.TALENT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return new GameState.TalentSpell(args[0]);\n    }\n  },\n  302: {\n    comment: \"302: Create a Feat Talent.\\n- nFeat: FEAT_*\\n\",\n    name: \"TalentFeat\",\n    type: NWScriptDataType.TALENT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return new GameState.TalentFeat(args[0]);\n    }\n  },\n  303: {\n    comment: \"303: Create a Skill Talent.\\n- nSkill: SKILL_*\\n\",\n    name: \"TalentSkill\",\n    type: NWScriptDataType.TALENT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return new GameState.TalentSkill(args[0]);\n    }\n  },\n  304: {\n    comment: \"304: Determine if oObject has effects originating from nSpell.\\n- nSpell: SPELL_*\\n- oObject\\n\",\n    name: \"GetHasSpellEffect\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        for (let i = 0, len = args[1].effects.length; i < len; i++) {\n          const effect = args[1].effects[i];\n          if (effect.getSpellId() == args[0]) {\n            return NW_TRUE;\n          }\n        }\n      }\n      return NW_FALSE;\n    }\n  },\n  305: {\n    comment: \"305: Get the spell (SPELL_*) that applied eSpellEffect.\\n* Returns -1 if eSpellEffect was applied outside a spell script.\\n\",\n    name: \"GetEffectSpellId\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [GameEffect]) {\n      if (args[0]) {\n        return args[0].getSpellId();\n      }\n      return -1;\n    }\n  },\n  306: {\n    comment: \"306: Determine whether oCreature has tTalent.\\n\",\n    name: \"GetCreatureHasTalent\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.TALENT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [TalentObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return (args[1] as ModuleCreature).hasTalent(args[0]) ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  307: {\n    comment: \"307: Get a random talent of oCreature, within nCategory.\\n- nCategory: TALENT_CATEGORY_*\\n- oCreature\\n- nInclusion: types of talent to include\\n\",\n    name: \"GetCreatureTalentRandom\",\n    type: NWScriptDataType.TALENT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return (args[1] as ModuleCreature).getRandomTalent(args[0], args[2]);\n      } else {\n        return undefined;\n      }\n    }\n  },\n  308: {\n    comment: \"308: Get the best talent (i.e. closest to nCRMax without going over) of oCreature,\\nwithin nCategory.\\n- nCategory: TALENT_CATEGORY_*\\n- nCRMax: Challenge Rating of the talent\\n- oCreature\\n- nInclusion: types of talent to include\\n- nExcludeType: TALENT_TYPE_FEAT or TALENT_TYPE_FORCE, type of talent that we wish to ignore\\n- nExcludeId: Talent ID of the talent we wish to ignore.\\nA value of TALENT_EXCLUDE_ALL_OF_TYPE for this parameter will mean that all talents of\\ntype nExcludeType are ignored.\\n\",\n    name: \"GetCreatureTalentBest\",\n    type: NWScriptDataType.TALENT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, ModuleObject, number, number, number]) {\n      if (BitWise.InstanceOfObject(args[2], ModuleObjectType.ModuleCreature)) {\n        return (args[2] as ModuleCreature).getTalentBest(args[0], args[1], args[3], args[4], args[5]);\n      }\n      return undefined;\n    }\n  },\n  309: {\n    comment: \"309: Use tChosenTalent on oTarget.\\n\",\n    name: \"ActionUseTalentOnObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.TALENT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [TalentObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))\n        (this.caller as ModuleCreature).useTalent(args[0], args[1]);\n    }\n  },\n  310: {\n    comment: \"310: Use tChosenTalent at lTargetLocation.\\n\",\n    name: \"ActionUseTalentAtLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.TALENT, NWScriptDataType.LOCATION]\n  },\n  311: {\n    comment: \"311: Get the gold piece value of oItem.\\n* Returns 0 if oItem is not a valid item.\\n\",\n    name: \"GetGoldPieceValue\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleItem]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return args[0].cost || 0 + args[0].addCost || 0;\n      }\n      return 0;\n    }\n  },\n  312: {\n    comment: \"312: * Returns TRUE if oCreature is of a playable racial type.\\n\",\n    name: \"GetIsPlayableRacialType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  313: {\n    comment: \"313: Jump to lDestination.  The action is added to the TOP of the action queue.\\n\",\n    name: \"JumpToLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))\n        this.caller.JumpToLocation(args[0]);\n    }\n  },\n  314: {\n    comment: \"314: Create a Temporary Hitpoints effect.\\n- nHitPoints: a positive integer\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nHitPoints < 0.\\n\",\n    name: \"EffectTemporaryHitpoints\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      if (args[0] < 0) return undefined;\n      const effect = new GameState.GameEffectFactory.EffectTemporaryHitPoints();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  315: {\n    comment: \"315: Get the number of ranks that oTarget has in nSkill.\\n- nSkill: SKILL_*\\n- oTarget\\n* Returns -1 if oTarget doesn't have nSkill.\\n* Returns 0 if nSkill is untrained.\\n\",\n    name: \"GetSkillRank\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return args[1].getSkillLevel(args[0]);\n      } else {\n        return 0;\n      }\n    }\n  },\n  316: {\n    comment: \"316: Get the attack target of oCreature.\\nThis only works when oCreature is in combat.\\n\",\n    name: \"GetAttackTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if (args[0].combatData.combatState) {\n          return args[0].combatData.lastAttackTarget || args[0].combatData.lastAttacker;\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n\n    }\n  },\n  317: {\n    comment: \"317: Get the attack type (SPECIAL_ATTACK_*) of oCreature's last attack.\\nThis only works when oCreature is in combat.\\n\",\n    name: \"GetLastAttackType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  318: {\n    comment: \"318: Get the attack mode (COMBAT_MODE_*) of oCreature's last attack.\\nThis only works when oCreature is in combat.\\n\",\n    name: \"GetLastAttackMode\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  319: {\n    comment: \"319: Get the distance in metres between oObjectA and oObjectB in 2D.\\n* Return value if either object is invalid: 0.0f\\n\",\n    name: \"GetDistanceBetween2D\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleObject)) {\n        return new THREE.Vector2(args[0].position.x, args[0].position.y)\n          .distanceTo(new THREE.Vector2(args[1].position.x, args[1].position.y));\n      } else {\n        return 0.0;\n      }\n    }\n  },\n  320: {\n    comment: \"320: * Returns TRUE if oCreature is in combat.\\n\",\n    name: \"GetIsInCombat\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].combatData.combatState ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  321: {\n    comment: \"321: Get the last command (ASSOCIATE_COMMAND_*) issued to oAssociate.\\n\",\n    name: \"GetLastAssociateCommand\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  322: {\n    comment: \"322: Give nGP gold to oCreature.\\n\",\n    name: \"GiveGoldToCreature\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        args[0].addGold(args[1] || 0);\n      }\n    }\n  },\n  323: {\n    comment: \"323: Set the destroyable status of the caller.\\n- bDestroyable: If this is FALSE, the caller does not fade out on death, but\\nsticks around as a corpse.\\n- bRaiseable: If this is TRUE, the caller can be raised via resurrection.\\n- bSelectableWhenDead: If this is TRUE, the caller is selectable after death.\\n\",\n    name: \"SetIsDestroyable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        this.caller.isDestroyable = !!args[0];\n        this.caller.isRaisable = !!args[1];\n        this.caller.isDeadSelectable = !!args[2];\n      }\n    }\n  },\n  324: {\n    comment: \"324: Set the locked state of oTarget, which can be a door or a placeable object.\\n\",\n    name: \"SetLocked\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) && !(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor))) return;\n      (args[0] as ModuleDoor | ModulePlaceable).setLocked(args[1] ? true : false);\n    }\n  },\n  325: {\n    comment: \"325: Get the locked state of oTarget, which can be a door or a placeable object.\\n\",\n    name: \"GetLocked\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) && !(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor))) return;\n      return (args[0] as ModuleDoor | ModulePlaceable).isLocked() ? NW_TRUE : NW_FALSE;\n    }\n  },\n  326: {\n    comment: \"326: Use this in a trigger's OnClick event script to get the object that last\\nclicked on it.\\nThis is identical to GetEnteringObject.\\n\",\n    name: \"GetClickingObject\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  327: {\n    comment: \"327: Initialise oTarget to listen for the standard Associates commands.\\n\",\n    name: \"SetAssociateListenPatterns\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT]\n  },\n  328: {\n    comment: \"328: Get the last weapon that oCreature used in an attack.\\n* Returns OBJECT_INVALID if oCreature did not attack, or has no weapon equipped.\\n\",\n    name: \"GetLastWeaponUsed\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  329: {\n    comment: \"329: Use oPlaceable.\\n\",\n    name: \"ActionInteractObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModulePlaceable)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionUseObject();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  330: {\n    comment: \"330: Get the last object that used the placeable object that is calling this function.\\n* Returns OBJECT_INVALID if it is called by something other than a placeable or\\na door.\\n\",\n    name: \"GetLastUsedBy\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if ((BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModulePlaceable)) || (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleDoor))) {\n        return (this.caller as ModuleDoor | ModulePlaceable).lastUsedBy || undefined;\n      }\n\n      return undefined;\n    }\n  },\n  331: {\n    comment: \"331: Returns the ability modifier for the specified ability\\nGet oCreature's ability modifier for nAbility.\\n- nAbility: ABILITY_*\\n- oCreature\\n\",\n    name: \"GetAbilityModifier\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n\n        switch (args[0]) {\n          case 0: //ABILITY_STRENGTH\n            return CombatRound.GetMod((args[1] as ModuleCreature).getSTR());\n          case 1: //ABILITY_DEXTERITY\n            return CombatRound.GetMod((args[1] as ModuleCreature).getDEX());\n          case 2: //ABILITY_CONSTITUTION\n            return CombatRound.GetMod((args[1] as ModuleCreature).getCON());\n          case 3: //ABILITY_INTELLIGENCE\n            return CombatRound.GetMod((args[1] as ModuleCreature).getINT());\n          case 4: //ABILITY_WISDOM\n            return CombatRound.GetMod((args[1] as ModuleCreature).getWIS());\n          case 5: //ABILITY_CHARISMA\n            return CombatRound.GetMod((args[1] as ModuleCreature).getCHA());\n        }\n\n        return 0;\n      } else {\n        return 0;\n      }\n    }\n  },\n  332: {\n    comment: \"332: Determined whether oItem has been identified.\\n\",\n    name: \"GetIdentified\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  333: {\n    comment: \"333: Set whether oItem has been identified.\\n\",\n    name: \"SetIdentified\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  334: {\n    comment: \"334: Get the distance between lLocationA and lLocationB. in 2D\\n\",\n    name: \"GetDistanceBetweenLocations2D\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [EngineLocation, EngineLocation]) {\n      if (args[0] instanceof EngineLocation && args[1] instanceof EngineLocation) {\n        return args[0].position.distanceTo(args[1].position);\n      }\n      return 0;\n    }\n  },\n  335: {\n    comment: \"335: Get the distance from the caller to oObject in metres.\\n* Return value on error: -1.0f\\n\",\n    name: \"GetDistanceToObject2D\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return new THREE.Vector2(this.caller.position.x, this.caller.position.y)\n          .distanceTo(\n            new THREE.Vector2(args[0].position.x, args[0].position.y)\n          );\n      } else {\n        return -1.0;\n      }\n    }\n  },\n  336: {\n    comment: \"336: Get the last blocking door encountered by the caller of this function.\\n* Returns OBJECT_INVALID if the caller is not a valid creature.\\n\",\n    name: \"GetBlockingDoor\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller.collisionManager.blockingObject, ModuleObjectType.ModuleDoor)) {\n        return this.caller.collisionManager.blockingObject;\n      }\n      return undefined;\n    }\n  },\n  337: {\n    comment: \"337: - oTargetDoor\\n- nDoorAction: DOOR_ACTION_*\\n* Returns TRUE if nDoorAction can be performed on oTargetDoor.\\n\",\n    name: \"GetIsDoorActionPossible\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleDoor, number]) {\n\n      /*\n      int    DOOR_ACTION_OPEN                 = 0;\n      int    DOOR_ACTION_UNLOCK               = 1;\n      int    DOOR_ACTION_BASH                 = 2;\n      int    DOOR_ACTION_IGNORE               = 3;\n      int    DOOR_ACTION_KNOCK                = 4;\n      */\n\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor)) {\n        switch (args[1]) {\n          case 0: return !args[0].isLocked();\n          case 1: return args[0].isLocked();\n          case 2: return args[0].isLocked();\n          case 3: return false;\n          case 4: return !args[0].isOpen();\n        }\n      }\n      return 0;\n    }\n  },\n  338: {\n    comment: \"338: Perform nDoorAction on oTargetDoor.\\n\",\n    name: \"DoDoorAction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleDoor, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor)) {\n        switch (args[1]) {\n          //OPEN\n          case 0: args[0].openDoor(this.caller); break;\n          //UNLOCK\n          case 1: args[0].attemptUnlock(this.caller); break;\n          //BASH\n          case 2: this.caller.attackCreature(args[0]); break;\n          //IGNORE (UNUSED?)\n          // case 3: args[0].openDoor(this.caller); break;\n          //KNOCK (UNUSED?)\n          // case 4: args[0].openDoor(this.caller); break;\n        }\n      }\n    }\n  },\n  339: {\n    comment: \"339: Get the first item in oTarget's inventory (start to cycle through oTarget's\\ninventory).\\n* Returns OBJECT_INVALID if the caller is not a creature, item, placeable or store,\\nor if no item is found.\\n\",\n    name: \"GetFirstItemInInventory\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        if (GameState.PartyManager.party.indexOf(args[0] as ModuleCreature) >= 0) {\n          this.objectInventoryIndex.set(-1, 0);\n          return GameState.InventoryManager.inventory[0];\n        } else {\n          this.objectInventoryIndex.set(args[0].id, 0);\n          return args[0].inventory[0];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  },\n  340: {\n    comment: \"340: Get the next item in oTarget's inventory (continue to cycle through oTarget's\\ninventory).\\n* Returns OBJECT_INVALID if the caller is not a creature, item, placeable or store,\\nor if no item is found.\\n\",\n    name: \"GetNextItemInInventory\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        if (GameState.PartyManager.party.indexOf(args[0] as ModuleCreature) >= 0) {\n          const nextId = this.objectInventoryIndex.get(-1) + 1;\n          this.objectInventoryIndex.set(-1, nextId);\n          return GameState.InventoryManager.inventory[nextId];\n        } else {\n          const nextId = this.objectInventoryIndex.get(args[0].id) + 1;\n          this.objectInventoryIndex.set(args[0].id, nextId);\n          return args[0].inventory[nextId];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  },\n  341: {\n    comment: \"341: A creature can have up to three classes.  This function determines the\\ncreature's class (CLASS_TYPE_*) based on nClassPosition.\\n- nClassPosition: 1, 2 or 3\\n- oCreature\\n* Returns CLASS_TYPE_INVALID if the oCreature does not have a class in\\nnClassPosition (i.e. a single-class creature will only have a value in\\nnClassLocation=1) or if oCreature is not a valid creature.\\n\",\n    name: \"GetClassByPosition\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleCreature]) {\n      const creature = args[1] as ModuleCreature;\n      switch (args[0]) {\n        case 1: return creature.classes[0]?.id || CreatureClassType.INVALID;\n        case 2: return creature.classes[1]?.id || CreatureClassType.INVALID;\n        case 3: return creature.classes[2]?.id || CreatureClassType.INVALID;\n      }\n      return CreatureClassType.INVALID;\n    }\n  },\n  342: {\n    comment: \"342: A creature can have up to three classes.  This function determines the\\ncreature's class level based on nClass Position.\\n- nClassPosition: 1, 2 or 3\\n- oCreature\\n* Returns 0 if oCreature does not have a class in nClassPosition\\n(i.e. a single-class creature will only have a value in nClassLocation=1)\\nor if oCreature is not a valid creature.\\n\",\n    name: \"GetLevelByPosition\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleCreature]) {\n      const creature = args[1] as ModuleCreature;\n      switch (args[0]) {\n        case 1: return creature.classes[0]?.level || 0;\n        case 2: return creature.classes[1]?.level || 0;\n        case 3: return creature.classes[2]?.level || 0;\n      }\n      return 0;\n    }\n  },\n  343: {\n    comment: \"343: Determine the levels that oCreature holds in nClassType.\\n- nClassType: CLASS_TYPE_*\\n- oCreature\\n\",\n    name: \"GetLevelByClass\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleCreature]) {\n      return args[1].getClassLevel(args[0]);\n    }\n  },\n  344: {\n    comment: \"344: Get the amount of damage of type nDamageType that has been dealt to the caller.\\n- nDamageType: DAMAGE_TYPE_*\\n\",\n    name: \"GetDamageDealtByType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return 0;\n    }\n  },\n  345: {\n    comment: \"345: Get the total amount of damage that has been dealt to the caller.\\n\",\n    name: \"GetTotalDamageDealt\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  346: {\n    comment: \"346: Get the last object that damaged the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid object.\\n\",\n    name: \"GetLastDamager\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return this.caller.combatData.lastDamager;\n      } else {\n        return undefined;\n      }\n    }\n  },\n  347: {\n    comment: \"347: Get the last object that disarmed the trap on the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid placeable, trigger or\\ndoor.\\n\",\n    name: \"GetLastDisarmed\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  348: {\n    comment: \"348: Get the last object that disturbed the inventory of the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid creature or placeable.\\n\",\n    name: \"GetLastDisturbed\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.lastDisturbed;\n    }\n  },\n  349: {\n    comment: \"349: Get the last object that locked the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid door or placeable.\\n\",\n    name: \"GetLastLocked\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  350: {\n    comment: \"350: Get the last object that unlocked the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid door or placeable.\\n\",\n    name: \"GetLastUnlocked\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  351: {\n    comment: \"351: Create a Skill Increase effect.\\n- nSkill: SKILL_*\\n- nValue\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nSkill is invalid.\\n\",\n    name: \"EffectSkillIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectSkillIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  352: {\n    comment: \"352: Get the type of disturbance (INVENTORY_DISTURB_*) that caused the caller's\\nOnInventoryDisturbed script to fire.  This will only work for creatures and\\nplaceables.\\n\",\n    name: \"GetInventoryDisturbType\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  353: {\n    comment: \"353: get the item that caused the caller's OnInventoryDisturbed script to fire.\\n* Returns OBJECT_INVALID if the caller is not a valid object.\\n\",\n    name: \"GetInventoryDisturbItem\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  354: {\n    comment: \"354: Displays the upgrade screen where the player can modify weapons and armor\\n\",\n    name: \"ShowUpgradeScreen\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      GameState.MenuManager.MenuUpgradeSelect.open();\n    }\n  },\n  355: {\n    comment: \"355: Set eEffect to be versus a specific alignment.\\n- eEffect\\n- nLawChaos: ALIGNMENT_LAWFUL/ALIGNMENT_CHAOTIC/ALIGNMENT_ALL\\n- nGoodEvil: ALIGNMENT_GOOD/ALIGNMENT_EVIL/ALIGNMENT_ALL\\n\",\n    name: \"VersusAlignmentEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  356: {\n    comment: \"356: Set eEffect to be versus nRacialType.\\n- eEffect\\n- nRacialType: RACIAL_TYPE_*\\n\",\n    name: \"VersusRacialTypeEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT, NWScriptDataType.INTEGER]\n  },\n  357: {\n    comment: \"357: Set eEffect to be versus traps.\\n\",\n    name: \"VersusTrapEffect\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT]\n  },\n  358: {\n    comment: \"358: Get the gender of oCreature.\\n\",\n    name: \"GetGender\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      return args[0].getGender();\n    }\n  },\n  359: {\n    comment: \"359: * Returns TRUE if tTalent is valid.\\n\",\n    name: \"GetIsTalentValid\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.TALENT],\n    action: function (this: NWScriptInstance, args: [TalentObject]) {\n      return typeof args[0] != 'undefined' && typeof args[0] == 'object' && typeof args[0].objectType != 'undefined' ? NW_TRUE : NW_FALSE;\n    }\n  },\n  360: {\n    comment: \"360: Causes the action subject to move away from lMoveAwayFrom.\\n\",\n    name: \"ActionMoveAwayFromLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT]\n  },\n  361: {\n    comment: \"361: Get the target that the caller attempted to attack - this should be used in\\nconjunction with GetAttackTarget(). This value is set every time an attack is\\nmade, and is reset at the end of combat.\\n* Returns OBJECT_INVALID if the caller is not a valid creature.\\n\",\n    name: \"GetAttemptedAttackTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.caller.combatData.lastAttemptedAttackTarget;\n    }\n  },\n  362: {\n    comment: \"362: Get the type (TALENT_TYPE_*) of tTalent.\\n\",\n    name: \"GetTypeFromTalent\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.TALENT],\n    action: function (this: NWScriptInstance, args: [TalentObject]) {\n      if (typeof args[0] == 'object') {\n        return args[0].objectType || 0;\n      } else {\n        return 0;\n      }\n    }\n  },\n  363: {\n    comment: \"363: Get the ID of tTalent.  This could be a SPELL_*, FEAT_* or SKILL_*.\\n\",\n    name: \"GetIdFromTalent\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.TALENT],\n    action: function (this: NWScriptInstance, args: [TalentObject]) {\n      if (args[0] != undefined) {\n        return args[0].id;\n      }\n      return 0;\n    }\n  },\n  364: {\n    comment: \"364: Starts a game of pazaak.\\n- nOpponentPazaakDeck: Index into PazaakDecks.2da; specifies which deck the opponent will use.\\n- sEndScript: Script to be run when game finishes.\\n- nMaxWager: Max player wager.  If <= 0, the player's credits won't be modified by the result of the game and the wager screen will not show up.\\n- bShowTutorial: Plays in tutorial mode (nMaxWager should be 0).\\n\",\n    name: \"PlayPazaak\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, string, number, number, ModuleObject]) {\n      GameState.PazaakManager.SetOpponentDeck(args[0] || 0);\n      GameState.PazaakManager.SetEndScript(args[1] || '');\n      GameState.PazaakManager.MaxWager = args[2] || 0;\n      GameState.PazaakManager.Wager = args[2] || 0;\n      GameState.PazaakManager.ShowTutorial = !!args[3];\n      GameState.PazaakManager.SetOpponent(args[4] as ModuleCreature || this.caller as ModuleCreature);\n      GameState.PazaakManager.Won = false;\n\n      GameState.PazaakManager.StartGame();\n    }\n  },\n  365: {\n    comment: \"365: Returns result of last Pazaak game.  Should be used only in an EndScript sent to PlayPazaak.\\n* Returns 0 if player loses, 1 if player wins.\\n\",\n    name: \"GetLastPazaakResult\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.PazaakManager.Won ? 1 : 0;\n    }\n  },\n  366: {\n    comment: \"366:  displays a feed back string for the object spicified and the constant\\nrepersents the string to be displayed see:FeedBackText.2da\\n\",\n    name: \"DisplayFeedBackText\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const oObject = args[0];\n      const nTextConstant = args[1];\n      if (!BitWise.InstanceOfObject(oObject, ModuleObjectType.ModuleObject)) return;\n      const feedback2DA = GameState.TwoDAManager?.datatables?.get('feedbacktext');\n      const row = feedback2DA?.rows ? (feedback2DA.rows[nTextConstant] ?? feedback2DA.getRowByIndex?.(nTextConstant)) : undefined;\n      const strref = row ? (row['StrRef'] ?? row['strref']) : undefined;\n      const strrefNum = strref != null ? (typeof strref === 'number' ? strref : parseInt(String(strref), 10)) : NaN;\n      let text: string;\n      if (!row || isNaN(strrefNum) || strrefNum === 0) {\n        text = 'BAD STRREF';\n      } else {\n        const tlk = GameState.TLKManager?.GetStringById?.(strrefNum);\n        text = (tlk?.Value ?? '').trim() || 'BAD STRREF';\n      }\n      oObject.setFeedbackInfo(text);\n    }\n  },\n  367: {\n    comment: \"367: Add a journal quest entry to the player.\\n- szPlotID: the plot identifier used in the toolset's Journal Editor\\n- nState: the state of the plot as seen in the toolset's Journal Editor\\n- bAllowOverrideHigher: If this is TRUE, you can set the state to a lower\\nnumber than the one it is currently on\\n\",\n    name: \"AddJournalQuestEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number, number]) {\n      return GameState.JournalManager.AddJournalQuestEntry(args[0], args[1], !!args[2]);\n    }\n  },\n  368: {\n    comment: \"368: Remove a journal quest entry from the player.\\n- szPlotID: the plot identifier used in the toolset's Journal Editor\\n\",\n    name: \"RemoveJournalQuestEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.JournalManager.RemoveJournalQuestEntry(args[0]);\n    }\n  },\n  369: {\n    comment: \"369: Gets the State value of a journal quest.  Returns 0 if no quest entry has been added for this szPlotID.\\n- szPlotID: the plot identifier used in the toolset's Journal Editor\\n\",\n    name: \"GetJournalEntry\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.JournalManager.GetJournalEntryState(args[0]);\n    }\n  },\n  370: {\n    comment: \"370: PlayRumblePattern\\nStarts a defined rumble pattern playing\\n\",\n    name: \"PlayRumblePattern\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.CameraShakeManager.playRumblePattern(args[0]);\n      return NW_TRUE;\n    }\n  },\n  371: {\n    comment: \"371: StopRumblePattern\\nStops a defined rumble pattern\\n\",\n    name: \"StopRumblePattern\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.CameraShakeManager.stopRumblePattern(args[0]);\n      return NW_TRUE;\n    }\n  },\n  372: {\n    comment: \"372: Damages the creatures force points\\n\",\n    name: \"EffectDamageForcePoints\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageForcePoints();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  373: {\n    comment: \"373: Heals the creatures force points\\n\",\n    name: \"EffectHealForcePoints\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectHealForcePoints();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  374: {\n    comment: \"374: Send a server message (szMessage) to the oPlayer.\\n\",\n    name: \"SendMessageToPC\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING]\n  },\n  375: {\n    comment: \"375: Get the target at which the caller attempted to cast a spell.\\nThis value is set every time a spell is cast and is reset at the end of\\ncombat.\\n* Returns OBJECT_INVALID if the caller is not a valid creature.\\n\",\n    name: \"GetAttemptedSpellTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.caller.combatData.lastAttemptedSpellTarget;\n    }\n  },\n  376: {\n    comment: \"376: Get the last creature that opened the caller.\\n* Returns OBJECT_INVALID if the caller is not a valid door or placeable.\\n\",\n    name: \"GetLastOpenedBy\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (\n        !(BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModulePlaceable)) &&\n        !(BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleDoor))\n      ) return;\n      return (this.caller as ModuleDoor | ModulePlaceable).lastObjectOpened;\n    }\n  },\n  377: {\n    comment: \"377: Determine whether oCreature has nSpell memorised.\\n- nSpell: SPELL_*\\n- oCreature\\n\",\n    name: \"GetHasSpell\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        return (args[1] as ModuleCreature).getHasSpell(args[0]) ? NW_TRUE : NW_FALSE;\n      } else {\n        return NW_FALSE;\n      }\n    }\n  },\n  378: {\n    comment: \"378: Open oStore for oPC.\\n\",\n    name: \"OpenStore\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleCreature, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleStore)) {\n        GameState.MenuManager.MenuStore.setStoreObject(args[0] as ModuleStore);\n        GameState.MenuManager.MenuStore.setCustomerObject(args[1]);\n        GameState.MenuManager.MenuStore.setBonusMarkUp(args[2]);\n        GameState.MenuManager.MenuStore.setBonusMarkDown(args[3]);\n      }\n    }\n  },\n  379: {\n    comment: \"379:\\n\",\n    name: \"ActionSurrenderToEnemies\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  380: {\n    comment: \"380: Get the first member of oMemberOfFaction's faction (start to cycle through\\noMemberOfFaction's faction).\\n* Returns OBJECT_INVALID if oMemberOfFaction's faction is invalid.\\n\",\n    name: \"GetFirstFactionMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          this.factionMemberIndex.set(faction.id, 0);\n          return faction.getFactionMemberByIndex(0, !!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  381: {\n    comment: \"381: Get the next member of oMemberOfFaction's faction (continue to cycle through\\noMemberOfFaction's faction).\\n* Returns OBJECT_INVALID if oMemberOfFaction's faction is invalid.\\n\",\n    name: \"GetNextFactionMember\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        const faction = GameState.FactionManager.GetCreatureFaction(args[0]);\n        if (faction) {\n          const nextId = this.factionMemberIndex.get(faction.id) + 1;\n          this.factionMemberIndex.set(faction.id, nextId);\n          return faction.getFactionMemberByIndex(nextId, !!args[1]);\n        }\n      }\n      return undefined;\n    }\n  },\n  382: {\n    comment: \"382: Force the action subject to move to lDestination.\\n\",\n    name: \"ActionForceMoveToLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.LOCATION, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [EngineLocation, number, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        (this.caller as ModuleCreature).moveToLocation(args[0], !!args[1]);//, args[2] );\n      }\n    }\n  },\n  383: {\n    comment: \"383: Force the action subject to move to oMoveTo.\\n\",\n    name: \"ActionForceMoveToObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, number]) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        (this.caller as ModuleCreature).moveToObject(args[0], !!args[1], args[2]);\n      }\n    }\n  },\n  384: {\n    comment: \"384: Get the experience assigned in the journal editor for szPlotID.\\n\",\n    name: \"GetJournalQuestExperience\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.JournalManager.GetJournalQuestExperience(args[0]);\n    }\n  },\n  385: {\n    comment: \"385: Jump to oToJumpTo (the action is added to the top of the action queue).\\n\",\n    name: \"JumpToObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      log.info('JumpToObject', args);\n      if (!(BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature))) return;\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return;\n\n      (this.caller as ModuleCreature).jumpToObject(args[0]);\n    }\n  },\n  386: {\n    comment: \"386: Set whether oMapPin is enabled.\\n- oMapPin\\n- nEnabled: 0=Off, 1=On\\n\",\n    name: \"SetMapPinEnabled\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  387: {\n    comment: \"387: Create a Hit Point Change When Dying effect.\\n- fHitPointChangePerRound: this can be positive or negative, but not zero.\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if fHitPointChangePerRound is 0.\\n\",\n    name: \"EffectHitPointChangeWhenDying\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.FLOAT]\n  },\n  388: {\n    comment: \"388: Spawn a GUI panel for the client that controls oPC.\\n- oPC\\n- nGUIPanel: GUI_PANEL_*\\n* Nothing happens if oPC is not a player character or if an invalid value is\\nused for nGUIPanel.\\n\",\n    name: \"PopUpGUIPanel\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  389: {\n    comment: \"389: This allows you to add a new class to any creature object\\n\",\n    name: \"AddMultiClass\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT]\n  },\n  390: {\n    comment: \"390: Tests a linked effect to see if the target is immune to it.\\nIf the target is imune to any of the linked effect then he is immune to all of it\\n\",\n    name: \"GetIsLinkImmune\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.EFFECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, GameEffect]) {\n      const oCreature = args[0];\n      const eEffect = args[1];\n      if (!eEffect || !BitWise.InstanceOfObject(oCreature, ModuleObjectType.ModuleCreature)) return 0;\n      return (oCreature as ModuleCreature).getEffectLinkImmunity(eEffect);\n    }\n  },\n  391: {\n    comment: \"391: Stunn the droid\\n\",\n    name: \"EffectDroidStun\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 3); // Droid Stun State\n      return effect.initialize();\n    }\n  },\n  392: {\n    comment: \"392: Force push the creature...\\n\",\n    name: \"EffectForcePushed\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectForcePushed();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  393: {\n    comment: \"393: Gives nXpAmount to oCreature.\\n\",\n    name: \"GiveXPToCreature\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleCreature, number]) {\n      args[0].addXP(args[1], ExperienceType.PLOT);\n    }\n  },\n  394: {\n    comment: \"394: Sets oCreature's experience to nXpAmount.\\n\",\n    name: \"SetXP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleCreature, number]) {\n      args[0].setXP(args[1])\n    }\n  },\n  395: {\n    comment: \"395: Get oCreature's experience.\\n\",\n    name: \"GetXP\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      return args[0].getXP();\n    }\n  },\n  396: {\n    comment: \"396: Convert nInteger to hex, returning the hex value as a string (8 hex digits).\\n\",\n    name: \"IntToHexString\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      let number = Number(args[0] ? args[0] : 0)\n\n      if (number < 0)\n        number = 0xFFFFFFFF + number + 1;\n\n      return number.toString(16).padStart(8, '0').toLocaleUpperCase();\n    }\n  },\n  397: {\n    comment: \"397: Get the base item type (BASE_ITEM_*) of oItem.\\n* Returns BASE_ITEM_INVALID if oItem is an invalid item.\\n\",\n    name: \"GetBaseItemType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return (args[0] as ModuleItem).getBaseItemId();\n      }\n      return 256;\n    }\n  },\n  398: {\n    comment: \"398: Determines whether oItem has nProperty.\\n- oItem\\n- nProperty: ITEM_PROPERTY_*\\n* Returns FALSE if oItem is not a valid item, or if oItem does not have\\nnProperty.\\n\",\n    name: \"GetItemHasItemProperty\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  399: {\n    comment: \"399: The creature will equip the melee weapon in its possession that can do the\\nmost damage. If no valid melee weapon is found, it will equip the most\\ndamaging range weapon. This function should only ever be called in the\\nEndOfCombatRound scripts, because otherwise it would have to stop the combat\\nround to run simulation.\\n- oVersus: You can try to get the most damaging weapon against oVersus\\n- bOffHand\\n\",\n    name: \"ActionEquipMostDamagingMelee\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n\n      if (args[0] == undefined)\n        args[0] = this.caller;\n\n      if (GameState.PartyManager.party.indexOf(args[0]) >= 0)\n        return;\n\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const inventory = (args[0] as ModuleCreature).getInventory();\n      const equipped = args[1] ? (args[0] as ModuleCreature).equipment.LEFTHAND : (args[0] as ModuleCreature).equipment.RIGHTHAND;\n      let weapon: ModuleItem = equipped;\n      if (args[0].isSimpleCreature()) {\n        return;\n      }\n\n      for (let i = 0, len = inventory.length; i < len; i++) {\n        const item = inventory[i];\n        const baseItem = item.baseItem;\n        if (\n          baseItem.weaponWield == WeaponWield.STUN_BATON ||\n          baseItem.weaponWield == WeaponWield.ONE_HANDED_SWORD ||\n          baseItem.weaponWield == WeaponWield.TWO_HANDED_SWORD\n        ) {\n          if (!weapon) {\n            weapon = item;\n          } else if ((baseItem.dieToRoll * baseItem.numDice) > (weapon.baseItem.dieToRoll * weapon.baseItem.numDice)) {\n            weapon = item;\n          }\n        }\n      }\n\n      //If no melee found, equip ranged\n      if (!weapon) {\n        for (let i = 0, len = inventory.length; i < len; i++) {\n          const item = inventory[i];\n          const baseItem = item.baseItem;\n          if (\n            baseItem.weaponWield == WeaponWield.BLASTER_PISTOL ||\n            baseItem.weaponWield == WeaponWield.BLASTER_RIFLE ||\n            baseItem.weaponWield == WeaponWield.BLASTER_HEAVY\n          ) {\n            if (!weapon) {\n              weapon = item;\n            } else if ((baseItem.dieToRoll * baseItem.numDice) > (weapon.baseItem.dieToRoll * weapon.baseItem.numDice)) {\n              weapon = item;\n            }\n          }\n        }\n      }\n\n      if (weapon == equipped) {\n        return false;\n      }\n\n      const action = new GameState.ActionFactory.ActionEquipItem();\n      action.setParameter(0, ActionParameterType.DWORD, weapon);\n      action.setParameter(1, ActionParameterType.INT, args[1] ? ModuleCreatureArmorSlot.LEFTHAND : ModuleCreatureArmorSlot.RIGHTHAND);\n      action.setParameter(2, ActionParameterType.INT, NW_FALSE);\n      this.caller.actionQueue.add(action);\n\n    }\n  },\n  400: {\n    comment: \"400: The creature will equip the range weapon in its possession that can do the\\nmost damage.\\nIf no valid range weapon can be found, it will equip the most damaging melee\\nweapon.\\n- oVersus: You can try to get the most damaging weapon against oVersus\\n\",\n    name: \"ActionEquipMostDamagingRanged\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n\n      if (args[0] == undefined) {\n        args[0] = this.caller;\n      }\n\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const inventory = (args[0] as ModuleCreature).getInventory();\n      const equipped = (args[0] as ModuleCreature).equipment.RIGHTHAND;\n      let weapon: ModuleItem = equipped;\n\n      if (args[0].isSimpleCreature()) {\n        return;\n      }\n\n      for (let i = 0, len = inventory.length; i < len; i++) {\n        const item = inventory[i];\n        const baseItem = item.baseItem;\n        if (\n          baseItem.weaponWield == WeaponWield.BLASTER_PISTOL ||\n          baseItem.weaponWield == WeaponWield.BLASTER_RIFLE ||\n          baseItem.weaponWield == WeaponWield.BLASTER_HEAVY\n        ) {\n          if (!weapon) {\n            weapon = item;\n          } else if ((baseItem.dieToRoll * baseItem.numDice) > (weapon.baseItem.dieToRoll * weapon.baseItem.numDice)) {\n            weapon = item;\n          }\n        }\n      }\n\n      //If no ranged found, equip melee\n      if (!weapon) {\n        for (let i = 0, len = inventory.length; i < len; i++) {\n          const item = inventory[i];\n          const baseItem = item.baseItem;\n          if (\n            baseItem.weaponWield == WeaponWield.STUN_BATON ||\n            baseItem.weaponWield == WeaponWield.ONE_HANDED_SWORD ||\n            baseItem.weaponWield == WeaponWield.TWO_HANDED_SWORD\n          ) {\n            if (!weapon) {\n              weapon = item;\n            } else if ((baseItem.dieToRoll * baseItem.numDice) > (weapon.baseItem.dieToRoll * weapon.baseItem.numDice)) {\n              weapon = item;\n            }\n          }\n        }\n      }\n\n      if (!weapon) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionEquipItem();\n      action.setParameter(0, ActionParameterType.DWORD, weapon);\n      action.setParameter(1, ActionParameterType.INT, ModuleCreatureArmorSlot.RIGHTHAND);\n      action.setParameter(2, ActionParameterType.INT, NW_FALSE);\n      this.caller.actionQueue.add(action);\n\n    }\n  },\n  401: {\n    comment: \"401: Get the Armour Class of oItem.\\n* Return 0 if the oItem is not a valid item, or if oItem has no armour value.\\n\",\n    name: \"GetItemACValue\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  402: {\n    comment: \"402:\\nEffect that will play an animation and display a visual effect to indicate the\\ntarget has resisted a force power.\\n\",\n    name: \"EffectForceResisted\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      const effect = new GameState.GameEffectFactory.EffectForceResisted();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setObject(0, args[0]);\n      effect.initialize();\n      return effect;\n    }\n  },\n  403: {\n    comment: \"403: Expose the entire map of oArea to oPlayer.\\n\",\n    name: \"ExploreAreaForPlayer\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).areaMap.revealEntireMap();\n      }\n    }\n  },\n  404: {\n    comment: \"404: The creature will equip the armour in its possession that has the highest\\narmour class.\\n\",\n    name: \"ActionEquipMostEffectiveArmor\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  405: {\n    comment: \"405: * Returns TRUE if it is currently day.\\n\",\n    name: \"GetIsDay\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  406: {\n    comment: \"406: * Returns TRUE if it is currently night.\\n\",\n    name: \"GetIsNight\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  407: {\n    comment: \"407: * Returns TRUE if it is currently dawn.\\n\",\n    name: \"GetIsDawn\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  408: {\n    comment: \"408: * Returns TRUE if it is currently dusk.\\n\",\n    name: \"GetIsDusk\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  409: {\n    comment: \"409: * Returns TRUE if oCreature was spawned from an encounter.\\n\",\n    name: \"GetIsEncounterCreature\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return 0;\n    }\n  },\n  410: {\n    comment: \"410: Use this in an OnPlayerDying module script to get the last player who is dying.\\n\",\n    name: \"GetLastPlayerDying\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  411: {\n    comment: \"411: Get the starting location of the module.\\n\",\n    name: \"GetStartingLocation\",\n    type: NWScriptDataType.LOCATION,\n    args: []\n  },\n  412: {\n    comment: \"412: Make oCreatureToChange join one of the standard factions.\\n** This will only work on an NPC **\\n- nStandardFaction: STANDARD_FACTION_*\\n\",\n    name: \"ChangeToStandardFaction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        args[0].faction = GameState.FactionManager.factions.get(args[1]);\n        GameState.FactionManager.AddCreatureToFaction(args[0]);\n      }\n    }\n  },\n  413: {\n    comment: \"413: Play oSound.\\n\",\n    name: \"SoundObjectPlay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound))\n        (args[0] as ModuleSound).start();\n    }\n  },\n  414: {\n    comment: \"414: Stop playing oSound.\\n\",\n    name: \"SoundObjectStop\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).stop();\n      }\n    }\n  },\n  415: {\n    comment: \"415: Set the volume of oSound.\\n- oSound\\n- nVolume: 0-127\\n\",\n    name: \"SoundObjectSetVolume\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).setVolume(args[1]);\n      }\n    }\n  },\n  416: {\n    comment: \"416: Set the position of oSound.\\n\",\n    name: \"SoundObjectSetPosition\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [ModuleObject, EngineLocation]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).setPosition(args[1].position.x, args[1].position.y, args[1].position.z);\n      }\n    }\n  },\n  417: {\n    comment: \"417: Immediately speak a conversation one-liner.\\n- sDialogResRef\\n- oTokenTarget: This must be specified if there are creature-specific tokens\\nin the string.\\n\",\n    name: \"SpeakOneLinerConversation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT]\n  },\n  418: {\n    comment: \"418: Get the amount of gold possessed by oTarget.\\n\",\n    name: \"GetGold\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return args[0].getGold();\n    }\n  },\n  419: {\n    comment: \"419: Use this in an OnRespawnButtonPressed module script to get the object id of\\nthe player who last pressed the respawn button.\\n\",\n    name: \"GetLastRespawnButtonPresser\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  420: {\n    comment: \"420:\\nEffect that will display a visual effect on the specified object's hand to\\nindicate a force power has fizzled out.\\n\",\n    name: \"EffectForceFizzle\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectForceFizzle();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      return effect.initialize();\n    }\n  },\n  421: {\n    comment: \"421: SetLightsaberPowered\\nAllows a script to set the state of the lightsaber.  This will override any\\ngame determined lightsaber powerstates.\\n\",\n    name: \"SetLightsaberPowered\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        (args[0] as ModuleCreature).weaponPowered(true);\n      }\n    }\n  },\n  422: {\n    comment: \"422: * Returns TRUE if the weapon equipped is capable of damaging oVersus.\\n\",\n    name: \"GetIsWeaponEffective\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  423: {\n    comment: \"423: Use this in a SpellCast script to determine whether the spell was considered\\nharmful.\\n* Returns TRUE if the last spell cast was harmful.\\n\",\n    name: \"GetLastSpellHarmful\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.lastSpellHarmful ? NW_TRUE : NW_FALSE;\n    }\n  },\n  424: {\n    comment: \"424: Activate oItem.\\n\",\n    name: \"EventActivateItem\",\n    type: NWScriptDataType.EVENT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.LOCATION, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, EngineLocation, ModuleObject]) {\n      const event = new EventSpellCastAt();\n      //oItem\n      event.setObject(0, args[0]);\n      //oCaller\n      event.setObject(1, this.caller);\n      //oPossessor\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem) && BitWise.InstanceOfObject((args[0] as ModuleItem).possessor, ModuleObjectType.ModuleObject)) {\n        event.setObject(2, (args[0] as ModuleItem).possessor);\n      } else {\n        event.setObject(2, undefined);\n      }\n      //oTarget\n      event.setObject(3, args[2]);\n\n      event.setFloat(0, args[1].position.x);\n      event.setFloat(1, args[1].position.y);\n      event.setFloat(2, args[1].position.z);\n\n      return event;\n    }\n  },\n  425: {\n    comment: \"425: Play the background music for oArea.\\n\",\n    name: \"MusicBackgroundPlay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBackgroundPlay();\n      }\n    }\n  },\n  426: {\n    comment: \"426: Stop the background music for oArea.\\n\",\n    name: \"MusicBackgroundStop\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBackgroundStop();\n      }\n    }\n  },\n  427: {\n    comment: \"427: Set the delay for the background music for oArea.\\n- oArea\\n- nDelay: delay in milliseconds\\n\",\n    name: \"MusicBackgroundSetDelay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBackgroundSetDelay(args[1]);\n      }\n    }\n  },\n  428: {\n    comment: \"428: Change the background day track for oArea to nTrack.\\n- oArea\\n- nTrack\\n\",\n    name: \"MusicBackgroundChangeDay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBackgroundDaySet(args[1]);\n      }\n    }\n  },\n  429: {\n    comment: \"429: Change the background night track for oArea to nTrack.\\n- oArea\\n- nTrack\\n\",\n    name: \"MusicBackgroundChangeNight\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBackgroundNightSet(args[1]);\n      }\n    }\n  },\n  430: {\n    comment: \"430: Play the battle music for oArea.\\n\",\n    name: \"MusicBattlePlay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBattlePlay();\n      }\n    }\n  },\n  431: {\n    comment: \"431: Stop the battle music for oArea.\\n\",\n    name: \"MusicBattleStop\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBattleStop();\n      }\n    }\n  },\n  432: {\n    comment: \"432: Change the battle track for oArea.\\n- oArea\\n- nTrack\\n\",\n    name: \"MusicBattleChange\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).musicBattleSet(args[1]);\n      }\n    }\n  },\n  433: {\n    comment: \"433: Play the ambient sound for oArea.\\n\",\n    name: \"AmbientSoundPlay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).ambientSoundPlay();\n      }\n    }\n  },\n  434: {\n    comment: \"434: Stop the ambient sound for oArea.\\n\",\n    name: \"AmbientSoundStop\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).ambientSoundStop();\n      }\n    }\n  },\n  435: {\n    comment: \"435: Change the ambient day track for oArea to nTrack.\\n- oArea\\n- nTrack\\n\",\n    name: \"AmbientSoundChangeDay\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).ambientSoundDaySet(args[1]);\n      }\n    }\n  },\n  436: {\n    comment: \"436: Change the ambient night track for oArea to nTrack.\\n- oArea\\n- nTrack\\n\",\n    name: \"AmbientSoundChangeNight\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        (args[0] as ModuleArea).ambientSoundNightSet(args[1]);\n      }\n    }\n  },\n  437: {\n    comment: \"437: Get the object that killed the caller.\\n\",\n    name: \"GetLastKiller\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  438: {\n    comment: \"438: Use this in a spell script to get the item used to cast the spell.\\n\",\n    name: \"GetSpellCastItem\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  439: {\n    comment: \"439: Use this in an OnItemActivated module script to get the item that was activated.\\n\",\n    name: \"GetItemActivated\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  440: {\n    comment: \"440: Use this in an OnItemActivated module script to get the creature that\\nactivated the item.\\n\",\n    name: \"GetItemActivator\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  441: {\n    comment: \"441: Use this in an OnItemActivated module script to get the location of the item's\\ntarget.\\n\",\n    name: \"GetItemActivatedTargetLocation\",\n    type: NWScriptDataType.LOCATION,\n    args: []\n  },\n  442: {\n    comment: \"442: Use this in an OnItemActivated module script to get the item's target.\\n\",\n    name: \"GetItemActivatedTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  443: {\n    comment: \"443: * Returns TRUE if oObject (which is a placeable or a door) is currently open.\\n\",\n    name: \"GetIsOpen\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        return (args[0] as ModuleDoor | ModulePlaceable).isOpen() ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  444: {\n    comment: \"444: Take nAmount of gold from oCreatureToTakeFrom.\\n- nAmount\\n- oCreatureToTakeFrom: If this is not a valid creature, nothing will happen.\\n- bDestroy: If this is TRUE, the caller will not get the gold.  Instead, the\\ngold will be destroyed and will vanish from the game.\\n\",\n    name: \"TakeGoldFromCreature\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, ModuleCreature, number]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n\n        //Remove nGold from the target\n        args[1].removeGold(args[0]);\n\n        //If the gold is returned to the caller\n        if (!args[2] && BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n          this.caller.addGold(args[0]);\n        }\n\n      }\n    }\n  },\n  445: {\n    comment: \"445: Determine whether oObject is in conversation.\\n\",\n    name: \"GetIsInConversation\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].isInConversation();\n      } else {\n        return 0;\n      }\n    }\n  },\n  446: {\n    comment: \"446: Create an Ability Decrease effect.\\n- nAbility: ABILITY_*\\n- nModifyBy: This is the amount by which to decrement the ability\\n\",\n    name: \"EffectAbilityDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectAbilityDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  447: {\n    comment: \"447: Create an Attack Decrease effect.\\n- nPenalty\\n- nModifierType: ATTACK_BONUS_*\\n\",\n    name: \"EffectAttackDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectAttackDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  448: {\n    comment: \"448: Create a Damage Decrease effect.\\n- nPenalty\\n- nDamageType: DAMAGE_TYPE_*\\n\",\n    name: \"EffectDamageDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  449: {\n    comment: \"449: Create a Damage Immunity Decrease effect.\\n- nDamageType: DAMAGE_TYPE_*\\n- nPercentImmunity\\n\",\n    name: \"EffectDamageImmunityDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectDamageImmunityDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      return effect.initialize();\n    }\n  },\n  450: {\n    comment: \"450: Create an AC Decrease effect.\\n- nValue\\n- nModifyType: AC_*\\n- nDamageType: DAMAGE_TYPE_*\\n* Default value for nDamageType should only ever be used in this function prototype.\\n\",\n    name: \"EffectACDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectACDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[1]);\n      effect.setInt(1, args[0]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      effect.setInt(5, args[2]);\n      return effect.initialize();\n    }\n  },\n  451: {\n    comment: \"451: Create a Movement Speed Decrease effect.\\n- nPercentChange: This is expected to be a positive integer between 1 and 99 inclusive.\\nIf a negative integer is supplied then a movement speed increase will result,\\nand if a number >= 100 is supplied then the effect is deleted.\\n\",\n    name: \"EffectMovementSpeedDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectMovementSpeedDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  452: {\n    comment: \"452: Create a Saving Throw Decrease effect.\\n- nSave\\n- nValue\\n- nSaveType: SAVING_THROW_TYPE_*\\n\",\n    name: \"EffectSavingThrowDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectSavingThrowDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[1]);\n      effect.setInt(1, args[0]);\n      effect.setInt(2, args[2]);\n      effect.setInt(3, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  453: {\n    comment: \"453: Create a Skill Decrease effect.\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nSkill is invalid.\\n\",\n    name: \"EffectSkillDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const effect = new GameState.GameEffectFactory.EffectSkillDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, args[1]);\n      effect.setInt(2, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  454: {\n    comment: \"454: Create a Force Resistance Decrease effect.\\n\",\n    name: \"EffectForceResistanceDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectForceResistanceDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  455: {\n    comment: \"455: Determine whether oTarget is a plot object.\\n\",\n    name: \"GetPlotFlag\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        return args[0].plot;\n\n      return 0;\n    }\n  },\n  456: {\n    comment: \"456: Set oTarget's plot object status.\\n\",\n    name: \"SetPlotFlag\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))\n        args[0].plot = !!args[1]\n    }\n  },\n  457: {\n    comment: \"457: Create an Invisibility effect.\\n- nInvisibilityType: INVISIBILITY_TYPE_*\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nInvisibilityType\\nis invalid.\\n\",\n    name: \"EffectInvisibility\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectInvisibility();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  458: {\n    comment: \"458: Create a Concealment effect.\\n- nPercentage: 1-100 inclusive\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nPercentage < 1 or\\nnPercentage > 100.\\n\",\n    name: \"EffectConcealment\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectConcealment();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  459: {\n    comment: \"459: Create a Force Shield that has parameters from the guven index into the forceshields.2da\\n\",\n    name: \"EffectForceShield\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const forceshield = GameState.TwoDAManager.datatables.get('forceshields').rows[args[0]];\n      if (forceshield) {\n        const effect = new GameState.GameEffectFactory.EffectForceShield();\n        effect.setCreator(this.caller);\n        effect.setSpellId(this.getSpellId());\n        effect.setInt(0, args[0]);\n        return effect.initialize();\n      } else {\n        return undefined;\n      }\n    }\n  },\n  460: {\n    comment: \"460: Create a Dispel Magic All effect.\\n\",\n    name: \"EffectDispelMagicAll\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER]\n  },\n  461: {\n    comment: \"461: Cut immediately to placeable camera 'nCameraId' during dialog.  nCameraId must be\\nan existing Placeable Camera ID.  Function only works during Dialog.\\n\",\n    name: \"SetDialogPlaceableCamera\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.CutsceneManager.setPlaceableCamera(args[0]);\n    }\n  },\n  462: {\n    comment: \"462:\\nReturns: TRUE if the player is in 'solo mode' (ie. the party is not supposed to follow the player).\\nFALSE otherwise.\\n\",\n    name: \"GetSoloMode\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.SOLOMODE ? NW_TRUE : NW_FALSE;\n    }\n  },\n  463: {\n    comment: \"463: Create a Disguise effect.\\n- * nDisguiseAppearance: DISGUISE_TYPE_*s\\n\",\n    name: \"EffectDisguise\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectDisguise();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  464: {\n    comment: \"464:\\nReturns the maximum amount of stealth xp available in the area.\\n\",\n    name: \"GetMaxStealthXP\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.stealthXPMax || 0;\n    }\n  },\n  465: {\n    comment: \"465: Create a True Seeing effect.\\n\",\n    name: \"EffectTrueSeeing\",\n    type: NWScriptDataType.EFFECT,\n    args: []\n  },\n  466: {\n    comment: \"466: Create a See Invisible effect.\\n\",\n    name: \"EffectSeeInvisible\",\n    type: NWScriptDataType.EFFECT,\n    args: []\n  },\n  467: {\n    comment: \"467: Create a Time Stop effect.\\n\",\n    name: \"EffectTimeStop\",\n    type: NWScriptDataType.EFFECT,\n    args: []\n  },\n  468: {\n    comment: \"468:\\nSet the maximum amount of stealth xp available in the area.\\n\",\n    name: \"SetMaxStealthXP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.module.area.stealthXPMax = args[0] || 0;\n    }\n  },\n  469: {\n    comment: \"469: Increase the blaster deflection rate, i think...\\n\",\n    name: \"EffectBlasterDeflectionIncrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectBlasterDeflectionIncrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  470: {\n    comment: \"470:decrease the blaster deflection rate\\n\",\n    name: \"EffectBlasterDeflectionDecrease\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectBlasterDeflectionDecrease();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  471: {\n    comment: \"471: Make the creature horified. BOO!\\n\",\n    name: \"EffectHorrified\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      log.info('EffectHorrified', this.caller);\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 8);\n      return effect.initialize();\n    }\n  },\n  472: {\n    comment: \"472: Create a Spell Level Absorption effect.\\n- nMaxSpellLevelAbsorbed: maximum spell level that will be absorbed by the\\neffect\\n- nTotalSpellLevelsAbsorbed: maximum number of spell levels that will be\\nabsorbed by the effect\\n- nSpellSchool: SPELL_SCHOOL_*\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if:\\nnMaxSpellLevelAbsorbed is not between -1 and 9 inclusive, or nSpellSchool\\nis invalid.\\n\",\n    name: \"EffectSpellLevelAbsorption\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  473: {\n    comment: \"473: Create a Dispel Magic Best effect.\\n\",\n    name: \"EffectDispelMagicBest\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER]\n  },\n  474: {\n    comment: \"474:\\nReturns the current amount of stealth xp available in the area.\\n\",\n    name: \"GetCurrentStealthXP\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.stealthXPMax || 0;\n    }\n  },\n  475: {\n    comment: \"475: Get the number of stacked items that oItem comprises.\\n\",\n    name: \"GetNumStackedItems\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return (args[0] as ModuleItem).getStackSize();\n      } else {\n        return 0;\n      }\n    }\n  },\n  476: {\n    comment: \"476: Use this on an NPC to cause all creatures within a 10-metre radius to stop\\nwhat they are doing and sets the NPC's enemies within this range to be\\nneutral towards the NPC. If this command is run on a PC or an object that is\\nnot a creature, nothing will happen.\\n\",\n    name: \"SurrenderToEnemies\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  477: {\n    comment: \"477: Create a Miss Chance effect.\\n- nPercentage: 1-100 inclusive\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nPercentage < 1 or\\nnPercentage > 100.\\n\",\n    name: \"EffectMissChance\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectMissChance();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      effect.setInt(1, GameState.SWRuleSet.racialTypeCount);\n      return effect.initialize();\n    }\n  },\n  478: {\n    comment: \"478:\\nSet the current amount of stealth xp available in the area.\\n\",\n    name: \"SetCurrentStealthXP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.module.area.stealthXP = args[0] || 0;\n    }\n  },\n  479: {\n    comment: \"479: Get the size (CREATURE_SIZE_*) of oCreature.\\n\",\n    name: \"GetCreatureSize\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return (args[0] as ModuleCreature).getAppearance().sizecategory;\n      }\n    }\n  },\n  480: {\n    comment: \"480:\\nAward the stealth xp to the given oTarget.  This will only work on creatures.\\n\",\n    name: \"AwardStealthXP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        (args[0] as ModuleCreature).addXP(GameState.module.area.stealthXP, ExperienceType.STEALTH);\n      }\n    }\n  },\n  481: {\n    comment: \"481:\\nReturns whether or not the stealth xp bonus is enabled (ie. whether or not\\nAwardStealthXP() will actually award any available stealth xp).\\n\",\n    name: \"GetStealthXPEnabled\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.stealthXPEnabled ? 1 : 0;\n    }\n  },\n  482: {\n    comment: \"482:\\nSets whether or not the stealth xp bonus is enabled (ie. whether or not\\nAwardStealthXP() will actually award any available stealth xp).\\n\",\n    name: \"SetStealthXPEnabled\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.module.area.setStealthXPEnabled(!!args[0]);\n    }\n  },\n  483: {\n    comment: \"483: The action subject will unlock oTarget, which can be a door or a placeable\\nobject.\\n\",\n    name: \"ActionUnlockObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor) && !BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionUnlockObject();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  484: {\n    comment: \"484: The action subject will lock oTarget, which can be a door or a placeable\\nobject.\\n\",\n    name: \"ActionLockObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor) && !BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionLockObject();\n      action.setParameter(0, ActionParameterType.DWORD, args[0]);\n      this.caller.actionQueue.add(action);\n    }\n  },\n  485: {\n    comment: \"485: Create a Modify Attacks effect to add attacks.\\n- nAttacks: maximum is 5, even with the effect stacked\\n* Returns an effect of type EFFECT_TYPE_INVALIDEFFECT if nAttacks > 5.\\n\",\n    name: \"EffectModifyAttacks\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER]\n  },\n  486: {\n    comment: \"486: Get the last trap detected by oTarget.\\n* Return value on error: OBJECT_INVALID\\n\",\n    name: \"GetLastTrapDetected\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  487: {\n    comment: \"487: Create a Damage Shield effect which does (nDamageAmount + nRandomAmount)\\ndamage to any melee attacker on a successful attack of damage type nDamageType.\\n- nDamageAmount: an integer value\\n- nRandomAmount: DAMAGE_BONUS_*\\n- nDamageType: DAMAGE_TYPE_*\\n\",\n    name: \"EffectDamageShield\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  488: {\n    comment: \"488: Get the trap nearest to oTarget.\\nNote : 'trap objects' are actually any trigger, placeable or door that is\\ntrapped in oTarget's area.\\n- oTarget\\n- nTrapDetected: if this is TRUE, the trap returned has to have been detected\\nby oTarget.\\n\",\n    name: \"GetNearestTrapToObject\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  489: {\n    comment: \"489: the will get the last attmpted movment target\\n\",\n    name: \"GetAttemptedMovementTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return;\n    }\n  },\n  490: {\n    comment: \"490: this function returns the bloking creature for the k_def_CBTBlk01 script\\n\",\n    name: \"GetBlockingCreature\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].collisionManager.blockingObject;\n      }\n      return undefined;\n    }\n  },\n  491: {\n    comment: \"491: Get oTarget's base fortitude saving throw value (this will only work for\\ncreatures, doors, and placeables).\\n* Returns 0 if oTarget is invalid.\\n\",\n    name: \"GetFortitudeSavingThrow\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  492: {\n    comment: \"492: Get oTarget's base will saving throw value (this will only work for creatures,\\ndoors, and placeables).\\n* Returns 0 if oTarget is invalid.\\n\",\n    name: \"GetWillSavingThrow\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  493: {\n    comment: \"493: Get oTarget's base reflex saving throw value (this will only work for\\ncreatures, doors, and placeables).\\n* Returns 0 if oTarget is invalid.\\n\",\n    name: \"GetReflexSavingThrow\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  494: {\n    comment: \"494: Get oCreature's challenge rating.\\n* Returns 0.0 if oCreature is invalid.\\n\",\n    name: \"GetChallengeRating\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  495: {\n    comment: \"495: Returns the found enemy creature on a pathfind.\\n\",\n    name: \"GetFoundEnemyCreature\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  496: {\n    comment: \"496: Get oCreature's movement rate.\\n* Returns 0 if oCreature is invalid.\\n\",\n    name: \"GetMovementRate\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  497: {\n    comment: \"497: GetSubRace of oCreature\\nReturns SUBRACE_*\\n\",\n    name: \"GetSubRace\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature))) return 0;\n      return (args[0] as ModuleCreature).getSubRace();\n    }\n  },\n  498: {\n    comment: \"498:\\nReturns the amount the stealth xp bonus gets decreased each time the player is detected.\\n\",\n    name: \"GetStealthXPDecrement\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.stealthXPLoss || 0;\n    }\n  },\n  499: {\n    comment: \"499:\\nSets the amount the stealth xp bonus gets decreased each time the player is detected.\\n\",\n    name: \"SetStealthXPDecrement\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.module.area.stealthXPLoss = args[0] || 0;\n    }\n  },\n  500: {\n    comment: \"500:\\n\",\n    name: \"DuplicateHeadAppearance\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  501: {\n    comment: \"501: The action subject will fake casting a spell at oTarget; the conjure and cast\\nanimations and visuals will occur, nothing else.\\n- nSpell\\n- oTarget\\n- nProjectilePathType: PROJECTILE_PATH_TYPE_*\\n\",\n    name: \"ActionCastFakeSpellAtObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  502: {\n    comment: \"502: The action subject will fake casting a spell at lLocation; the conjure and\\ncast animations and visuals will occur, nothing else.\\n- nSpell\\n- lTarget\\n- nProjectilePathType: PROJECTILE_PATH_TYPE_*\\n\",\n    name: \"ActionCastFakeSpellAtLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER]\n  },\n  503: {\n    comment: \"503: CutsceneAttack\\nThis function allows the designer to specify exactly what's going to happen in a combat round\\nThere are no guarentees made that the animation specified here will be correct - only that it will be played,\\nso it is up to the designer to ensure that they have selected the right animation\\nIt relies upon constants specified above for the attack result\\n\",\n    name: \"CutsceneAttack\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        this.caller.attackCreature(args[0], undefined, true, args[3], GameState.TwoDAManager.datatables.get('animations').rows[args[1]].name, args[2]);\n      } else {\n        log.error('attackCreature', args[0]);\n      }\n    }\n  },\n  504: {\n    comment: \"504: Set the camera mode for oPlayer.\\n- oPlayer\\n- nCameraMode: CAMERA_MODE_*\\n* If oPlayer is not player-controlled or nCameraMode is invalid, nothing\\nhappens.\\n\",\n    name: \"SetCameraMode\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  505: {\n    comment: \"505: SetLockOrientationInDialog\\nAllows the locking and unlocking of orientation changes for an object in dialog\\n- oObject - Object\\n- nValue - TRUE or FALSE\\n\",\n    name: \"SetLockOrientationInDialog\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        args[0].lockDialogOrientation = args[1] ? true : false;\n      }\n    }\n  },\n  506: {\n    comment: \"506: SetLockHeadFollowInDialog\\nAllows the locking and undlocking of head following for an object in dialog\\n- oObject - Object\\n- nValue - TRUE or FALSE\\n\",\n    name: \"SetLockHeadFollowInDialog\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  507: {\n    comment: \"507: CutsceneMoveToPoint\\nUsed by the cutscene system to allow designers to script combat\\n\",\n    name: \"CutsceneMove\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.VECTOR, NWScriptDataType.INTEGER]\n  },\n  508: {\n    comment: \"508: EnableVideoEffect\\nEnables the video frame buffer effect specified by nEffectType, which is\\nan index into VideoEffects.2da. This video effect will apply indefinitely,\\nand so it should *always* be cleared by a call to DisableVideoEffect().\\n\",\n    name: \"EnableVideoEffect\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.VideoEffectManager.SetVideoEffect(!isNaN(args[0]) ? args[0] : -1);\n    }\n  },\n  509: {\n    comment: \"509: Shut down the currently loaded module and start a new one (moving all\\ncurrently-connected players to the starting point.\\n\",\n    name: \"StartNewModule\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string, string, string, string, string, string, string, string]) {\n      GameState.LoadModule(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n    }\n  },\n  510: {\n    comment: \"510: DisableVideoEffect\\nDisables any video frame buffer effect that may be running. See\\nEnableVideoEffect() to see how to use them.\\n\",\n    name: \"DisableVideoEffect\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      GameState.VideoEffectManager.SetVideoEffect(-1);\n    }\n  },\n  511: {\n    comment: \"511: * Returns TRUE if oItem is a ranged weapon.\\n\",\n    name: \"GetWeaponRanged\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleItem)) {\n        return (args[0] as ModuleItem).getWeaponType() == 4 ? true : false;\n      }\n      return false;\n    }\n  },\n  512: {\n    comment: \"512: Only if we are in a single player game, AutoSave the game.\\n\",\n    name: \"DoSinglePlayerAutoSave\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  513: {\n    comment: \"513: Get the game difficulty (GAME_DIFFICULTY_*).\\n\",\n    name: \"GetGameDifficulty\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.SWRuleSet.currentDifficulty;\n    }\n  },\n  514: {\n    comment: \"514:\\nThis will test the combat action queue to see if the user has placed any actions on the queue.\\nwill only work during combat.\\n\",\n    name: \"GetUserActionsPending\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      //This will kinda work for now but I think it is supposed to check if any actions in the queue were set by the player\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        return this.caller.combatData.combatQueue.length ? NW_TRUE : NW_FALSE;//this.caller.actionQueue.length ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  515: {\n    comment: \"515: RevealMap\\nReveals the map at the given WORLD point 'vPoint' with a MAP Grid Radius 'nRadius'\\nIf this function is called with no parameters it will reveal the entire map.\\n(NOTE: if this function is called with a valid point but a default radius, ie. 'nRadius' of -1\\nthen the entire map will be revealed)\\n\",\n    name: \"RevealMap\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3, number]) {\n      GameState.module.area.areaMap.revealPosition(args[0].x, args[0].y, args[1]);\n    }\n  },\n  516: {\n    comment: \"516: SetTutorialWindowsEnabled\\nSets whether or not the tutorial windows are enabled (ie. whether or not they will\\nappear when certain things happen for the first time).\\n\",\n    name: \"SetTutorialWindowsEnabled\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  517: {\n    comment: \"517: ShowTutorialWindow\\nPops up the specified tutorial window.  If the tutorial window has already popped\\nup once before, this will do nothing.\\n\",\n    name: \"ShowTutorialWindow\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      //KotOR unlike TSL hardcodes these values instead of using the tutorial.2da as a lookup table\n      //It might be worth overriding the scripts in the game to use 2da values to keep it inline with TSL\n      //making it more extendable.\n      switch (args[0]) {\n        case 2: //Movement_Keys - end_m01aa - k_pend_pctut.ncs\n          GameState.MenuManager.InGameConfirm.ShowTutorialMessage(42);\n          break;\n        case 1:\n          // ???\n          break;\n        case 0: //Start_Swoop_Race - tar_m03mg - heartbeat.ncs\n          GameState.MenuManager.InGameConfirm.ShowTutorialMessage(9);\n          break;\n        default:\n          // ???\n          break;\n      }\n    }\n  },\n  518: {\n    comment: \"518: StartCreditSequence\\nStarts the credits sequence.  If bTransparentBackground is TRUE, the credits will be displayed\\nwith a transparent background, allowing whatever is currently onscreen to show through.  If it\\nis set to FALSE, the credits will be displayed on a black background.\\n\",\n    name: \"StartCreditSequence\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  519: {\n    comment: \"519: IsCreditSequenceInProgress\\nReturns TRUE if the credits sequence is currently in progress, FALSE otherwise.\\n\",\n    name: \"IsCreditSequenceInProgress\",\n    type: NWScriptDataType.INTEGER,\n    args: []\n  },\n  520: {\n    comment: \"520: Sets the minigame lateral acceleration/sec value\\n\",\n    name: \"SWMG_SetLateralAccelerationPerSecond\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const p = GameState.module?.area?.miniGame?.player;\n      if (p) p.accel_lateral_secs = args[0];\n    }\n  },\n  521: {\n    comment: \"521: Returns the minigame lateral acceleration/sec value\\n\",\n    name: \"SWMG_GetLateralAccelerationPerSecond\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const p = GameState.module?.area?.miniGame?.player;\n      return (p != null && typeof p.accel_lateral_secs === 'number') ? p.accel_lateral_secs : 0;\n    }\n  },\n  522: {\n    comment: \"522: Get the current action (ACTION_*) that oObject is executing.\\n\",\n    name: \"GetCurrentAction\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n\n      if (args[0] == undefined)\n        args[0] = this.caller;\n\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n\n        const action = args[0].actionQueue[0];\n        if (action) {\n          switch (action.type) {\n            case ActionType.ActionMoveToPoint: return 0;\n            case ActionType.ActionPickUpItem: return 1;\n            case ActionType.ActionDropItem: return 2;\n            case ActionType.ActionPhysicalAttacks: return 3;\n            case ActionType.ActionCastSpell: return 4;\n            case ActionType.ActionItemCastSpell: return 4;\n            case ActionType.ActionOpenDoor: return 5;\n            case ActionType.ActionCloseDoor: return 6;\n            case ActionType.ActionDialogObject: return 7;\n            case ActionType.ActionDisarmMine: return 8;\n            case ActionType.ActionRecoverMine: return 9;\n            case ActionType.ActionFlagMine: return 10;\n            case ActionType.ActionExamineMine: return 11;\n            case ActionType.ActionSetMine: return 12;\n            case ActionType.ActionUnlockObject: return 13;\n            case ActionType.ActionLockObject: return 14;\n            case ActionType.ActionUseObject: return 15;\n            //case ActionType.ActionAnimalEmpathy: return 16;\n            //case ActionType.ActionRest: return 17;\n            //case ActionType.ActionTaunt: return 18;\n            case ActionType.ActionItemCastSpell: return 19;\n            case ActionType.ActionCounterSpell: return 31;\n            case ActionType.ActionHeal: return 33;\n            //case ActionType.ActionPickPocket: return 34;\n            case ActionType.ActionForceFollowObject: return 35;\n            case ActionType.ActionWait: return 36;\n            //case ActionType.ActionSit: return 37;\n            case ActionType.ActionFollowLeader: return 38;\n          }\n        } else {\n          return 65534; //Empty\n        }\n      }\n\n      return 65535; //Invalid\n    }\n  },\n  523: {\n    comment: \"523:\\n\",\n    name: \"GetDifficultyModifier\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const multiplier = GameState.SWRuleSet.difficulty[GameState.SWRuleSet.currentDifficulty]?.multiplier;\n      return !isNaN(multiplier) ? multiplier : 1;\n    }\n  },\n  524: {\n    comment: \"524: Returns the appearance type of oCreature (0 if creature doesn't exist)\\n- oCreature\\n\",\n    name: \"GetAppearanceType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].appearance;\n      }\n      return 0;\n    }\n  },\n  525: {\n    comment: \"525: Display floaty text above the specified creature.\\nThe text will also appear in the chat buffer of each player that receives the\\nfloaty text.\\n- nStrRefToDisplay: String ref (therefore text is translated)\\n- oCreatureToFloatAbove\\n- bBroadcastToFaction: If this is TRUE then only creatures in the same faction\\nas oCreatureToFloatAbove\\nwill see the floaty text, and only if they are within range (30 metres).\\n\",\n    name: \"FloatingTextStrRefOnCreature\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  526: {\n    comment: \"526: Display floaty text above the specified creature.\\nThe text will also appear in the chat buffer of each player that receives the\\nfloaty text.\\n- sStringToDisplay: String\\n- oCreatureToFloatAbove\\n- bBroadcastToFaction: If this is TRUE then only creatures in the same faction\\nas oCreatureToFloatAbove\\nwill see the floaty text, and only if they are within range (30 metres).\\n\",\n    name: \"FloatingTextStringOnCreature\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  527: {\n    comment: \"527: - oTrapObject: a placeable, door or trigger\\n* Returns TRUE if oTrapObject is disarmable.\\n\",\n    name: \"GetTrapDisarmable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapDisarmable ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  528: {\n    comment: \"528: - oTrapObject: a placeable, door or trigger\\n* Returns TRUE if oTrapObject is detectable.\\n\",\n    name: \"GetTrapDetectable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapDetectable ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  529: {\n    comment: \"529: - oTrapObject: a placeable, door or trigger\\n- oCreature\\n* Returns TRUE if oCreature has detected oTrapObject\\n\",\n    name: \"GetTrapDetectedBy\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  530: {\n    comment: \"530: - oTrapObject: a placeable, door or trigger\\n* Returns TRUE if oTrapObject has been flagged as visible to all creatures.\\n\",\n    name: \"GetTrapFlagged\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapFlag ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  531: {\n    comment: \"531: Get the trap base type (TRAP_BASE_TYPE_*) of oTrapObject.\\n- oTrapObject: a placeable, door or trigger\\n\",\n    name: \"GetTrapBaseType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapType;\n      }\n      return -1;\n    }\n  },\n  532: {\n    comment: \"532: - oTrapObject: a placeable, door or trigger\\n* Returns TRUE if oTrapObject is one-shot (i.e. it does not reset itself\\nafter firing.\\n\",\n    name: \"GetTrapOneShot\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapOneShot ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  533: {\n    comment: \"533: Get the creator of oTrapObject, the creature that set the trap.\\n- oTrapObject: a placeable, door or trigger\\n* Returns OBJECT_INVALID if oTrapObject was created in the toolset.\\n\",\n    name: \"GetTrapCreator\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT]\n  },\n  534: {\n    comment: \"534: Get the tag of the key that will disarm oTrapObject.\\n- oTrapObject: a placeable, door or trigger\\n\",\n    name: \"GetTrapKeyTag\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT]\n  },\n  535: {\n    comment: \"535: Get the DC for disarming oTrapObject.\\n- oTrapObject: a placeable, door or trigger\\n\",\n    name: \"GetTrapDisarmDC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapDisarmDC;\n      }\n      return NW_FALSE;\n    }\n  },\n  536: {\n    comment: \"536: Get the DC for detecting oTrapObject.\\n- oTrapObject: a placeable, door or trigger\\n\",\n    name: \"GetTrapDetectDC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].trapDetectDC;\n      }\n      return NW_FALSE;\n    }\n  },\n  537: {\n    comment: \"537: * Returns TRUE if a specific key is required to open the lock on oObject.\\n\",\n    name: \"GetLockKeyRequired\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  538: {\n    comment: \"538: Get the tag of the key that will open the lock on oObject.\\n\",\n    name: \"GetLockKeyTag\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  539: {\n    comment: \"539: * Returns TRUE if the lock on oObject is lockable.\\n\",\n    name: \"GetLockLockable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  540: {\n    comment: \"540: Get the DC for unlocking oObject.\\n\",\n    name: \"GetLockUnlockDC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  541: {\n    comment: \"541: Get the DC for locking oObject.\\n\",\n    name: \"GetLockLockDC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  542: {\n    comment: \"542: Get the last PC that levelled up.\\n\",\n    name: \"GetPCLevellingUp\",\n    type: NWScriptDataType.OBJECT,\n    args: []\n  },\n  543: {\n    comment: \"543: - nFeat: FEAT_*\\n- oObject\\n* Returns TRUE if oObject has effects on it originating from nFeat.\\n\",\n    name: \"GetHasFeatEffect\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT]\n  },\n  544: {\n    comment: \"544: Set the status of the illumination for oPlaceable.\\n- oPlaceable\\n- bIlluminate: if this is TRUE, oPlaceable's illumination will be turned on.\\nIf this is FALSE, oPlaceable's illumination will be turned off.\\nNote: You must call RecomputeStaticLighting() after calling this function in\\norder for the changes to occur visually for the players.\\nSetPlaceableIllumination() buffers the illumination changes, which are then\\nsent out to the players once RecomputeStaticLighting() is called.  As such,\\nit is best to call SetPlaceableIllumination() for all the placeables you wish\\nto set the illumination on, and then call RecomputeStaticLighting() once after\\nall the placeable illumination has been set.\\n* If oPlaceable is not a placeable object, or oPlaceable is a placeable that\\ndoesn't have a light, nothing will happen.\\n\",\n    name: \"SetPlaceableIllumination\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  545: {\n    comment: \"545: * Returns TRUE if the illumination for oPlaceable is on\\n\",\n    name: \"GetPlaceableIllumination\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  546: {\n    comment: \"546: - oPlaceable\\n- nPlaceableAction: PLACEABLE_ACTION_*\\n* Returns TRUE if nPlacebleAction is valid for oPlaceable.\\n\",\n    name: \"GetIsPlaceableObjectActionPossible\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        if ((args[0] as ModulePlaceable).isDead()) {\n          return false;\n        }\n        switch (args[1]) {\n          //PLACEABLE_ACTION_OPEN\n          case 0: return !(args[0] as ModulePlaceable).locked;\n          //PLACEABLE_ACTION_UNLOCK_OBJECT\n          case 1: return (args[0] as ModulePlaceable).locked;\n          //PLACEABLE_ACTION_BASH\n          case 2: return (args[0] as ModulePlaceable).locked;\n          //PLACEABLE_ACTION_KNOCK\n          case 3: return (args[0] as ModulePlaceable).locked;\n        }\n      }\n      return 0;\n    }\n  },\n  547: {\n    comment: \"547: The caller performs nPlaceableAction on oPlaceable.\\n- oPlaceable\\n- nPlaceableAction: PLACEABLE_ACTION_*\\n\",\n    name: \"DoPlaceableObjectAction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        switch (args[1]) {\n          //PLACEABLE_ACTION_OPEN\n          case 0: (args[0] as ModulePlaceable).use(this.caller);\n            break;\n          //PLACEABLE_ACTION_UNLOCK_OBJECT\n          case 1: (args[0] as ModulePlaceable).attemptUnlock(this.caller);\n            break;\n          //PLACEABLE_ACTION_BASH\n          case 2: (this.caller as ModuleCreature).attackCreature(args[0] as ModulePlaceable); break;\n          //PLACEABLE_ACTION_KNOCK\n          case 3:\n            // (args[0] as ModulePlaceable).actionUseObject(this.caller);\n            break;\n        }\n      }\n    }\n  },\n  548: {\n    comment: \"548: Get the first PC in the player list.\\nThis resets the position in the player list for GetNextPC().\\n\",\n    name: \"GetFirstPC\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.PartyManager.party[0];\n    }\n  },\n  549: {\n    comment: \"549: Get the next PC in the player list.\\nThis picks up where the last GetFirstPC() or GetNextPC() left off.\\n\",\n    name: \"GetNextPC\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return;\n    }\n  },\n  550: {\n    comment: \"550: Set oDetector to have detected oTrap.\\n\",\n    name: \"SetTrapDetectedBy\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  551: {\n    comment: \"551: Note: Only placeables, doors and triggers can be trapped.\\n* Returns TRUE if oObject is trapped.\\n\",\n    name: \"GetIsTrapped\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleTrigger) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleDoor) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModulePlaceable)) {\n        return (args[0] as ModuleTrigger).trapFlag ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  552: {\n    comment: \"552: SetEffectIcon\\nThis will link the specified effect icon to the specified effect.  The\\neffect returned will contain the link to the effect icon and applying this\\neffect will cause an effect icon to appear on the portrait/charsheet gui.\\neEffect: The effect which should cause the effect icon to appear.\\nnIcon: Index into effecticon.2da of the effect icon to use.\\n\",\n    name: \"SetEffectIcon\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.EFFECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [GameEffect, number]) {\n      const eIcon = new GameState.GameEffectFactory.EffectIcon();\n      eIcon.setCreator(this.caller);\n      eIcon.setSpellId(this.getSpellId());\n      eIcon.setInt(0, args[1]);\n      eIcon.initialize();\n\n      const eLink = new GameState.GameEffectFactory.EffectLink(args[0], eIcon);\n      eLink.setCreator(this.caller);\n      eLink.setSpellId(this.getSpellId());\n      return eLink.initialize();\n    }\n  },\n  553: {\n    comment: \"553: FaceObjectAwayFromObject\\nThis will cause the object oFacer to face away from oObjectToFaceAwayFrom.\\nThe objects must be in the same area for this to work.\\n\",\n    name: \"FaceObjectAwayFromObject\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  554: {\n    comment: \"554: Spawn in the Death GUI.\\nThe default (as defined by BioWare) can be spawned in by PopUpGUIPanel, but\\nif you want to turn off the 'Respawn' or 'Wait for Help' buttons, this is the\\nfunction to use.\\n- oPC\\n- bRespawnButtonEnabled: if this is TRUE, the 'Respawn' button will be enabled\\non the Death GUI.\\n- bWaitForHelpButtonEnabled: if this is TRUE, the 'Wait For Help' button will\\nbe enabled on the Death GUI.\\n- nHelpStringReference\\n- sHelpString\\n\",\n    name: \"PopUpDeathGUIPanel\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.STRING]\n  },\n  555: {\n    comment: \"555: Disable oTrap.\\n- oTrap: a placeable, door or trigger.\\n\",\n    name: \"SetTrapDisabled\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT]\n  },\n  556: {\n    comment: \"556: Get the last object that was sent as a GetLastAttacker(), GetLastDamager(),\\nGetLastSpellCaster() (for a hostile spell), or GetLastDisturbed() (when a\\ncreature is pickpocketed).\\nNote: Return values may only ever be:\\n1) A Creature\\n2) Plot Characters will never have this value set\\n3) Area of Effect Objects will return the AOE creator if they are registered\\nas this value, otherwise they will return INVALID_OBJECT_ID\\n4) Traps will not return the creature that set the trap.\\n5) This value will never be overwritten by another non-creature object.\\n6) This value will never be a dead/destroyed creature\\n\",\n    name: \"GetLastHostileActor\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n\n      if (typeof args[0] == 'undefined')\n        return undefined;\n\n      return args[0].combatData.lastAttackTarget || args[0].combatData.lastAttacker || args[0].combatData.lastDamager || undefined;\n    }\n  },\n  557: {\n    comment: \"557: Force all the characters of the players who are currently in the game to\\nbe exported to their respective directories i.e. LocalVault/ServerVault/ etc.\\n\",\n    name: \"ExportAllCharacters\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  558: {\n    comment: \"558: Get the Day Track for oArea.\\n\",\n    name: \"MusicBackgroundGetDayTrack\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        return (args[0] as ModuleArea).audio.music.day;\n      }\n      return -1;\n    }\n  },\n  559: {\n    comment: \"559: Get the Night Track for oArea.\\n\",\n    name: \"MusicBackgroundGetNightTrack\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        return (args[0] as ModuleArea).audio.music.night;\n      }\n      return -1;\n    }\n  },\n  560: {\n    comment: \"560: Write sLogEntry as a timestamped entry into the log file\\n\",\n    name: \"WriteTimestampedLogEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING]\n  },\n  561: {\n    comment: \"561: Get the module's name in the language of the server that's running it.\\n* If there is no entry for the language of the server, it will return an\\nempty string\\n\",\n    name: \"GetModuleName\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.name.getValue();\n    }\n  },\n  562: {\n    comment: \"562: Get the leader of the faction of which oMemberOfFaction is a member.\\n* Returns OBJECT_INVALID if oMemberOfFaction is not a valid creature.\\n\",\n    name: \"GetFactionLeader\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      //https://nwnlexicon.com/index.php/GetFactionLeader\n      return GameState.FactionManager.GetFactionLeader(args[0]);\n    }\n  },\n  563: {\n    comment: \"563: Turns on or off the speed blur effect in rendered scenes.\\nbEnabled: Set TRUE to turn it on, FALSE to turn it off.\\nfRatio: Sets the frame accumulation ratio.\\n\",\n    name: \"SWMG_SetSpeedBlurEffect\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const bEnabled = !!args[0];\n      const fRatio = (args.length > 1 && typeof args[1] === 'number' && !isNaN(args[1])) ? args[1] : 0.75;\n      GameState.VideoEffectManager.SetSpeedBlurEffect(bEnabled, fRatio);\n    }\n  },\n  564: {\n    comment: \"564: Immediately ends the currently running game and returns to the start screen.\\nnShowEndGameGui: Set TRUE to display the death gui.\\n\",\n    name: \"EndGame\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  565: {\n    comment: \"565: Get a variable passed when calling console debug runscript\\n\",\n    name: \"GetRunScriptVar\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.scriptVar;\n    }\n  },\n  566: {\n    comment: \"566: This function returns a value that matches one of the MOVEMENT_SPEED_... constants\\nif the OID passed in is not found or not a creature then it will return\\nMOVEMENT_SPEED_IMMOBILE.\\n\",\n    name: \"GetCreatureMovmentType\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if (args[0].isDebilitated()) {\n          return 1; //IMMOBILE\n        } else {\n          return 0; //PC\n        }\n      }\n      return 1; //IMMOBILE\n    }\n  },\n  567: {\n    comment: \"567: Set the ambient day volume for oArea to nVolume.\\n- oArea\\n- nVolume: 0 - 100\\n\",\n    name: \"AmbientSoundSetDayVolume\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        const audioEngine = AudioEngine.GetAudioEngine();\n        audioEngine.ambientAudioDayEmitter.setVolume(args[1] / 100);\n      }\n    }\n  },\n  568: {\n    comment: \"568: Set the ambient night volume for oArea to nVolume.\\n- oArea\\n- nVolume: 0 - 100\\n\",\n    name: \"AmbientSoundSetNightVolume\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        const audioEngine = AudioEngine.GetAudioEngine();\n        audioEngine.ambientAudioDayEmitter.setVolume(args[1] / 100);\n      }\n    }\n  },\n  569: {\n    comment: \"569: Get the Battle Track for oArea.\\n\",\n    name: \"MusicBackgroundGetBattleTrack\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleArea)) {\n        return (args[0] as ModuleArea).audio.music.battle;\n      }\n      return -1;\n    }\n  },\n  570: {\n    comment: \"570: Determine whether oObject has an inventory.\\n* Returns TRUE for creatures and stores, and checks to see if an item or placeable object is a container.\\n* Returns FALSE for all other object types.\\n\",\n    name: \"GetHasInventory\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT]\n  },\n  571: {\n    comment: \"571: Get the duration (in seconds) of the sound attached to nStrRef\\n* Returns 0.0f if no duration is stored or if no sound is attached\\n\",\n    name: \"GetStrRefSoundDuration\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.INTEGER]\n  },\n  572: {\n    comment: \"572: Add oPC to oPartyLeader's party.  This will only work on two PCs.\\n- oPC: player to add to a party\\n- oPartyLeader: player already in the party\\n\",\n    name: \"AddToParty\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT]\n  },\n  573: {\n    comment: \"573: Remove oPC from their current party. This will only work on a PC.\\n- oPC: removes this player from whatever party they're currently in.\\n\",\n    name: \"RemoveFromParty\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT]\n  },\n  574: {\n    comment: \"574: Adds a creature to the party\\nReturns whether the addition was successful\\nAddPartyMember\\n\",\n    name: \"AddPartyMember\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        GameState.PartyManager.AddCreatureToParty(args[0], (args[1] as ModuleCreature));\n        return NW_TRUE;\n      }\n      return NW_FALSE;\n    }\n  },\n  575: {\n    comment: \"575: Removes a creature from the party\\nReturns whether the removal was syccessful\\nRemovePartyMember\\n\",\n    name: \"RemovePartyMember\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.PartyManager.RemoveNPCById(args[0], true);\n      return 0;\n    }\n  },\n  576: {\n    comment: \"576: Returns whether a specified creature is a party member\\nIsObjectPartyMember\\n\",\n    name: \"IsObjectPartyMember\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      return (GameState.PartyManager.party.indexOf(args[0]) >= 0 || args[0] == GameState.PartyManager.Player ? NW_TRUE : NW_FALSE);\n    }\n  },\n  577: {\n    comment: \"577: Returns the party member at a given index in the party.\\nThe order of members in the party can vary based on\\nwho the current leader is (member 0 is always the current\\nparty leader).\\nGetPartyMemberByIndex\\n\",\n    name: \"GetPartyMemberByIndex\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return GameState.PartyManager.party[args[0]];\n    }\n  },\n  578: {\n    comment: \"578: GetGlobalBoolean\\nThis function returns the value of a global boolean (TRUE or FALSE) scripting variable.\\n\",\n    name: \"GetGlobalBoolean\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.GlobalVariableManager.GetGlobalBoolean(args[0],) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  579: {\n    comment: \"579: SetGlobalBoolean\\nThis function sets the value of a global boolean (TRUE or FALSE) scripting variable.\\n\",\n    name: \"SetGlobalBoolean\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      GameState.GlobalVariableManager.SetGlobalBoolean(args[0], !!args[1]);\n    }\n  },\n  580: {\n    comment: \"580: GetGlobalNumber\\nThis function returns the value of a global number (-128 to +127) scripting variable.\\n\",\n    name: \"GetGlobalNumber\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.GlobalVariableManager.GetGlobalNumber(args[0]);\n    }\n  },\n  581: {\n    comment: \"581: SetGlobalNumber\\nThis function sets the value of a global number (-128 to +127) scripting variable.\\n\",\n    name: \"SetGlobalNumber\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      GameState.GlobalVariableManager.SetGlobalNumber(args[0], args[1]);\n    }\n  },\n  582: {\n    comment: \"post a string to the screen at column nX and row nY for fLife seconds\\n582. AurPostString\\n\",\n    name: \"AurPostString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [string, number, number, number]) {\n      log.info('AurPostString', args[0]);\n    }\n  },\n  583: {\n    comment: \"583: OnAnimKey\\nget the event and the name of the model on which the event happened\\nSWMG_GetLastEvent\\n\",\n    name: \"SWMG_GetLastEvent\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastAnimEvent ?? '';\n    }\n  },\n  584: {\n    comment: \"584: SWMG_GetLastEventModelName\\n\",\n    name: \"SWMG_GetLastEventModelName\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastAnimEventModelName ?? '';\n    }\n  },\n  585: {\n    comment: \"585: gets an object by its name (duh!)\\nSWMG_GetObjectByName\\n\",\n    name: \"SWMG_GetObjectByName\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (!mg) return undefined;\n      const name = (args[0] || '').toLowerCase();\n      for (let i = 0; i < mg.obstacles.length; i++) {\n        if ((mg.obstacles[i].name || '').toLowerCase() === name) return mg.obstacles[i];\n      }\n      for (let i = 0; i < mg.enemies.length; i++) {\n        if ((mg.enemies[i].name || '').toLowerCase() === name) return mg.enemies[i];\n      }\n      if (mg.player && (mg.player.name || '').toLowerCase() === name) return mg.player;\n      return undefined;\n    }\n  },\n  586: {\n    comment: \"586: plays an animation on an object\\nSWMG_PlayAnimation\\n\",\n    name: \"SWMG_PlayAnimation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, string, number, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy)) {\n        (args[0] as ModuleMGPlayer | ModuleMGEnemy).playAnimation(args[1], args[2], args[3], args[4]);\n      }\n    }\n  },\n  587: {\n    comment: \"587: OnHitBullet\\nget the damage, the target type (see TARGETflags), and the shooter\\nSWMG_GetLastBulletHitDamage\\n\",\n    name: \"SWMG_GetLastBulletHitDamage\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastBulletHitDamage ?? 0;\n    }\n  },\n  588: {\n    comment: \"588: SWMG_GetLastBulletHitTarget\\n\",\n    name: \"SWMG_GetLastBulletHitTarget\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      return (mg?.lastBulletHitTarget && BitWise.InstanceOfObject(mg.lastBulletHitTarget, ModuleObjectType.ModuleMGEnemy)) ? 1 : 0;\n    }\n  },\n  589: {\n    comment: \"589: SWMG_GetLastBulletHitShooter\\n\",\n    name: \"SWMG_GetLastBulletHitShooter\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastBulletHitShooter;\n    }\n  },\n  590: {\n    comment: \"590: adjusts a followers hit points, can specify the absolute value to set to\\nSWMG_AdjustFollowerHitPoints\\n\",\n    name: \"SWMG_AdjustFollowerHitPoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer)) {\n        (args[0] as ModuleMGPlayer | ModuleMGEnemy | ModuleMGObstacle).adjustHitPoints(args[1], args[2]);\n      }\n    }\n  },\n  591: {\n    comment: \"591: the default implementation of OnBulletHit\\nSWMG_OnBulletHit\\n\",\n    name: \"SWMG_OnBulletHit\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        //return this.caller.onBulletHit();\n      }\n    }\n  },\n  592: {\n    comment: \"592: the default implementation of OnObstacleHit\\nSWMG_OnObstacleHit\\n\",\n    name: \"SWMG_OnObstacleHit\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleMGObstacle)) {\n        //return this.caller.onObstacleHit();\n      }\n    }\n  },\n  593: {\n    comment: \"593: returns the last follower and obstacle hit\\nSWMG_GetLastFollowerHit\\n\",\n    name: \"SWMG_GetLastFollowerHit\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.mgFollower || undefined;\n    }\n  },\n  594: {\n    comment: \"594: SWMG_GetLastObstacleHit\\n\",\n    name: \"SWMG_GetLastObstacleHit\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return this.mgObstacle || undefined;\n    }\n  },\n  595: {\n    comment: \"595: gets information about the last bullet fired\\nSWMG_GetLastBulletFiredDamage\\n\",\n    name: \"SWMG_GetLastBulletFiredDamage\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastBulletFiredDamage ?? 0;\n    }\n  },\n  596: {\n    comment: \"596: SWMG_GetLastBulletFiredTarget\\n\",\n    name: \"SWMG_GetLastBulletFiredTarget\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastBulletFiredTarget ?? 0;\n    }\n  },\n  597: {\n    comment: \"597: gets an objects name\\nSWMG_GetObjectName\\n\",\n    name: \"SWMG_GetObjectName\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].name || '';\n      }\n      return '';\n    }\n  },\n  598: {\n    comment: \"598: the default implementation of OnDeath\\nSWMG_OnDeath\\n\",\n    name: \"SWMG_OnDeath\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        //this.caller.onDeath();\n      }\n    }\n  },\n  599: {\n    comment: \"599: a bunch of Is functions for your pleasure\\nSWMG_IsFollower\\n\",\n    name: \"SWMG_IsFollower\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return (GameState.module.area.miniGame.enemies.indexOf(args[0] as ModuleMGEnemy) >= 0) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  600: {\n    comment: \"600: SWMG_IsPlayer\\n\",\n    name: \"SWMG_IsPlayer\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return GameState.module.area.miniGame.player == args[0] ? NW_TRUE : NW_FALSE;\n    }\n  },\n  601: {\n    comment: \"601: SWMG_IsEnemy\\n\",\n    name: \"SWMG_IsEnemy\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return GameState.module.area.miniGame.enemies.indexOf(args[0] as ModuleMGEnemy) >= 0;\n    }\n  },\n  602: {\n    comment: \"602: SWMG_IsTrigger\\n\",\n    name: \"SWMG_IsTrigger\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      //return GameState.module.area.MiniGame.Enemies.indexOf(args[0]) >= 0;\n    }\n  },\n  603: {\n    comment: \"603: SWMG_IsObstacle\\n\",\n    name: \"SWMG_IsObstacle\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (!mg || !args[0]) return NW_FALSE;\n      return (mg.obstacles.indexOf(args[0] as ModuleMGObstacle) >= 0) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  604: {\n    comment: \"604: SWMG_SetFollowerHitPoints\\n\",\n    name: \"SWMG_SetFollowerHitPoints\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const obj = args[0];\n      if (obj && (BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGObstacle) || BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGPlayer))) {\n        (obj as ModuleMGPlayer | ModuleMGEnemy | ModuleMGObstacle).hit_points = args[1];\n      }\n    }\n  },\n  605: {\n    comment: \"605: SWMG_OnDamage\\n\",\n    name: \"SWMG_OnDamage\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        //this.caller.onDamaged();\n      }\n    }\n  },\n  606: {\n    comment: \"606: SWMG_GetLastHPChange\\n\",\n    name: \"SWMG_GetLastHPChange\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastHPChange ?? 0;\n    }\n  },\n  607: {\n    comment: \"607: SWMG_RemoveAnimation\\n\",\n    name: \"SWMG_RemoveAnimation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [ModuleObject, string]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy)) {\n        (args[0] as ModuleMGPlayer | ModuleMGEnemy).removeAnimation(args[1]);\n      }\n    }\n  },\n  608: {\n    comment: \"608: SWMG_GetCameraNearClip\\n\",\n    name: \"SWMG_GetCameraNearClip\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.nearClip ?? 0.1;\n    }\n  },\n  609: {\n    comment: \"609: SWMG_GetCameraFarClip\\n\",\n    name: \"SWMG_GetCameraFarClip\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.farClip ?? 100;\n    }\n  },\n  610: {\n    comment: \"610: SWMG_SetCameraClip\\n\",\n    name: \"SWMG_SetCameraClip\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg) { mg.nearClip = args[0]; mg.farClip = args[1]; }\n    }\n  },\n  611: {\n    comment: \"611: SWMG_GetPlayer\\n\",\n    name: \"SWMG_GetPlayer\",\n    type: NWScriptDataType.OBJECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      return (mg && mg.player) ? mg.player : undefined;\n    }\n  },\n  612: {\n    comment: \"612: SWMG_GetEnemyCount\\n\",\n    name: \"SWMG_GetEnemyCount\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      return mg ? mg.enemies.length : 0;\n    }\n  },\n  613: {\n    comment: \"613: SWMG_GetEnemy\\n\",\n    name: \"SWMG_GetEnemy\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (!mg || args[0] < 0 || args[0] >= mg.enemies.length) return undefined;\n      return mg.enemies[args[0]];\n    }\n  },\n  614: {\n    comment: \"614: SWMG_GetObstacleCount\\n\",\n    name: \"SWMG_GetObstacleCount\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      return mg ? mg.obstacles.length : 0;\n    }\n  },\n  615: {\n    comment: \"615: SWMG_GetObstacle\\n\",\n    name: \"SWMG_GetObstacle\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (!mg || args[0] < 0 || args[0] >= mg.obstacles.length) return undefined;\n      return mg.obstacles[args[0]];\n    }\n  },\n  616: {\n    comment: \"616: SWMG_GetHitPoints\\n\",\n    name: \"SWMG_GetHitPoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle)) {\n        return (args[0] as ModuleMGEnemy | ModuleMGObstacle).hit_points;\n      }\n      return 0;\n    }\n  },\n  617: {\n    comment: \"617: SWMG_GetMaxHitPoints\\n\",\n    name: \"SWMG_GetMaxHitPoints\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle)) {\n        return (args[0] as ModuleMGEnemy | ModuleMGObstacle).max_hps;\n      }\n      return 0;\n    }\n  },\n  618: {\n    comment: \"618: SWMG_SetMaxHitPoints\\n\",\n    name: \"SWMG_SetMaxHitPoints\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const obj = args[0];\n      if (obj && (BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGObstacle) || BitWise.InstanceOfObject(obj, ModuleObjectType.ModuleMGPlayer))) {\n        (obj as ModuleMGPlayer | ModuleMGEnemy | ModuleMGObstacle).max_hps = args[1];\n      }\n    }\n  },\n  619: {\n    comment: \"619: SWMG_GetSphereRadius\\n\",\n    name: \"SWMG_GetSphereRadius\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      const o = args[0];\n      if (o && (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy))) {\n        return (o as ModuleMGPlayer | ModuleMGEnemy).sphere_radius ?? 0;\n      }\n      return 0;\n    }\n  },\n  620: {\n    comment: \"620: SWMG_SetSphereRadius\\n\",\n    name: \"SWMG_SetSphereRadius\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0];\n      if (o && (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy))) {\n        (o as ModuleMGPlayer | ModuleMGEnemy).sphere_radius = args[1];\n      }\n    }\n  },\n  621: {\n    comment: \"621: SWMG_GetNumLoops\\n\",\n    name: \"SWMG_GetNumLoops\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      const o = args[0];\n      if (o && BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer)) return (o as ModuleMGPlayer).num_loops ?? 0;\n      return 0;\n    }\n  },\n  622: {\n    comment: \"622: SWMG_SetNumLoops\\n\",\n    name: \"SWMG_SetNumLoops\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0];\n      if (o && BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer)) (o as ModuleMGPlayer).num_loops = args[1];\n    }\n  },\n  623: {\n    comment: \"623: SWMG_GetPosition\\n\",\n    name: \"SWMG_GetPosition\",\n    type: NWScriptDataType.VECTOR,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!args[0]) return { x: 0, y: 0, z: 0 };\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy)) {\n        const vec3 = new THREE.Vector3();\n        (args[0].model || args[0].container)?.getWorldPosition?.(vec3);\n        return vec3;\n      }\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle)) {\n        const p = (args[0] as ModuleMGObstacle).position;\n        return p ? { x: p.x, y: p.y, z: p.z } : { x: 0, y: 0, z: 0 };\n      }\n      return { x: 0, y: 0, z: 0 };\n    }\n  },\n  624: {\n    comment: \"624: SWMG_GetGunBankCount\\n\",\n    name: \"SWMG_GetGunBankCount\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy)) {\n        return ((args[0] as ModuleMGPlayer | ModuleMGEnemy).gunBanks?.length) ?? 0;\n      }\n      return 0;\n    }\n  },\n  625: {\n    comment: \"625: SWMG_GetGunBankBulletModel\\n\",\n    name: \"SWMG_GetGunBankBulletModel\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.model_name) ? banks[idx].proto_bullet.model_name : '';\n      }\n      return '';\n    }\n  },\n  626: {\n    comment: \"626: SWMG_GetGunBankGunModel\\n\",\n    name: \"SWMG_GetGunBankGunModel\",\n    type: NWScriptDataType.STRING,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.gunModel) ? banks[idx].gunModel : '';\n      }\n      return '';\n    }\n  },\n  627: {\n    comment: \"627: SWMG_GetGunBankDamage\\n\",\n    name: \"SWMG_GetGunBankDamage\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.damage_amt != null) ? banks[idx].proto_bullet.damage_amt : 0;\n      }\n      return 0;\n    }\n  },\n  628: {\n    comment: \"628: SWMG_GetGunBankTimeBetweenShots\\n\",\n    name: \"SWMG_GetGunBankTimeBetweenShots\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.rate_of_fire != null) ? banks[idx].proto_bullet.rate_of_fire : 0;\n      }\n      return 0;\n    }\n  },\n  629: {\n    comment: \"629: SWMG_GetGunBankLifespan\\n\",\n    name: \"SWMG_GetGunBankLifespan\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.lifespan != null) ? banks[idx].proto_bullet.lifespan : 0;\n      }\n      return 0;\n    }\n  },\n  630: {\n    comment: \"630: SWMG_GetGunBankSpeed\\n\",\n    name: \"SWMG_GetGunBankSpeed\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.speed != null) ? banks[idx].proto_bullet.speed : 0;\n      }\n      return 0;\n    }\n  },\n  631: {\n    comment: \"631: SWMG_GetGunBankTarget\\n\",\n    name: \"SWMG_GetGunBankTarget\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.proto_bullet?.target_type != null) ? banks[idx].proto_bullet.target_type : 0;\n      }\n      return 0;\n    }\n  },\n  632: {\n    comment: \"632: SWMG_SetGunBankBulletModel\\n\",\n    name: \"SWMG_SetGunBankBulletModel\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, string]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.model_name = v ?? '';\n      }\n    }\n  },\n  633: {\n    comment: \"633: SWMG_SetGunBankGunModel\\n\",\n    name: \"SWMG_SetGunBankGunModel\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, string]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        const bank = banks?.[idx];\n        if (bank && 'gunModel' in bank) bank.gunModel = v ?? '';\n      }\n    }\n  },\n  634: {\n    comment: \"634: SWMG_SetGunBankDamage\\n\",\n    name: \"SWMG_SetGunBankDamage\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.damage_amt = v ?? 0;\n      }\n    }\n  },\n  635: {\n    comment: \"635: SWMG_SetGunBankTimeBetweenShots\\n\",\n    name: \"SWMG_SetGunBankTimeBetweenShots\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.rate_of_fire = v ?? 0;\n      }\n    }\n  },\n  636: {\n    comment: \"636: SWMG_SetGunBankLifespan\\n\",\n    name: \"SWMG_SetGunBankLifespan\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.lifespan = v ?? 0;\n      }\n    }\n  },\n  637: {\n    comment: \"637: SWMG_SetGunBankSpeed\\n\",\n    name: \"SWMG_SetGunBankSpeed\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.speed = v ?? 0;\n      }\n    }\n  },\n  638: {\n    comment: \"638: SWMG_SetGunBankTarget\\n\",\n    name: \"SWMG_SetGunBankTarget\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      const o = args[0]; const idx = args[1]; const v = args[2];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet) banks[idx].proto_bullet.target_type = v ?? 0;\n      }\n    }\n  },\n  639: {\n    comment: \"639: SWMG_GetLastBulletHitPart\\n\",\n    name: \"SWMG_GetLastBulletHitPart\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.lastBulletHitPart ?? '';\n    }\n  },\n  640: {\n    comment: \"640: SWMG_IsGunBankTargetting\\n\",\n    name: \"SWMG_IsGunBankTargetting\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        if (banks && banks[idx]?.proto_bullet?.target_type != null) return banks[idx].proto_bullet.target_type ? NW_TRUE : NW_FALSE;\n      }\n      return NW_FALSE;\n    }\n  },\n  641: {\n    comment: \"641: SWMG_GetPlayerOffset\\nreturns a vector with the player rotation for rotation minigames\\nreturns a vector with the player translation for translation minigames\\n\",\n    name: \"SWMG_GetPlayerOffset\",\n    type: NWScriptDataType.VECTOR,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      if (!mg?.player) return { x: 0, y: 0, z: 0 };\n      if (mg.type === 2) {\n        const rot = mg.player.rotation;\n        return new THREE.Vector3(THREE.MathUtils.radToDeg(rot.x), THREE.MathUtils.radToDeg(rot.y), THREE.MathUtils.radToDeg(rot.z));\n      }\n      return mg.player.position.clone();\n    }\n  },\n  642: {\n    comment: \"642: SWMG_GetPlayerInvincibility\\n\",\n    name: \"SWMG_GetPlayerInvincibility\",\n    type: NWScriptDataType.FLOAT,\n    args: []\n  },\n  643: {\n    comment: \"643: SWMG_GetPlayerSpeed\\n\",\n    name: \"SWMG_GetPlayerSpeed\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.miniGame.player.speed;\n    }\n  },\n  644: {\n    comment: \"644: SWMG_GetPlayerMinSpeed\\n\",\n    name: \"SWMG_GetPlayerMinSpeed\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.miniGame.player.speed_min;\n    }\n  },\n  645: {\n    comment: \"645: SWMG_GetPlayerAccelerationPerSecond\\n\",\n    name: \"SWMG_GetPlayerAccelerationPerSecond\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.miniGame.player.accel_secs;\n    }\n  },\n  646: {\n    comment: \"646: SWMG_GetPlayerTunnelPos\\n\",\n    name: \"SWMG_GetPlayerTunnelPos\",\n    type: NWScriptDataType.VECTOR,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module.area.miniGame.player.tunnel.pos;\n    }\n  },\n  647: {\n    comment: \"647: SWMG_SetPlayerOffset\\n\",\n    name: \"SWMG_SetPlayerOffset\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3]) {\n      GameState.module.area.miniGame.player.position.copy(args[0]);\n    }\n  },\n  648: {\n    comment: \"648: SWMG_SetPlayerInvincibility\\n\",\n    name: \"SWMG_SetPlayerInvincibility\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player) mg.player.invince = args[0];\n    }\n  },\n  649: {\n    comment: \"649: SWMG_SetPlayerSpeed\\n\",\n    name: \"SWMG_SetPlayerSpeed\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player) mg.player.speed = args[0];\n    }\n  },\n  650: {\n    comment: \"650: SWMG_SetPlayerMinSpeed\\n\",\n    name: \"SWMG_SetPlayerMinSpeed\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player) mg.player.speed_min = args[0];\n    }\n  },\n  651: {\n    comment: \"651: SWMG_SetPlayerAccelerationPerSecond\\n\",\n    name: \"SWMG_SetPlayerAccelerationPerSecond\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player) mg.player.accel_secs = args[0];\n    }\n  },\n  652: {\n    comment: \"652: SWMG_SetPlayerTunnelPos\\n\",\n    name: \"SWMG_SetPlayerTunnelPos\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [{ x: number; y: number; z: number }]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player?.tunnel?.pos && args[0]) Object.assign(mg.player.tunnel.pos, args[0]);\n    }\n  },\n  653: {\n    comment: \"653: SWMG_GetPlayerTunnelNeg\\n\",\n    name: \"SWMG_GetPlayerTunnelNeg\",\n    type: NWScriptDataType.VECTOR,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const p = GameState.module?.area?.miniGame?.player?.tunnel?.neg;\n      return p ? { x: p.x, y: p.y, z: p.z } : { x: 0, y: 0, z: 0 };\n    }\n  },\n  654: {\n    comment: \"654: SWMG_SetPlayerTunnelNeg\\n\",\n    name: \"SWMG_SetPlayerTunnelNeg\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [THREE.Vector3]) {\n      GameState.module.area.miniGame.player.tunnel.neg = args[0];\n    }\n  },\n  655: {\n    comment: \"655: SWMG_GetPlayerOrigin\\n\",\n    name: \"SWMG_GetPlayerOrigin\",\n    type: NWScriptDataType.VECTOR,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player?.position) return mg.player.position.clone();\n      return { x: 0, y: 0, z: 0 };\n    }\n  },\n  656: {\n    comment: \"656: SWMG_SetPlayerOrigin\\n\",\n    name: \"SWMG_SetPlayerOrigin\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR],\n    action: function (this: NWScriptInstance, args: [{ x: number; y: number; z: number }]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player?.position && args[0]) mg.player.position.set(args[0].x, args[0].y, args[0].z);\n    }\n  },\n  657: {\n    comment: \"657: SWMG_GetGunBankHorizontalSpread\\n\",\n    name: \"SWMG_GetGunBankHorizontalSpread\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.horizSpread != null) ? banks[idx].horizSpread : 0;\n      }\n      return 0;\n    }\n  },\n  658: {\n    comment: \"658: SWMG_GetGunBankVerticalSpread\\n\",\n    name: \"SWMG_GetGunBankVerticalSpread\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.vertSpread != null) ? banks[idx].vertSpread : 0;\n      }\n      return 0;\n    }\n  },\n  659: {\n    comment: \"659: SWMG_GetGunBankSensingRadius\\n\",\n    name: \"SWMG_GetGunBankSensingRadius\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.sensingRadius != null) ? banks[idx].sensingRadius : 0;\n      }\n      return 0;\n    }\n  },\n  660: {\n    comment: \"660: SWMG_GetGunBankInaccuracy\\n\",\n    name: \"SWMG_GetGunBankInaccuracy\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      const o = args[0]; const idx = args[1];\n      if (BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGPlayer) || BitWise.InstanceOfObject(o, ModuleObjectType.ModuleMGEnemy)) {\n        const banks = (o as ModuleMGPlayer | ModuleMGEnemy).gunBanks;\n        return (banks && banks[idx]?.inaccuracy != null) ? banks[idx].inaccuracy : 0;\n      }\n      return 0;\n    }\n  },\n  661: {\n    comment: \"661: SWMG_SetGunBankHorizontalSpread\\n\",\n    name: \"SWMG_SetGunBankHorizontalSpread\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT]\n  },\n  662: {\n    comment: \"662: SWMG_SetGunBankVerticalSpread\\n\",\n    name: \"SWMG_SetGunBankVerticalSpread\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT]\n  },\n  663: {\n    comment: \"663: SWMG_SetGunBankSensingRadius\\n\",\n    name: \"SWMG_SetGunBankSensingRadius\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT]\n  },\n  664: {\n    comment: \"664: SWMG_SetGunBankInaccuracy\\n\",\n    name: \"SWMG_SetGunBankInaccuracy\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.FLOAT]\n  },\n  665: {\n    comment: \"665: GetIsInvulnerable\\nThis returns whether the follower object is currently invulnerable to damage\\n\",\n    name: \"SWMG_GetIsInvulnerable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer)) {\n        return ((args[0] as ModuleMGPlayer | ModuleMGEnemy | ModuleMGObstacle).invince > 0) ? NW_TRUE : NW_FALSE;\n      }\n      return 0;\n    }\n  },\n  666: {\n    comment: \"666: StartInvulnerability\\nThis will begin a period of invulnerability (as defined by Invincibility)\\n\",\n    name: \"SWMG_StartInvulnerability\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGObstacle) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGEnemy) || BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleMGPlayer)) {\n        (args[0] as ModuleMGPlayer | ModuleMGEnemy | ModuleMGObstacle).startInvulnerability();\n      }\n    }\n  },\n  667: {\n    comment: \"667: GetPlayerMaxSpeed\\nThis returns the player character's max speed\\n\",\n    name: \"SWMG_GetPlayerMaxSpeed\",\n    type: NWScriptDataType.FLOAT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.module?.area?.miniGame?.player?.speed_max ?? 0;\n    }\n  },\n  668: {\n    comment: \"668: SetPlayerMaxSpeed\\nThis sets the player character's max speed\\n\",\n    name: \"SWMG_SetPlayerMaxSpeed\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const mg = GameState.module?.area?.miniGame;\n      if (mg?.player) mg.player.speed_max = args[0];\n    }\n  },\n  669: {\n    comment: \"669: AddJournalWorldEntry\\nAdds a user entered entry to the world notices\\n\",\n    name: \"AddJournalWorldEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [number, string, string]) {\n      //UNUSED\n    }\n  },\n  670: {\n    comment: \"670: AddJournalWorldEntryStrref\\nAdds an entry to the world notices using stringrefs\\n\",\n    name: \"AddJournalWorldEntryStrref\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      //UNUSED\n    }\n  },\n  671: {\n    comment: \"671: BarkString\\nthis will cause a creature to bark the strRef from the talk table\\nIf creature is specefied as OBJECT_INVALID a general bark is made.\\n\",\n    name: \"BarkString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      log.info('BarkString', args[1]);\n      GameState.MenuManager.InGameBark.barkFromStringRef(args[1]);\n    }\n  },\n  672: {\n    comment: \"672: DeleteJournalWorldAllEntries\\nNuke's 'em all, user entered or otherwise.\\n\",\n    name: \"DeleteJournalWorldAllEntries\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      //UNUSED\n    }\n  },\n  673: {\n    comment: \"673: DeleteJournalWorldEntry\\nDeletes a user entered world notice\\n\",\n    name: \"DeleteJournalWorldEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      //UNUSED\n    }\n  },\n  674: {\n    comment: \"674: DeleteJournalWorldEntryStrref\\nDeletes the world notice pertaining to the string ref\\n\",\n    name: \"DeleteJournalWorldEntryStrref\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      //UNUSED\n    }\n  },\n  675: {\n    comment: \"675: EffectForceDrain\\nThis command will reduce the force points of a creature.\\n\",\n    name: \"EffectForceDrain\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.INTEGER]\n  },\n  676: {\n    comment: \"676: EffectTemporaryForcePoints\\n\\n\",\n    name: \"EffectPsychicStatic\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: [number]) {\n      const effect = new GameState.GameEffectFactory.EffectTemporaryForce();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, args[0]);\n      return effect.initialize();\n    }\n  },\n  677: {\n    comment: \"677: PlayVisualAreaEffect\\n\",\n    name: \"PlayVisualAreaEffect\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.LOCATION]\n  },\n  678: {\n    comment: \"678: SetJournalQuestEntryPicture\\nSets the picture for the quest entry on this object (creature)\\n\",\n    name: \"SetJournalQuestEntryPicture\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  679: {\n    comment: \"679. GetLocalBoolean\\nThis gets a boolean flag on an object\\ncurrently the index is a range between 0 and 63\\n\",\n    name: \"GetLocalBoolean\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getLocalBoolean(args[1]) ? NW_TRUE : NW_FALSE;\n      } else {\n        return 0;\n      }\n    }\n  },\n  680: {\n    comment: \"680. SetLocalBoolean\\nThis sets a boolean flag on an object\\ncurrently the index is a range between 0 and 63\\n\",\n    name: \"SetLocalBoolean\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      args[0].setLocalBoolean(args[1], !!args[2])\n    }\n  },\n  681: {\n    comment: \"681. GetLocalNumber\\nThis gets a number on an object\\ncurrently the index is a range between 0 and 0\\n\",\n    name: \"GetLocalNumber\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return args[0].getLocalNumber(args[1]);\n      } else {\n        return 0;\n      }\n    }\n  },\n  682: {\n    comment: \"682. SetLocalNumber\\nThis sets a number on an object\\ncurrently the index is a range between 0 and 0\\n\",\n    name: \"SetLocalNumber\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number, number]) {\n      args[0].setLocalNumber(\n        args[1],\n        args[2]\n      )\n    }\n  },\n  683: {\n    comment: \"683. SWMG_GetSoundFrequency\\nGets the frequency of a trackfollower sound\\n\",\n    name: \"SWMG_GetSoundFrequency\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  684: {\n    comment: \"684. SWMG_SetSoundFrequency\\nSets the frequency of a trackfollower sound\\n\",\n    name: \"SWMG_SetSoundFrequency\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  685: {\n    comment: \"685. SWMG_GetSoundFrequencyIsRandom\\nGets whether the frequency of a trackfollower sound is using the random model\\n\",\n    name: \"SWMG_GetSoundFrequencyIsRandom\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  686: {\n    comment: \"686. SWMG_SetSoundFrequencyIsRandom\\nSets whether the frequency of a trackfollower sound is using the random model\\n\",\n    name: \"SWMG_SetSoundFrequencyIsRandom\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  687: {\n    comment: \"687. SWMG_GetSoundVolume\\nGets the volume of a trackfollower sound\\n\",\n    name: \"SWMG_GetSoundVolume\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  688: {\n    comment: \"688. SWMG_SetSoundVolume\\nSets the volume of a trackfollower sound\\n\",\n    name: \"SWMG_SetSoundVolume\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  689: {\n    comment: \"689. SoundObjectGetPitchVariance\\nGets the pitch variance of a placeable sound object\\n\",\n    name: \"SoundObjectGetPitchVariance\",\n    type: NWScriptDataType.FLOAT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        return (args[0] as ModuleSound).pitchVariation;\n      }\n      return 0;\n    }\n  },\n  690: {\n    comment: \"690. SoundObjectSetPitchVariance\\nSets the pitch variance of a placeable sound object\\n\",\n    name: \"SoundObjectSetPitchVariance\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).setPitchVariation(args[1]);\n      }\n    }\n  },\n  691: {\n    comment: \"691. SoundObjectGetVolume\\nGets the volume of a placeable sound object\\n\",\n    name: \"SoundObjectGetVolume\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        return (args[0] as ModuleSound).volume;\n      }\n      return 0;\n    }\n  },\n  692: {\n    comment: \"692: GetGlobalLocation\\nThis function returns the a global location scripting variable.\\n\",\n    name: \"GetGlobalLocation\",\n    type: NWScriptDataType.LOCATION,\n    args: [NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [string]) {\n      return GameState.GlobalVariableManager.GetGlobalLocation(args[0]);\n    }\n  },\n  693: {\n    comment: \"693: SetGlobalLocation\\nThis function sets the a global location scripting variable.\\n\",\n    name: \"SetGlobalLocation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [string, EngineLocation]) {\n      GameState.GlobalVariableManager.SetGlobalLocation(args[0], args[1]);\n    }\n  },\n  694: {\n    comment: \"694. AddAvailableNPCByObject\\nThis adds a NPC to the list of available party members using\\na game object as the template\\nReturns if true if successful, false if the NPC had already\\nbeen added or the object specified is invalid\\n\",\n    name: \"AddAvailableNPCByObject\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [number, ModuleObject]) {\n      return GameState.PartyManager.AddAvailableNPCByObject(args[0], args[1] as ModuleCreature) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  695: {\n    comment: \"695. RemoveAvailableNPC\\nThis removes a NPC from the list of available party members\\nReturns whether it was successful or not\\n\",\n    name: \"RemoveAvailableNPC\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.PartyManager.RemoveAvailableNPC(args[0]);\n      return NW_TRUE;\n    }\n  },\n  696: {\n    comment: \"696. IsAvailableNPC\\nThis returns whether a NPC is in the list of available party members\\n\",\n    name: \"IsAvailableCreature\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return GameState.PartyManager.IsAvailable(args[0]) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  697: {\n    comment: \"697. AddAvailableNPCByTemplate\\nThis adds a NPC to the list of available party members using\\na template\\nReturns if true if successful, false if the NPC had already\\nbeen added or the template specified is invalid\\n\",\n    name: \"AddAvailableNPCByTemplate\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.STRING],\n    action: function (this: NWScriptInstance, args: [number, string]) {\n      return GameState.PartyManager.AddAvailableNPCByTemplate(args[0], args[1]) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  698: {\n    comment: \"698. SpawnAvailableNPC\\nThis spawns a NPC from the list of available creatures\\nReturns a pointer to the creature object\\n\",\n    name: \"SpawnAvailableNPC\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.LOCATION],\n    action: function (this: NWScriptInstance, args: [number, EngineLocation]) {\n      const template = GameState.PartyManager.NPCS[args[0]]?.template;\n      if (!template) { return undefined; }\n\n      const partyMember = new GameState.Module.ModuleArea.ModuleCreature(template);\n      args[1].area.attachObject(partyMember);\n      partyMember.load();\n      partyMember.clearAllActions();\n      partyMember.loadModel().then((model: OdysseyModel3D) => {\n        partyMember.model.userData.moduleObject = partyMember;\n        partyMember.setPosition(args[1].position);\n        partyMember.setFacing(args[1].getFacing(), true);\n        partyMember.box = new THREE.Box3().setFromObject(partyMember.container);\n        model.hasCollision = true;\n        GameState.group.creatures.add(partyMember.container);\n      });\n      return partyMember;\n    }\n  },\n  699: {\n    comment: \"699. IsNPCPartyMember\\nReturns if a given NPC constant is in the party currently\\n\",\n    name: \"IsNPCPartyMember\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return GameState.PartyManager.IsNPCInParty(args[0]) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  700: {\n    comment: \"700. ActionBarkString\\nthis will cause a creature to bark the strRef from the talk table.\\n\",\n    name: \"ActionBarkString\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  701: {\n    comment: \"701. GetIsConversationActive\\nChecks to see if any conversations are currently taking place\\n\",\n    name: \"GetIsConversationActive\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return (GameState.Mode == EngineMode.DIALOG) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  702: {\n    comment: \"702. EffectLightsaberThrow\\nThis function throws a lightsaber at a target\\nIf multiple targets are specified, then the lightsaber travels to them\\nsequentially, returning to the first object specified\\nThis effect is applied to an object, so an effector is not needed\\n\",\n    name: \"EffectLightsaberThrow\",\n    type: NWScriptDataType.EFFECT,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER]\n  },\n  703: {\n    comment: \"703.\\ncreates the effect of a whirl wind.\\n\",\n    name: \"EffectWhirlWind\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 10); // Whirlwind State\n      return effect.initialize();\n    }\n  },\n  704: {\n    comment: \"704.\\nReturns the party ai style\\n\",\n    name: \"GetPartyAIStyle\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return GameState.PartyManager.aiStyle;\n    }\n  },\n  705: {\n    comment: \"705.\\nReturns the party members ai style\\n\",\n    name: \"GetNPCAIStyle\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleCreature]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature))\n        return args[0].aiStyle;\n\n      return 0;\n    }\n  },\n  706: {\n    comment: \"706.\\nSets the party ai style\\n\",\n    name: \"SetPartyAIStyle\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.PartyManager.aiStyle = args[0];\n    }\n  },\n  707: {\n    comment: \"707.\\nSets the party members ai style\\n\",\n    name: \"SetNPCAIStyle\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature))\n        (args[0] as ModuleCreature).aiStyle = args[1];\n    }\n  },\n  708: {\n    comment: \"708: SetNPCSelectability\\n\",\n    name: \"SetNPCSelectability\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      GameState.PartyManager.SetSelectable(args[0], !!args[1]);\n    }\n  },\n  709: {\n    comment: \"709: GetNPCSelectability\\n\",\n    name: \"GetNPCSelectability\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return GameState.PartyManager.IsSelectable(args[0]) ? NW_TRUE : NW_FALSE;\n    }\n  },\n  710: {\n    comment: \"710: Clear all the effects of the caller.\\n* No return value, but if an error occurs, the log file will contain\\n'ClearAllEffects failed.'.\\n\",\n    name: \"ClearAllEffects\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        this.caller.removeEffectsByType(GameEffectDurationType.TEMPORARY);\n      }\n    }\n  },\n  711: {\n    comment: \"711: GetLastConversation\\nGets the last conversation string.\\n\\n\",\n    name: \"GetLastConversation\",\n    type: NWScriptDataType.STRING,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const last_spoken = GameState.DialogMessageManager.Entries[0];\n      if (last_spoken) {\n        return last_spoken.message;\n      }\n      return '';\n    }\n  },\n  712: {\n    comment: \"712: ShowPartySelectionGUI\\nBrings up the party selection GUI for the player to\\nselect the members of the party from\\nif exit script is specified, will be executed when\\nthe GUI is exited\\n\",\n    name: \"ShowPartySelectionGUI\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number, number]) {\n      //Setting ignoreUnescapable = TRUE allows the exithawk script to manage the party ingoring the unescapable flag\n      //set in the area properties. This is my current understanding of how I think it should work...\n      GameState.MenuManager.MenuPartySelection.open(args[0], args[1], args[2]);\n      GameState.MenuManager.MenuPartySelection.ignoreUnescapable = true;\n    }\n  },\n  713: {\n    comment: \"713: GetStandardFaction\\nFind out which standard faction oObject belongs to.\\n* Returns INVALID_STANDARD_FACTION if oObject does not belong to\\na Standard Faction, or an error has occurred.\\n\",\n    name: \"GetStandardFaction\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        return typeof args[0].faction == 'number' ? args[0].faction : -1;\n      }\n      return -1;\n    }\n  },\n  714: {\n    comment: \"714: GivePlotXP\\nGive nPercentage% of the experience associated with plot sPlotName\\nto the party\\n- sPlotName\\n- nPercentage\\n\",\n    name: \"GivePlotXP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      const count = GameState.TwoDAManager.datatables.get('plot').RowCount;\n      for (let i = 0; i < count; i++) {\n        if (GameState.TwoDAManager.datatables.get('plot').rows[i].label.localeCompare(args[0], undefined, { sensitivity: 'base' }) === 0) {\n          GameState.PartyManager.GiveXP(parseInt(GameState.TwoDAManager.datatables.get('plot').rows[i]) * (args[1] * 0.01));\n        }\n      }\n    }\n  },\n  715: {\n    comment: \"715. GetMinOneHP\\nChecks to see if oObject has the MinOneHP Flag set on them.\\n\",\n    name: \"GetMinOneHP\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature))) return;\n      if (args[0]) {\n        return args[0].min1HP ? NW_TRUE : NW_FALSE;\n      }\n      return 0;\n    }\n  },\n  716: {\n    comment: \"716. SetMinOneHP\\nSets/Removes the MinOneHP Flag on oObject.\\n\",\n    name: \"SetMinOneHP\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        args[0].setMinOneHP(!!args[1])\n      }\n    }\n  },\n  717: {\n    comment: \"717. SWMG_GetPlayerTunnelInfinite\\nGets whether each of the dimensions is infinite\\n\",\n    name: \"SWMG_GetPlayerTunnelInfinite\",\n    type: NWScriptDataType.VECTOR,\n    args: []\n  },\n  718: {\n    comment: \"718. SWMG_SetPlayerTunnelInfinite\\nSets whether each of the dimensions is infinite\\n\",\n    name: \"SWMG_SetPlayerTunnelInfinite\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.VECTOR]\n  },\n  719: {\n    comment: \"719. SetGlobalFadeIn\\nSets a Fade In that starts after fWait seconds and fades for fLength Seconds.\\nThe Fade will be from a color specified by the RGB values fR, fG, and fB.\\nNote that fR, fG, and fB are normalized values.\\nThe default values are an immediate cut in from black.\\n\",\n    name: \"SetGlobalFadeIn\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number, number, number, number]) {\n      log.info('SetGlobalFadeIn', args[1], args[2], args[3], args[4]);\n      GameState.FadeOverlayManager.holdForScript = false;\n      GameState.FadeOverlayManager.FadeIn(args[1], args[2], args[3], args[4], args[0]);\n    }\n  },\n  720: {\n    comment: \"720. SetGlobalFadeOut\\nSets a Fade Out that starts after fWait seconds and fades for fLength Seconds.\\nThe Fade will be to a color specified by the RGB values fR, fG, and fB.\\nNote that fR, fG, and fB are normalized values.\\nThe default values are an immediate cut to from black.\\n\",\n    name: \"SetGlobalFadeOut\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number, number, number, number, number]) {\n      log.info('SetGlobalFadeOut', args[1], args[2], args[3], args[4]);\n      GameState.FadeOverlayManager.holdForScript = false;\n      GameState.FadeOverlayManager.FadeOut(args[1], args[2], args[3], args[4], args[0]);\n    }\n  },\n  721: {\n    comment: \"721. GetLastAttackTarget\\nReturns the last attack target for a given object\\n\",\n    name: \"GetLastHostileTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].combatData.lastAttackTarget;\n      } else {\n        return this.caller.combatData.lastAttackTarget;\n      }\n    }\n  },\n  722: {\n    comment: \"722. GetLastAttackAction\\nReturns the last attack action for a given object\\n\",\n    name: \"GetLastAttackAction\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject)) {\n        switch (args[0].combatData.lastAttackAction) {\n          case ActionType.ActionPhysicalAttacks:\n            return 3;\n          case ActionType.ActionCastSpell:\n          case ActionType.ActionItemCastSpell:\n            return 4;\n        }\n      }\n      return -1;\n    }\n  },\n  723: {\n    comment: \"723. GetLastForcePowerUsed\\nReturns the last force power used (as a spell number that indexes the Spells.2da) by the given object\\n\",\n    name: \"GetLastForcePowerUsed\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if (args[0].combatData.lastForcePowerUsed) {\n          return args[0].combatData.lastForcePowerUsed.id;\n        }\n      }\n      return -1;\n    }\n  },\n  724: {\n    comment: \"724. GetLastCombatFeatUsed\\nReturns the last feat used (as a feat number that indexes the Feats.2da) by the given object\\n\",\n    name: \"GetLastCombatFeatUsed\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        if (args[0].combatData.lastCombatFeatUsed) {\n          return args[0].combatData.lastCombatFeatUsed.id;\n        }\n      }\n      return -1;\n    }\n  },\n  725: {\n    comment: \"725. GetLastAttackResult\\nReturns the result of the last attack\\n\",\n    name: \"GetLastAttackResult\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return args[0].combatData.lastAttackResult || 0;\n    }\n  },\n  726: {\n    comment: \"726. GetWasForcePowerSuccessful\\nReturns whether the last force power used was successful or not\\n\",\n    name: \"GetWasForcePowerSuccessful\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      return 0;\n    }\n  },\n  727: {\n    comment: \"727. GetFirstAttacker\\nReturns the first object in the area that is attacking oCreature\\n\",\n    name: \"GetFirstAttacker\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return;\n\n      this.creatureAttackerIndex.set(args[0].id, 0);\n      return GameState.ModuleObjectManager.GetAttackerByIndex(args[0], 0);\n    }\n  },\n  728: {\n    comment: \"728. GetNextAttacker\\nReturns the next object in the area that is attacking oCreature\\n\",\n    name: \"GetNextAttacker\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (!(BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleObject))) return;\n\n      const nextId = this.creatureAttackerIndex.get(args[0].id) + 1;\n      this.creatureAttackerIndex.set(args[0].id, nextId);\n      return GameState.ModuleObjectManager.GetAttackerByIndex(args[0], nextId);\n    }\n  },\n  729: {\n    comment: \"729. SetFormation\\nPut oCreature into the nFormationPattern about oAnchor at position nPosition\\n- oAnchor: The formation is set relative to this object\\n- oCreature: This is the creature that you wish to join the formation\\n- nFormationPattern: FORMATION_*\\n- nPosition: Integer from 1 to 10 to specify which position in the formation\\noCreature is supposed to take.\\n\",\n    name: \"SetFormation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.OBJECT, NWScriptDataType.INTEGER, NWScriptDataType.INTEGER]\n  },\n  730: {\n    comment: \"730. ActionFollowLeader\\nthis action has a party member follow the leader.\\nDO NOT USE ON A CREATURE THAT IS NOT IN THE PARTY!!\\n\",\n    name: \"ActionFollowLeader\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (!BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleCreature)) {\n        return;\n      }\n\n      const action = new GameState.ActionFactory.ActionFollowLeader();\n      this.caller.actionQueue.add(action);\n    }\n  },\n  731: {\n    comment: \"731. SetForcePowerUnsuccessful\\nSets the reason (through a constant) for why a force power failed\\n\",\n    name: \"SetForcePowerUnsuccessful\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [AttackResult, ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[1], ModuleObjectType.ModuleCreature)) {\n        args[1].combatData.lastAttackResult = args[0];\n      }\n    }\n  },\n  732: {\n    comment: \"732. GetIsDebilitated\\nReturns whether the given object is debilitated or not\\n\",\n    name: \"GetIsDebilitated\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].isDebilitated();\n      }\n      return 0;\n    }\n  },\n  733: {\n    comment: \"733. PlayMovie\\nPlayes a Movie.\\n\",\n    name: \"PlayMovie\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING],\n    action: async function (this: NWScriptInstance, args: [string]) {\n      await VideoPlayer.Load(args[0]);\n    }\n  },\n  734: {\n    comment: \"734. SaveNPCState\\nTells the party table to save the state of a party member NPC\\n\",\n    name: \"SaveNPCState\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.PartyManager.SavePartyMember(args[0]);\n    }\n  },\n  735: {\n    comment: \"735: Get the Category of tTalent.\\n\",\n    name: \"GetCategoryFromTalent\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.TALENT],\n    action: function (this: NWScriptInstance, args: [TalentObject]) {\n      if (typeof args[0] != 'undefined') {\n        let category = Number(args[0].category);\n        if (isNaN(category))\n          category = -1;\n\n        return category;\n      } else {\n        return -1;\n      }\n    }\n  },\n  736: {\n    comment: \"736: This affects all creatures in the area that are in faction nFactionFrom...\\n- Makes them join nFactionTo\\n- Clears all actions\\n- Disables combat mode\\n\",\n    name: \"SurrenderByFaction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const nFactionFrom = args[0];\n      const nFactionTo = args[1];\n      const area = this.caller?.area ?? GameState.module?.area;\n      const targetFaction = GameState.FactionManager?.factions?.get(nFactionTo);\n      if (!area?.creatures?.length || !targetFaction) return;\n      for (let i = 0, len = area.creatures.length; i < len; i++) {\n        const creature = area.creatures[i];\n        if (!BitWise.InstanceOfObject(creature, ModuleObjectType.ModuleCreature)) continue;\n        const factionId = creature.factionId ?? creature.faction?.id;\n        if (factionId !== nFactionFrom) continue;\n        GameState.FactionManager.RemoveCreatureFromFaction(creature);\n        creature.factionId = nFactionTo;\n        creature.faction = targetFaction;\n        targetFaction.addMember(creature);\n        creature.combatData.combatState = false;\n        creature.clearTarget();\n        creature.clearAllActions(false);\n        creature.pacifyCreature();\n      }\n    }\n  },\n  737: {\n    comment: \"737: This affects all creatures in the area that are in faction nFactionFrom.\\nmaking them change to nFactionTo\\n\",\n    name: \"ChangeFactionByFaction\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      const nFactionFrom = args[0];\n      const nFactionTo = args[1];\n      const area = this.caller?.area ?? GameState.module?.area;\n      const targetFaction = GameState.FactionManager?.factions?.get(nFactionTo);\n      if (!area?.creatures?.length || !targetFaction) return;\n      for (let i = 0, len = area.creatures.length; i < len; i++) {\n        const creature = area.creatures[i];\n        if (!BitWise.InstanceOfObject(creature, ModuleObjectType.ModuleCreature)) continue;\n        const factionId = creature.factionId ?? creature.faction?.id;\n        if (factionId !== nFactionFrom) continue;\n        GameState.FactionManager.RemoveCreatureFromFaction(creature);\n        creature.factionId = nFactionTo;\n        creature.faction = targetFaction;\n        targetFaction.addMember(creature);\n        if (creature.perceptionList) creature.perceptionList.length = 0;\n      }\n    }\n  },\n  738: {\n    comment: \"738: PlayRoomAnimation\\nPlays a looping animation on a room\\n\",\n    name: \"PlayRoomAnimation\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      for (let i = 0, len = GameState.module.area.rooms.length; i < len; i++) {\n        const room = GameState.module.area.rooms[i];\n        if (room.roomName.toLowerCase() == args[0].toLowerCase()) {\n          if (room.model) {\n            room.model.playAnimation('scriptloop' + Utility.PadInt(args[1], 2));\n          }\n          break;\n        }\n      }\n    }\n  },\n  739: {\n    comment: \"739: ShowGalaxyMap\\nBrings up the Galaxy Map Gui, with 'nPlanet' selected.  'nPlanet' can only be a planet\\nthat has already been set available and selectable.\\n\",\n    name: \"ShowGalaxyMap\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      Planetary.SetSelectedPlanet(args[0]);\n      GameState.MenuManager.MenuGalaxyMap.open();\n    }\n  },\n  740: {\n    comment: \"740: SetPlanetSelectable\\nSets 'nPlanet' selectable on the Galaxy Map Gui.\\n\",\n    name: \"SetPlanetSelectable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      Planetary.SetPlanetSelectable(args[0], !!args[1]);\n    }\n  },\n  741: {\n    comment: \"741: GetPlanetSelectable\\nReturns wheter or not 'nPlanet' is selectable.\\n\",\n    name: \"GetPlanetSelectable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Planetary.planets[args[0]].selectable ? NW_TRUE : NW_FALSE;\n    }\n  },\n  742: {\n    comment: \"742: SetPlanetAvailable\\nSets 'nPlanet' available on the Galaxy Map Gui.\\n\",\n    name: \"SetPlanetAvailable\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number, number]) {\n      Planetary.SetPlanetAvailable(args[0], args[1] ? true : false);\n    }\n  },\n  743: {\n    comment: \"743: GetPlanetAvailable\\nReturns wheter or not 'nPlanet' is available.\\n\",\n    name: \"GetPlanetAvailable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return Planetary.planets[args[0]].enabled ? NW_TRUE : NW_FALSE;\n    }\n  },\n  744: {\n    comment: \"744: GetSelectedPlanet\\nReturns the ID of the currently selected planet.  Check Planetary.2da\\nfor which planet the return value corresponds to. If the return is -1\\nno planet is selected.\\n\",\n    name: \"GetSelectedPlanet\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return Planetary.selectedIndex;\n    }\n  },\n  745: {\n    comment: \"745: SoundObjectFadeAndStop\\nFades a sound object for 'fSeconds' and then stops it.\\n\",\n    name: \"SoundObjectFadeAndStop\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleSound)) {\n        (args[0] as ModuleSound).stop(args[1] || 0);\n      }\n    }\n  },\n  746: {\n    comment: \"746: SetAreaFogColor\\nSet the fog color for the area oArea.\\n\",\n    name: \"SetAreaFogColor\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT, NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [ModuleArea, number, number, number]) {\n      if (args[0]) {\n        args[0].fog.color.setRGB(args[1], args[2], args[3]);\n      }\n    }\n  },\n  747: {\n    comment: \"747: ChangeItemCost\\nChange the cost of an item\\n\",\n    name: \"ChangeItemCost\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.FLOAT]\n  },\n  748: {\n    comment: \"748: GetIsLiveContentAvailable\\nDetermines whether a given live content package is available\\nnPkg = LIVE_CONTENT_PKG1, LIVE_CONTENT_PKG2, ..., LIVE_CONTENT_PKG6\\n\",\n    name: \"GetIsLiveContentAvailable\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      return NW_FALSE;\n    }\n  },\n  749: {\n    comment: \"749: ResetDialogState\\nResets the GlobalDialogState for the engine.\\nNOTE: NEVER USE THIS UNLESS YOU KNOW WHAT ITS FOR!\\nonly to be used for a failing OnDialog script\\n\",\n    name: \"ResetDialogState\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      if (BitWise.InstanceOfObject(this.caller, ModuleObjectType.ModuleObject)) {\n        this.conversation = undefined;\n      }\n      // if(BitWise.InstanceOfObject(this.listenPatternSpeaker, ModuleObjectType.ModuleObject)){\n      //   this.listenPatternSpeaker._conversation = undefined;\n      // }\n    }\n  },\n  750: {\n    comment: \"750: SetAlignmentGoodEvil\\nSet oCreature's alignment value\\n\",\n    name: \"SetGoodEvilValue\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleCreature, number]) {\n      if (args[1] > 100) args[1] = 100;\n      if (args[1] < 0) args[1] = 0;\n\n      if (args[0]) {\n        args[0].setGoodEvil(args[1]);\n      }\n    }\n  },\n  751: {\n    comment: \"751: GetIsPoisoned\\nReturns TRUE if the object specified is poisoned.\\n\",\n    name: \"GetIsPoisoned\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].isPoisoned();\n      }\n      return 0;\n    }\n  },\n  752: {\n    comment: \"752: GetSpellTarget\\nReturns the object id of the spell target\\n\",\n    name: \"GetSpellTarget\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.OBJECT],\n    action: function (this: NWScriptInstance, args: [ModuleObject]) {\n      if (BitWise.InstanceOfObject(args[0], ModuleObjectType.ModuleCreature)) {\n        return args[0].combatData.lastSpellTarget;\n      }\n      return undefined;\n    }\n  },\n  753: {\n    comment: \"753: SetSoloMode\\nActivates/Deactivates solo mode for the player's party.\\n\",\n    name: \"SetSoloMode\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.SOLOMODE = !!args[0];\n    }\n  },\n  754: {\n    comment: \"754: EffectCutSceneHorrified\\nGet a horrified effect for cutscene purposes (ie. this effect will ignore immunities).\\n\",\n    name: \"EffectCutSceneHorrified\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 8); // Horrified State\n      effect.setInt(1, 1); // is cutscene effect?\n      return effect.initialize();\n    }\n  },\n  755: {\n    comment: \"755: EffectCutSceneParalyze\\nGet a paralyze effect for cutscene purposes (ie. this effect will ignore immunities).\\n\",\n    name: \"EffectCutSceneParalyze\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 5); // Paralyze State\n      effect.setInt(1, 1); // is cutscene effect?\n      return effect.initialize();\n    }\n  },\n  756: {\n    comment: \"756: EffectCutSceneStunned\\nGet a stun effect for cutscene purposes (ie. this effect will ignore immunities).\\n\",\n    name: \"EffectCutSceneStunned\",\n    type: NWScriptDataType.EFFECT,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      const effect = new GameState.GameEffectFactory.EffectSetState();\n      effect.setCreator(this.caller);\n      effect.setSpellId(this.getSpellId());\n      effect.setInt(0, 4); // Stun State\n      effect.setInt(1, 1); // is cutscene effect?\n      return effect.initialize();\n    }\n  },\n  757: {\n    comment: \"757: CancelPostDialogCharacterSwitch()\\nIf a dialog has been started by an NPC on a Non PartyMemeberCanInteract object\\ncalling this function will cancel the Post Dialog switching back to the NPC\\nthat did the initiating.\\n\",\n    name: \"CancelPostDialogCharacterSwitch\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  758: {\n    comment: \"758: SetMaxHitPoints\\nSet the maximum hitpoints of oObject\\nThe objects maximum AND current hitpoints will be nMaxHP after the function is called\\n\",\n    name: \"SetMaxHitPoints\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [ModuleObject, number]) {\n      if (args[0]) {\n        args[0].setMaxHP(args[1]);\n      }\n    }\n  },\n  759: {\n    comment: \"759: NoClicksFor()\\nThis command will not allow clicking on anything for 'fDuration' seconds\\n\",\n    name: \"NoClicksFor\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      GameState.noClickTimer = args[0] || 0;\n    }\n  },\n  760: {\n    comment: \"760: HoldWorldFadeInForDialog()\\nThis will hold the fade in at the begining of a module until a dialog starts\\n\",\n    name: \"HoldWorldFadeInForDialog\",\n    type: NWScriptDataType.VOID,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      GameState.holdWorldFadeInForDialog = true;\n    }\n  },\n  761: {\n    comment: \"761: ShipBuild()\\nThis will return if this is a shipping build. this should be used to disable all debug output.\\n\",\n    name: \"ShipBuild\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return NW_FALSE;\n    }\n  },\n  762: {\n    comment: \"762: SurrenderRetainBuffs()\\nThis will do the same as SurrenderToEnemies, except that affected creatures will not\\nlose effects which they have put on themselves\\n\",\n    name: \"SurrenderRetainBuffs\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  763: {\n    comment: \"763. SuppressStatusSummaryEntry\\nThis will prevent the next n entries that should have shown up in the status summary\\nfrom being added\\nThis will not add on to any existing summary suppressions, but rather replace it.  So\\nto clear the supression system pass 0 as the entry value\\n\",\n    name: \"SuppressStatusSummaryEntry\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER]\n  },\n  764: {\n    comment: \"764. GetCheatCode\\nReturns true if cheat code has been enabled\\n\",\n    name: \"GetCheatCode\",\n    type: NWScriptDataType.INTEGER,\n    args: [NWScriptDataType.INTEGER]\n  },\n  765: {\n    comment: \"765. SetMusicVolume\\nNEVER USE THIS!\\n\",\n    name: \"SetMusicVolume\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.FLOAT],\n    action: function (this: NWScriptInstance, args: [number]) {\n      AudioEngine.GAIN_MUSIC = Math.max(0, Math.min(1, args[0] / 100));\n    }\n  },\n  766: {\n    comment: \"766. CreateItemOnFloor\\nShould only be used for items that have been created on the ground, and will\\nbe destroyed without ever being picked up or equipped.  Returns true if successful\\n\",\n    name: \"CreateItemOnFloor\",\n    type: NWScriptDataType.OBJECT,\n    args: [NWScriptDataType.STRING, NWScriptDataType.LOCATION, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, EngineLocation, number]) {\n      const buffer = ResourceLoader.loadCachedResource(ResourceTypes.uti, args[0]);\n      if (buffer) {\n        const item = new GameState.Module.ModuleArea.ModuleItem(new GFFObject(buffer));\n        item.placedInWorld = true;\n        item.position.copy(args[1].position);\n        item.rotation.order = 'ZYX';\n        item.rotation.set(args[1].getFacing(), Math.PI / 2, 0);\n        item.load();\n        item.loadModel().then((model: OdysseyModel3D) => {\n          item.model.userData.moduleObject = item;\n\n          model.name = item.getTag();\n          GameState.group.placeables.add(model);\n          GameState.module.area.items.push(item);\n\n          item.getCurrentRoom();\n        });\n        return true;\n      }\n      log.error('CreateItemOnFloor', 'Failed to load item template', args);\n      return false;\n    }\n  },\n  767: {\n    comment: \"767. SetAvailableNPCId\\nThis will set the object id that should be used for a specific available NPC\\n\",\n    name: \"SetAvailableNPCId\",\n    type: NWScriptDataType.VOID,\n    args: []\n  },\n  768: {\n    comment: \"768. IsMoviePlaying\\nChecks if a movie is currently playing.\\n\",\n    name: \"IsMoviePlaying\",\n    type: NWScriptDataType.INTEGER,\n    args: [],\n    action: function (this: NWScriptInstance, args: []) {\n      return VideoPlayer.IsMoviePlaying() ? 1 : 0;\n    }\n  },\n  769: {\n    comment: \"769. QueueMovie\\nQueues up a movie to be played using PlayMovieQueue.\\nIf bSkippable is TRUE, the player can cancel the movie by hitting escape.\\nIf bSkippable is FALSE, the player cannot cancel the movie and must wait\\nfor it to finish playing.\\n\",\n    name: \"QueueMovie\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.STRING, NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [string, number]) {\n      VideoPlayer.QueueMovie(args[0], !!args[1]);\n    }\n  },\n  770: {\n    comment: \"770. PlayMovieQueue\\nPlays the movies that have been added to the queue by QueueMovie\\nIf bAllowSeparateSkips is TRUE, hitting escape to cancel a movie only\\ncancels out of the currently playing movie rather than the entire queue\\nof movies (assuming the currently playing movie is flagged as skippable).\\nIf bAllowSeparateSkips is FALSE, the entire movie queue will be cancelled\\nif the player hits escape (assuming the currently playing movie is flagged\\nas skippable).\\n\",\n    name: \"PlayMovieQueue\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.INTEGER],\n    action: function (this: NWScriptInstance, args: [number]) {\n      VideoPlayer.PlayMovieQueue(!!args[0]);\n    }\n  },\n  771: {\n    comment: \"771. YavinHackCloseDoor\\nThis is an incredibly hacky function to allow the doors to be properly\\nclosed on Yavin without running into the problems we've had.  It is too\\nlate in development to fix it correctly, so thus we do this.  Life is\\nhard.  You'll get over it\\n\",\n    name: \"YavinHackCloseDoor\",\n    type: NWScriptDataType.VOID,\n    args: [NWScriptDataType.OBJECT]\n  }\n} as unknown as { [key: number]: import(\"../interface/nwscript/INWScriptDefAction\").INWScriptDefAction };\n\n// for (let property in NWScriptDef.Actions) {\n//   if (NWScriptDef.Actions.hasOwnProperty(property)) {\n//     if(NWScriptDefK1.Actions[property]){\n//       if(NWScriptDefK1.Actions[property].action === undefined){\n//         NWScriptDefK1.Actions[property].action = NWScriptDef.Actions[property].action;\n//       }\n//     }\n//   }\n// }\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\NWScriptInstructionSet.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":182,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":182,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":187,"column":23,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":187,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":337,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":337,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":337,"column":40,"nodeType":"MemberExpression","messageId":"errorCall","endLine":337,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":421,"column":13,"nodeType":"MemberExpression","messageId":"errorCall","endLine":421,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":421,"column":40,"nodeType":"MemberExpression","messageId":"errorCall","endLine":421,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":630,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":630,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":633,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":633,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":636,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":636,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":639,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":639,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":642,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":642,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":646,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":646,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":647,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":647,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `NWScriptStackVariable | NWScriptStackValue`.","line":648,"column":23,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":648,"endColumn":58}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\nimport { NWScriptTypes } from \"@/enums/nwscript/NWScriptTypes\";\nimport { GameState } from \"@/GameState\";\nimport { INWScriptDefAction } from \"@/interface/nwscript/INWScriptDefAction\";\n// import { ModuleObjectManager } from \"@/managers/ModuleObjectManager\";\nimport type { INWScriptStoreState } from \"@/interface/nwscript/INWScriptStoreState\";\nimport { NW_FALSE, NW_TRUE } from \"@/nwscript/NWScriptConstants\";\nimport type { NWScriptInstance } from \"@/nwscript/NWScriptInstance\";\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\nimport { NWScriptSubroutine } from \"@/nwscript/NWScriptSubroutine\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.NWScript);\n\n\n\n\n/**\n * CALL_CPDOWNSP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_CPDOWNSP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  //Replace the target stack element with the appropriate element relative to the top of the stack\n  this.stack.stack.copyWithin(\n    Math.max((this.stack.pointer + instruction.offset) / 4, 0),\n    (this.stack.pointer - instruction.size) / 4,\n    (this.stack.pointer) / 4,\n  );\n}\n\n/**\n * CALL_RSADD\n *\n * Reserve Space On Stack\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_RSADD = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  switch (instruction.type) {\n    case 3:\n      this.stack.push(0, NWScriptDataType.INTEGER);\n      break;\n    case 4:\n      this.stack.push(0.0, NWScriptDataType.FLOAT);\n      break;\n    case 5:\n      this.stack.push('', NWScriptDataType.STRING);\n      break;\n    case 6:\n      this.stack.push(undefined, NWScriptDataType.OBJECT);\n      break;\n    case 16:\n      this.stack.push(undefined, NWScriptDataType.EFFECT);\n      break;\n    case 17:\n      this.stack.push(undefined, NWScriptDataType.EVENT);\n      break;\n    case 18:\n      this.stack.push(undefined, NWScriptDataType.LOCATION);\n      break;\n    case 19:\n      this.stack.push(undefined, NWScriptDataType.TALENT);\n      break;\n    default:\n      log.warn(\"RSADD unknown type\", instruction.type, instruction);\n      throw 'unknown type ' + instruction.type;\n      break;\n  }\n}\n\n/**\n * CALL_CPTOPSP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_CPTOPSP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  const elements = this.stack.copyAtPointer(instruction.offset, instruction.size);\n  if (elements.length == (instruction.size / 4)) {\n    this.stack.stack.push(...elements);\n    this.stack.pointer += instruction.size;\n  } else {\n    throw new Error(`CPTOPSP: copy size miss-match, expected: ${instruction.size} | received: ${elements.length * 4}`);\n  }\n}\n\n/**\n * CALL_CONST\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_CONST = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  switch (instruction.type) {\n    case 3:\n      this.stack.push(instruction.integer, NWScriptDataType.INTEGER);\n      break;\n    case 4:\n      this.stack.push(instruction.float, NWScriptDataType.FLOAT);\n      break;\n    case 5:\n      this.stack.push(instruction.string, NWScriptDataType.STRING);\n      break;\n    case 6:\n      if (instruction.object == 0) {\n        this.stack.push(this.caller, NWScriptDataType.OBJECT);\n      } else {\n        this.stack.push(undefined, NWScriptDataType.OBJECT);\n      }\n      break;\n    case 12:\n      this.stack.push(instruction.string, NWScriptDataType.LOCATION);\n      break;\n    default:\n      log.warn(\"CONST unknown type\", instruction.type, instruction);\n      break;\n  }\n}\n\n/**\n * CALL_ACTION\n *\n * Constant Type is declared by the next byte x03, x04, x05, x06\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_ACTION = function (this: NWScriptInstance, instruction: NWScriptInstruction): void {\n  const action_definition: INWScriptDefAction = instruction.actionDefinition;\n  const args: (number | string | object)[] = [];\n\n  for (let i = 0, len = action_definition.args.length; i < len; i++) {\n    switch (action_definition.args[i]) {\n      case NWScriptDataType.OBJECT:\n        args.push(this.stack.pop()?.value);\n        //Test for and fix instances where an object id is pushed instead of an object reference\n        if (typeof args[i] == 'number') args[i] = GameState.ModuleObjectManager.GetObjectById(args[i]);\n        break;\n      case NWScriptDataType.STRING:\n      case NWScriptDataType.INTEGER:\n      case NWScriptDataType.FLOAT:\n      case NWScriptDataType.EFFECT:\n      case NWScriptDataType.EVENT:\n      case NWScriptDataType.LOCATION:\n      case NWScriptDataType.TALENT:\n        args.push(this.stack.pop()?.value);\n        break;\n      case NWScriptDataType.ACTION:\n        args.push(this.state.pop());\n        break;\n      case NWScriptDataType.VECTOR:\n        args.push(new THREE.Vector3(\n          this.stack.pop()?.value,\n          this.stack.pop()?.value,\n          this.stack.pop()?.value\n        ))\n        break;\n      default:\n        //Pop the function variables off the stack after we are done with them\n        args.push(this.stack.pop()?.value);\n        log.warn(\"CALL_ACTION unknown arg type\", action_definition, args);\n        break;\n    }\n  }\n\n  if (typeof action_definition.action === 'function') {\n    const actionValue = action_definition.action.call(this, args);\n    if (action_definition.type != NWScriptDataType.VOID) {\n      if (typeof actionValue == 'undefined' && action_definition.type != NWScriptDataType.OBJECT) {\n        log.warn(\"CALL_ACTION returned undefined\", action_definition.name);\n      }\n      this.stack.push(actionValue, action_definition.type);\n    }\n  } else {\n    log.warn(\"NWScript Action not found\", action_definition.name, action_definition);\n  }\n\n}\n\n/**\n * CALL_LOGANDII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_LOGANDII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  if (this.var1 && this.var2)\n    this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n  else\n    this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n}\n\n/**\n * CALL_LOGORII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_LOGORII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  if (this.var1 || this.var2)\n    this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n  else\n    this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n}\n\n/**\n * CALL_INCORII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_INCORII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  this.stack.push(this.var1 | this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_EXCORII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_EXCORII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n  this.stack.push(this.var1 ^ this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_BOOLANDII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_BOOLANDII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  this.stack.push(this.var1 & this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_EQUAL\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_EQUAL = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  if (instruction.type == NWScriptDataType.STRUCTURE) {\n    this.struct2 = [];\n    this.struct1 = [];\n\n    const count = instruction.sizeOfStructure / 4;\n    //populate structure2's variables\n    for (let i = 0; i < count; i++) {\n      this.struct2.push(this.stack.pop()?.value);\n    }\n    //populate structure1's variables\n    for (let i = 0; i < count; i++) {\n      this.struct1.push(this.stack.pop()?.value);\n    }\n\n    let areStructuresEqual = true;\n    //Check for equality between the structures variables\n    for (let i = 0; i < count; i++) {\n      if (this.struct1[i] != this.struct2[i]) {\n        areStructuresEqual = false;\n      }\n    }\n\n    // log.info('EQUALTT', areStructuresEqual, this.struct1, this.struct2);\n\n    if (areStructuresEqual)\n      this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n    else\n      this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n\n  } else {\n    this.var2 = this.stack.pop()?.value;\n    this.var1 = this.stack.pop()?.value;\n\n    switch (instruction.type) {\n      case NWScriptTypes.II:\n        if (this.var1 == this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.FF:\n        if (this.var1 == this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.OO:\n        if (this.var1 == this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.SS:\n        if (this.var1.toLowerCase() == this.var2.toLowerCase())\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.LOCLOC:\n        if (this.locationCompare(this.var1, this.var2)) {\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        } else {\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//TRUE\n        }\n        break;\n      default:\n        log.warn(\"EQUAL: Missing Type\", instruction.type);\n        break;\n    }\n  }\n}\n\n/**\n * CALL_NEQUAL\n *\n * Constant Type is declared by the next byte x03, x04, x05, x06\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_NEQUAL = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  if (instruction.type == NWScriptDataType.STRUCTURE) {\n    this.struct2 = [];\n    this.struct1 = [];\n\n    const count = instruction.sizeOfStructure / 4;\n\n    //populate structure2's variables\n    for (let i = 0; i < count; i++) {\n      this.struct2.push(this.stack.pop()?.value);\n    }\n    //populate structure1's variables\n    for (let i = 0; i < count; i++) {\n      this.struct1.push(this.stack.pop()?.value);\n    }\n\n    let areStructuresEqual = true;\n    //Check for equality between the structures variables\n    for (let i = 0; i < count; i++) {\n      if (this.struct1[i] != this.struct2[i]) {\n        areStructuresEqual = false;\n      }\n    }\n\n    // log.info('NEQUALTT', !areStructuresEqual, this.struct1, this.struct2);\n\n    if (!areStructuresEqual)\n      this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n    else\n      this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n\n  } else {\n    this.var2 = this.stack.pop()?.value;\n    this.var1 = this.stack.pop()?.value;\n\n    switch (instruction.type) {\n      case NWScriptTypes.II:\n        if (this.var1 != this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.FF:\n        if (this.var1 != this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.OO:\n        if (this.var1 != this.var2)\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.SS:\n        if (this.var1.toLowerCase() != this.var2.toLowerCase())\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        else\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n        break;\n      case NWScriptTypes.LOCLOC:\n        if (!this.locationCompare(this.var1, this.var2)) {\n          this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n        } else {\n          this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//TRUE\n        }\n        break;\n      default:\n        log.warn(\"NEQUAL: Missing Type\", instruction.type);\n        break;\n    }\n  }\n}\n\n/**\n * CALL_GEQ\n *\n * Constant Type is declared by the next byte x03, x04, x05, x06\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_GEQ = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      if (this.var1 >= this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    case NWScriptTypes.FF:\n      if (this.var1 >= this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    default:\n      log.warn(\"GEQ: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_GT\n *\n * Constant Type is declared by the next byte x03, x04\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_GT = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      if (this.var1 > this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    case NWScriptTypes.FF:\n      if (this.var1 > this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    default:\n      log.warn(\"GT: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_LT\n *\n * Constant Type is declared by the next byte (e.g. 3, 4)\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_LT = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      if (this.var1 < this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    case NWScriptTypes.FF:\n      if (this.var1 < this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    default:\n      log.warn(\"LT: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_LEQ\n *\n * Constant Type is declared by the next byte (e.g. 3, 4)\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_LEQ = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      if (this.var1 <= this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    case NWScriptTypes.FF:\n      if (this.var1 <= this.var2)\n        this.stack.push(NW_TRUE, NWScriptDataType.INTEGER)//TRUE\n      else\n        this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n      break;\n    default:\n      log.warn(\"LEQ: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_SHLEFTII\n *\n * Constant Type is declared by the next byte (e.g. 3, 4)\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_SHLEFTII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n  this.stack.push(this.var1 << this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_SHRIGHTII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_SHRIGHTII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n  this.stack.push(this.var1 >> this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_USHRIGHTII\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_USHRIGHTII = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n  this.stack.push(this.var1 >>> this.var2, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_ADD\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_ADD = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = (this.stack.pop()?.value);\n  this.var1 = (this.stack.pop()?.value);\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      this.stack.push(this.var1 + this.var2, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.IF:\n      this.stack.push(this.var1 + this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FI:\n      this.stack.push(this.var1 + this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FF:\n      this.stack.push(this.var1 + this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.SS:\n      this.stack.push(this.var1 + this.var2, NWScriptDataType.STRING);\n      break;\n    case NWScriptTypes.VV:\n      this.var3 = this.stack.pop()?.value;\n      this.stack.push(this.var1 + this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      this.stack.push(this.var2 + this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      this.stack.push(this.var3 + this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      break;\n    default:\n      log.warn(\"ADD: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_SUB\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_SUB = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      this.stack.push(this.var1 - this.var2, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.IF:\n      this.stack.push(this.var1 - this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FI:\n      this.stack.push(this.var1 - this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FF:\n      this.stack.push(this.var1 - this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.VV:\n      this.var3 = this.stack.pop()?.value;\n      this.stack.push(this.var1 - this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      this.stack.push(this.var2 - this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      this.stack.push(this.var3 - this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      break;\n    default:\n      log.warn(\"SUB: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_MUL\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_MUL = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.IF:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FI:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FF:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.VF:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.FLOAT); //Z\n      this.stack.push(this.stack.pop()?.value * this.var2, NWScriptDataType.FLOAT); //Y\n      this.stack.push(this.stack.pop()?.value * this.var2, NWScriptDataType.FLOAT); //X\n      break;\n    case NWScriptTypes.FV:\n      this.stack.push(this.var1 * this.var2, NWScriptDataType.FLOAT); //Z\n      this.stack.push(this.var1 * this.stack.pop()?.value, NWScriptDataType.FLOAT); //Y\n      this.stack.push(this.var1 * this.stack.pop()?.value, NWScriptDataType.FLOAT); //X\n      break;\n    default:\n      log.warn(\"MUL: Missing Type\", instruction.type);\n      break;\n  }\n}\n\n/**\n * CALL_DIV\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_DIV = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      this.stack.push((this.var1 / this.var2) | 0, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.IF:\n      this.stack.push(this.var1 / this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FI:\n      this.stack.push(this.var1 / this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FF:\n      this.stack.push(this.var1 / this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.VF:\n      this.stack.push(this.var1 / this.var2, NWScriptDataType.FLOAT); //Z\n      this.stack.push(this.stack.pop()?.value / this.var2, NWScriptDataType.FLOAT); //Y\n      this.stack.push(this.stack.pop()?.value / this.var2, NWScriptDataType.FLOAT); //X\n      break;\n  }\n}\n\n/**\n * CALL_MOD\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_MOD = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var2 = this.stack.pop()?.value;\n  this.var1 = this.stack.pop()?.value;\n\n  switch (instruction.type) {\n    case NWScriptTypes.II:\n      this.stack.push(this.var1 % this.var2, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.IF:\n      this.stack.push(this.var1 % this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FI:\n      this.stack.push(this.var1 % this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.FF:\n      this.stack.push(this.var1 % this.var2, NWScriptDataType.FLOAT);\n      break;\n    case NWScriptTypes.VF:\n      this.stack.push(this.var1 % this.var2, NWScriptDataType.FLOAT); //Z\n      this.stack.push(this.stack.pop()?.value % this.var2, NWScriptDataType.FLOAT); //Y\n      this.stack.push(this.stack.pop()?.value % this.var2, NWScriptDataType.FLOAT); //X\n      break;\n  }\n}\n\n/**\n * CALL_NEG\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_NEG = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  switch (instruction.type) {\n    case NWScriptTypes.I:\n      this.stack.push(-this.stack.pop()?.value, NWScriptDataType.INTEGER);\n      break;\n    case NWScriptTypes.F:\n      this.stack.push(-this.stack.pop()?.value, NWScriptDataType.FLOAT);\n      break;\n  }\n}\n\n/**\n * CALL_COMPI\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_COMPI = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.stack.push(~this.stack.pop()?.value, NWScriptDataType.INTEGER);\n}\n\n/**\n * CALL_MOVSP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_MOVSP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.stack.stack.splice(\n    (this.stack.pointer += instruction.offset) / 4,\n    (Math.abs(instruction.offset) / 4)\n  );\n}\n\n/**\n * CALL_STORE_STATEALL\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n * @deprecated\n */\nexport const CALL_STORE_STATEALL = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  //OBSOLETE NOT SURE IF USED IN KOTOR\n}\n\n/**\n * CALL_JMP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_JMP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.seek = instruction.address + instruction.offset;\n}\n\n/**\n * CALL_JSR\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_JSR = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.seek = instruction.address + instruction.offset;\n  this.subRoutine = new NWScriptSubroutine(instruction.nextInstr.address);\n  this.subRoutines.push(this.subRoutine); //Where to return to after the subRoutine is done\n\n  if (this.subRoutines.length > 1000)\n    throw 'JSR seems to be looping endlessly';\n}\n\n/**\n * CALL_JZ\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_JZ = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  const popped = this.stack.pop()?.value;\n  if (popped == 0) {\n    this.seek = instruction.address + instruction.offset;\n  }\n}\n\n/**\n * CALL_RETN\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_RETN = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  if (!this.subRoutines.length) {\n    this.subRoutine = undefined;\n    this.running = false;\n    return;\n  }\n\n  const subRoutine = this.subRoutines.pop();\n  subRoutine.onEnd();\n\n  this.subRoutine = this.subRoutines[this.subRoutines.length - 1];\n\n  if (subRoutine.returnAddress == -1) {\n    this.seek = null;\n  } else {\n    this.seek = subRoutine.returnAddress;\n  }\n}\n\n/**\n * CALL_DESTRUCT\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_DESTRUCT = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  //retrieve the elements to save from the stack by popping them off of the stack\n  const elements = this.stack.stack.splice(\n    //offset of the first element to retrieve\n    ((this.stack.pointer - instruction.sizeToDestroy) + instruction.offsetToSaveElement) / 4,\n    //count of elements to save\n    instruction.sizeOfElementToSave / 4\n  );\n  //push the saved elements back onto the stack\n  this.stack.stack.push(\n    //the spread operator (...) merges the returned array elements back onto the stack array instead\n    //of pushing the array itself back onto the stack\n    ...elements\n  );\n\n  //destroy the remaing elements off the stack\n  this.stack.stack.splice(\n    //offset of the first element to destroy\n    (this.stack.pointer - instruction.sizeToDestroy) / 4,\n    //count of elements to destroy\n    (instruction.sizeToDestroy - instruction.sizeOfElementToSave) / 4\n  )\n\n  //Adjust the stack pointer accoringly\n  this.stack.pointer -= (instruction.sizeToDestroy - instruction.sizeOfElementToSave);\n}\n\n/**\n * CALL_NOTI\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_NOTI = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  if (!this.stack.pop()?.value)\n    this.stack.push(NW_TRUE, NWScriptDataType.INTEGER);//TRUE\n  else\n    this.stack.push(NW_FALSE, NWScriptDataType.INTEGER)//FALSE\n}\n\n/**\n * CALL_DECISP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_DECISP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var1 = (this.stack.getAtPointer(instruction.offset));\n  this.var1.value -= 1;\n}\n\n/**\n * CALL_INCISP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_INCISP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var1 = (this.stack.getAtPointer(instruction.offset));\n  this.var1.value += 1;\n}\n\n/**\n * CALL_JNZ\n *\n * I believe this is used in SWITCH statements\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_JNZ = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  const jnzTOS = this.stack.pop()?.value;\n  if (jnzTOS != 0) {\n    this.seek = instruction.address + instruction.offset;\n  }\n}\n\n/**\n * CALL_CPDOWNBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_CPDOWNBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.stack.stack.copyWithin(\n    (this.stack.basePointer + instruction.offset) / 4,\n    (this.stack.pointer - instruction.size) / 4,\n  );\n}\n\n/**\n * CALL_CPTOPBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_CPTOPBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  const elements = this.stack.copyAtBasePointer(instruction.offset, instruction.size);\n  if (elements.length == (instruction.size / 4)) {\n    this.stack.stack.push(...elements);\n    this.stack.pointer += instruction.size;\n  } else {\n    throw new Error(`CPTOPBP: copy size miss-match, expected: ${instruction.size} | received: ${elements.length * 4}`);\n  }\n}\n\n/**\n * CALL_DECIBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_DECIBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var1 = (this.stack.getAtBasePointer(instruction.offset));\n  this.var1.value -= 1;\n}\n\n/**\n * CALL_INCIBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_INCIBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.var1 = (this.stack.getAtBasePointer(instruction.offset));\n  this.var1.value += 1;\n}\n\n/**\n * CALL_SAVEBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_SAVEBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.stack.saveBP();\n}\n\n/**\n * CALL_RESTOREBP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_RESTOREBP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  this.stack.restoreBP();\n}\n\n/**\n * CALL_STORE_STATE\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_STORE_STATE = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  const state: INWScriptStoreState = {\n    offset: instruction.nextInstr.nextInstr.address,\n    base: [], //this.stack.stack.slice(0, (instr.bpOffset/4)),\n    local: [], //this.stack.stack.slice(this.stack.stack.length-(instr.spOffset/4), this.stack.stack.length)\n    instr: instruction,\n    script: this.nwscript.newInstance()\n  };\n\n  //log.info('STORE_STATE', this.stack.stack.length, this.stack.basePointer);\n  state.script.address = state.offset;\n  state.script.offset = state.offset;\n  state.script.nwscript = this.nwscript;\n  state.script.isStoreState = true;\n  state.script.name = this.name;\n  state.script.prevByteCode = 0;\n  //state.script.Definition = this.Definition;\n  state.script.subRoutines = [];\n\n  state.script.stack.stack = this.stack.stack.slice();\n  state.script.stack.basePointer = this.stack.basePointer;\n  state.script.stack.pointer = this.stack.pointer;\n  state.script.caller = this.caller;\n  state.script.enteringObject = this.enteringObject;\n  state.script.listenPatternNumber = this.listenPatternNumber;\n  state.script.listenPatternSpeaker = this.listenPatternSpeaker;\n  state.script.scriptVar = this.scriptVar;\n  this.state.push(state);\n  state.script.state = this.state.slice();\n\n  //log.info('STORE_STATE', state.script);\n\n}\n\n/**\n * CALL_NOP\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport const CALL_NOP = function (this: NWScriptInstance, instruction: NWScriptInstruction) {\n  //NO Operation\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\NWScriptStack.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `GFFFieldValue`.","line":250,"column":88,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":250,"endColumn":153},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":278,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":278,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":279,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":279,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":391,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":391,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":392,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":392,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":477,"column":100,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":477,"endColumn":165},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":492,"column":43,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":492,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":494,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":494,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":494,"column":21,"nodeType":"MemberExpression","messageId":"errorCall","endLine":494,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":495,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":495,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":496,"column":36,"nodeType":"MemberExpression","messageId":"errorCall","endLine":496,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [i] on a type that cannot be resolved.","line":496,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":496,"endColumn":43}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GameEffectFactory } from \"@/effects/GameEffectFactory\";\r\nimport EngineLocation from \"@/engine/EngineLocation\";\r\nimport { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\r\nimport { GFFDataType } from \"@/enums/resource/GFFDataType\";\r\nimport { GameState } from \"@/GameState\";\r\nimport type { ModuleObject } from \"@/module\";\r\nimport { NWScriptEventFactory } from \"@/nwscript/events/NWScriptEventFactory\";\r\nimport type { NWScriptStackValue } from \"@/nwscript/NWScriptStackVariable\";\r\nimport { NWScriptStackVariable } from \"@/nwscript/NWScriptStackVariable\";\r\nimport { GFFField } from \"@/resource/GFFField\";\r\nimport { GFFStruct } from \"@/resource/GFFStruct\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\n\r\n/** Stored state for stack save/restore (local/global stack snapshot and pointers). */\r\nexport interface INWScriptStackStoreState {\r\n  localStack: NWScriptStackVariable[];\r\n  globalStack: NWScriptStackVariable[];\r\n  pointer: number;\r\n  basePointer: number;\r\n}\r\n\r\nconst STACK_PACKET_CONSTANTS = {\r\n  STACK_ELEMENT_SIZE: 8,\r\n  HEADER_SIZE: 16\r\n}\r\n\r\n/**\r\n * NWScriptStack class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptStack.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptStack {\r\n  stack: NWScriptStackVariable[];\r\n  pointer: number;\r\n  basePointer: number;\r\n  _storeState: INWScriptStackStoreState;\r\n  oldBP: number;\r\n  stackSize: number;\r\n\r\n\r\n  constructor(){\r\n    this.stack = [];\r\n    this.pointer = 0;\r\n    this.basePointer = 0;\r\n    this._storeState = {\r\n      localStack: [],\r\n      globalStack: [],\r\n      pointer: 0,\r\n      basePointer: 0\r\n    };\r\n    this.oldBP = 0;\r\n    this.stackSize = 0;\r\n  }\r\n\r\n  //Data pushed to the stack must be no longer and no shorter than 4 bytes\r\n  push(data: NWScriptStackVariable | NWScriptStackValue, type?: NWScriptDataType): void {\r\n    if(data instanceof NWScriptStackVariable){\r\n      this.stack.push( data );\r\n    }else{\r\n      if(type === null)\r\n        log.warn('NWScriptStack.push: type is NULL', data);\r\n\r\n      if(type === undefined && type !== NWScriptDataType.OBJECT)\r\n        log.warn('NWScriptStack.push: type undefined (and not OBJECT)', data);\r\n\r\n      if(type === NWScriptDataType.VECTOR){\r\n        if(typeof data === 'object' && data !== null && 'x' in (data as Record<string, number>)){\r\n          const v = data as { x?: number; y?: number; z?: number };\r\n          this.stack.push( new NWScriptStackVariable({ value: v.z ?? 0.0, type: NWScriptDataType.FLOAT }) );\r\n          this.stack.push( new NWScriptStackVariable({ value: v.y ?? 0.0, type: NWScriptDataType.FLOAT }) );\r\n          this.stack.push( new NWScriptStackVariable({ value: v.x ?? 0.0, type: NWScriptDataType.FLOAT }) );\r\n          //Increase the pointer by 8 to account for Y and X\r\n          this.pointer += 8;\r\n        }else{\r\n          this.stack.push( new NWScriptStackVariable({ value: 0.0, type: NWScriptDataType.FLOAT }) );\r\n          this.stack.push( new NWScriptStackVariable({ value: 0.0, type: NWScriptDataType.FLOAT }) );\r\n          this.stack.push( new NWScriptStackVariable({ value: 0.0, type: NWScriptDataType.FLOAT }) );\r\n          //Increase the pointer by 8 to account for Y and X\r\n          this.pointer += 8;\r\n        }\r\n      }else{\r\n        this.stack.push( new NWScriptStackVariable({ value: data as NWScriptStackValue, type: type ?? NWScriptDataType.INTEGER }) );\r\n      }\r\n    }\r\n    this.pointer += 4;\r\n  }\r\n\r\n  pop(){\r\n    \r\n    this.pointer -= 4;\r\n    return this.stack.pop();\r\n  }\r\n\r\n  peek(offset = 0){\r\n    return this.stack[ ( (this.pointer - 4) - offset)  / 4];\r\n  }\r\n\r\n  getPointerPositionRelative(relPos = -4){\r\n    return (this.pointer + relPos) / 4;\r\n  }\r\n\r\n  getAtPointer(index = -4){\r\n    return this.stack[this.getPointerPositionRelative(index)];\r\n  }\r\n\r\n  getAtTop(index = -4){\r\n    return this.stack[((this.stack.length*4) + index) / 4];\r\n  }\r\n\r\n  getAtBasePointer(index = -4){\r\n    return this.stack[(this.basePointer + index) / 4];\r\n  }\r\n\r\n  copyAtBasePointer(index = -4, copyLength = 4){\r\n    return this.stack.slice((this.basePointer + index) / 4, ((this.basePointer + index) / 4) + (copyLength / 4));\r\n  }\r\n\r\n  copyAtPointer(index = -4, copyLength = 4){\r\n    return this.stack.slice((this.pointer + index) / 4, ((this.pointer + index) / 4) + (copyLength / 4));\r\n  }\r\n\r\n  replace(index = -4, data?: NWScriptStackVariable): void {\r\n\r\n    /*if(!(data instanceof Uint8Array))\r\n      throw 'Data is not of type Uint8Array';\r\n\r\n    if(data.length != 4)\r\n      throw 'Data is not 4Bytes in length. All data pushed to the stack must be 4Bytes in length.';*/\r\n\r\n    /*index = index / 4; //This is always a negative value\r\n\r\n    if(index > -1)\r\n      throw 'Index cannot be greater than -1.';\r\n\r\n    log.debug('STACK_LEN', this.stack.length, index, (this.stack.length*4) + index);\r\n\r\n    this.stack[this.stack.length + index] = data;*/\r\n\r\n    //index = index / 4; //This is always a negative value\r\n    \r\n    //if(index > -1)\r\n    //  throw 'Index cannot be greater than -1.';\r\n\r\n    this.stack[((this.pointer + index)/4)] = data;\r\n\r\n  }\r\n\r\n  replaceBP(index = -4, data?: NWScriptStackVariable): void {\r\n    \r\n    /*if(!(data instanceof Uint8Array))\r\n      throw 'Data is not of type Uint8Array';\r\n\r\n    if(data.length != 4)\r\n      throw 'Data is not 4Bytes in length. All data pushed to the stack must be 4Bytes in length.';*/\r\n\r\n    //index = index / 4; //This is always a negative value\r\n\r\n    /*if(index > -4)\r\n      throw 'Index cannot be greater than -4.';\r\n\r\n    this.stack[(this.basePointer*4) + index] = data;*/\r\n\r\n    //index = index / 4; //This is always a negative value\r\n    \r\n    //if(index > -1)\r\n    //  throw 'Index cannot be greater than -1.';\r\n    this.stack[(this.basePointer + index)/4] = data;\r\n\r\n  }\r\n\r\n  getSize(){\r\n\r\n  }\r\n\r\n  getPointer(){\r\n    return this.pointer;\r\n  }\r\n\r\n  setPointer(pos: number = 0){\r\n    this.pointer += pos;\r\n  }\r\n\r\n  setBasePointer(pos: number = 0){\r\n    this.basePointer += pos;\r\n  }\r\n\r\n  storeState(bpO: number = 0, spO: number = 0){\r\n\r\n    const stack = [];\r\n    for(let i = 0; i < spO; i++){\r\n      const tmpPointer = (this.pointer - i);\r\n      stack.push(this.stack[tmpPointer])\r\n    }\r\n\r\n    this._storeState = {\r\n      localStack: this.stack,//stack.reverse(),\r\n      globalStack: this.stack,//globalStack.reverse(),\r\n      pointer: this.pointer,\r\n      basePointer: this.basePointer\r\n    };\r\n    //TODO:: Actually implement this properly\r\n\r\n  }\r\n\r\n  restoreState(){\r\n    this.stack = this._storeState.localStack;\r\n    this.stack = this._storeState.globalStack;\r\n    this.pointer = this._storeState.pointer;\r\n    this.basePointer = this._storeState.basePointer;\r\n    //TODO:: Actually implement this properly\r\n  }\r\n\r\n  saveBP() {\r\n    this.oldBP = this.basePointer;\r\n    this.basePointer = this.pointer;\r\n    //this.pointer = 0;\r\n  }\r\n\r\n  restoreBP() {\r\n    //alert('restore BP');\r\n    //this.basePointer = this.oldBP;\r\n  }\r\n\r\n  dispose(){\r\n    this.stack = [];\r\n    this.pointer = 0;\r\n    this.basePointer = 0;\r\n  }\r\n\r\n  saveForEventSituation(){\r\n    const struct = new GFFStruct();\r\n\r\n    struct.addField( new GFFField(GFFDataType.INT, 'BasePointer') ).setValue(this.basePointer);\r\n\r\n    const stack = struct.addField( new GFFField(GFFDataType.LIST, 'Stack') ).setValue(this.pointer);\r\n    for(let i = 0; i < this.stack.length; i++){\r\n      const element = this.stack[i];\r\n      const elementStruct = new GFFStruct(i);\r\n\r\n      elementStruct.addField( new GFFField(GFFDataType.CHAR, 'Type') ).setValue( element.type );\r\n      switch(element.type){\r\n        case NWScriptDataType.OBJECT:\r\n          elementStruct.addField( new GFFField(GFFDataType.DWORD, 'Value') ).setValue( typeof element.value === 'object' ? element.value.id : 2130706432 );\r\n        break;\r\n        case NWScriptDataType.INTEGER:\r\n          elementStruct.addField( new GFFField(GFFDataType.INT, 'Value') ).setValue( element.value );\r\n        break;\r\n        case NWScriptDataType.FLOAT:\r\n          elementStruct.addField( new GFFField(GFFDataType.FLOAT, 'Value') ).setValue( element.value );\r\n        break;\r\n        case NWScriptDataType.STRING:\r\n          elementStruct.addField( new GFFField(GFFDataType.CEXOSTRING, 'Value') ).setValue( element.value );\r\n        break;\r\n        case NWScriptDataType.EFFECT:\r\n          const gameDefinedStruct = new GFFStruct(0);\r\n        break;\r\n      }\r\n      stack.addChildStruct(elementStruct);\r\n    }\r\n\r\n    struct.addField( new GFFField(GFFDataType.INT, 'StackPointer') ).setValue(this.pointer);\r\n    struct.addField( new GFFField(GFFDataType.INT, 'StackPointer') ).setValue(this.stackSize);\r\n  \r\n    return struct;\r\n  }\r\n\r\n  static FromActionStruct = function( struct: GFFStruct, _object_self?: ModuleObject ): NWScriptStack {\r\n\r\n    const stack = new NWScriptStack();\r\n  \r\n    stack.basePointer = struct.getFieldByLabel('BasePointer').getValue() * 4;\r\n    stack.pointer = struct.getFieldByLabel('StackPointer').getValue() * 4;\r\n    const stackSize = struct.getFieldByLabel('TotalSize').getValue();\r\n  \r\n    if(stackSize){\r\n      const stackStructs = struct.getFieldByLabel('Stack').getChildStructs();\r\n  \r\n      for(let i = 0, len = stackStructs.length; i < len; i++){\r\n  \r\n        const stackElement = stackStructs[i];\r\n        if(stackElement.hasField('Value')){\r\n          const type = stackElement.getFieldByLabel('Value').getType();\r\n          const value = stackElement.getFieldByLabel('Value').getValue();\r\n          switch(type){\r\n            case 4: //Object\r\n              let obj = GameState.ModuleObjectManager.GetObjectById(value);\r\n              \r\n              if(value == 0x7f000000) // OBJECT_INVALID per Aurora spec\r\n                obj = undefined;\r\n  \r\n              stack.stack.push( new NWScriptStackVariable({ value: obj, type: NWScriptDataType.OBJECT }) );\r\n            break;\r\n            case 5: //int\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.INTEGER }) );\r\n            break;\r\n            case 8: //float\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.FLOAT }) );\r\n            break;\r\n            case 10: //String\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.STRING }) );\r\n            break;\r\n            default:\r\n              log.error('Unknown stack element type', stackElement);\r\n            break;\r\n          }\r\n        }else if(stackElement.hasField('GameDefinedStrct')){\r\n          const gameStruct = stackElement.getFieldByLabel('GameDefinedStrct').getChildStructs()[0];\r\n  \r\n          switch(gameStruct.getType()){\r\n            case 0: //Effect\r\n              stack.stack.push( new NWScriptStackVariable({ value: NWScriptStack.EffectFromStruct(gameStruct), type: NWScriptDataType.EFFECT }));\r\n            break;\r\n            case 1: //Event\r\n              stack.stack.push( new NWScriptStackVariable({ value: NWScriptStack.EventFromStruct(gameStruct), type: NWScriptDataType.EVENT }));\r\n            break;\r\n            case 2: //Location\r\n              stack.stack.push( new NWScriptStackVariable({ value: NWScriptStack.LocationFromStruct(gameStruct), type: NWScriptDataType.LOCATION }));\r\n            break;\r\n            case 3: //Talent\r\n              stack.stack.push( new NWScriptStackVariable({ value: NWScriptStack.TalentFromStruct(gameStruct), type: NWScriptDataType.TALENT }));\r\n            break;\r\n          }\r\n  \r\n        }\r\n  \r\n      }\r\n    }\r\n  \r\n    return stack;\r\n  \r\n  };\r\n  \r\n  static TalentFromStruct = function( struct: GFFStruct ){\r\n    const talentType = struct.getFieldByLabel('Type').getValue();\r\n    let talent = undefined;\r\n    switch(talentType){\r\n      case 0:\r\n        talent = new GameState.TalentSpell(struct.getFieldByLabel('ID').getValue());\r\n      break;\r\n      case 1:\r\n        talent = new GameState.TalentFeat(struct.getFieldByLabel('ID').getValue());\r\n      break;\r\n      case 2:\r\n        talent = new GameState.TalentSkill(struct.getFieldByLabel('ID').getValue());\r\n      break;\r\n    }\r\n  \r\n    talent.setItem( GameState.ModuleObjectManager.GetObjectById( struct.getFieldByLabel('Item').getValue() ) );\r\n    talent.setItemPropertyIndex( struct.getFieldByLabel('ItemPropertyIndex').getValue() );\r\n    talent.setCasterLevel( struct.getFieldByLabel('CasterLevel').getValue() );\r\n    talent.setMetaType( struct.getFieldByLabel('MetaType').getValue() );\r\n  \r\n    return talent;\r\n  }\r\n  \r\n  static LocationFromStruct = function( struct: GFFStruct ){\r\n    return new EngineLocation(\r\n      struct.getFieldByLabel('PositionX').getValue(),\r\n      struct.getFieldByLabel('PositionY').getValue(),\r\n      struct.getFieldByLabel('PositionZ').getValue(),\r\n      struct.getFieldByLabel('OrientationX').getValue(),\r\n      struct.getFieldByLabel('OrientationY').getValue(),\r\n      struct.getFieldByLabel('OrientationZ').getValue(),\r\n    );\r\n  }\r\n  \r\n  static EventFromStruct = function( struct: GFFStruct ){\r\n    const event = NWScriptEventFactory.EventFromStruct(struct);\r\n    log.debug('EventFromStruct', event, struct);\r\n    return event;\r\n  }\r\n  \r\n  static EffectFromStruct = function( struct: GFFStruct ){\r\n  \r\n    //https://github.com/nwnxee/unified/blob/master/NWNXLib/API/Constants/Effect.hpp\r\n    return GameEffectFactory.EffectFromStruct( struct );\r\n  \r\n  }\r\n  \r\n  static FromEventQueueStruct = function( struct: GFFStruct ){\r\n  \r\n    const stack = new NWScriptStack();\r\n  \r\n    stack.basePointer = struct.getFieldByLabel('BasePointer').getValue() * 4;\r\n    stack.pointer = struct.getFieldByLabel('StackPointer').getValue() * 4;\r\n    const stackSize = struct.getFieldByLabel('TotalSize').getValue();\r\n  \r\n    if(stackSize){\r\n      if(struct.hasField('Stack')){\r\n        const stackStructs = struct.getFieldByLabel('Stack').getChildStructs();\r\n  \r\n        for(let i = 0, len = stackStructs.length; i < len; i++){\r\n  \r\n          const stackElement = stackStructs[i];\r\n          const type = stackElement.getFieldByLabel('Type').getValue();\r\n          const value = stackElement.getFieldByLabel('Value').getValue();\r\n          switch(type){\r\n            case NWScriptDataType.OBJECT: //Object\r\n              let obj = GameState.ModuleObjectManager.GetObjectById(value);\r\n  \r\n              if(value == 2130706432) //this is either OBJECT_INVALID or OBJECT_SELF\r\n                obj = undefined;\r\n  \r\n              stack.stack.push( new NWScriptStackVariable({ value: obj, type: NWScriptDataType.OBJECT }) );\r\n            break;\r\n            case NWScriptDataType.INTEGER: //int\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.INTEGER }) );\r\n            break;\r\n            case NWScriptDataType.FLOAT: //float\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.FLOAT }) );\r\n            break;\r\n            case NWScriptDataType.STRING: //String\r\n              stack.stack.push( new NWScriptStackVariable({ value: value, type: NWScriptDataType.STRING }) );\r\n            break;\r\n            default:\r\n              log.error('Unknown stack element in FromEventQueueStruct', stackElement);\r\n            break;\r\n          }\r\n  \r\n        }\r\n      }\r\n    }\r\n  \r\n    return stack;\r\n  \r\n  };\r\n\r\n  /**\r\n   * Saves the stack for debugging\r\n   * @returns The stack data\r\n   */\r\n  saveForDebugger(){\r\n    const stackDataSize = (this.stack.length * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE);\r\n\r\n    let stringCount = 0;\r\n    let stringDataSize = 0;\r\n    const stringPacker = [];\r\n    for(let i = 0; i < this.stack.length; i++){\r\n      if(this.stack[i].type != NWScriptDataType.STRING){ continue; }\r\n      stringCount++;\r\n      stringPacker.push(this.stack[i].value);\r\n      stringDataSize += 4 + this.stack[i].value.length;\r\n    }\r\n\r\n    const totalPacketSize = STACK_PACKET_CONSTANTS.HEADER_SIZE + stackDataSize + stringDataSize;\r\n\r\n    const stackDataOffset = STACK_PACKET_CONSTANTS.HEADER_SIZE;\r\n    \r\n    const data = new Uint8Array(totalPacketSize);\r\n    const dataView = new DataView(data.buffer);\r\n\r\n    /**\r\n     * Write the stack header data to the packet\r\n     */\r\n    dataView.setInt32(0, this.basePointer, true);\r\n    dataView.setInt32(4, this.pointer, true);\r\n    dataView.setInt32(8, this.stack.length, true);\r\n    dataView.setInt32(12, stringPacker.length, true);\r\n\r\n    let stringPackerIndex = 0;\r\n    /**\r\n     * Write the stack element data to the packet\r\n     */\r\n    for(let i = 0; i < this.stack.length; i++){\r\n      const element = this.stack[i];\r\n      dataView.setInt32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE), element.type, true);\r\n      if(element.type == NWScriptDataType.STRING){\r\n        dataView.setUint32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, stringPackerIndex++, true);\r\n      }else if(element.type == NWScriptDataType.OBJECT){\r\n        dataView.setUint32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, (typeof element.value === 'object' ? element.value.id : 2130706432), true);\r\n      }else if(element.type == NWScriptDataType.FLOAT){\r\n        dataView.setFloat32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, element.value, true);\r\n      }else{\r\n        dataView.setInt32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, element.value, true);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Write the string data to the packet\r\n     * We have to write these values seperately because of the variable length of the strings\r\n     */\r\n    let stringDataOffset = STACK_PACKET_CONSTANTS.HEADER_SIZE + stackDataSize;\r\n    for(let i = 0; i < stringPacker.length; i++){\r\n      const str = stringPacker[i];\r\n      dataView.setInt32(stringDataOffset, str.length, true);\r\n      stringDataOffset += 4;\r\n      const chars = str.split('');\r\n      for(let i = 0; i < chars.length; i++){\r\n        data[stringDataOffset++] = chars[i].charCodeAt(0) & 0xFF;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  static FromDebuggerPacket( data: Uint8Array ): NWScriptStack {\r\n    const dataView = new DataView(data.buffer);\r\n\r\n    const basePointer = dataView.getInt32(0, true);\r\n    const pointer = dataView.getInt32(4, true);\r\n    const stackLength = dataView.getInt32(8, true);\r\n    const stringCount = dataView.getInt32(12, true);\r\n\r\n    const stack = new NWScriptStack();\r\n    stack.basePointer = basePointer;\r\n    stack.pointer = pointer;\r\n\r\n    const stackDataSize = (stackLength * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE);\r\n    const stackDataOffset = STACK_PACKET_CONSTANTS.HEADER_SIZE;\r\n    const stackStringOffset = STACK_PACKET_CONSTANTS.HEADER_SIZE + stackDataSize;\r\n\r\n    /**\r\n     * Read the strings from the packet\r\n     */\r\n    const stringDataArray = [];\r\n    const stringDecoder = new TextDecoder();\r\n    let stringDataOffset = stackStringOffset;\r\n    for(let i = 0; i < stringCount; i++){\r\n      const stringLength = dataView.getInt32(stringDataOffset, true);\r\n      const string = stringDecoder.decode(data.subarray(stringDataOffset + 4, stringDataOffset + 4 + stringLength));\r\n      stringDataOffset += 4 + stringLength;\r\n      stringDataArray.push(string);\r\n    }\r\n\r\n    /**\r\n     * Read the stack elements from the packet\r\n     */\r\n    for(let i = 0; i < stackLength; i++){\r\n      const elementType = dataView.getInt32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE), true);\r\n      let elementValue = undefined;\r\n\r\n      if(elementType == NWScriptDataType.STRING){\r\n        elementValue = stringDataArray[dataView.getUint32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, true)];\r\n      }else if(elementType == NWScriptDataType.OBJECT){\r\n        elementValue = dataView.getUint32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, true);\r\n      }else if(elementType == NWScriptDataType.FLOAT){\r\n        elementValue = dataView.getFloat32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, true);\r\n      }else{\r\n        elementValue = dataView.getInt32(stackDataOffset + (i * STACK_PACKET_CONSTANTS.STACK_ELEMENT_SIZE) + 4, true);\r\n      }\r\n      stack.stack.push(new NWScriptStackVariable({ type: elementType, value: elementValue }));\r\n    }\r\n\r\n    return stack;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\compiler\\NWScriptCompiler.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | number`.","line":491,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":491,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | number`.","line":492,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":492,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `string | number`.","line":493,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":493,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .properties on a type that cannot be resolved.","line":555,"column":57,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":555,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":556,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":556,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .properties on a type that cannot be resolved.","line":556,"column":53,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":556,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":557,"column":18,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":557,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":558,"column":34,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":558,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":561,"column":63,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":561,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":568,"column":51,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":568,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":569,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":569,"endColumn":130},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":569,"column":72,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":569,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":570,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":570,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":577,"column":45,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":577,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":578,"column":77,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":578,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":578,"column":110,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":578,"endColumn":170},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .struct_reference on a type that cannot be resolved.","line":578,"column":137,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":578,"endColumn":153},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":580,"column":77,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":580,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":580,"column":111,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":580,"endColumn":171},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .struct_reference on a type that cannot be resolved.","line":580,"column":138,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":580,"endColumn":154},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":584,"column":19,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":584,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .struct_reference on a type that cannot be resolved.","line":584,"column":46,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":584,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":585,"column":19,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":585,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":604,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":604,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":610,"column":49,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":610,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":614,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":614,"endColumn":156},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":639,"column":23,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":639,"endColumn":136},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":669,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":669,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":670,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":670,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":670,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":670,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":675,"column":45,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":675,"endColumn":109},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":675,"column":53,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":675,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":677,"column":45,"nodeType":"BinaryExpression","messageId":"unsafeArgument","endLine":677,"endColumn":110},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":677,"column":53,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":677,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":729,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":729,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":758,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":758,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":760,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":760,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":762,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":762,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .struct_reference on a type that cannot be resolved.","line":762,"column":39,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":762,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":764,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":764,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":765,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":765,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":766,"column":50,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":766,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":768,"column":32,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":768,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":769,"column":50,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":769,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":771,"column":41,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":771,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":771,"column":59,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":771,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":798,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":798,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1029,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1029,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":1031,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1031,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .is_global on a type that cannot be resolved.","line":1032,"column":21,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1032,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":1033,"column":53,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1033,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stackPointer on a type that cannot be resolved.","line":1035,"column":53,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1035,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .unary on a type that cannot be resolved.","line":1175,"column":27,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1175,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type error.","line":1175,"column":48,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":1175,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .unary on a type that cannot be resolved.","line":1175,"column":69,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1175,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1298,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1298,"endColumn":120},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":1299,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1299,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `CompilerStatementNode`.","line":1300,"column":48,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1300,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [j] on a type that cannot be resolved.","line":1300,"column":54,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":1300,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1331,"column":40,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":1331,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1712,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1712,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1733,"column":41,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1733,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1745,"column":69,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1745,"endColumn":106},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1765,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1765,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1784,"column":39,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1784,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `SemanticDataType | { type?: string; value?: string; }`.","line":1795,"column":69,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1795,"endColumn":106},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1963,"column":29,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1963,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":1965,"column":28,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":1965,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":1965,"column":28,"nodeType":"MemberExpression","messageId":"errorCall","endLine":1965,"endColumn":44},{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":2620,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":2622,"endColumn":4}],"suppressedMessages":[],"errorCount":70,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SemanticDataType } from \"@/nwscript/compiler/ASTSemanticTypes\";\r\nimport {\r\n  CompilerProgramNode,\r\n  CompilerFunctionNode,\r\n  CompilerStatementNode,\r\n  CompilerBlockNode,\r\n  CompilerStructNode,\r\n  CompilerStructPropertyNode,\r\n  CompilerVariableNode,\r\n  CompilerVariableReferenceNode,\r\n  CompilerBreakNode,\r\n  CompilerContinueNode,\r\n  CompilerForNode,\r\n  CompilerIfNode,\r\n  CompilerSwitchNode,\r\n  CompilerArgumentNode,\r\n  CompilerAssignNode,\r\n  CompilerBinaryNode,\r\n  CompilerCompareNode,\r\n  CompilerReturnNode,\r\n  CompilerUnaryNode,\r\n  CompilerIncDecNode,\r\n  CompilerFunctionCallNode,\r\n  CompilerVariableListNode,\r\n  CompilerDoWhileNode,\r\n  CompilerWhileNode,\r\n} from '@/nwscript/compiler/CompilerNodeTypes';\r\nimport type {\r\n  CompilerLiteralNode,\r\n  CompilerStatementNodeWithContext,\r\n  CompilerArrayLiteralNode,\r\n  CompilerExpressionNode,\r\n  CompilerElseIfNode,\r\n  CompilerElseNode,\r\n} from '@/nwscript/compiler/CompilerNodeTypes';\r\nimport type { EngineConstant } from \"@/nwscript/compiler/NWScriptParser\";\r\nimport {\r\n  OP_CPDOWNSP, OP_RSADD, OP_CPTOPSP, OP_CONST, OP_ACTION, OP_LOGANDII, OP_LOGORII, OP_INCORII, OP_EXCORII,\r\n  OP_BOOLANDII, OP_EQUAL, OP_NEQUAL, OP_GEQ, OP_GT, OP_LT, OP_LEQ, OP_SHLEFTII, OP_SHRIGHTII, OP_USHRIGHTII,\r\n  OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MODII, OP_NEG, OP_COMPI, OP_MOVSP, OP_STORE_STATEALL, OP_JMP,   OP_JSR,\r\n  OP_JZ, OP_RETN, OP_DESTRUCT, OP_NOTI, OP_DECISP, OP_INCISP, OP_JNZ, OP_CPDOWNBP, OP_CPTOPBP, OP_DECIBP, OP_INCIBP,\r\n  OP_SAVEBP, OP_RESTOREBP, OP_STORE_STATE, OP_NOP, OP_T\r\n} from \"@/nwscript/NWScriptOPCodes\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\n\r\n/** Callback for compiler events (e.g. opcode trace). */\r\ntype NWScriptEventCallback = () => void;\r\n\r\nconst _NWEngineTypeUnaryTypeOffset = 0x10;\r\nconst NWEngineTypeBinaryTypeOffset = 0x30;\r\n\r\ntype ByteArray = Uint8Array;\r\ntype WritableBuffer = Uint8Array & {\r\n  writeInt8(value: number, offset: number): void;\r\n  writeInt16BE(value: number, offset: number): void;\r\n  writeInt32BE(value: number, offset: number): void;\r\n  writeUInt16BE(value: number, offset: number): void;\r\n  writeFloatBE(value: number, offset: number): void;\r\n};\r\n\r\nconst allocBuffer = (length: number): WritableBuffer => {\r\n  if (typeof Buffer !== \"undefined\" && typeof Buffer.alloc === \"function\") {\r\n    return Buffer.alloc(length) as WritableBuffer;\r\n  }\r\n  const arr = new Uint8Array(length) as WritableBuffer;\r\n  const dv = new DataView(arr.buffer);\r\n  arr.writeInt8 = (value: number, offset: number) => dv.setInt8(offset, value);\r\n  arr.writeInt16BE = (value: number, offset: number) => dv.setInt16(offset, value, false);\r\n  arr.writeInt32BE = (value: number, offset: number) => dv.setInt32(offset, value, false);\r\n  arr.writeUInt16BE = (value: number, offset: number) => dv.setUint16(offset, value, false);\r\n  arr.writeFloatBE = (value: number, offset: number) => dv.setFloat32(offset, value, false);\r\n  return arr;\r\n};\r\n\r\nconst NWCompileDataTypes = {\r\n  'I' : 0x03,\r\n  'F' : 0x04,\r\n  'S' : 0x05,\r\n  'O' : 0x06,\r\n  'V' : 0x07,\r\n  'STRUCT': 0x08,\r\n  'II': 0x20,\r\n  'FF': 0x21,\r\n  'OO': 0x22,\r\n  'SS': 0x23,\r\n  'TT': 0x24,\r\n  'IF': 0x25,\r\n  'FI': 0x26,\r\n\r\n  'VV': 0x3A,\r\n  'VF': 0x3B,\r\n  'FV': 0x3C,\r\n};\r\n\r\nconst concatBuffers = (buffers: ByteArray[]) => {\r\n  let totalLength = 0;\r\n  for(let i = 0; i < buffers.length; i++){\r\n    totalLength += buffers[i].length;\r\n  }\r\n  const mergedArray = new Uint8Array(totalLength);\r\n  let offset = 0;\r\n  for(let i = 0; i < buffers.length; i++){\r\n    mergedArray.set(buffers[i], offset);\r\n    offset += buffers[i].length;\r\n  }\r\n  return mergedArray;\r\n}\r\n\r\n/**\r\n * NWScriptCompiler class.\r\n *\r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n *\r\n * @file NWScriptCompiler.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptCompiler {\r\n\r\n  program: CompilerProgramNode | null = null;\r\n  basePointer = 0;\r\n  stackPointer = 0;\r\n  log: unknown[] = [];\r\n  scope: NWScriptScope | undefined;\r\n  scopes: NWScriptScope[] = [];\r\n  /** Current scope; use after scopePush has been called. */\r\n  get scopeOrThrow(): NWScriptScope {\r\n    if (this.scope === undefined) throw new Error('NWScriptCompiler: scope not set (call scopePush first)');\r\n    return this.scope;\r\n  }\r\n  _silent: boolean = false;\r\n\r\n  _eventListeners: Record<string, NWScriptEventCallback[]> = {\r\n    log: [],\r\n    compile_start: [],\r\n    compile_fail: [],\r\n    compile_end: [],\r\n  };\r\n  spCache: number = 0;\r\n  bytesWritten: number = 0;\r\n  freezeBytesWritten: boolean = false;\r\n  basePointerWriting: boolean;\r\n  functionBlockStartOffset: number | undefined = undefined;\r\n  errors: { type: string; message: string; statement: CompilerStatementNode | undefined; offender: CompilerStatementNode | undefined }[] = [];\r\n\r\n  constructor(ast: CompilerProgramNode){\r\n\r\n    this.program = ast;\r\n    this.scopes = [];\r\n    this._silent = false;\r\n    this.errors = [];\r\n\r\n  }\r\n\r\n  addEventListener(type: string, callback?: NWScriptEventCallback){\r\n    const evList = this.getEventListenerListByType(type);\r\n    if(evList && callback !== undefined){\r\n      const evExists = this.getEventListener(type, callback);\r\n      if(!evExists){\r\n        evList.push(callback);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  removeEventListener(type: string, callback?: NWScriptEventCallback){\r\n    const evList = this.getEventListenerListByType(type);\r\n    if(evList && callback !== undefined){\r\n      const evExists = this.getEventListener(type, callback);\r\n      if(evExists){\r\n        const i = evList.indexOf(callback);\r\n        evList.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  triggerEventListener(type: string){\r\n    const evList = this.getEventListenerListByType(type);\r\n    if(evList){\r\n      for(let i = 0; i < evList.length; i++){\r\n        const fn = evList[i];\r\n        if(typeof fn === 'function')\r\n          fn();\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getEventListenerListByType(type: string){\r\n    const evList = this._eventListeners[type];\r\n    if(typeof evList == 'object' && Array.isArray(evList)){\r\n      return evList;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  getEventListener(type: string, callback?: NWScriptEventCallback){\r\n    const evList = this.getEventListenerListByType(type);\r\n    if(evList){\r\n      const i = evList.indexOf(callback);\r\n      return evList[i];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  opcodeDebug(_name: string, _buffer: Uint8Array){\r\n    if( this._silent ) return;\r\n    // log.info( (name + \"                \").slice(0, 16), buffer );\r\n  }\r\n\r\n  scopePush( scope: NWScriptScope ){\r\n    if(scope instanceof NWScriptScope){\r\n      this.scopes.push( scope );\r\n      this.scope = this.scopes[this.scopes.length-1];\r\n    }\r\n  }\r\n\r\n  scopePop(){\r\n    this.scopes.pop();\r\n    this.scope = this.scopes[this.scopes.length-1];\r\n  }\r\n\r\n  getCurrentScope(){\r\n    return this.scopes[this.scopes.length - 1];\r\n  }\r\n\r\n  addBytesWritten( nBytes = 0 ){\r\n    if(this.freezeBytesWritten){\r\n      return;\r\n    }\r\n    this.bytesWritten += nBytes;\r\n  }\r\n\r\n  scopeAddBytesWritten( nNumBytes = 0 ){\r\n    if(!this.scope){\r\n      log.error('scopeAddBytesWritten: scope is undefined');\r\n      return;\r\n    }\r\n    if(!this.freezeBytesWritten){\r\n      this.scopeOrThrow.bytes_written += nNumBytes;\r\n    }\r\n  }\r\n\r\n  compile(){\r\n    this.log = [];\r\n    this.errors = [];\r\n    if(!this.program) return;\r\n    if(typeof this.program === 'object' && this.program.type == 'program'){\r\n      if(this.program.main){\r\n        return this.compileStart(this.program.main, false);\r\n      }else if(this.program.startingConditional){\r\n        return this.compileStart(this.program.startingConditional, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  getStatementLength( statement: CompilerStatementNode ): number {\r\n    const bpCache = this.basePointer;\r\n    const spCache = this.stackPointer;\r\n    this._silent = true;\r\n    this.freezeBytesWritten = true;\r\n    const buffer = this.compileStatement( statement ) as Uint8Array;\r\n    this._silent = false;\r\n    this.freezeBytesWritten = false;\r\n    this.basePointer = bpCache;\r\n    this.spCache = spCache;\r\n    return buffer.length;\r\n  }\r\n\r\n  initializeCompiler(){\r\n    this.basePointer = 0;\r\n    this.stackPointer = 0;\r\n    this.scopes = [];\r\n    this.scope = undefined;\r\n    this.bytesWritten = 0;\r\n    this.basePointerWriting = false;\r\n    this._silent = false;\r\n    this.freezeBytesWritten = false;\r\n  }\r\n\r\n  /**\r\n   * Compile the global block\r\n   */\r\n  compileGlobal(buffers: ByteArray[] = [], returnInt: boolean = false): ByteArray[] {\r\n    if(!this.program){\r\n      log.error('compileGlobal: program is undefined');\r\n      return buffers;\r\n    }\r\n    const globalStatements = this.program.statements.filter( (s: CompilerStatementNode) => {\r\n      return ((s.type == 'variable' || s.type == 'variableList') && s.is_const == false) || s.type == 'struct';\r\n    });\r\n    if(globalStatements.length){\r\n      this.basePointerWriting = true;\r\n      for(let i = 0; i < globalStatements.length; i++){\r\n        buffers.push( this.compileStatement( globalStatements[i]) as Uint8Array );\r\n      }\r\n\r\n      buffers.push( this.writeSAVEBP() );\r\n      if(returnInt){\r\n        buffers.push( this.writeRSADD(NWCompileDataTypes.I) );\r\n      }\r\n      buffers.push(\r\n        this.writeJSR(\r\n          this.getInstructionLength(OP_JSR) +\r\n          this.getInstructionLength(OP_RESTOREBP) +\r\n          ( (this.basePointer > 0) ? this.getInstructionLength(OP_MOVSP) : 0 ) +\r\n          this.getInstructionLength(OP_RETN)\r\n        )\r\n      );\r\n      buffers.push( this.writeRESTOREBP() );\r\n      if(this.basePointer > 0){\r\n        buffers.push( this.writeMOVSP( -this.basePointer, true ) );\r\n      }\r\n      buffers.push( this.writeRETN() );\r\n    }\r\n    return buffers;\r\n  }\r\n\r\n  compilePass(funcMain: CompilerFunctionNode, returnInt: boolean = false): ByteArray[] {\r\n    log.info('compilePass: Begin');\r\n    const buffers: ByteArray[] = [new Uint8Array(0)];\r\n    if(!this.program){\r\n      log.error('compilePass: program is undefined');\r\n      return buffers;\r\n    }\r\n\r\n    this.initializeCompiler();\r\n\r\n    this.scopePush( new NWScriptScope() );\r\n\r\n    //MAIN / StartingConditional OR Global Functions\r\n    if(returnInt){\r\n      buffers.push( this.writeRSADD(NWCompileDataTypes.I) );\r\n    }\r\n    buffers.push(\r\n      this.writeJSR(\r\n        this.getInstructionLength(OP_JSR) +\r\n        this.getInstructionLength(OP_RETN)\r\n      )\r\n    );\r\n    buffers.push( this.writeRETN() );\r\n\r\n    this.compileGlobal(buffers, returnInt);\r\n\r\n    const functions = this.program.functions as unknown as CompilerFunctionNode[];\r\n    const subroutines = functions.filter( (f: CompilerFunctionNode) => f.called ).sort( (a: CompilerFunctionNode, b: CompilerFunctionNode) => (a.callIndex ?? 0) - (b.callIndex ?? 0) );\r\n\r\n    funcMain.blockOffset = this.bytesWritten;\r\n    buffers.push( this.compileFunction( funcMain ) );\r\n\r\n    for(let i = 0; i < subroutines.length; i++){\r\n      const global_function = subroutines[i] as CompilerFunctionNode;\r\n      if(global_function.called){\r\n        global_function.blockOffset = this.bytesWritten;\r\n        const funcBuffer = this.compileFunction( global_function );\r\n        buffers.push( funcBuffer );\r\n      }\r\n    }\r\n\r\n    this.scopePop();\r\n    log.info('compilePass: End');\r\n    return buffers;\r\n  }\r\n\r\n  compileStart(funcMain: CompilerFunctionNode, returnInt: boolean = false): ByteArray {\r\n    this.basePointer  = 0;\r\n    this.stackPointer = 0;\r\n    this.scopes = [];\r\n    if(!this.program || this.program.type != 'program'){\r\n      log.error('CompileStart: program is undefined');\r\n      return new Uint8Array(0);\r\n    }\r\n\r\n    log.info('CompileStart: Begin');\r\n\r\n    const _pass1 = this.compilePass(funcMain, returnInt);\r\n    const pass2 = this.compilePass(funcMain, returnInt);\r\n\r\n    const program = concatBuffers(pass2);\r\n\r\n    const NCS_Header = new Uint8Array(8);\r\n    NCS_Header[0] = 0x4E; // N\r\n    NCS_Header[1] = 0x43; // C\r\n    NCS_Header[2] = 0x53; // S\r\n    NCS_Header[3] = 0x20; //\r\n    NCS_Header[4] = 0x56; // V\r\n    NCS_Header[5] = 0x31; // 1\r\n    NCS_Header[6] = 0x2E; // .\r\n    NCS_Header[7] = 0x30; // 0\r\n\r\n    const T = this.writeT(program.length + 13);\r\n    log.info('CompileStart: Complete');\r\n    return concatBuffers([NCS_Header, T, program]);\r\n  }\r\n\r\n  /**\r\n   * Get the stack length of a datatype\r\n   *\r\n   * all non void datatypes when placed on the stack take up 4 bytes\r\n   * these positions on the stack are just pointers to the actual data\r\n   *\r\n   * vectors take up 12 bytes because they are stored as 3 floats ( 4 bytes each ) packed end to end on the stack\r\n   * @param datatype - The datatype to get the stack length for\r\n   * @returns The stack length of bytes required to store the datatype\r\n   */\r\n  getDataTypeStackLength( datatype?: SemanticDataType | { type?: string; value?: string } ): number {\r\n    if(datatype && datatype.type == 'datatype'){\r\n      switch(datatype.value){\r\n        case 'void':    return 0;\r\n        case 'vector':  return 12;\r\n        case 'int':     return 4;\r\n        case 'float':   return 4;\r\n        case 'string':  return 4;\r\n        case 'object':  return 4;\r\n        default:        return 4;\r\n      }\r\n    }\r\n    throw 'Invalid datatype object ' + datatype;\r\n  }\r\n\r\n  getStatementDataTypeSize( statement: CompilerStatementNode | CompilerBlockNode ): number {\r\n    if(!statement) {\r\n      log.error('getStatementDataTypeSize');\r\n      log.info(statement);\r\n      throw new Error('Invalid statement object');\r\n    }\r\n    const s = statement as CompilerStatementNode & { datatype?: SemanticDataType; returntype?: SemanticDataType; function_reference?: { returntype: SemanticDataType }; property_reference?: { datatype: SemanticDataType } };\r\n    if(s.datatype) return this.getDataTypeStackLength(s.datatype);\r\n    if(s.returntype) return this.getDataTypeStackLength(s.returntype);\r\n    if(s.function_reference) return this.getDataTypeStackLength(s.function_reference.returntype);\r\n    if(s.property_reference) return this.getDataTypeStackLength(s.property_reference.datatype);\r\n    log.error('getStatementDataTypeSize');\r\n    log.info(statement);\r\n    throw new Error('Invalid statement object');\r\n  }\r\n\r\n  compileStatement( statement: CompilerStatementNode ): ByteArray {\r\n    if(statement){\r\n      switch(statement.type){\r\n        case 'literal':       return this.compileLiteral( statement );\r\n        case 'array_literal': return this.compileArrayLiteral( statement );\r\n        case 'variable':      return this.compileVariable( statement );\r\n        case 'variableList':      return this.compileVariableList( statement );\r\n        case 'variable_reference':return this.compileVariable( statement );\r\n        case 'argument':      return this.compileArgument( statement );\r\n        case 'struct':        return this.compileStruct( statement );\r\n        case 'property':      return this.compileStructProperty( statement );\r\n        case 'compare':       return this.compileCompare( statement );\r\n        case 'function':      return this.compileFunction( statement );\r\n        case 'function_call': return this.compileFunctionCall( statement );\r\n        case 'block':         return this.compileAnonymousBlock( statement );\r\n        case 'return':        return this.compileReturn( statement );\r\n        case 'if':            return this.compileIf( statement );\r\n        case 'switch':        return this.compileSwitch( statement );\r\n        case 'do':            return this.compileDoWhileLoop( statement );\r\n        case 'while':         return this.compileWhileLoop( statement );\r\n        case 'for':           return this.compileForLoop( statement );\r\n        case 'incor':         return this.compileINCOR( statement );\r\n        case 'xor':           return this.compileEXCOR( statement );\r\n        case 'booland':       return this.compileBOOLAND( statement );\r\n        case 'shift':         return this.compileShift( statement );\r\n        case 'comp':          return this.compileComp( statement );\r\n        case 'add':           return this.compileAdd( statement );\r\n        case 'sub':           return this.compileSub( statement );\r\n        case 'mul':           return this.compileMul( statement );\r\n        case 'div':           return this.compileDiv( statement );\r\n        case 'neg':           return this.compileNEG( statement );\r\n        case 'not':           return this.compileNOT( statement );\r\n        case 'inc':           return this.compileINC( statement );\r\n        case 'dec':           return this.compileDEC( statement );\r\n        case 'continue':      return this.compileContinue( statement );\r\n        case 'break':         return this.compileBreak( statement );\r\n        case 'assign':         return this.compileAssign( statement );\r\n        default: log.error('unhandled statement', statement.type);\r\n        log.info(statement);\r\n      }\r\n    }\r\n    throw new Error('compileStatement: statement is undefined or invalid');\r\n  }\r\n\r\n  compileLiteral( statement: CompilerLiteralNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'literal'){\r\n      if(statement.datatype.value == 'vector'){\r\n        buffers.push( this.writeCONST(NWCompileDataTypes.F, statement.value.x) );\r\n        buffers.push( this.writeCONST(NWCompileDataTypes.F, statement.value.y) );\r\n        buffers.push( this.writeCONST(NWCompileDataTypes.F, statement.value.z) );\r\n      }else{\r\n        buffers.push( this.writeCONST(statement.datatype.unary, statement.value) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileArrayLiteral( statement: CompilerArrayLiteralNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'array_literal'){\r\n      for(let i = 0; i < statement.elements.length; i++){\r\n        buffers.push( this.compileStatement( statement.elements[i] ) as Uint8Array );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  getDataType( value?: CompilerStatementNode ): SemanticDataType {\r\n    if(typeof value == 'object' && value !== null){\r\n      if(value.type == 'literal') return (value as CompilerLiteralNode).datatype;\r\n      if(value.type == 'variable_reference') return (value as CompilerVariableReferenceNode).variable_reference?.datatype as SemanticDataType;\r\n      if(value.type == 'variable') { const v = value as CompilerVariableNode; return v.datatype || v.variable_reference?.datatype as SemanticDataType; }\r\n      if(value.type == 'variableList') return (value as CompilerVariableListNode).datatype;\r\n      if(value.type == 'argument') return (value as CompilerArgumentNode).datatype;\r\n      if(value.type == 'property') return (value as CompilerStructPropertyNode).datatype;\r\n      if(value.type == 'function_call') {\r\n        const fc = value as CompilerFunctionCallNode;\r\n        if (fc.function_reference) return fc.function_reference.returntype;\r\n      }\r\n      if(value.type == 'add') return this.getDataType(value.left);\r\n      if(value.type == 'sub') return this.getDataType(value.left);\r\n      if(value.type == 'mul') return this.getDataType(value.left);\r\n      if(value.type == 'div') return this.getDataType(value.left);\r\n      if(value.type == 'compare') return this.getDataType(value.left);\r\n      if(value.type == 'not') return this.getDataType(value.value);\r\n      if(value.type == 'neg') return this.getDataType(value.value);\r\n      if(value.type == 'inc') return this.getDataType(value.value);\r\n      if(value.type == 'dec') return this.getDataType(value.value);\r\n    }\r\n    log.info('getDataType', value);\r\n    throw 'Invalid value for getDataType: ' + value;\r\n  }\r\n\r\n  compileVariableList( statement: CompilerVariableListNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'variableList'){\r\n      for(let i = 0; i < statement.variables.length; i++){\r\n        buffers.push( this.compileStatement( statement.variables[i] ) as Uint8Array );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileVariable( statement: CompilerVariableNode | CompilerVariableReferenceNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && (statement.type == 'variable' || statement.type == 'variable_reference')){\r\n      if(statement.struct_reference){\r\n        if(statement.declare === true){\r\n          statement.stackPointer = this.stackPointer;\r\n          statement.is_global = this.basePointerWriting;\r\n\r\n          for(let i = 0; i < statement.struct_reference.properties.length; i++){\r\n            const prop = statement.struct_reference.properties[i];\r\n            prop.is_global = statement.is_global;\r\n            if( this.getDataType(prop).value == 'vector'){\r\n              buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n            }else{\r\n              buffers.push( this.writeRSADD( this.getDataType(prop).unary ) );\r\n            }\r\n          }\r\n\r\n        }else{\r\n          if(statement.struct_reference && statement.variable_reference){\r\n            if(statement.value){ //assigning\r\n              buffers.push( this.compileStatement(statement.value) as Uint8Array );\r\n              const propertyStackPointer = (statement.struct_reference.stackPointer + statement.variable_reference.offsetPointer);\r\n              if(statement.struct_reference.is_global){\r\n                buffers.push( this.writeCPDOWNBP( (propertyStackPointer - this.basePointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n              }else{\r\n                buffers.push( this.writeCPDOWNSP( (propertyStackPointer - this.stackPointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n              }\r\n              buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.datatype) ) );\r\n            }else{ //retrieving\r\n              if(statement.struct_reference.is_global){\r\n                buffers.push( this.writeCPTOPBP( statement.struct_reference.stackPointer - this.basePointer, statement.struct_reference.struct_reference.structDataLength ) );\r\n              }else{\r\n                buffers.push( this.writeCPTOPSP( statement.struct_reference.stackPointer - this.stackPointer, statement.struct_reference.struct_reference.structDataLength ) );\r\n              }\r\n              buffers.push(\r\n                this.writeDESTRUCT(\r\n                  statement.struct_reference.struct_reference.structDataLength,\r\n                  statement.variable_reference.offsetPointer,\r\n                  this.getDataTypeStackLength( statement.variable_reference.datatype )\r\n                )\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }else{\r\n        if(statement.declare === true){\r\n          statement.stackPointer = this.stackPointer;\r\n          statement.is_global = this.basePointerWriting;\r\n          if(statement.datatype.value == 'vector'){\r\n            buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n            buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n            buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n          }else{\r\n            buffers.push( this.writeRSADD( statement.datatype.unary ) );\r\n          }\r\n          if(statement.value){\r\n            buffers.push( this.compileStatement(statement.value) as Uint8Array );\r\n            buffers.push( this.writeCPDOWNSP( (statement.stackPointer - this.stackPointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n            buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.datatype) ) );\r\n          }\r\n        }else{\r\n          if(statement.value){ //assigning\r\n            buffers.push( this.compileStatement(statement.value) as Uint8Array );\r\n            if(statement.variable_reference.is_global){\r\n              buffers.push( this.writeCPDOWNBP( (statement.variable_reference.stackPointer - this.basePointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n            }else if(statement.variable_reference.type == 'argument'){\r\n              const arg_stack_pointer = (this.stackPointer - this.scopeOrThrow.block.preStatementsStackPointer) + statement.variable_reference.stackPointer;\r\n              buffers.push( this.writeCPDOWNSP( -arg_stack_pointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n            }else{\r\n              buffers.push( this.writeCPDOWNSP( (statement.variable_reference.stackPointer - this.stackPointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n            }\r\n            buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.datatype) ) );\r\n          }else{ //retrieving\r\n            const varRef = statement.variable_reference;\r\n            if(statement.is_global){\r\n              const lit = this.getConstantLiteral(varRef);\r\n              if(lit){\r\n                buffers.push( this.compileLiteral( lit ) );\r\n              }else if(varRef){\r\n                buffers.push( this.writeCPTOPBP( varRef.stackPointer - this.basePointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n              }\r\n            }else if(varRef){\r\n              if(varRef.is_engine_constant){\r\n                const lit = this.getConstantLiteral(varRef);\r\n                if(lit){\r\n                  buffers.push( this.compileLiteral( lit ) );\r\n                }else{\r\n                  // fallback to stack copy if somehow not literal\r\n                  buffers.push( this.writeCPTOPSP( varRef.stackPointer - this.stackPointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n                }\r\n              }else if(varRef.type == 'argument'){\r\n                const arg_stack_pointer = (this.stackPointer - this.scopeOrThrow.block.preStatementsStackPointer) + varRef.stackPointer;\r\n                buffers.push( this.writeCPTOPSP( -arg_stack_pointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n              }else{\r\n                if(varRef.is_global){\r\n                  buffers.push( this.writeCPTOPBP( varRef.stackPointer - this.basePointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n                }else{\r\n                  buffers.push( this.writeCPTOPSP( varRef.stackPointer - this.stackPointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n                }\r\n              }\r\n\r\n              if(statement.type == 'variable_reference' && statement.terminated){\r\n                buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.datatype) ) );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileAssign( statement: CompilerAssignNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'assign'){\r\n      if(statement.left.type != 'variable_reference' && statement.left.type != 'property'){\r\n        throw 'Invalid left type for assign: Must be a variable reference or property';\r\n      }\r\n      const left = statement.left;\r\n      const right = statement.right;\r\n      if(left.type == 'property'){\r\n        const varRef = left.left.variable_reference;\r\n        const isGlobal = varRef?.is_global;\r\n        const propRef = left.property_reference;\r\n        buffers.push( this.compileStatement(right) as Uint8Array );\r\n        // @todo support vectors, currently we only support single slot datatypes\r\n        if(isGlobal){\r\n          buffers.push( this.writeCPDOWNBP( (varRef.stackPointer - this.basePointer) + propRef.offsetPointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n        }else{\r\n          buffers.push( this.writeCPDOWNSP( (varRef.stackPointer - this.stackPointer) + propRef.offsetPointer, this.getDataTypeStackLength(statement.datatype) ) );\r\n        }\r\n      }else{\r\n        const varRef = left.variable_reference;\r\n        buffers.push( this.compileStatement(right) as Uint8Array );\r\n        if(varRef.is_global){\r\n          buffers.push( this.writeCPDOWNBP( (varRef.stackPointer - this.basePointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n        }else{\r\n          buffers.push( this.writeCPDOWNSP( (varRef.stackPointer - this.stackPointer), this.getDataTypeStackLength(statement.datatype) ) );\r\n        }\r\n      }\r\n      if(!this.getCurrentScope()?.consumingValue){\r\n        buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.datatype) ) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  // Normalize an engine constant into a literal node the emitter understands.\r\n  // Returns undefined if it cannot be resolved as a literal.\r\n  getConstantLiteral(constant: CompilerLiteralNode | CompilerVariableNode | EngineConstant){\r\n    if(!constant) return undefined;\r\n    // If already a literal node, return as-is\r\n    if(constant.value && constant.value.type === 'literal') return constant.value;\r\n    // If value is a primitive number/string, wrap it as a literal with the constant's datatype\r\n    if(typeof constant.value === 'number' || typeof constant.value === 'string'){\r\n      return {\r\n        type: 'literal',\r\n        datatype: constant.datatype,\r\n        value: constant.value\r\n      };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Compile a struct statement\r\n   *\r\n   * This is used when declaring a struct\r\n   *\r\n   * @param statement - The struct statement to compile\r\n   * @returns The compiled struct statement as a Uint8Array\r\n   */\r\n  compileStruct( statement: CompilerStructNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'struct'){\r\n      statement.stackPointer = this.stackPointer;\r\n      statement.is_global = this.basePointerWriting;\r\n      statement.structDataLength = 0;\r\n      for(let i = 0; i < statement.properties.length; i++){\r\n        const prop = statement.properties[i];\r\n        prop.stackPointer = this.stackPointer;\r\n        prop.offsetPointer = statement.structDataLength;\r\n        if(prop.datatype.value == 'vector'){\r\n          // commented this out because we don't add struct definitions to the stack\r\n          // buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n          // buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n          // buffers.push( this.writeRSADD( NWCompileDataTypes.F ) );\r\n          statement.structDataLength += 12;\r\n        }else{\r\n          // commented this out because we don't add struct definitions to the stack\r\n          // buffers.push( this.writeRSADD( prop.datatype.unary ) );\r\n          statement.structDataLength += 4;\r\n        }\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  /**\r\n   * Compile a struct property statement\r\n   *\r\n   * This is used when accessing a property of a struct\r\n   *\r\n   * @param statement - The property statement to compile\r\n   * @returns The compiled property statement as a Uint8Array\r\n   */\r\n  compileStructProperty( statement: CompilerStructPropertyNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'property'){\r\n      const left = statement.left;\r\n      const varRef = left.variable_reference;\r\n      const propRef = statement.property_reference;\r\n      const propOffset = propRef.offsetPointer;\r\n      const propSize = this.getDataTypeStackLength(propRef.datatype);\r\n      const structDataLength = varRef.struct_reference?.structDataLength || 0;\r\n      //propRef.datatype.value == 'vector'\r\n      if(varRef.is_global){\r\n        const offset = (varRef.stackPointer - this.basePointer);\r\n        buffers.push( this.writeCPTOPBP( offset, structDataLength ) );\r\n      }else{\r\n        const offset = (varRef.stackPointer - this.stackPointer);\r\n        buffers.push( this.writeCPTOPSP( offset, structDataLength ) );\r\n      }\r\n      buffers.push( this.writeDESTRUCT( structDataLength, propOffset, propSize ) );\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileArgument( statement: CompilerArgumentNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'argument'){\r\n      buffers.push( this.compileStatement(statement.value) as Uint8Array );\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileReturn( statement: CompilerReturnNode ){\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    //cache the stack pointer\r\n    const sp = this.stackPointer;\r\n\r\n    //Get the size of the return value of this block\r\n    const nReturnDataSize = this.getStatementDataTypeSize(this.scopeOrThrow.block);\r\n    //Push the return value to the stack if we have one\r\n    if(statement.value){\r\n      const currentScope = this.getCurrentScope();\r\n      currentScope.consumingValue = true;\r\n      buffers.push( this.compileStatement( statement.value ) as Uint8Array );\r\n      currentScope.consumingValue = false;\r\n      const returnStackOffset = this.scopeOrThrow.block.returnStackPointer;\r\n      const blockStackOffset = (this.stackPointer - this.scopeOrThrow.block.preStatementsStackPointer);\r\n      const returnStackPointer = returnStackOffset - blockStackOffset;\r\n      //Copy the return value down to the return value pointer of this block\r\n      buffers.push( this.writeCPDOWNSP( returnStackPointer, nReturnDataSize ) );\r\n    }\r\n\r\n    //Clear the stack\r\n    const stackOffset = (this.stackPointer - this.scopeOrThrow.block.preStatementsStackPointer);\r\n    if(stackOffset > 0){\r\n      buffers.push( this.writeMOVSP( -stackOffset ) );\r\n      this.stackPointer += stackOffset;\r\n    }else if(stackOffset < 0){\r\n      log.warn(`${this.scopeOrThrow.block.name}: stack offset is less than 0, this should not happen: ${stackOffset}`);\r\n    }\r\n\r\n    //Jump to the end of the current executing block\r\n    const jmpOffset = ( this.scopeOrThrow.block.retn_jmp || 0 ) - ( this.scopeOrThrow.bytes_written + 0 );\r\n    buffers.push( this.writeJMP( this.scopeOrThrow.block.retn_jmp ? jmpOffset : 0x7FFFFFFF ) );\r\n\r\n    //clear the return data off the stack\r\n    // - This is ignored because of the previous JMP, but this is how nwnnsscomp does things\r\n    if(nReturnDataSize){\r\n      buffers.push( this.writeMOVSP(-nReturnDataSize) );\r\n    }\r\n\r\n    //restore the stack pointer\r\n    this.stackPointer = sp;\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileFunction( block: CompilerFunctionNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    this.scopePush( new NWScriptScope() );\r\n    this.scopeOrThrow.block = block;\r\n\r\n    //store the position of the stack pointer so it can be restored at the end of this block\r\n    const storeSP = this.stackPointer;\r\n\r\n    //byte offset to the start of this function block\r\n    block.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n    //return data stack size\r\n    const nReturnDataSize = this.getStatementDataTypeSize(this.scopeOrThrow.block);\r\n\r\n    //get the total stacksize of all the function arguments\r\n    let nArgumentDataSize = 0;\r\n    if(block.arguments.length){\r\n      for(let i = 0; i < block.arguments.length; i++){\r\n        const arg = block.arguments[i] as CompilerArgumentNode & { index?: number; datasize?: number; stackPointer?: number };\r\n        arg.index = i;\r\n        arg.datasize = (this.getStatementDataTypeSize(arg)) || 4;\r\n        nArgumentDataSize += arg.datasize;\r\n        arg.stackPointer = nArgumentDataSize;\r\n        this.stackPointer += arg.datasize;\r\n      }\r\n      block.argumentsStackPointer = -nArgumentDataSize;\r\n    }else{\r\n      block.argumentsStackPointer = 0;\r\n    }\r\n    block.returnStackPointer = -(nArgumentDataSize + nReturnDataSize);\r\n\r\n    block.preStatementsStackPointer = nArgumentDataSize;\r\n\r\n    //byte offset to the end of this function block\r\n    block.block_start_jmp = this.scopeOrThrow.bytes_written;\r\n\r\n    for(let i = 0; i < block.statements.length; i++){\r\n      const stmt = block.statements[i];\r\n      if(stmt && typeof stmt === 'object'){\r\n        (stmt as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n      }\r\n      buffers.push( this.compileStatement( stmt ) as Uint8Array );\r\n    }\r\n\r\n    block.postStatementsStackPointer = this.stackPointer;\r\n\r\n    //byte offset to the end of this function block\r\n    block.block_end_jmp = this.scopeOrThrow.bytes_written;\r\n\r\n    //-----------------------------------------//\r\n    // Clean up the block stack before exiting\r\n    //-----------------------------------------//\r\n\r\n    //removing any left over local variables created by this function\r\n    const stackOffset = (block.postStatementsStackPointer - block.preStatementsStackPointer);\r\n    if(stackOffset > 0){\r\n      buffers.push( this.writeMOVSP(-stackOffset));\r\n    }else if(stackOffset < 0){\r\n      log.warn(`${block.name}: stack offset is less than 0, this should not happen: ${stackOffset}`);\r\n    }\r\n\r\n    //byte offset to the end of this function block\r\n    block.retn_jmp = this.scopeOrThrow.bytes_written;\r\n\r\n    //clear arguments off the stack after the jmp marker because RETURN statements don't clear the arguments off the stack it is done here\r\n    if(nArgumentDataSize){\r\n      buffers.push( this.writeMOVSP(-nArgumentDataSize) );\r\n    }\r\n\r\n    //Close out this function block with a RETN statement\r\n    buffers.push( this.writeRETN() );\r\n\r\n    block.blockSize = concatBuffers(buffers).length;\r\n\r\n    //restore the stack pointer to where it was before this function was compiled\r\n    this.stackPointer = storeSP;\r\n    this.scopePop();\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileFunctionCall( statement: CompilerFunctionCallNode ){\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == \"function_call\"){\r\n      //RETURNTYPE\r\n      if(statement.function_reference.returntype){\r\n        if(statement.function_reference.returntype.value != 'void'){\r\n          //only call RSADD if this function has a return value and it isn't an engine routine\r\n          if(!statement.function_reference.is_engine_action){\r\n            if(statement.function_reference.returntype.unary == NWCompileDataTypes.V){\r\n              buffers.push( this.writeRSADD(NWCompileDataTypes.F) );\r\n              buffers.push( this.writeRSADD(NWCompileDataTypes.F) );\r\n              buffers.push( this.writeRSADD(NWCompileDataTypes.F) );\r\n            }else{\r\n              buffers.push( this.writeRSADD(statement.function_reference.returntype.unary) );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //ARGUMENTS\r\n      const _arguments = statement.arguments.slice(0).reverse();\r\n      const __arguments = statement.function_reference.arguments.slice(0).reverse();\r\n      let argumentsDataSize = 0;\r\n      for(let i = 0; i < __arguments.length; i++){\r\n        const arg = _arguments[i];\r\n        const arg_ref = __arguments[i];\r\n\r\n        if(!arg){\r\n          throw 'missing argument';\r\n        }\r\n\r\n        if(arg_ref.datatype.value == 'action'){\r\n          buffers.push( this.writeSTORE_STATE( this.basePointer, this.stackPointer ) );\r\n          buffers.push(\r\n            this.writeJMP(\r\n              this.getInstructionLength(OP_JMP) +\r\n              this.getStatementLength( arg ) +\r\n              this.getInstructionLength(OP_RETN)\r\n            )\r\n          );\r\n          // const ssScope = new NWScriptScope();\r\n          // this.scopePush( ssScope );\r\n          buffers.push( this.compileStatement(arg) as Uint8Array );\r\n          // this.scopePop();\r\n          buffers.push( this.writeRETN() );\r\n        }else{\r\n          buffers.push( this.compileStatement(arg) as Uint8Array );\r\n        }\r\n        argumentsDataSize += (this.getStatementDataTypeSize(arg));\r\n      }\r\n\r\n      /**\r\n       * ENGINE ROUTINE CALL\r\n       */\r\n      if(statement.action_id >= 0)\r\n      {\r\n        const returnSize = this.getDataTypeStackLength(statement.function_reference.returntype);\r\n        buffers.push( this.writeACTION(0x00, statement.action_id, statement.arguments.length, returnSize, argumentsDataSize) );\r\n      }\r\n      /**\r\n       * LOCAL FUNCTION CALL\r\n       */\r\n      else\r\n      {\r\n        const funcRef = this.program?.functions.find( (f: CompilerFunctionNode) => f.name === statement.function_reference.name ) as CompilerFunctionNode | undefined;\r\n        const jsrOffset = ((funcRef?.blockOffset || 0) - (this.bytesWritten || 0)) || 0x7FFFFFFF;\r\n        buffers.push( this.writeJSR(jsrOffset) );\r\n        this.stackPointer -= argumentsDataSize;\r\n      }\r\n\r\n      // If this call returns a value but is used as a stand-alone statement, drop it now\r\n      const retSize = this.getDataTypeStackLength(statement.function_reference.returntype);\r\n      if(retSize && statement.statement_context === 'statement'){\r\n        buffers.push( this.writeMOVSP( -retSize ) );\r\n      }\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileAnonymousBlock( statement: CompilerBlockNode ){\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'block'){\r\n      statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n      // statement.preStatementsSPCache = this.stackPointer;\r\n      for(let i = 0; i < statement.statements.length; i++){\r\n        const stmt = statement.statements[i];\r\n        if(stmt && typeof stmt === 'object'){\r\n          (stmt as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n        }\r\n        buffers.push( this.compileStatement( stmt ) as Uint8Array );\r\n      }\r\n\r\n      /**\r\n       * I no longer believe that a block needs to clean up the stack\r\n       * This is from my obervations of anonymous blocks in switch cases inside GN_GetGrenadeTalent\r\n       * and other places.\r\n       */\r\n      // const stackElementsToRemove = this.stackPointer - statement.preStatementsSPCache;\r\n      // if(stackElementsToRemove){\r\n      //   buffers.push( this.writeMOVSP( -stackElementsToRemove ) );\r\n      // }\r\n      statement.block_end = this.scopeOrThrow.bytes_written;\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileAdd( statement: CompilerBinaryNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'add'){\r\n      const leftBuf = this.compileStatement(statement.left) as Uint8Array;\r\n      buffers.push( leftBuf );\r\n\r\n      // Fallback: if left did not emit bytes (e.g., variable_reference not pushed), push it now\r\n      if(leftBuf.length === 0){\r\n        const varRef = statement.left?.variable_reference;\r\n        const dtSize = this.getStatementDataTypeSize(statement.left);\r\n        if(varRef && typeof varRef.stackPointer === 'number'){\r\n          if(varRef.is_global){\r\n            buffers.push( this.writeCPTOPBP( varRef.stackPointer - this.basePointer, dtSize ) );\r\n          }else{\r\n            buffers.push( this.writeCPTOPSP( varRef.stackPointer - this.stackPointer, dtSize ) );\r\n          }\r\n        }else if(typeof statement.left?.stackPointer === 'number'){\r\n          buffers.push( this.writeCPTOPSP( statement.left.stackPointer - this.stackPointer, dtSize ) );\r\n        }\r\n      }\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.II ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.IF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.FI ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.FF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.S && this.getDataType(statement.right).unary == NWCompileDataTypes.S){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.SS ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.V && this.getDataType(statement.right).unary == NWCompileDataTypes.V){\r\n        buffers.push( this.writeADD( NWCompileDataTypes.VV ) );\r\n      }else{\r\n        //unsupported add\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileSub( statement: CompilerBinaryNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'sub'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.II ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.IF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.FI ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.FF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.S && this.getDataType(statement.right).unary == NWCompileDataTypes.S){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.SS ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.V && this.getDataType(statement.right).unary == NWCompileDataTypes.V){\r\n        buffers.push( this.writeSUB( NWCompileDataTypes.VV ) );\r\n      }else{\r\n        //unsupported sub\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileMul( statement: CompilerBinaryNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'mul'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.II ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.IF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.FI ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.FF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.V && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.VF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.V){\r\n        buffers.push( this.writeMUL( NWCompileDataTypes.FV ) );\r\n      }else{\r\n        //unsupported mul\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileDiv( statement: CompilerBinaryNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'div'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.II ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.IF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.FI ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.FF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.V && this.getDataType(statement.right).unary == NWCompileDataTypes.F){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.VF ) );\r\n      }else if(this.getDataType(statement.left).unary == NWCompileDataTypes.F && this.getDataType(statement.right).unary == NWCompileDataTypes.V){\r\n        buffers.push( this.writeDIV( NWCompileDataTypes.FV ) );\r\n      }else{\r\n        //unsupported div\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileCompare( statement: CompilerCompareNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'compare'){\r\n      const leftBuf = this.compileStatement(statement.left) as Uint8Array;\r\n      buffers.push( leftBuf );\r\n\r\n      // Ensure left operand is on stack if it's a variable reference and nothing was emitted\r\n      if(statement.left?.type === 'variable_reference' && leftBuf.length === 0){\r\n        const varRef = statement.left.variable_reference;\r\n        const dtSize = this.getDataTypeStackLength(\r\n          statement.left.datatype ||\r\n          varRef?.datatype ||\r\n          this.getDataType(statement.left)\r\n        );\r\n        if(varRef && typeof varRef.stackPointer === 'number'){\r\n          if(varRef.is_global){\r\n            buffers.push( this.writeCPTOPBP( varRef.stackPointer - this.basePointer, dtSize ) );\r\n          }else{\r\n            buffers.push( this.writeCPTOPSP( varRef.stackPointer - this.stackPointer, dtSize ) );\r\n          }\r\n        }else if(typeof statement.left?.stackPointer === 'number'){\r\n          buffers.push( this.writeCPTOPSP( statement.left.stackPointer - this.stackPointer, dtSize ) );\r\n        }\r\n      }\r\n\r\n      if(statement.type == 'compare'){\r\n        if(statement.operator.value == '||'){\r\n          buffers.push( this.writeCPTOPSP(-4) );\r\n          buffers.push( this.writeJZ( statement.jz_1 ? statement.jz_1 - this.scopeOrThrow.bytes_written : 0x7FFFFFFF ) );\r\n          buffers.push( this.writeCPTOPSP(-4) );\r\n          buffers.push( this.writeJZ( statement.jz_2 ? statement.jz_2 - this.scopeOrThrow.bytes_written : 0x7FFFFFFF ) );\r\n          statement.jz_1 = this.scopeOrThrow.bytes_written;\r\n        }else if(statement.operator.value == '&&'){\r\n          buffers.push( this.writeCPTOPSP(-4) );\r\n          buffers.push( this.writeJZ( statement.jz_2 ? statement.jz_2 - this.scopeOrThrow.bytes_written : 0x7FFFFFFF ) );\r\n        }\r\n      }\r\n\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n\r\n      const inferUnary = (node: CompilerExpressionNode): number | undefined => {\r\n        if(!node) return undefined;\r\n        if(node.datatype?.unary !== undefined) return node.datatype.unary;\r\n        const dt = this.getDataType(node);\r\n        if(dt?.unary !== undefined) return dt.unary;\r\n        if(node.type === 'literal' && node.datatype?.unary !== undefined) return node.datatype.unary;\r\n        return undefined;\r\n      };\r\n\r\n      let lUnary = inferUnary(statement.left);\r\n      let rUnary = inferUnary(statement.right);\r\n\r\n      // Fallback: if one side is int and the other is unknown, assume int\r\n      if(!lUnary && rUnary === NWCompileDataTypes.I) lUnary = NWCompileDataTypes.I;\r\n      if(!rUnary && lUnary === NWCompileDataTypes.I) rUnary = NWCompileDataTypes.I;\r\n\r\n      if(statement.operator.value == '=='){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeEQUAL(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeEQUAL(NWCompileDataTypes.FF) );\r\n        }else if(lUnary == NWCompileDataTypes.S && rUnary == NWCompileDataTypes.S){\r\n          buffers.push( this.writeEQUAL(NWCompileDataTypes.SS) );\r\n        }else if(lUnary == NWCompileDataTypes.O && rUnary == NWCompileDataTypes.O){\r\n          buffers.push( this.writeEQUAL(NWCompileDataTypes.OO) );\r\n        }else{\r\n          const engine_type_left = lUnary;\r\n          const engine_type_right = rUnary;\r\n          if( engine_type_left !== undefined && engine_type_right !== undefined &&\r\n              (engine_type_left >= 0x10 && engine_type_left <= 0x1F) && (engine_type_right >= 0x10 && engine_type_right <= 0x1F) ){\r\n            if(engine_type_left == engine_type_right){\r\n              const engine_type_index = engine_type_left - 0x10;\r\n              buffers.push( this.writeEQUAL(NWEngineTypeBinaryTypeOffset + engine_type_index) );\r\n            }\r\n          }\r\n        }\r\n      }else if(statement.operator.value == '!='){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeNEQUAL(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeNEQUAL(NWCompileDataTypes.FF) );\r\n        }else if(lUnary == NWCompileDataTypes.S && rUnary == NWCompileDataTypes.S){\r\n          buffers.push( this.writeNEQUAL(NWCompileDataTypes.SS) );\r\n        }else if(lUnary == NWCompileDataTypes.O && rUnary == NWCompileDataTypes.O){\r\n          buffers.push( this.writeNEQUAL(NWCompileDataTypes.OO) );\r\n        }else{\r\n          const engine_type_left = lUnary;\r\n          const engine_type_right = rUnary;\r\n          if( engine_type_left !== undefined && engine_type_right !== undefined &&\r\n              (engine_type_left >= 0x10 && engine_type_left <= 0x1F) && (engine_type_right >= 0x10 && engine_type_right <= 0x1F) ){\r\n            if(engine_type_left == engine_type_right){\r\n              const engine_type_index = engine_type_left - 0x10;\r\n              buffers.push( this.writeNEQUAL(NWEngineTypeBinaryTypeOffset + engine_type_index) );\r\n            }\r\n          }\r\n        }\r\n      }else if(statement.operator.value == '&&'){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeLOGANDII() );\r\n          statement.jz_2 = this.scopeOrThrow.bytes_written;\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: LOGANDII datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }else if(statement.operator.value == '||'){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          statement.jz_2 = this.scopeOrThrow.bytes_written;\r\n          buffers.push( this.writeLOGORII() );\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: LOGORII datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }else if(statement.operator.value == '>='){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeGEQ(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeGEQ(NWCompileDataTypes.FF) );\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: GEQ datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }else if(statement.operator.value == '>'){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeGT(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeGT(NWCompileDataTypes.FF) );\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: GT datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }else if(statement.operator.value == '<'){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeLT(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeLT(NWCompileDataTypes.FF) );\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: LT datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }else if(statement.operator.value == '<='){\r\n        if(lUnary == NWCompileDataTypes.I && rUnary == NWCompileDataTypes.I){\r\n          buffers.push( this.writeLEQ(NWCompileDataTypes.II) );\r\n        }else if(lUnary == NWCompileDataTypes.F && rUnary == NWCompileDataTypes.F){\r\n          buffers.push( this.writeLEQ(NWCompileDataTypes.FF) );\r\n        }else{\r\n          //ERROR: unsupported datatypes to compare\r\n          log.error('Unsupported: LEQ datatypes', this.getDataType(statement.left), this.getDataType(statement.right) );\r\n        }\r\n      }\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileIf( statement: CompilerIfNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'if'){\r\n      // Build chain: if + elseIfs + else, drop any null/undefined\r\n      const ifelses: (CompilerIfNode | CompilerElseIfNode | CompilerElseNode)[] = ([] as (CompilerIfNode | CompilerElseIfNode | CompilerElseNode)[]).concat([statement], statement.elseIfs || [], statement.else || []).filter(Boolean);\r\n\r\n      for(let i = 0; i < ifelses.length; i++){\r\n        const ifelse = ifelses[i];\r\n\r\n        //Compile the condition statements (support single or array)\r\n        const conds = Array.isArray(ifelse.condition) ? ifelse.condition : (ifelse.condition ? [ifelse.condition] : []);\r\n        for(let j = 0; j < conds.length; j++){\r\n          buffers.push( this.compileStatement( conds[j] ) as Uint8Array );\r\n        }\r\n\r\n        //the offset prior to writing the JZ statement\r\n        ifelse.jz_start = this.scopeOrThrow.bytes_written;\r\n\r\n        //write the JZ statement\r\n        if(ifelse.type != 'else'){\r\n          //jump to next ifelse or else statement if condition is false\r\n          buffers.push( this.writeJZ(ifelse.jz ? ifelse.jz : 0x7FFFFFFF) );\r\n        }\r\n\r\n        //the offset prior to writing the statements\r\n        ifelse.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n        const sp_cache = this.stackPointer;\r\n\r\n        //Compile if statements\r\n        for(let j = 0; j < ifelse.statements.length; j++){\r\n          buffers.push( this.compileStatement( ifelse.statements[j] ) as Uint8Array );\r\n        }\r\n\r\n        const sp_offset = this.stackPointer - sp_cache;\r\n        if(sp_offset){\r\n          buffers.push( this.writeMOVSP(-sp_offset) );\r\n        }\r\n\r\n        //the offset prior to writing the JMP statement\r\n        ifelse.jmp_start = this.scopeOrThrow.bytes_written;\r\n        //write the JMP statement\r\n        if(ifelse.type != 'else'){\r\n          buffers.push( this.writeJMP( ifelses[i].jmp ? ifelses[i].jmp : 0x7FFFFFFF ) ); //jump to the end of the else if chain\r\n        }\r\n\r\n        //the offset that marks the end of this ifelse block\r\n        ifelse.block_end = this.scopeOrThrow.bytes_written;\r\n\r\n        if(ifelse.type != 'else'){\r\n          if(!ifelse.jz){\r\n            ifelse.jz = ifelse.block_end - ifelse.jz_start;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Calculate JMP offsets\r\n      for(let i = 0; i < ifelses.length; i++){\r\n        ifelses[i].end_of_if_else_block = this.scopeOrThrow.bytes_written;\r\n        if(!ifelses[i].jmp){\r\n          ifelses[i].jmp = ifelses[i].end_of_if_else_block - ifelses[i].jmp_start;\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileSwitch( statement: CompilerSwitchNode ){\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'switch'){\r\n\r\n      statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n      const switchCondition = statement.condition;\r\n      const has_default = statement.default && statement.default.type == 'default' ? true : false;\r\n\r\n      //save the pointer to the switch varaible location on the stack\r\n      const switch_condition_sp = this.stackPointer;\r\n      //push the switch variable onto the stack\r\n      buffers.push( this.compileStatement(switchCondition) as Uint8Array );\r\n\r\n      for(let i = 0; i < statement.cases.length; i++){\r\n        const _case = statement.cases[i];\r\n        buffers.push( this.writeCPTOPSP( (switch_condition_sp - this.stackPointer), 0x04) );\r\n        buffers.push( this.compileStatement( _case.value ) as Uint8Array );\r\n        buffers.push( this.writeEQUAL(NWCompileDataTypes.II) );\r\n        buffers.push( this.writeJNZ( _case.block_start ? _case.block_start - this.scopeOrThrow.bytes_written : 0x7FFFFFFF ) );\r\n      }\r\n\r\n      if(has_default){\r\n        buffers.push( this.writeJMP( statement.default.block_start - this.scopeOrThrow.bytes_written ) );\r\n      }else{\r\n        buffers.push( this.writeJMP( statement.block_end - this.scopeOrThrow.bytes_written ) );\r\n      }\r\n\r\n      //Compile the case statements\r\n      for(let i = 0; i < statement.cases.length; i++){\r\n        const _case = statement.cases[i];\r\n        _case.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n        for(let j = 0; j < _case.statements.length; j++){\r\n          buffers.push( this.compileStatement( _case.statements[j] ) as Uint8Array );\r\n        }\r\n\r\n        if(!_case.fallthrough){\r\n          buffers.push( this.writeJMP( statement.block_end - this.scopeOrThrow.bytes_written ) );\r\n        }\r\n\r\n        _case.block_end = this.scopeOrThrow.bytes_written;\r\n      }\r\n\r\n      //Compile the default statements\r\n      if(has_default){\r\n        const _default = statement.default;\r\n        _default.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n        for(let i = 0; i < _default.statements.length; i++){\r\n          buffers.push( this.compileStatement( _default.statements[i] ) as Uint8Array );\r\n        }\r\n\r\n        buffers.push( this.writeJMP( statement.block_end - this.scopeOrThrow.bytes_written ) );\r\n\r\n        _default.block_end = this.scopeOrThrow.bytes_written;\r\n      }\r\n\r\n      //mark the end of the switch block\r\n      statement.block_end = this.scopeOrThrow.bytes_written;\r\n\r\n      //clear the switch variable off the stack\r\n      buffers.push( this.writeMOVSP( -4 ) );\r\n\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileDoWhileLoop( statement: CompilerDoWhileNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'do'){\r\n      const nested_state = new NWScriptNestedState( statement );\r\n      this.scopeOrThrow.addNestedState( nested_state );\r\n\r\n      statement.block_start = this.scopeOrThrow.bytes_written;\r\n      statement.preStatementsSPCache = this.stackPointer;\r\n\r\n      statement.statements_start = this.scopeOrThrow.bytes_written;\r\n      for(let i = 0; i < statement.statements.length; i++){\r\n        const stmt = statement.statements[i];\r\n        if(stmt && typeof stmt === 'object'){\r\n        (stmt as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n        }\r\n        buffers.push( this.compileStatement( stmt ) as Uint8Array );\r\n      }\r\n\r\n      const stackElementsToRemove = this.stackPointer - statement.preStatementsSPCache;\r\n      if(stackElementsToRemove){\r\n        buffers.push( this.writeMOVSP( -stackElementsToRemove ) );\r\n      }\r\n      statement.statements_end = this.scopeOrThrow.bytes_written;\r\n\r\n      statement.continue_start = this.scopeOrThrow.bytes_written;\r\n\r\n      statement.condition_start = this.scopeOrThrow.bytes_written;\r\n      const conds = Array.isArray(statement.condition) ? statement.condition : (statement.condition ? [statement.condition] : []);\r\n      for(let i = 0; i < conds.length; i++){\r\n        buffers.push( this.compileStatement( conds[i] ) as Uint8Array );\r\n      }\r\n\r\n      //If the condition is false Jump out of the loop\r\n      buffers.push(\r\n        this.writeJZ(\r\n          this.getInstructionLength(OP_JZ) +\r\n          this.getInstructionLength(OP_JMP)\r\n        )\r\n      );\r\n\r\n      //JMP back to the beginning of the DO-While statement\r\n      buffers.push(\r\n        this.writeJMP(\r\n          -(this.scopeOrThrow.bytes_written - statement.block_start)\r\n        )\r\n      );\r\n\r\n      statement.condition_end = this.scopeOrThrow.bytes_written;\r\n\r\n      statement.block_end = this.scopeOrThrow.bytes_written;\r\n      this.scopeOrThrow.removeNestedState( nested_state );\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileWhileLoop( statement: CompilerWhileNode ){\r\n\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'while'){\r\n      const nested_state = new NWScriptNestedState( statement );\r\n      this.scopeOrThrow.addNestedState( nested_state );\r\n      //Cache the byte offset of the beginning of this code block\r\n      statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n      statement.continue_start = this.scopeOrThrow.bytes_written;\r\n\r\n      //Compile the while condition statements (support single)\r\n      const conds = Array.isArray(statement.condition) ? statement.condition : (statement.condition ? [statement.condition] : []);\r\n      for(let i = 0; i < conds.length; i++){\r\n        buffers.push( this.compileStatement( conds[i] ) as Uint8Array );\r\n        if(i) buffers.push( this.writeEQUAL(NWCompileDataTypes.II) );\r\n      }\r\n\r\n      //If the condition is false Jump out of the loop\r\n      buffers.push(\r\n        this.writeJZ( statement.block_end ? (statement.block_end - this.scopeOrThrow.bytes_written) : 0x7FFFFFFF )\r\n      );\r\n\r\n      //Cache the current stack pointer\r\n      statement.preStatementsSPCache = this.stackPointer;\r\n\r\n      //Compile the block statements\r\n      for(let i = 0; i < statement.statements.length; i++){\r\n        const stmt = statement.statements[i];\r\n        if(stmt && typeof stmt === 'object'){\r\n          stmt.statement_context = 'statement';\r\n        }\r\n        buffers.push( this.compileStatement( stmt ) as Uint8Array );\r\n      }\r\n\r\n      //Get stack elements that should be removed from this scope\r\n      const stackElementsToRemove = this.stackPointer - statement.preStatementsSPCache;\r\n      if(stackElementsToRemove){\r\n        buffers.push( this.writeMOVSP( -stackElementsToRemove ) );\r\n      }\r\n\r\n      //JMP back to the beginning of the DO-While statement\r\n      buffers.push(\r\n        this.writeJMP(\r\n          -(this.scopeOrThrow.bytes_written - statement.block_start)\r\n        )\r\n      );\r\n\r\n      statement.block_end = this.scopeOrThrow.bytes_written;\r\n      this.scopeOrThrow.removeNestedState( nested_state );\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileForLoop( statement: CompilerForNode ){\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    if(statement && statement.type == 'for'){\r\n      const nested_state = new NWScriptNestedState( statement );\r\n      this.scopeOrThrow.addNestedState( nested_state );\r\n\r\n      //Cache the byte offset of the beginning of this code block\r\n      statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n      //Begin initializer\r\n      statement.initializer_start = this.scopeOrThrow.bytes_written;\r\n\r\n      if(statement.initializer && typeof statement.initializer === 'object'){\r\n        (statement.initializer as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n      }\r\n      buffers.push( this.compileStatement( statement.initializer ) as Uint8Array );\r\n\r\n      statement.initializer_end = this.scopeOrThrow.bytes_written;\r\n      //End initializer\r\n\r\n\r\n\r\n      //Begin condition\r\n      statement.condition_start = this.scopeOrThrow.bytes_written;\r\n      statement.continue_start = this.scopeOrThrow.bytes_written;\r\n\r\n      const conds = Array.isArray(statement.condition) ? statement.condition : (statement.condition ? [statement.condition] : []);\r\n      for(let i = 0; i < conds.length; i++){\r\n        buffers.push( this.compileStatement( conds[i] ) as Uint8Array );\r\n        if(i) buffers.push( this.writeEQUAL(NWCompileDataTypes.II) );\r\n      }\r\n      buffers.push(\r\n        this.writeJZ(\r\n          statement.block_end ? (statement.block_end - this.scopeOrThrow.bytes_written) : 0x7FFFFFFF\r\n        )\r\n      );\r\n\r\n      statement.condition_end = this.scopeOrThrow.bytes_written;\r\n      //End condition\r\n\r\n\r\n\r\n      //Begin statements\r\n      statement.statements_start = this.scopeOrThrow.bytes_written;\r\n\r\n      statement.preStatementsSPCache = this.stackPointer;\r\n      for(let i = 0; i < statement.statements.length; i++){\r\n        const stmt = statement.statements[i];\r\n        if(stmt && typeof stmt === 'object'){\r\n        (stmt as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n        }\r\n        buffers.push( this.compileStatement( stmt ) as Uint8Array );\r\n      }\r\n      const stackOffset = this.stackPointer - statement.preStatementsSPCache;\r\n      if(stackOffset) buffers.push( this.writeMOVSP( -stackOffset ) );\r\n\r\n      statement.statements_end = this.scopeOrThrow.bytes_written;\r\n      //End statements\r\n\r\n\r\n\r\n      //Begin incrementor\r\n      statement.incrementor_start = this.scopeOrThrow.bytes_written;\r\n\r\n      if(statement.incrementor && typeof statement.incrementor === 'object'){\r\n        (statement.incrementor as CompilerStatementNodeWithContext).statement_context = 'statement';\r\n      }\r\n      buffers.push( this.compileStatement( statement.incrementor ) as Uint8Array );\r\n\r\n      statement.incrementor_end = this.scopeOrThrow.bytes_written;\r\n      //End incrementor\r\n\r\n      buffers.push(\r\n        this.writeJMP(\r\n          statement.condition_start ? -(this.scopeOrThrow.bytes_written - statement.condition_start) : 0x7FFFFFFF\r\n        )\r\n      );\r\n\r\n      statement.block_end = this.scopeOrThrow.bytes_written;\r\n      this.scopeOrThrow.removeNestedState( nested_state );\r\n    }\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileContinue( statement: CompilerContinueNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement.type !== 'continue'){\r\n      throw new Error('Invalid statement type: expected continue, got ' + statement.type);\r\n    }\r\n    statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n    const active_loop = this.scopeOrThrow.getTopContinueableNestedState();\r\n    if(active_loop){\r\n      const stackOffset = this.stackPointer - active_loop.statement.preStatementsSPCache;\r\n      if(stackOffset){\r\n        buffers.push( this.writeMOVSP( -stackOffset ) );\r\n        //return the stack pointer to it's previous state so that the outer loop is not affected\r\n        this.stackPointer += stackOffset;\r\n      }else{\r\n        //log.info('noting to remove')\r\n      }\r\n      buffers.push(\r\n        this.writeJMP(\r\n          active_loop.statement.continue_start ? -(this.scopeOrThrow.bytes_written - active_loop.statement.continue_start) : 0x7FFFFFFF\r\n        )\r\n      );\r\n    }else{\r\n      //log.info('no active loop');\r\n      //can't use continue outside of a loop\r\n    }\r\n\r\n    statement.block_end = this.scopeOrThrow.bytes_written;\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileBreak( statement: CompilerBreakNode ){\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement.type !== 'break'){\r\n      throw new Error('Invalid statement type: expected break, got ' + statement.type);\r\n    }\r\n    statement.block_start = this.scopeOrThrow.bytes_written;\r\n\r\n    const active_loop = this.scopeOrThrow.getTopContinueableNestedState();\r\n    if(active_loop){\r\n      const stackOffset = this.stackPointer - active_loop.statement.preStatementsSPCache;\r\n      if(stackOffset){\r\n        buffers.push( this.writeMOVSP( -stackOffset ) );\r\n        //return the stack pointer to it's previous state so that the outer loop is not affected\r\n        this.stackPointer += stackOffset;\r\n      }else{\r\n        //log.info('noting to remove')\r\n      }\r\n      buffers.push(\r\n        this.writeJMP(\r\n          active_loop.statement.block_end ? -(this.scopeOrThrow.bytes_written - active_loop.statement.block_end) : 0x7FFFFFFF\r\n        )\r\n      );\r\n    }else{\r\n      //log.info('no active loop');\r\n      //can't use break outside of a loop\r\n    }\r\n\r\n    statement.block_end = this.scopeOrThrow.bytes_written;\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  //Not the value\r\n  compileNOT( statement: CompilerUnaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    buffers.push( this.compileStatement( statement.value ) as Uint8Array );\r\n    buffers.push( this.writeNOTI( ) );\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileINC( statement: CompilerIncDecNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'inc'){\r\n      const varRef = statement.variable_reference;\r\n      if(varRef.is_global){\r\n        if(!statement.postfix){\r\n          buffers.push(\r\n            this.writeINCIBP(\r\n              varRef.stackPointer - this.stackPointer\r\n            )\r\n          );\r\n        }\r\n        buffers.push(\r\n          this.writeCPTOPBP(\r\n            varRef.stackPointer - this.basePointer,\r\n            this.getDataTypeStackLength(varRef.datatype)\r\n          )\r\n        );\r\n        if(statement.postfix){\r\n          buffers.push(\r\n            this.writeINCIBP(\r\n              varRef.stackPointer - this.basePointer\r\n            )\r\n          );\r\n        }\r\n      }else{\r\n        if(!statement.postfix){\r\n          buffers.push(\r\n            this.writeINCISP(\r\n              varRef.stackPointer - this.stackPointer\r\n            )\r\n          );\r\n        }\r\n        buffers.push(\r\n          this.writeCPTOPSP(\r\n            varRef.stackPointer - this.stackPointer,\r\n            this.getDataTypeStackLength(varRef.datatype)\r\n          )\r\n        );\r\n        if(statement.postfix){\r\n          buffers.push(\r\n            this.writeINCISP(\r\n              varRef.stackPointer - this.stackPointer\r\n            )\r\n          );\r\n        }\r\n      }\r\n      if(!this.getCurrentScope()?.consumingValue){\r\n        buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.variable_reference.datatype) ) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  compileDEC( statement: CompilerIncDecNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'dec'){\r\n      const varRef = statement.variable_reference;\r\n      if(varRef.is_global){\r\n        if(!statement.postfix){\r\n          buffers.push(\r\n            this.writeDECIBP(\r\n              varRef.stackPointer - this.basePointer\r\n            )\r\n          );\r\n        }\r\n        buffers.push( this.writeCPTOPBP(\r\n          varRef.stackPointer - this.basePointer,\r\n          this.getDataTypeStackLength(varRef.datatype)\r\n        ) );\r\n        if(statement.postfix){\r\n          buffers.push(\r\n            this.writeDECIBP(\r\n              varRef.stackPointer - this.basePointer\r\n            )\r\n          );\r\n        }\r\n      }else{\r\n        if(!statement.postfix){\r\n          buffers.push(\r\n            this.writeDECISP(\r\n              varRef.stackPointer - this.stackPointer\r\n            )\r\n          );\r\n        }\r\n        buffers.push( this.writeCPTOPSP(\r\n          varRef.stackPointer - this.stackPointer,\r\n          this.getDataTypeStackLength(varRef.datatype)\r\n        ) );\r\n        if(statement.postfix){\r\n          buffers.push(\r\n            this.writeDECISP(\r\n              varRef.stackPointer - this.stackPointer\r\n            )\r\n          );\r\n        }\r\n      }\r\n      if(!this.getCurrentScope()?.consumingValue){\r\n        buffers.push( this.writeMOVSP( -this.getDataTypeStackLength(statement.variable_reference.datatype) ) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  //Negate the number\r\n  compileNEG( statement: CompilerUnaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    buffers.push( this.compileStatement( statement.value ) as Uint8Array );\r\n    buffers.push( this.writeNEG( this.getDataType( statement.value ).unary ) );\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  //Ones compliment\r\n  compileComp( statement: CompilerUnaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n\r\n    buffers.push( this.compileStatement( statement.value ) as Uint8Array );\r\n    buffers.push( this.writeCOMPI( ) );\r\n\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  // Boolean/bitwise AND (int & int)\r\n  // { type:'booland', left:<expr>, right:<expr>, operator:{value:'&'} }\r\n  compileBOOLAND( statement: CompilerBinaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'booland'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n\r\n      const ldt = this.getDataType(statement.left);\r\n      const rdt = this.getDataType(statement.right);\r\n      if(ldt?.unary == NWCompileDataTypes.I && rdt?.unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeBOOLANDII() );\r\n      }else{\r\n        // Keep the compiler from silently producing garbage\r\n        this.errors?.push?.({\r\n          type: 'compile',\r\n          message: `BOOLAND requires int & int (got ${ldt?.value ?? 'unknown'} & ${rdt?.value ?? 'unknown'})`,\r\n          statement,\r\n          offender: statement\r\n        });\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  // Shifts (int << int), (int >> int), (int >>> int)\r\n  // AST shape:\r\n  // { type:'shift', left:<expr>, right:<expr>, operator:{value:'<<'|'>>'|'>>>'} }\r\n  compileShift( statement: CompilerBinaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'shift'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n\r\n      const ldt = this.getDataType(statement.left);\r\n      const rdt = this.getDataType(statement.right);\r\n      if(ldt?.unary == NWCompileDataTypes.I && rdt?.unary == NWCompileDataTypes.I){\r\n        const op = statement?.operator?.value;\r\n        if(op == '<<'){\r\n          buffers.push( this.writeSHLEFTII() );\r\n        }else if(op == '>>'){\r\n          buffers.push( this.writeSHRIGHTII() );\r\n        }else if(op == '>>>'){\r\n          buffers.push( this.writeUSHRIGHTII() );\r\n        }else{\r\n          this.errors?.push?.({\r\n            type: 'compile',\r\n            message: `Unknown shift operator '${op}'`,\r\n            statement,\r\n            offender: statement\r\n          });\r\n        }\r\n      }else{\r\n        this.errors?.push?.({\r\n          type: 'compile',\r\n          message: `Shift requires int <op> int (got ${ldt?.value ?? 'unknown'} ${statement?.operator?.value ?? '?'} ${rdt?.value ?? 'unknown'})`,\r\n          statement,\r\n          offender: statement\r\n        });\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  //Inclusive OR\r\n  compileINCOR( statement: CompilerBinaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'incor'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeINCORII( ) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  //Exclusive OR\r\n  compileEXCOR( statement: CompilerBinaryNode ): Uint8Array {\r\n    const buffers: Uint8Array[] = [];\r\n    if(statement && statement.type == 'xor'){\r\n      buffers.push( this.compileStatement(statement.left) as Uint8Array );\r\n      buffers.push( this.compileStatement(statement.right) as Uint8Array );\r\n      if(this.getDataType(statement.left).unary == NWCompileDataTypes.I && this.getDataType(statement.right).unary == NWCompileDataTypes.I){\r\n        buffers.push( this.writeEXCORII( ) );\r\n      }\r\n    }\r\n    return concatBuffers(buffers);\r\n  }\r\n\r\n  writeCPDOWNSP( offsetRelativeToTopOfStack = 0, numBytesToCopy = 4 ){\r\n    const buffer =  allocBuffer(this.getInstructionLength(OP_CPDOWNSP));\r\n    buffer.writeInt8(OP_CPDOWNSP, 0);\r\n    buffer.writeInt8(0x01, 1);\r\n    buffer.writeInt32BE(offsetRelativeToTopOfStack, 2);\r\n    buffer.writeInt16BE(numBytesToCopy, 6);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_CPDOWNSP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeRSADD( type = 0x03 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_RSADD));\r\n    buffer.writeInt8(OP_RSADD, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4; //The value of SP is increased by the size of the type reserved.  (Always 4)\r\n    this.opcodeDebug('OP_RSADD', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeCPTOPSP( offsetRelativeToTopOfStack = 0, numBytesToCopy = 4 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_CPTOPSP));\r\n    buffer.writeInt8(OP_CPTOPSP, 0);\r\n    buffer.writeInt8(0x01, 1);\r\n    buffer.writeInt32BE(offsetRelativeToTopOfStack, 2);\r\n    buffer.writeInt16BE(numBytesToCopy, 6);\r\n    this.stackPointer += numBytesToCopy;\r\n    this.opcodeDebug('OP_CPTOPSP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeCONST( type = 0x03, value?: number | string ){\r\n    let data_length = this.getInstructionLength(OP_CONST);\r\n    if(type == NWCompileDataTypes.S) data_length += value.length - 2;\r\n\r\n    const buffer = allocBuffer(data_length);\r\n    buffer.writeInt8(OP_CONST, 0);\r\n    buffer.writeInt8(type, 1);\r\n    switch(type){\r\n      case NWCompileDataTypes.I: //INT\r\n        buffer.writeInt32BE(value, 2);\r\n      break;\r\n      case NWCompileDataTypes.F: //Float\r\n        buffer.writeFloatBE(value, 2);\r\n      break;\r\n      case NWCompileDataTypes.S: //String\r\n        buffer.writeInt16BE(value.length, 2);\r\n        for(let i = 0; i < value.length; i++){\r\n          buffer.writeInt8(value.charCodeAt(i), 4 + i);\r\n        }\r\n      break;\r\n      case NWCompileDataTypes.O: //Object\r\n        buffer.writeInt32BE(value, 2);\r\n      break;\r\n    }\r\n    this.stackPointer += 4; //The value of SP is increased by the size of the type reserved.  (Always 4)\r\n    this.opcodeDebug('OP_CONST', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeACTION( type = 0x00, routineNumber = 0, numArguments = 0, returnSize = 4, nArgumentDataSize: number = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_ACTION));\r\n    buffer.writeInt8(OP_ACTION, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeUInt16BE(routineNumber, 2);\r\n    buffer.writeInt8(numArguments, 4);\r\n    this.stackPointer += returnSize;//Increase by size of return value\r\n    this.stackPointer -= nArgumentDataSize;//Decrease by the size of the arguments;\r\n    this.opcodeDebug('OP_ACTION', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeLOGANDII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_LOGANDII));\r\n    buffer.writeInt8(OP_LOGANDII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_LOGANDII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeLOGORII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_LOGORII));\r\n    buffer.writeInt8(OP_LOGORII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_LOGORII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeINCORII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_INCORII));\r\n    buffer.writeInt8(OP_INCORII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_INCORII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeEXCORII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_EXCORII));\r\n    buffer.writeInt8(OP_EXCORII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_EXCORII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeBOOLANDII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_BOOLANDII));\r\n    buffer.writeInt8(OP_BOOLANDII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_BOOLANDII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeEQUAL( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_EQUAL));\r\n    buffer.writeInt8(OP_EQUAL, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_EQUAL', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeNEQUAL( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_NEQUAL));\r\n    buffer.writeInt8(OP_NEQUAL, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_NEQUAL', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeGEQ( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_GEQ));\r\n    buffer.writeInt8(OP_GEQ, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_GEQ', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeGT( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_GT));\r\n    buffer.writeInt8(OP_GT, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_GT', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeLT( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_LT));\r\n    buffer.writeInt8(OP_LT, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_LT', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeLEQ( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_LEQ));\r\n    buffer.writeInt8(OP_LEQ, 0);\r\n    buffer.writeInt8(type, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_LEQ', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSHLEFTII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_SHLEFTII));\r\n    buffer.writeInt8(OP_SHLEFTII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_SHLEFTII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSHRIGHTII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_SHRIGHTII));\r\n    buffer.writeInt8(OP_SHRIGHTII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_SHRIGHTII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeUSHRIGHTII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_USHRIGHTII));\r\n    buffer.writeInt8(OP_USHRIGHTII, 0);\r\n    buffer.writeInt8(0x20, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_USHRIGHTII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeADD( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_ADD));\r\n    buffer.writeInt8(OP_ADD, 0);\r\n    buffer.writeInt8(type, 1);\r\n\r\n    //Increase by size of return value && Decrease by size of both operands\r\n    if(type == NWCompileDataTypes.II){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.IF){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.FI){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.FF){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.SS){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.VV){ this.stackPointer += 12; this.stackPointer -= (12 * 2); }\r\n    this.opcodeDebug('OP_ADD', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSUB( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_SUB));\r\n    buffer.writeInt8(OP_SUB, 0);\r\n    buffer.writeInt8(type, 1);\r\n\r\n    //Increase by size of return value && Decrease by size of both operands\r\n    if(type == NWCompileDataTypes.II){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.IF){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.FI){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.FF){ this.stackPointer += 4; this.stackPointer -= (4 * 2); }\r\n    if(type == NWCompileDataTypes.VV){ this.stackPointer += 12; this.stackPointer -= (12 * 2); }\r\n    this.opcodeDebug('OP_SUB', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeMUL( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_MUL));\r\n    buffer.writeInt8(OP_MUL, 0);\r\n    buffer.writeInt8(type, 1);\r\n\r\n    //Increase by size of return value && Decrease by size of both operands\r\n    if(type == NWCompileDataTypes.II){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.IF){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.FI){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.FF){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.VF){ this.stackPointer += 12; this.stackPointer -= (12 + 4);  }\r\n    if(type == NWCompileDataTypes.FV){ this.stackPointer += 12; this.stackPointer -= (4  + 12); }\r\n    this.opcodeDebug('OP_MUL', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeDIV( type = 0x20 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_DIV));\r\n    buffer.writeInt8(OP_DIV, 0);\r\n    buffer.writeInt8(type, 1);\r\n\r\n    //Increase by size of return value && Decrease by size of both operands\r\n    if(type == NWCompileDataTypes.II){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.IF){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.FI){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.FF){ this.stackPointer += 4;  this.stackPointer -=  (4 * 2);  }\r\n    if(type == NWCompileDataTypes.VF){ this.stackPointer += 12; this.stackPointer -= (12 + 4);  }\r\n    if(type == NWCompileDataTypes.FV){ this.stackPointer += 12; this.stackPointer -= (4  + 12); }\r\n    this.opcodeDebug('OP_DIV', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.bytesWritten += buffer.length;\r\n    return buffer;\r\n  }\r\n\r\n  writeMODII( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_MODII));\r\n    buffer.writeInt8(OP_MODII, 0);\r\n    buffer.writeInt8(NWCompileDataTypes.II, 1);\r\n    this.stackPointer += 4;//Increase by size of return value\r\n    this.stackPointer -= (4 * 2);//Decrease by size of both operands\r\n    this.opcodeDebug('OP_MODII', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeNEG( type = 0x03 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_NEG));\r\n    buffer.writeInt8(OP_NEG, 0);\r\n    buffer.writeInt8(type, 1);\r\n    //SP remains unchanged because both the return value and the operand cosumed are of the same length\r\n    this.opcodeDebug('OP_NEG', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.bytesWritten += buffer.length;\r\n    return buffer;\r\n  }\r\n\r\n  writeCOMPI( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_COMPI));\r\n    buffer.writeInt8(OP_COMPI, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    //SP remains unchanged because both the return value and the operand cosumed are of the same length\r\n    this.opcodeDebug('OP_COMPI', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeMOVSP( nSize = 0, ignoreStackPointer = false ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_MOVSP));\r\n    buffer.writeInt8(OP_MOVSP, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeInt32BE(nSize, 2);\r\n    if(!ignoreStackPointer){\r\n      this.stackPointer += nSize;//Increase by size of return value; This should be a negative value so the stackPointer will actually go down\r\n    }\r\n    this.opcodeDebug('OP_MOVSP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSTORE_STATEALL( nSize = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_STORE_STATEALL));\r\n    buffer.writeInt8(OP_STORE_STATEALL, 0);\r\n    buffer.writeInt8(nSize, 1);\r\n    //SP remains unchanged\r\n    this.opcodeDebug('OP_STORE_STATEALL', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeJMP( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_JMP));\r\n    buffer.writeInt8(OP_JMP, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //SP remains unchanged.\r\n    this.opcodeDebug('OP_JMP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeJSR( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_JSR));\r\n    buffer.writeInt8(OP_JSR, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //SP remains unchanged.  The return value is NOT placed on the stack.\r\n    this.opcodeDebug('OP_JSR', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeJZ( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_JZ));\r\n    buffer.writeInt8(OP_JZ, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    this.stackPointer -= 4;\r\n    this.opcodeDebug('OP_JZ', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeRETN( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_RETN));\r\n    buffer.writeInt8(OP_RETN, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    //SP remains unchanged.  The return value is NOT placed on the stack.\r\n    this.opcodeDebug('OP_RETN', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeDESTRUCT( nTotalSizeToDestory = 0, nOffsetOfElementToKeep = 0, nSizeOfElementToKeep = 4 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_DESTRUCT));\r\n    buffer.writeInt8(OP_DESTRUCT, 0);\r\n    buffer.writeInt8(0x01, 1);\r\n    buffer.writeInt16BE(nTotalSizeToDestory, 2); //total size of structure properties\r\n    buffer.writeInt16BE(nOffsetOfElementToKeep, 4);  //offset of structure property to keep on stack\r\n    buffer.writeInt16BE(nSizeOfElementToKeep, 6); //size of structure property to keep on stack\r\n    this.stackPointer -= (nTotalSizeToDestory - nSizeOfElementToKeep);\r\n    this.opcodeDebug('OP_DESTRUCT', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeNOTI( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_NOTI));\r\n    buffer.writeInt8(OP_NOTI, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    //The value of SP remains unchanged since the operand and result are of the same size.\r\n    this.opcodeDebug('OP_NOTI', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeDECISP( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_DECISP));\r\n    buffer.writeInt8(OP_DECISP, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_DECISP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeINCISP( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_INCISP));\r\n    buffer.writeInt8(OP_INCISP, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_INCISP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeJNZ( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_JNZ));\r\n    buffer.writeInt8(OP_JNZ, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    this.stackPointer -= 4; //The value of SP is decremented by the size of the integer.\r\n    this.opcodeDebug('OP_JNZ', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeCPDOWNBP( nOffset = 0, nSize = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_CPDOWNBP));\r\n    buffer.writeInt8(OP_CPDOWNBP, 0);\r\n    buffer.writeInt8(0x01, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    buffer.writeInt16BE(nSize, 6);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_CPDOWNBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeCPTOPBP( nOffset = 0, nSize = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_CPTOPBP));\r\n    buffer.writeInt8(OP_CPTOPBP, 0);\r\n    buffer.writeInt8(0x01, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    buffer.writeInt16BE(nSize, 6);\r\n    this.stackPointer += nSize; //The value of SP is increased by the number of copied bytes.\r\n    this.opcodeDebug('OP_CPTOPBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeDECIBP( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_DECIBP));\r\n    buffer.writeInt8(OP_DECIBP, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_DECIBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeINCIBP( nOffset = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_INCIBP));\r\n    buffer.writeInt8(OP_INCIBP, 0);\r\n    buffer.writeInt8(0x03, 1);\r\n    buffer.writeInt32BE(nOffset, 2);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_INCIBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSAVEBP( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_SAVEBP));\r\n    buffer.writeInt8(OP_SAVEBP, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_SAVEBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.basePointer = this.stackPointer;\r\n    this.stackPointer = 0;\r\n    this.basePointerWriting = false;\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeRESTOREBP( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_RESTOREBP));\r\n    buffer.writeInt8(OP_RESTOREBP, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_RESTOREBP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeSTORE_STATE( nBStackSize = 0, nStackSize = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_STORE_STATE));\r\n    buffer.writeInt8(OP_STORE_STATE, 0);\r\n    buffer.writeInt8(0x10, 1);\r\n    buffer.writeInt32BE(nBStackSize, 2);\r\n    buffer.writeInt32BE(nStackSize, 6);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_STORE_STATE', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeNOP( ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_NOP));\r\n    buffer.writeInt8(OP_NOP, 0);\r\n    buffer.writeInt8(0x00, 1);\r\n    //The value of SP remains unchanged.\r\n    this.opcodeDebug('OP_NOP', buffer);\r\n    this.scopeAddBytesWritten(buffer.length);\r\n    this.addBytesWritten(buffer.length);\r\n    return buffer;\r\n  }\r\n\r\n  writeT( nScriptSize = 0 ){\r\n    const buffer = allocBuffer(this.getInstructionLength(OP_T));\r\n    buffer.writeInt8(OP_T, 0);\r\n    buffer.writeInt32BE(nScriptSize, 1);\r\n    //The value of SP remains unchanged.\r\n    //this.opcodeDebug('OP_T', buffer);\r\n    return buffer;\r\n  }\r\n\r\n  getInstructionLength( instr = 0x00 ){\r\n    switch(instr){\r\n      case OP_CPDOWNSP: return 8;\r\n      case OP_RSADD: return 2;\r\n      case OP_CPTOPSP: return 8;\r\n      case OP_CONST: return 6;\r\n      case OP_ACTION: return 5;\r\n      case OP_LOGANDII: return 2;\r\n      case OP_LOGORII: return 2;\r\n      case OP_INCORII: return 2;\r\n      case OP_EXCORII: return 2;\r\n      case OP_BOOLANDII: return 2;\r\n      case OP_EQUAL: return 2;\r\n      case OP_NEQUAL: return 2;\r\n      case OP_GEQ: return 2;\r\n      case OP_GT: return 2;\r\n      case OP_LT: return 2;\r\n      case OP_LEQ: return 2;\r\n      case OP_SHLEFTII: return 2;\r\n      case OP_SHRIGHTII: return 2;\r\n      case OP_USHRIGHTII: return 2;\r\n      case OP_ADD: return 2;\r\n      case OP_SUB: return 2;\r\n      case OP_MUL: return 2;\r\n      case OP_DIV: return 2;\r\n      case OP_MODII: return 2;\r\n      case OP_NEG: return 2;\r\n      case OP_COMPI: return 2;\r\n      case OP_MOVSP: return 6;\r\n      case OP_STORE_STATEALL: return 2;\r\n      case OP_JMP: return 6;\r\n      case OP_JSR: return 6;\r\n      case OP_JZ: return 6;\r\n      case OP_RETN: return 2;\r\n      case OP_DESTRUCT: return 8;\r\n      case OP_NOTI: return 2;\r\n      case OP_DECISP: return 6;\r\n      case OP_INCISP: return 6;\r\n      case OP_JNZ: return 6;\r\n      case OP_CPDOWNBP: return 8;\r\n      case OP_CPTOPBP: return 8;\r\n      case OP_DECIBP: return 6;\r\n      case OP_INCIBP: return 6;\r\n      case OP_SAVEBP: return 2;\r\n      case OP_RESTOREBP: return 2;\r\n      case OP_STORE_STATE: return 10;\r\n      case OP_NOP : return 2;\r\n      case OP_T: return 5;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  getInstructionLabel( instr = 0x00 ){\r\n    switch(instr){\r\n      case OP_CPDOWNSP: return 'CPDOWNSP';\r\n      case OP_RSADD: return 'RSADD';\r\n      case OP_CPTOPSP: return 'CPTOPSP';\r\n      case OP_CONST: return 'CONST';\r\n      case OP_ACTION: return 'ACTION';\r\n      case OP_LOGANDII: return 'LOGANDII';\r\n      case OP_LOGORII: return 'LOGORII';\r\n      case OP_INCORII: return 'INCORII';\r\n      case OP_EXCORII: return 'EXCORII';\r\n      case OP_BOOLANDII: return 'BOOLANDII';\r\n      case OP_EQUAL: return 'EQUAL';\r\n      case OP_NEQUAL: return 'NEQUAL';\r\n      case OP_GEQ: return 'GEQ';\r\n      case OP_GT: return 'GT';\r\n      case OP_LT: return 'LT';\r\n      case OP_LEQ: return 'LEQ';\r\n      case OP_SHLEFTII: return 'SHIFTII';\r\n      case OP_SHRIGHTII: return 'SHRIGHTII';\r\n      case OP_USHRIGHTII: return 'USHRIGHTII';\r\n      case OP_ADD: return 'ADD';\r\n      case OP_SUB: return 'SUB';\r\n      case OP_MUL: return 'MUL';\r\n      case OP_DIV: return 'DIV';\r\n      case OP_MODII: return 'MODII';\r\n      case OP_NEG: return 'NEG';\r\n      case OP_COMPI: return 'COMPI';\r\n      case OP_MOVSP: return 'MOVSP';\r\n      case OP_STORE_STATEALL: return 'STORE_STATEALL';\r\n      case OP_JMP: return 'JMP';\r\n      case OP_JSR: return 'JSR';\r\n      case OP_JZ: return 'JZ';\r\n      case OP_RETN: return 'RETN';\r\n      case OP_DESTRUCT: return 'DESTRUCT';\r\n      case OP_NOTI: return 'NOTI';\r\n      case OP_DECISP: return 'DECISP';\r\n      case OP_INCISP: return 'INCISP';\r\n      case OP_JNZ: return 'JNZ';\r\n      case OP_CPDOWNBP: return 'CPDOWNBP';\r\n      case OP_CPTOPBP: return 'CPTOPBP';\r\n      case OP_DECIBP: return 'DECIBP';\r\n      case OP_INCIBP: return 'INCIBP';\r\n      case OP_SAVEBP: return 'SAVEBP';\r\n      case OP_RESTOREBP: return 'RESTOREBP';\r\n      case OP_STORE_STATE: return 'STORE_STATE';\r\n      case OP_NOP : return 'NOP';\r\n      case OP_T: return 'T';\r\n    }\r\n    return -1;\r\n  }\r\n\r\n}\r\n\r\nclass NWScriptScope {\r\n  is_global = false;\r\n  bytes_written = 0;\r\n  nested_states: NWScriptNestedState[] = [];\r\n  block: CompilerBlockNode | undefined;\r\n  consumingValue = false;\r\n\r\n  constructor( ){\r\n\r\n  }\r\n\r\n  addNestedState( state: NWScriptNestedState ){\r\n    if(state instanceof NWScriptNestedState){\r\n      this.nested_states.push(state);\r\n    }\r\n  }\r\n\r\n  removeNestedState( state: NWScriptNestedState ){\r\n    const idx = this.nested_states.indexOf( state );\r\n    if(idx >= 0) this.nested_states.splice(idx, 1);\r\n  }\r\n\r\n  getTopContinueableNestedState( ){\r\n    return this.nested_states.slice(0).reverse().find( s => { return (s.statement.type == 'for' || s.statement.type == 'while' || s.statement.type == 'do') } );\r\n  }\r\n\r\n  getTopBreakableNestedState( ){\r\n    return this.nested_states.slice(0).reverse().find( s => s.statement.type == 'if' );\r\n  }\r\n\r\n  popped(){\r\n    //\r\n  }\r\n\r\n}\r\n\r\nclass NWScriptNestedState {\r\n\r\n  statement: CompilerStatementNode;\r\n  constructor( statement: CompilerStatementNode ) {\r\n    this.statement = statement;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\compiler\\NWScriptIRBuilder.ts","messages":[{"ruleId":"no-duplicate-case","severity":2,"message":"Duplicate case label.","line":717,"column":7,"nodeType":"SwitchCase","messageId":"unexpected","endLine":719,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":1279,"column":28,"nodeType":"ConditionalExpression","messageId":"unsafeArgument","endLine":1279,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1622,"column":53,"nodeType":"Property","messageId":"anyAssignment","endLine":1622,"endColumn":72}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  SemanticProgramNode,\n  SemanticFunctionNode,\n  SemanticStatementNode,\n  SemanticBlockNode,\n  SemanticReturnNode,\n  SemanticFunctionCallNode,\n  SemanticLiteralNode,\n  SemanticExpressionNode,\n  SemanticVariableReferenceNode,\n  SemanticAssignNode,\n  SemanticBinaryNode,\n  SemanticCompareNode,\n  SemanticUnaryNode,\n  SemanticIncDecNode,\n  SemanticIfNode,\n  SemanticElseNode,\n  SemanticWhileNode,\n  SemanticDoWhileNode,\n  SemanticForNode,\n  SemanticSwitchNode,\n  SemanticPropertyNode,\n  SemanticIndexNode,\n  SemanticArrayLiteralNode,\n  SemanticVariableNode,\n  SemanticVariableListNode,\n  SemanticBreakNode,\n  SemanticContinueNode,\n  type SemanticDataType,\n} from \"@/nwscript/compiler/ASTSemanticTypes\";\nimport {\n  OP_CPDOWNSP,\n  OP_RSADD,\n  OP_CPTOPSP,\n  OP_CONST,\n  OP_ACTION,\n  OP_LOGANDII,\n  OP_LOGORII,\n  OP_INCORII,\n  OP_EXCORII,\n  OP_BOOLANDII,\n  OP_EQUAL,\n  OP_NEQUAL,\n  OP_GEQ,\n  OP_GT,\n  OP_LT,\n  OP_LEQ,\n  OP_SHLEFTII,\n  OP_SHRIGHTII,\n  OP_USHRIGHTII,\n  OP_ADD,\n  OP_SUB,\n  OP_MUL,\n  OP_DIV,\n  OP_MODII,\n  OP_NEG,\n  OP_COMPI,\n  OP_MOVSP,\n  OP_RETN,\n  OP_SAVEBP,\n  OP_RESTOREBP,\n  OP_CPTOPBP,\n  OP_CPDOWNBP,\n  OP_JMP,\n  OP_JSR,\n  OP_JZ,\n  OP_JNZ,\n  OP_NOTI,\n  OP_DECISP,\n  OP_INCISP,\n  OP_NOP,\n  OP_STORE_STATE,\n} from \"@/nwscript/NWScriptOPCodes\";\n\n\n// Minimal IR types: label-based, linear instruction list.\nexport type IRProgram = {\n  functions: IRFunction[];\n};\n\nexport type IRFunction = {\n  name: string;\n  isEngineAction?: boolean;\n  arguments: IRValue[];\n  returnType: IRType | null;\n  returnSize: number;\n  instructions: IRInstruction[];\n  entryLabel: string;\n};\n\nexport type IRType = {\n  kind: \"datatype\";\n  value: string;\n  unary: number;\n};\n\nexport type IRValue =\n  | { kind: \"const\"; type: IRType; value: number | string }\n  | { kind: \"var\"; name: string; isGlobal?: boolean; offset?: number; size?: number }\n  | { kind: \"temp\"; id: number };\n\n// IR instructions are deliberately concrete and label-based.\nexport type IRInstruction =\n  | { op: \"label\"; name: string }\n  | { op: \"rsadd\"; type: IRType }\n  | { op: \"movsp\"; delta: number }\n  | { op: \"loadconst\"; type: IRType; value: number | string }\n  | { op: \"loadvar\"; type: IRType; varName: string; isGlobal?: boolean; size?: number }\n  | { op: \"storevar\"; type: IRType; varName: string; isGlobal?: boolean; size?: number }\n  | { op: \"binop\"; kind: \"add\" | \"sub\" | \"mul\" | \"div\" | \"mod\"; typeCode?: number }\n  | { op: \"compare\"; kind: \"eq\" | \"ne\" | \"gt\" | \"lt\" | \"ge\" | \"le\"; typeCode?: number; size?: number }\n  | { op: \"logic\"; kind: \"and\" | \"or\"; typeCode?: number }\n  | { op: \"unary\"; kind: \"neg\" | \"not\"; typeCode?: number }\n  | { op: \"inc\"; varName: string; isGlobal?: boolean; postfix?: boolean; size?: number }\n  | { op: \"dec\"; varName: string; isGlobal?: boolean; postfix?: boolean; size?: number }\n  | { op: \"loadfield\"; type: IRType; field: string; parent?: string }\n  | { op: \"storefield\"; type: IRType; field: string; parent?: string }\n  | { op: \"loadindex\"; type: IRType; indexLiteral?: number }\n  | { op: \"storeindex\"; type: IRType; indexLiteral?: number }\n  | { op: \"cpdownsp\"; offset: number; size: number }\n  | { op: \"jsr\"; target: string }\n  | { op: \"jmp\"; target: string }\n  | { op: \"jz\"; target: string }\n  | { op: \"jnz\"; target: string }\n  | { op: \"action\"; id: number; argc: number; returnSize: number; argSize: number }\n  | { op: \"store_state\"; bStackSize: number; stackSize: number }\n  | { op: \"return\" }\n  | { op: \"nop\" };\n\nexport type IRStructLayout = {\n  name: string;\n  size: number;\n  fields: Record<string, { offset: number; size: number }>;\n};\n\nexport type IRStackSlot = { offset: number; size: number };\n\nexport type IRStackFrame = {\n  args: Record<string, IRStackSlot>;\n  locals: Record<string, IRStackSlot>;\n  frameSize: number;\n  localsSize: number;\n  argsSize: number;\n};\n\nexport type IRLabelMap = Record<string, number>;\n\nexport type IRLayoutResult = {\n  labels: IRLabelMap;\n  stack: IRStackFrame;\n  globals: Record<string, IRStackSlot>;\n  size: number;\n};\n\nexport type IREmittedFunction = {\n  name: string;\n  code: Uint8Array;\n  layout: IRLayoutResult;\n};\n\nexport type IREmittedProgram = {\n  functions: IREmittedFunction[];\n  total: Uint8Array;\n};\n\ntype WritableBuffer = Uint8Array & {\n  writeInt8(value: number, offset: number): void;\n  writeInt16BE(value: number, offset: number): void;\n  writeInt32BE(value: number, offset: number): void;\n  writeUInt16BE(value: number, offset: number): void;\n  writeFloatBE(value: number, offset: number): void;\n};\n\nconst allocBuffer = (length: number): WritableBuffer => {\n  if (typeof Buffer !== \"undefined\" && typeof Buffer.alloc === \"function\") {\n    return Buffer.alloc(length) as WritableBuffer;\n  }\n  const arr = new Uint8Array(length) as WritableBuffer;\n  const dv = new DataView(arr.buffer);\n  arr.writeInt8 = (value: number, offset: number) => dv.setInt8(offset, value);\n  arr.writeInt16BE = (value: number, offset: number) => dv.setInt16(offset, value, false);\n  arr.writeInt32BE = (value: number, offset: number) => dv.setInt32(offset, value, false);\n  arr.writeUInt16BE = (value: number, offset: number) => dv.setUint16(offset, value, false);\n  arr.writeFloatBE = (value: number, offset: number) => dv.setFloat32(offset, value, false);\n  return arr;\n};\n\nconst concatBuffers = (buffers: Uint8Array[]) => {\n  let totalLength = 0;\n  for (let i = 0; i < buffers.length; i++) {\n    totalLength += buffers[i].length;\n  }\n  const mergedArray = new Uint8Array(totalLength);\n  let offset = 0;\n  for (let i = 0; i < buffers.length; i++) {\n    mergedArray.set(buffers[i], offset);\n    offset += buffers[i].length;\n  }\n  return mergedArray;\n};\n\n/**\n * NWScriptIRBuilder\n * -----------------\n * Lowers a semantic program into a simple, label-based IR suitable for\n * a sizing pass (layout) and a separate emission pass.\n *\n * This builder currently creates IR function shells and preserves the\n * entry labels; you can extend `lowerFunction` to emit detailed IR from\n * statements/expressions.\n */\nexport class NWScriptIRBuilder {\n  private tempId = 0;\n  private breakLabels: string[] = [];\n  private continueLabels: string[] = [];\n\n  private newTemp(): IRValue {\n    return { kind: \"temp\", id: this.tempId++ };\n  }\n\n  private newLabel(prefix: string): string {\n    this.tempId += 1;\n    return `${prefix}_${this.tempId.toString(16)}`;\n  }\n\n  static build(program: SemanticProgramNode): IRProgram {\n    const irFunctions: IRFunction[] = [];\n\n    // Main or StartingConditional first, then other called functions if present.\n    const funcs: SemanticFunctionNode[] = [];\n    if (program.main) funcs.push(program.main);\n    if (program.startingConditional) funcs.push(program.startingConditional);\n    for (const f of program.functions || []) {\n      if (!funcs.includes(f)) funcs.push(f);\n    }\n\n    for (const fn of funcs) {\n      irFunctions.push(this.lowerFunction(fn));\n    }\n\n    return { functions: irFunctions };\n  }\n\n  // Lower a function to IR; currently handles returns, expressions, control-flow.\n  private static lowerFunction(fn: SemanticFunctionNode): IRFunction {\n    const entryLabel = `fn_${fn.name}`;\n    const builder = new NWScriptIRBuilder();\n    const instructions: IRInstruction[] = [{ op: \"label\", name: entryLabel }];\n    builder.lowerStatements(fn.statements as SemanticStatementNode[], instructions);\n    const retSize = NWScriptIRBuilder.getTypeSize(fn.returntype);\n\n    return {\n      name: fn.name,\n      isEngineAction: fn.is_engine_action ?? false,\n      arguments: [],\n      returnType: fn.returntype\n        ? { kind: \"datatype\", value: fn.returntype.value, unary: fn.returntype.unary }\n        : null,\n      returnSize: retSize,\n      instructions,\n      entryLabel,\n    };\n  }\n\n  private lowerStatements(stmts: SemanticStatementNode[], acc: IRInstruction[]) {\n    for (const stmt of stmts) {\n      this.lowerStatement(stmt, acc);\n    }\n  }\n\n  private lowerStatement(stmt: SemanticStatementNode, acc: IRInstruction[]): void {\n    switch (stmt.type) {\n      case \"block\":\n        this.lowerStatements((stmt as SemanticBlockNode).statements as SemanticStatementNode[], acc);\n        break;\n      case \"return\":\n        if ((stmt as SemanticReturnNode).value) {\n          this.lowerExpression((stmt as SemanticReturnNode).value as SemanticExpressionNode, acc);\n        }\n        acc.push({ op: \"return\" });\n        break;\n      case \"function_call\":\n        this.lowerFunctionCall(stmt as SemanticFunctionCallNode, acc);\n        break;\n      case \"literal\":\n        this.lowerLiteral(stmt as SemanticLiteralNode, acc);\n        break;\n      case \"property\":\n        this.lowerProperty(stmt as SemanticPropertyNode, acc);\n        break;\n      case \"index\":\n        this.lowerIndex(stmt as SemanticIndexNode, acc);\n        break;\n      case \"array_literal\":\n        this.lowerArrayLiteral(stmt as SemanticArrayLiteralNode, acc);\n        break;\n      case \"variable_reference\":\n        this.lowerVarRef(stmt as SemanticVariableReferenceNode, acc);\n        break;\n      case \"assign\":\n        this.lowerAssign(stmt as SemanticAssignNode, acc);\n        break;\n      case \"add\":\n      case \"sub\":\n      case \"mul\":\n      case \"div\":\n      case \"mod\":\n        this.lowerBinary(stmt as SemanticBinaryNode, acc);\n        break;\n      case \"compare\":\n        this.lowerCompare(stmt as SemanticCompareNode, acc);\n        break;\n      case \"neg\":\n      case \"not\":\n        this.lowerUnary(stmt as SemanticUnaryNode, acc);\n        break;\n      case \"inc\":\n      case \"dec\":\n        this.lowerIncDec(stmt as SemanticIncDecNode, acc);\n        break;\n      case \"if\":\n        this.lowerIf(stmt as unknown as SemanticIfNode, acc);\n        break;\n      case \"while\":\n        this.lowerWhile(stmt as unknown as SemanticWhileNode, acc);\n        break;\n      case \"do\":\n        this.lowerDoWhile(stmt as unknown as SemanticDoWhileNode, acc);\n        break;\n      case \"for\":\n        this.lowerFor(stmt as unknown as SemanticForNode, acc);\n        break;\n      case \"switch\":\n        this.lowerSwitch(stmt as unknown as SemanticSwitchNode, acc);\n        break;\n      case \"break\":\n        this.lowerBreak(stmt as SemanticBreakNode, acc);\n        break;\n      case \"continue\":\n        this.lowerContinue(stmt as SemanticContinueNode, acc);\n        break;\n      default:\n        acc.push({ op: \"nop\" });\n        break;\n    }\n  }\n\n  private lowerLiteral(lit: SemanticLiteralNode, acc: IRInstruction[]) {\n    const type: IRType = { kind: \"datatype\", value: lit.datatype.value, unary: lit.datatype.unary };\n    acc.push({ op: \"loadconst\", type, value: lit.value });\n  }\n\n  private lowerArrayLiteral(arr: SemanticArrayLiteralNode, acc: IRInstruction[]) {\n    // NWScript has no true arrays; array literals here are used for default\n    // vector-ish arguments. Emit each element as its literal; caller decides\n    // how many stack slots to reserve/consume.\n    for (const el of arr.elements) {\n      this.lowerExpression(el as SemanticExpressionNode, acc);\n    }\n  }\n\n  private lowerProperty(prop: SemanticPropertyNode, acc: IRInstruction[]) {\n    // Evaluate base\n    this.lowerExpression(prop.left as SemanticExpressionNode, acc);\n    const dt: IRType = prop.datatype\n      ? { kind: \"datatype\", value: prop.datatype.value, unary: prop.datatype.unary }\n      : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n    const leftDt = (prop.left as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype;\n    const parentStruct = leftDt?.struct ?? leftDt?.value ?? undefined;\n    if (prop.right) {\n      this.lowerExpression(prop.right as SemanticExpressionNode, acc);\n      acc.push({ op: \"storefield\", type: dt, field: prop.name, parent: parentStruct });\n    } else {\n      acc.push({ op: \"loadfield\", type: dt, field: prop.name, parent: parentStruct });\n    }\n  }\n\n  private lowerIndex(idx: SemanticIndexNode, acc: IRInstruction[]) {\n    this.lowerExpression(idx.left as SemanticExpressionNode, acc);\n    this.lowerExpression(idx.index as SemanticExpressionNode, acc);\n    const idxDt = (idx as SemanticIndexNode & { datatype?: SemanticDataType }).datatype;\n    const dt: IRType = idxDt\n      ? { kind: \"datatype\", value: idxDt.value, unary: idxDt.unary }\n      : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n    let litIdx: number | undefined;\n    if (idx.index.type === \"literal\" && typeof (idx.index as SemanticLiteralNode).value === \"number\") {\n      litIdx = (idx.index as SemanticLiteralNode).value as number;\n    }\n    // If part of assignment, store will be handled in assign lowering; otherwise load.\n    acc.push({ op: \"loadindex\", type: dt, indexLiteral: litIdx });\n  }\n  private lowerVarRef(vr: SemanticVariableReferenceNode, acc: IRInstruction[]) {\n    const dt: IRType = vr.datatype\n      ? { kind: \"datatype\", value: vr.datatype.value, unary: vr.datatype.unary }\n      : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n    acc.push({ op: \"loadvar\", type: dt, varName: vr.name, isGlobal: vr.is_global });\n  }\n\n  private lowerAssign(asn: SemanticAssignNode, acc: IRInstruction[]) {\n    this.lowerExpression(asn.right as SemanticExpressionNode, acc);\n    const left = asn.left;\n    if (left.type === \"variable_reference\") {\n      const vr = left as SemanticVariableReferenceNode;\n      const dt: IRType = vr.datatype\n        ? { kind: \"datatype\", value: vr.datatype.value, unary: vr.datatype.unary }\n        : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n      acc.push({ op: \"storevar\", type: dt, varName: vr.name, isGlobal: vr.is_global });\n    } else if (left.type === \"property\") {\n      const prop = left as SemanticPropertyNode;\n      const dt: IRType = prop.datatype\n        ? { kind: \"datatype\", value: prop.datatype.value, unary: prop.datatype.unary }\n        : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n      this.lowerExpression(prop.left as SemanticExpressionNode, acc);\n      acc.push({ op: \"storefield\", type: dt, field: prop.name });\n    } else if (left.type === \"index\") {\n      const idx = left as SemanticIndexNode;\n      const idxDt = (idx as SemanticIndexNode & { datatype?: SemanticDataType }).datatype;\n      const dt: IRType = idxDt\n        ? { kind: \"datatype\", value: idxDt.value, unary: idxDt.unary }\n        : { kind: \"datatype\", value: \"int\", unary: 0x03 };\n      this.lowerExpression(idx.left as SemanticExpressionNode, acc);\n      this.lowerExpression(idx.index as SemanticExpressionNode, acc);\n      let litIdx: number | undefined;\n      if (idx.index.type === \"literal\" && typeof (idx.index as SemanticLiteralNode).value === \"number\") {\n        litIdx = (idx.index as SemanticLiteralNode).value as number;\n      }\n      acc.push({ op: \"storeindex\", type: dt, indexLiteral: litIdx });\n    } else {\n      acc.push({ op: \"nop\" });\n    }\n  }\n\n  private lowerBinary(bin: SemanticBinaryNode, acc: IRInstruction[]) {\n    this.lowerExpression(bin.left as SemanticExpressionNode, acc);\n    this.lowerExpression(bin.right as SemanticExpressionNode, acc);\n    const typeCode = NWScriptIRBuilder.getBinaryOpTypeCode(\n      bin.type,\n      (bin.left as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype,\n      (bin.right as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype\n    );\n    switch (bin.type) {\n      case \"add\":\n        acc.push({ op: \"binop\", kind: \"add\", typeCode });\n        break;\n      case \"sub\":\n        acc.push({ op: \"binop\", kind: \"sub\", typeCode });\n        break;\n      case \"mul\":\n        acc.push({ op: \"binop\", kind: \"mul\", typeCode });\n        break;\n      case \"div\":\n        acc.push({ op: \"binop\", kind: \"div\", typeCode });\n        break;\n      case \"mod\":\n        acc.push({ op: \"binop\", kind: \"mod\", typeCode });\n        break;\n      default:\n        acc.push({ op: \"nop\" });\n        break;\n    }\n  }\n\n  private lowerCompare(cmp: SemanticCompareNode, acc: IRInstruction[]) {\n    const op = cmp.operator?.value;\n    if (op === \"&&\" || op === \"||\") {\n      // Short-circuit lowering: evaluate left, branch if decisive, else evaluate right\n      const lblShort = this.newLabel(op === \"&&\" ? \"and_short\" : \"or_short\");\n      const lblEnd = this.newLabel(op === \"&&\" ? \"and_end\" : \"or_end\");\n      // Evaluate left\n      this.lowerExpression(cmp.left as SemanticExpressionNode, acc);\n      // Duplicate top for branch check\n      acc.push({ op: \"loadconst\", type: { kind: \"datatype\", value: \"int\", unary: 0x03 }, value: 0 });\n      acc.push({ op: \"compare\", kind: \"eq\" });\n      // For &&, if left == 0 jump short-circuit false; for ||, if left == 0 fall through to right\n      if (op === \"&&\") {\n        acc.push({ op: \"jz\", target: lblShort }); // if result of (left==0) is zero -> left !=0, continue; else jump short\n      } else {\n        acc.push({ op: \"jnz\", target: lblShort }); // if left == 0 then jnz? Actually jnz jumps when !=0; we want jump when left!=0 -> short-circuit true\n      }\n      // Evaluate right\n      this.lowerExpression(cmp.right as SemanticExpressionNode, acc);\n      // combine right with previous? Just leave right result on stack\n      acc.push({ op: \"jmp\", target: lblEnd });\n      // short-circuit path\n      acc.push({ op: \"label\", name: lblShort });\n      if (op === \"&&\") {\n        // left was false => push 0\n        acc.push({ op: \"loadconst\", type: { kind: \"datatype\", value: \"int\", unary: 0x03 }, value: 0 });\n      } else {\n        // left was true => push 1\n        acc.push({ op: \"loadconst\", type: { kind: \"datatype\", value: \"int\", unary: 0x03 }, value: 1 });\n      }\n      acc.push({ op: \"label\", name: lblEnd });\n      return;\n    }\n\n    this.lowerExpression(cmp.left as SemanticExpressionNode, acc);\n    this.lowerExpression(cmp.right as SemanticExpressionNode, acc);\n    const typeInfo = NWScriptIRBuilder.getCompareTypeInfo(\n      (cmp.left as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype,\n      (cmp.right as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype,\n      (cmp as SemanticCompareNode & { datatype?: SemanticDataType })?.datatype\n    );\n    switch (op) {\n      case \"==\":\n        acc.push({ op: \"compare\", kind: \"eq\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      case \"!=\":\n        acc.push({ op: \"compare\", kind: \"ne\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      case \">\":\n        acc.push({ op: \"compare\", kind: \"gt\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      case \"<\":\n        acc.push({ op: \"compare\", kind: \"lt\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      case \">=\":\n        acc.push({ op: \"compare\", kind: \"ge\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      case \"<=\":\n        acc.push({ op: \"compare\", kind: \"le\", typeCode: typeInfo.typeCode, size: typeInfo.size });\n        break;\n      default:\n        acc.push({ op: \"nop\" });\n        break;\n    }\n  }\n\n  private lowerUnary(un: SemanticUnaryNode, acc: IRInstruction[]) {\n    this.lowerExpression(un.value as SemanticExpressionNode, acc);\n    const typeCode = NWScriptIRBuilder.getUnaryTypeCode(\n      un.type,\n      (un as SemanticUnaryNode & { datatype?: SemanticDataType }).datatype ??\n        (un.value as SemanticExpressionNode & { datatype?: SemanticDataType })?.datatype\n    );\n    switch (un.type) {\n      case \"neg\":\n        acc.push({ op: \"unary\", kind: \"neg\", typeCode });\n        break;\n      case \"not\":\n        acc.push({ op: \"unary\", kind: \"not\", typeCode });\n        break;\n      default:\n        acc.push({ op: \"nop\" });\n        break;\n    }\n  }\n\n  private lowerIncDec(id: SemanticIncDecNode, acc: IRInstruction[]) {\n    const vr = id.value as SemanticVariableReferenceNode;\n    if (vr && vr.type === \"variable_reference\") {\n      const name = vr.name;\n      const isPost = (id as SemanticIncDecNode & { postFix?: boolean; postfix?: boolean }).postFix ?? (id as SemanticIncDecNode & { postfix?: boolean }).postfix;\n      if (id.type === \"inc\") {\n        acc.push({ op: \"inc\", varName: name, isGlobal: vr.is_global, postfix: isPost });\n      } else {\n        acc.push({ op: \"dec\", varName: name, isGlobal: vr.is_global, postfix: isPost });\n      }\n    } else {\n      acc.push({ op: \"nop\" });\n    }\n  }\n\n  private lowerIf(node: SemanticIfNode, acc: IRInstruction[]) {\n    const lblElse = this.newLabel(\"else\");\n    const lblEnd = this.newLabel(\"endif\");\n    this.lowerExpression(node.condition as SemanticExpressionNode, acc);\n    acc.push({ op: \"jz\", target: lblElse });\n    this.lowerStatements(node.statements as SemanticStatementNode[], acc);\n    acc.push({ op: \"jmp\", target: lblEnd });\n    acc.push({ op: \"label\", name: lblElse });\n    if (node.elseIfs && node.elseIfs.length) {\n      for (const ei of node.elseIfs) {\n        const lblNext = this.newLabel(\"elseif_next\");\n        this.lowerExpression(ei.condition as SemanticExpressionNode, acc);\n        acc.push({ op: \"jz\", target: lblNext });\n        this.lowerStatements(ei.statements as SemanticStatementNode[], acc);\n        acc.push({ op: \"jmp\", target: lblEnd });\n        acc.push({ op: \"label\", name: lblNext });\n      }\n    }\n    if (node.else) {\n      this.lowerStatements((node.else as SemanticElseNode).statements as SemanticStatementNode[], acc);\n    }\n    acc.push({ op: \"label\", name: lblEnd });\n  }\n\n  private lowerWhile(node: SemanticWhileNode, acc: IRInstruction[]) {\n    const lblStart = this.newLabel(\"while_start\");\n    const lblEnd = this.newLabel(\"while_end\");\n    this.continueLabels.push(lblStart);\n    this.breakLabels.push(lblEnd);\n    acc.push({ op: \"label\", name: lblStart });\n    this.lowerExpression(node.condition as SemanticExpressionNode, acc);\n    acc.push({ op: \"jz\", target: lblEnd });\n    this.lowerStatements(node.statements as SemanticStatementNode[], acc);\n    acc.push({ op: \"jmp\", target: lblStart });\n    acc.push({ op: \"label\", name: lblEnd });\n    this.continueLabels.pop();\n    this.breakLabels.pop();\n  }\n\n  private lowerDoWhile(node: SemanticDoWhileNode, acc: IRInstruction[]) {\n    const lblStart = this.newLabel(\"do_start\");\n    const lblCond = this.newLabel(\"do_cond\");\n    const lblEnd = this.newLabel(\"do_end\");\n    this.continueLabels.push(lblCond);\n    this.breakLabels.push(lblEnd);\n    acc.push({ op: \"label\", name: lblStart });\n    this.lowerStatements(node.statements as SemanticStatementNode[], acc);\n    acc.push({ op: \"label\", name: lblCond });\n    this.lowerExpression(node.condition as SemanticExpressionNode, acc);\n    acc.push({ op: \"jnz\", target: lblStart });\n    acc.push({ op: \"label\", name: lblEnd });\n    this.continueLabels.pop();\n    this.breakLabels.pop();\n  }\n\n  private lowerFor(node: SemanticForNode, acc: IRInstruction[]) {\n    const lblStart = this.newLabel(\"for_start\");\n    const lblEnd = this.newLabel(\"for_end\");\n    const lblInc = this.newLabel(\"for_inc\");\n    this.continueLabels.push(lblInc);\n    this.breakLabels.push(lblEnd);\n    // initializer\n    if (node.initializer) {\n      this.lowerExpression(node.initializer as SemanticExpressionNode, acc);\n    }\n    acc.push({ op: \"label\", name: lblStart });\n    // condition\n    if (node.condition) {\n      this.lowerExpression(node.condition as SemanticExpressionNode, acc);\n      acc.push({ op: \"jz\", target: lblEnd });\n    }\n    // body\n    this.lowerStatements(node.statements as SemanticStatementNode[], acc);\n    acc.push({ op: \"label\", name: lblInc });\n    // incrementor\n    if (node.incrementor) {\n      this.lowerExpression(node.incrementor as SemanticExpressionNode, acc);\n    }\n    acc.push({ op: \"jmp\", target: lblStart });\n    acc.push({ op: \"label\", name: lblEnd });\n    this.continueLabels.pop();\n    this.breakLabels.pop();\n  }\n\n  private lowerSwitch(node: SemanticSwitchNode, acc: IRInstruction[]) {\n    const lblEnd = this.newLabel(\"switch_end\");\n    this.breakLabels.push(lblEnd);\n    const caseLabels = node.cases.map((_c, i) => this.newLabel(`case_${i}`));\n    const defaultLabel = node.default ? this.newLabel(\"default\") : lblEnd;\n    this.lowerExpression(node.condition as SemanticExpressionNode, acc);\n    for (let i = 0; i < node.cases.length; i++) {\n      this.lowerExpression(node.cases[i].value as SemanticExpressionNode, acc);\n      acc.push({ op: \"compare\", kind: \"eq\" });\n      acc.push({ op: \"jnz\", target: caseLabels[i] });\n    }\n    acc.push({ op: \"jmp\", target: defaultLabel });\n    for (let i = 0; i < node.cases.length; i++) {\n      acc.push({ op: \"label\", name: caseLabels[i] });\n      this.lowerStatements(node.cases[i].statements as SemanticStatementNode[], acc);\n      if (!node.cases[i].fallthrough) {\n        acc.push({ op: \"jmp\", target: lblEnd });\n      }\n    }\n    if (node.default) {\n      acc.push({ op: \"label\", name: defaultLabel });\n      this.lowerStatements(node.default.statements as SemanticStatementNode[], acc);\n      acc.push({ op: \"jmp\", target: lblEnd });\n    }\n    acc.push({ op: \"label\", name: lblEnd });\n    this.breakLabels.pop();\n  }\n\n  private lowerBreak(_node: SemanticBreakNode, acc: IRInstruction[]) {\n    const target = this.breakLabels[this.breakLabels.length - 1];\n    if (target) {\n      acc.push({ op: \"jmp\", target });\n    } else {\n      acc.push({ op: \"nop\" });\n    }\n  }\n\n  private lowerContinue(_node: SemanticContinueNode, acc: IRInstruction[]) {\n    const target = this.continueLabels[this.continueLabels.length - 1];\n    if (target) {\n      acc.push({ op: \"jmp\", target });\n    } else {\n      acc.push({ op: \"nop\" });\n    }\n  }\n\n  private lowerExpression(expr: SemanticExpressionNode, acc: IRInstruction[]) {\n    switch (expr.type) {\n      case \"literal\":\n        this.lowerLiteral(expr as SemanticLiteralNode, acc);\n        break;\n      case \"array_literal\":\n        this.lowerArrayLiteral(expr as SemanticArrayLiteralNode, acc);\n        break;\n      case \"variable_reference\":\n        this.lowerVarRef(expr as SemanticVariableReferenceNode, acc);\n        break;\n      case \"function_call\":\n        this.lowerFunctionCall(expr as SemanticFunctionCallNode, acc);\n        break;\n      case \"property\":\n        this.lowerProperty(expr as SemanticPropertyNode, acc);\n        break;\n      case \"index\":\n        this.lowerIndex(expr as SemanticIndexNode, acc);\n        break;\n      case \"assign\":\n        this.lowerAssign(expr as SemanticAssignNode, acc);\n        break;\n      case \"array_literal\":\n        this.lowerArrayLiteral(expr as SemanticArrayLiteralNode, acc);\n        break;\n      case \"add\":\n      case \"sub\":\n      case \"mul\":\n      case \"div\":\n      case \"mod\":\n        this.lowerBinary(expr as SemanticBinaryNode, acc);\n        break;\n      case \"compare\":\n        this.lowerCompare(expr as SemanticCompareNode, acc);\n        break;\n      case \"neg\":\n      case \"not\":\n        this.lowerUnary(expr as SemanticUnaryNode, acc);\n        break;\n      case \"inc\":\n      case \"dec\":\n        this.lowerIncDec(expr as SemanticIncDecNode, acc);\n        break;\n      default:\n        acc.push({ op: \"nop\" });\n        break;\n    }\n  }\n\n  // Minimal lowering for function calls: emit an action placeholder or jsr placeholder.\n  private lowerFunctionCall(call: SemanticFunctionCallNode, acc: IRInstruction[]) {\n    const reversedArgs = [...call.arguments].reverse();\n    const argSize = reversedArgs.reduce(\n      (sum, a) => sum + NWScriptIRBuilder.getStatementSize(a as SemanticExpressionNode),\n      0\n    );\n\n    const isEngine = call.function_reference && (call.function_reference as SemanticFunctionNode & { is_engine_action?: boolean }).is_engine_action;\n    const retSize = NWScriptIRBuilder.getTypeSize(call.function_reference?.returntype);\n\n    // For script calls with return, preallocate return slot (RSADD)\n    if (!isEngine && retSize > 0) {\n      const retDt = call.function_reference?.returntype;\n      if (retSize === 12) {\n        // vector: three float slots\n        for (let i = 0; i < 3; i++) {\n          acc.push({\n            op: \"rsadd\",\n            type: { kind: \"datatype\", value: \"float\", unary: 0x04 },\n          });\n        }\n      } else {\n        acc.push({\n          op: \"rsadd\",\n          type: {\n            kind: \"datatype\",\n            value: retDt?.value ?? \"int\",\n            unary: retDt?.unary ?? 0x03,\n          },\n        });\n      }\n    }\n\n    // Emit arguments (reverse order), with action-type trampoline handling\n    for (const arg of reversedArgs) {\n      const dt = (arg as SemanticExpressionNode & { datatype?: SemanticDataType }).datatype;\n      if (dt && dt.value === \"action\") {\n        const afterLabel = this.newLabel(\"action_after\");\n        acc.push({ op: \"store_state\", bStackSize: 0, stackSize: 0 }); // computed at emit\n        acc.push({ op: \"jmp\", target: afterLabel });\n        this.lowerExpression(arg as SemanticExpressionNode, acc);\n        acc.push({ op: \"return\" }); // end of trampoline\n        acc.push({ op: \"label\", name: afterLabel });\n      } else {\n        this.lowerExpression(arg as SemanticExpressionNode, acc);\n      }\n    }\n\n    if (isEngine) {\n      acc.push({\n        op: \"action\",\n        id: call.action_id ?? 0,\n        argc: reversedArgs.length,\n        returnSize: retSize,\n        argSize,\n      });\n      // ACTION pops args internally; SP change accounted via returnSize/argSize in encoder\n    } else {\n      const targetLabel = `fn_${call.name}`;\n      acc.push({ op: \"jsr\", target: targetLabel });\n      // Script calls: pop args only; return stays in preallocated slot\n      if (argSize > 0) {\n        acc.push({ op: \"movsp\", delta: -argSize });\n      }\n    }\n  }\n\n  // Size helpers -----------------------------------------------------\n  private static getTypeSize(dt: SemanticDataType | undefined): number {\n    if (!dt) return 0;\n    // In NWScript, most types are 4-byte stack slots (int, float, string ref, object ref).\n    // Vectors are 12 bytes; structs unknown -> sum of fields handled elsewhere.\n    const val = dt.value ?? dt;\n    if (val === \"vector\") return 12;\n    return 4;\n  }\n\n  private static getStatementSize(expr: SemanticExpressionNode): number {\n    switch (expr.type) {\n      case \"literal\":\n        return NWScriptIRBuilder.getTypeSize((expr as SemanticLiteralNode).datatype);\n      case \"array_literal\": {\n        const arr = expr as SemanticArrayLiteralNode;\n        return arr.elements.reduce(\n          (sum, el) => sum + NWScriptIRBuilder.getStatementSize(el as SemanticExpressionNode),\n          0\n        );\n      }\n      case \"variable_reference\":\n        return NWScriptIRBuilder.getTypeSize((expr as SemanticVariableReferenceNode).datatype);\n      case \"property\":\n        return NWScriptIRBuilder.getTypeSize((expr as SemanticPropertyNode).datatype);\n      case \"index\":\n        return NWScriptIRBuilder.getTypeSize((expr as SemanticExpressionNode & { datatype?: SemanticDataType }).datatype);\n      case \"assign\":\n        return NWScriptIRBuilder.getStatementSize(\n          (expr as SemanticAssignNode).right as SemanticExpressionNode\n        );\n      case \"function_call\":\n        return NWScriptIRBuilder.getTypeSize(\n          (expr as SemanticFunctionCallNode).function_reference?.returntype\n        );\n      default:\n        return 4;\n    }\n  }\n\n  // ---------------- Layout & Emit ----------------\n\n  /**\n   * Build IR, layout labels/stack, and emit concrete opcode buffers.\n   */\n  static layoutAndEmit(program: SemanticProgramNode): IREmittedProgram {\n    const ir = this.build(program);\n    const structLayouts = this.computeStructLayouts(program);\n    const globals = this.computeGlobals(program, structLayouts);\n    const fnMap = new Map<string, SemanticFunctionNode>();\n    if (program.main) fnMap.set(program.main.name, program.main);\n    if (program.startingConditional) fnMap.set(program.startingConditional.name, program.startingConditional);\n    for (const f of program.functions || []) {\n      fnMap.set(f.name, f);\n    }\n\n    const emitted: IREmittedFunction[] = [];\n    for (const irFn of ir.functions) {\n      const semanticFn = fnMap.get(irFn.name);\n      const stack = this.buildStackFrame(semanticFn, structLayouts);\n      const layout = this.layoutFunction(irFn, stack, structLayouts, globals);\n      const code = this.emitFunction(irFn, layout, structLayouts, stack, globals);\n      emitted.push({ name: irFn.name, code, layout });\n    }\n\n    // Build global init stub: reserve globals, run initializers via expression lowering, anchor BP at globals,\n    // JSR into main/start, restore BP, pop globals, RETN.\n    const globalStub: Uint8Array[] = [];\n    const globalsList = (program.scope?.variables || []).filter((v: SemanticVariableNode) => v.is_global);\n    // Reserve each global slot\n    for (const g of globalsList) {\n      const gSize = NWScriptIRBuilder.getTypeSize(g.datatype);\n      const rs = allocBuffer(2);\n      rs.writeInt8(OP_RSADD, 0);\n      rs.writeInt8(g.datatype.unary ?? 0x03, 1);\n      globalStub.push(rs);\n      // Handle vector (12 bytes) by extra RSADDs if needed\n      if (gSize === 12) {\n        for (let i = 0; i < 2; i++) {\n          const rsv = allocBuffer(2);\n          rsv.writeInt8(OP_RSADD, 0);\n          rsv.writeInt8(0x04, 1);\n          globalStub.push(rsv);\n        }\n      }\n    }\n    // Lower initializers to SP-relative copies\n    {\n      let stubSp = globalsList.reduce((s, g) => s + NWScriptIRBuilder.getTypeSize(g.datatype), 0);\n      const structLayoutsInit = this.computeStructLayouts(program);\n      for (const g of globalsList) {\n        const initInstrs: IRInstruction[] = [];\n        if (g.value) {\n          const builder = new NWScriptIRBuilder();\n          builder.lowerExpression(g.value as SemanticExpressionNode, initInstrs);\n        } else {\n          initInstrs.push({\n            op: \"loadconst\",\n            type: { kind: \"datatype\", value: g.datatype.value, unary: g.datatype.unary ?? 0x03 },\n            value: 0,\n          });\n        }\n        let pcInit = 0;\n        for (const ii of initInstrs) {\n          if (ii.op === \"label\") continue;\n          const enc = this.encodeInstruction(\n            ii,\n            {},\n            pcInit,\n            stubSp,\n            0,\n            stubSp,\n            { args: {}, locals: {}, frameSize: 0, localsSize: 0, argsSize: 0 },\n            structLayoutsInit,\n            globals,\n            0\n          );\n          globalStub.push(enc.buffer);\n          stubSp = enc.nextSp;\n          pcInit += enc.buffer.length;\n        }\n        const gSize = NWScriptIRBuilder.getTypeSize(g.datatype);\n        const cp = allocBuffer(8);\n        cp.writeInt8(OP_CPDOWNSP, 0);\n        cp.writeInt8(0x01, 1);\n        cp.writeInt32BE(-stubSp, 2);\n        cp.writeInt16BE(gSize, 6);\n        globalStub.push(cp);\n        const pop = allocBuffer(6);\n        pop.writeInt8(OP_MOVSP, 0);\n        pop.writeInt8(0x00, 1);\n        pop.writeInt32BE(-gSize, 2);\n        globalStub.push(pop);\n        // Net: stubSp unchanged (reserved slot holds value)\n      }\n    }\n    // Anchor BP at globals top\n    const save = allocBuffer(2);\n    save.writeInt8(OP_SAVEBP, 0);\n    save.writeInt8(0x00, 1);\n    globalStub.push(save);\n    // Placeholder JSR; fill displacement later\n    const jsr = allocBuffer(6);\n    jsr.writeInt8(OP_JSR, 0);\n    jsr.writeInt8(0x00, 1);\n    globalStub.push(jsr);\n    // Restore BP\n    const restore = allocBuffer(2);\n    restore.writeInt8(OP_RESTOREBP, 0);\n    restore.writeInt8(0x00, 1);\n    globalStub.push(restore);\n    // Pop globals\n    if (globalsList.length > 0) {\n      const mov = allocBuffer(6);\n      mov.writeInt8(OP_MOVSP, 0);\n      mov.writeInt8(0x00, 1);\n      const globalsSize = globalsList.reduce((s: number, g: SemanticVariableNode) => s + NWScriptIRBuilder.getTypeSize(g.datatype), 0);\n      mov.writeInt32BE(-globalsSize, 2);\n      globalStub.push(mov);\n    }\n    const r = allocBuffer(2);\n    r.writeInt8(OP_RETN, 0);\n    r.writeInt8(0x00, 1);\n    globalStub.push(r);\n\n    // Fix JSR displacement to jump to the first function block (immediately after stub)\n    const stubLen = globalStub.reduce((n, b) => n + b.length, 0);\n    const jsrPos = globalStub\n      .map((b, i) => ({ b, i }))\n      .find((x) => x.b === jsr)?.i ?? -1;\n    if (jsrPos >= 0) {\n      const offsetBeforeJsr = globalStub.slice(0, jsrPos).reduce((n, b) => n + b.length, 0);\n      const disp = stubLen - (offsetBeforeJsr + jsr.length);\n      jsr.writeInt32BE(disp, 2);\n    }\n\n    const total = concatBuffers([concatBuffers(globalStub), ...emitted.map((e) => e.code)]);\n    return { functions: emitted, total };\n  }\n\n  private static computeStructLayouts(program: SemanticProgramNode): Record<string, IRStructLayout> {\n    const layouts: Record<string, IRStructLayout> = {};\n    for (const s of program.structs || []) {\n      let offset = 0;\n      const fields: Record<string, { offset: number; size: number }> = {};\n      for (const prop of s.properties) {\n        const size = NWScriptIRBuilder.getTypeSize(prop.datatype);\n        fields[prop.name] = { offset, size };\n        offset += size;\n      }\n      layouts[s.name] = { name: s.name, size: offset, fields };\n    }\n    return layouts;\n  }\n\n  private static collectLocals(stmts: SemanticStatementNode[], bucket: SemanticVariableNode[]) {\n    for (const stmt of stmts) {\n      if (!stmt) continue;\n      switch (stmt.type) {\n        case \"variable\":\n          bucket.push(stmt as SemanticVariableNode);\n          break;\n        case \"variableList\": {\n          const vars = (stmt as SemanticVariableListNode).variables || [];\n          bucket.push(...vars);\n          break;\n        }\n        case \"block\":\n          this.collectLocals((stmt as SemanticBlockNode).statements as SemanticStatementNode[], bucket);\n          break;\n        case \"if\":\n          this.collectLocals((stmt as SemanticIfNode).statements as SemanticStatementNode[], bucket);\n          for (const ei of (stmt as SemanticIfNode).elseIfs || []) {\n            this.collectLocals(ei.statements as SemanticStatementNode[], bucket);\n          }\n          if ((stmt as SemanticIfNode).else) {\n            this.collectLocals(((stmt as SemanticIfNode).else as SemanticElseNode).statements as SemanticStatementNode[], bucket);\n          }\n          break;\n        case \"while\":\n        case \"do\":\n        case \"for\":\n        case \"switch\":\n          // Traverse nested statements for locals\n          this.collectLocals((stmt as SemanticBlockNode).statements, bucket);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private static buildStackFrame(\n    fn: SemanticFunctionNode | undefined,\n    structLayouts: Record<string, IRStructLayout>\n  ): IRStackFrame {\n    const args: Record<string, IRStackSlot> = {};\n    const locals: Record<string, IRStackSlot> = {};\n    let argsSize = 0;\n    if (fn?.arguments) {\n      for (const arg of fn.arguments) {\n        const size = NWScriptIRBuilder.getTypeSize(arg.datatype);\n        args[arg.name] = { offset: 0, size }; // temp, corrected below\n        argsSize += size;\n      }\n    }\n\n    let localsSize = 0;\n    const localVars: SemanticVariableNode[] = [];\n    if (fn?.statements) {\n      this.collectLocals(fn.statements as SemanticStatementNode[], localVars);\n    }\n    for (const v of localVars) {\n      const size =\n        v.datatype?.struct && structLayouts[v.datatype.struct]\n          ? structLayouts[v.datatype.struct].size\n          : NWScriptIRBuilder.getTypeSize(v.datatype);\n      localsSize += size;\n    }\n\n    // Assign locals offsets relative to top after locals are reserved: negative distance\n    let localCursor = -localsSize;\n    for (const v of localVars) {\n      const size =\n        v.datatype?.struct && structLayouts[v.datatype.struct]\n          ? structLayouts[v.datatype.struct].size\n          : NWScriptIRBuilder.getTypeSize(v.datatype);\n      locals[v.name] = { offset: localCursor, size };\n      localCursor += size;\n    }\n\n    // Args sit beneath locals; offset is negative distance from top after locals reserve.\n    let argCursor = -localsSize;\n    for (const arg of fn?.arguments || []) {\n      const slot = args[arg.name];\n      if (!slot) continue;\n      slot.offset = argCursor - slot.size;\n      argCursor -= slot.size;\n    }\n\n    return { args, locals, frameSize: argsSize + localsSize, localsSize, argsSize };\n  }\n\n  private static computeGlobals(\n    program: SemanticProgramNode,\n    structLayouts: Record<string, IRStructLayout>\n  ): Record<string, IRStackSlot> {\n    const globals: Record<string, IRStackSlot> = {};\n    let offset = 0;\n    const addGlobal = (name: string, dt: SemanticDataType) => {\n      const size =\n        dt?.struct && structLayouts[dt.struct] ? structLayouts[dt.struct].size : NWScriptIRBuilder.getTypeSize(dt);\n      offset -= size;\n      globals[name] = { offset, size };\n    };\n    for (const v of program.scope?.variables || []) {\n      if (v.is_global) addGlobal(v.name, v.datatype);\n    }\n    for (const c of program.scope?.constants || []) {\n      if ((c as SemanticVariableNode).is_global) addGlobal(c.name, (c as SemanticVariableNode).datatype);\n    }\n    return globals;\n  }\n\n  private static layoutFunction(\n    fn: IRFunction,\n    stack: IRStackFrame,\n    structLayouts: Record<string, IRStructLayout>,\n    globals: Record<string, IRStackSlot>\n  ): IRLayoutResult {\n    const labels: IRLabelMap = {};\n    let pc = 0;\n    for (const instr of fn.instructions) {\n      if (instr.op === \"label\") {\n        labels[instr.name] = pc;\n        continue;\n      }\n      pc += this.estimateInstructionSize(instr, structLayouts);\n    }\n    return { labels, stack, globals, size: pc };\n  }\n\n  private static estimateInstructionSize(instr: IRInstruction, _structs: Record<string, IRStructLayout>): number {\n    switch (instr.op) {\n      case \"label\":\n        return 0;\n      case \"rsadd\":\n        return 2;\n      case \"movsp\":\n        return 6;\n      case \"nop\":\n        return 1;\n      case \"loadconst\":\n        if (instr.type.value === \"string\" && typeof instr.value === \"string\") {\n          return instr.value.length + 4; // matches CONST string len (base 6 + len -2)\n        }\n        if (instr.type.unary === 0x07 || instr.type.value === \"vector\") {\n          return 6 * 3;\n        }\n        return 6;\n      case \"store_state\":\n        return 6;\n      case \"loadvar\":\n      case \"storevar\":\n      case \"loadfield\":\n      case \"storefield\":\n      case \"loadindex\":\n      case \"storeindex\":\n      case \"cpdownsp\":\n        return 8;\n      case \"binop\":\n      case \"compare\":\n      case \"logic\":\n      case \"unary\":\n      case \"inc\":\n      case \"dec\":\n        return 2;\n      case \"jsr\":\n      case \"jmp\":\n      case \"jz\":\n      case \"jnz\":\n        return 6;\n      case \"action\":\n        return 5;\n      case \"return\":\n        return 2;\n      default:\n        return 2;\n    }\n  }\n\n  private static emitFunction(\n    fn: IRFunction,\n    layout: IRLayoutResult,\n    structLayouts: Record<string, IRStructLayout>,\n    stack: IRStackFrame,\n    globals: Record<string, IRStackSlot>\n  ): Uint8Array {\n    const buffers: Uint8Array[] = [];\n    let pc = 0;\n    let sp = 0;\n    let bp = 0;\n    // Prologue: reserve locals\n    if (stack.localsSize > 0) {\n      const buf = allocBuffer(6);\n      buf.writeInt8(OP_MOVSP, 0);\n      buf.writeInt8(0x00, 1);\n      buf.writeInt32BE(stack.localsSize, 2);\n      buffers.push(buf);\n      sp += stack.localsSize;\n      pc += buf.length;\n    }\n    const entrySp = sp;\n    for (const instr of fn.instructions) {\n      if (instr.op === \"label\") {\n        continue;\n      }\n      const buf = this.encodeInstruction(\n        instr,\n        layout.labels,\n        pc,\n        sp,\n        bp,\n        entrySp,\n        stack,\n        structLayouts,\n        globals,\n        fn.returnSize\n      );\n      sp = buf.nextSp;\n      bp = buf.nextBp;\n      buffers.push(buf.buffer);\n      pc += buf.buffer.length;\n    }\n    return concatBuffers(buffers);\n  }\n\n  private static resolveVarOffset(\n    name: string,\n    stack: IRStackFrame,\n    globals: Record<string, IRStackSlot>\n  ): { slot: IRStackSlot | undefined; isGlobal: boolean } {\n    if (stack.locals[name]) return { slot: stack.locals[name], isGlobal: false };\n    if (stack.args[name]) return { slot: stack.args[name], isGlobal: false };\n    if (globals[name]) return { slot: globals[name], isGlobal: true };\n    return { slot: undefined, isGlobal: false };\n  }\n\n  private static encodeInstruction(\n    instr: IRInstruction,\n    labels: IRLabelMap,\n    pc: number,\n    sp: number,\n    bp: number,\n    entrySp: number,\n    stack: IRStackFrame,\n    structLayouts: Record<string, IRStructLayout>,\n    globals: Record<string, IRStackSlot>,\n    currentFnReturnSize: number\n  ): { buffer: Uint8Array; nextSp: number; nextBp: number } {\n    let nextSp = sp;\n    let nextBp = bp;\n    switch (instr.op) {\n      case \"rsadd\": {\n        const buf = allocBuffer(2);\n        buf.writeInt8(OP_RSADD, 0);\n        buf.writeInt8(instr.type.unary, 1);\n        nextSp += 4;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"movsp\": {\n        const buf = allocBuffer(6);\n        buf.writeInt8(OP_MOVSP, 0);\n        buf.writeInt8(0x00, 1);\n        buf.writeInt32BE(instr.delta, 2);\n        nextSp += instr.delta;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"loadconst\": {\n        if (instr.type.unary === 0x07 || instr.type.value === \"vector\") {\n          // Encode as three floats if possible\n          const vals = Array.isArray(instr.value) ? instr.value : [0, 0, 0];\n          const buffers: Uint8Array[] = [];\n          for (let i = 0; i < 3; i++) {\n            const b = allocBuffer(6);\n            b.writeInt8(OP_CONST, 0);\n            b.writeInt8(0x04, 1); // float\n            b.writeFloatBE(typeof vals[i] === \"number\" ? vals[i] : 0, 2);\n            buffers.push(b);\n            nextSp += 4;\n          }\n          return { buffer: concatBuffers(buffers), nextSp, nextBp };\n        }\n        const buf = allocBuffer(\n          instr.type.value === \"string\" && typeof instr.value === \"string\"\n            ? instr.value.length + 4\n            : 6\n        );\n        buf.writeInt8(OP_CONST, 0);\n        buf.writeInt8(instr.type.unary, 1);\n        if (instr.type.value === \"string\" && typeof instr.value === \"string\") {\n          buf.writeInt16BE(instr.value.length, 2);\n          for (let i = 0; i < instr.value.length; i++) {\n            buf.writeInt8(instr.value.charCodeAt(i), 4 + i);\n          }\n        } else if (instr.type.value === \"float\") {\n          buf.writeFloatBE(Number(instr.value ?? 0), 2);\n        } else {\n          buf.writeInt32BE(Number(instr.value ?? 0), 2);\n        }\n        nextSp += NWScriptIRBuilder.getTypeSize(instr.type);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"loadvar\": {\n        const { slot, isGlobal } = this.resolveVarOffset(instr.varName, stack, globals);\n        const size = instr.size ?? slot?.size ?? 4;\n        const buf = allocBuffer(8);\n        if (isGlobal) {\n          buf.writeInt8(OP_CPTOPBP, 0);\n          buf.writeInt8(0x01, 1);\n          const offset = slot?.offset ?? 0;\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(size, 6);\n        } else {\n          buf.writeInt8(OP_CPTOPSP, 0);\n          buf.writeInt8(0x01, 1);\n          const offset = (slot?.offset ?? 0) - (sp - entrySp);\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(size, 6);\n        }\n        nextSp += size;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"storevar\": {\n        const { slot, isGlobal } = this.resolveVarOffset(instr.varName, stack, globals);\n        const size = instr.size ?? slot?.size ?? 4;\n        const buf = allocBuffer(8);\n        if (isGlobal) {\n          buf.writeInt8(OP_CPDOWNBP, 0);\n          buf.writeInt8(0x01, 1);\n          const offset = slot?.offset ?? 0;\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(size, 6);\n        } else {\n          buf.writeInt8(OP_CPDOWNSP, 0);\n          buf.writeInt8(0x01, 1);\n          const offset = (slot?.offset ?? 0) - (sp - entrySp) + size;\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(size, 6);\n        }\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"binop\": {\n        const buf = allocBuffer(2);\n        let opcode = OP_ADD;\n        switch (instr.kind) {\n          case \"sub\":\n            opcode = OP_SUB;\n            break;\n          case \"mul\":\n            opcode = OP_MUL;\n            break;\n          case \"div\":\n            opcode = OP_DIV;\n            break;\n          case \"mod\":\n            opcode = OP_MODII;\n            break;\n          default:\n            opcode = OP_ADD;\n            break;\n        }\n        buf.writeInt8(opcode, 0);\n        buf.writeInt8(instr.typeCode ?? 0x20, 1);\n        nextSp += -4 - 4 + 4;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"compare\": {\n        const isTT = instr.typeCode === 0x24;\n        const buf = allocBuffer(isTT ? 4 : 2);\n        let opcode = OP_EQUAL;\n        switch (instr.kind) {\n          case \"ne\":\n            opcode = OP_NEQUAL;\n            break;\n          case \"gt\":\n            opcode = OP_GT;\n            break;\n          case \"lt\":\n            opcode = OP_LT;\n            break;\n          case \"ge\":\n            opcode = OP_GEQ;\n            break;\n          case \"le\":\n            opcode = OP_LEQ;\n            break;\n          default:\n            opcode = OP_EQUAL;\n            break;\n        }\n        buf.writeInt8(opcode, 0);\n        buf.writeInt8(instr.typeCode ?? 0x20, 1);\n        if (isTT && instr.size) {\n          buf.writeInt16BE(instr.size, 2);\n        }\n        nextSp += -4 - 4 + 4;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"logic\": {\n        const buf = allocBuffer(2);\n        const opcode = instr.kind === \"and\" ? OP_LOGANDII : OP_LOGORII;\n        buf.writeInt8(opcode, 0);\n        buf.writeInt8(instr.typeCode ?? 0x20, 1);\n        nextSp += -4 - 4 + 4;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"unary\": {\n        const buf = allocBuffer(2);\n        const opcode = instr.kind === \"not\" ? OP_NOTI : OP_NEG;\n        buf.writeInt8(opcode, 0);\n        buf.writeInt8(instr.typeCode ?? 0x20, 1);\n        // operand consumed, result pushes 4\n        nextSp += -4 + 4;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"inc\":\n      case \"dec\": {\n        const buf = allocBuffer(2);\n        const opcode = instr.op === \"inc\" ? OP_INCISP : OP_DECISP;\n        buf.writeInt8(opcode, 0);\n        buf.writeInt8(0x03, 1);\n        // inc/dec leaves stack unchanged\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"loadfield\": {\n        const layout =\n          (instr.parent && structLayouts[instr.parent]) ||\n          (instr.type.value && structLayouts[instr.type.value]) ||\n          undefined;\n        const fieldInfo = layout?.fields[instr.field];\n        const fieldOffset = fieldInfo?.offset ?? 0;\n        const fieldSize = fieldInfo?.size ?? NWScriptIRBuilder.getTypeSize(instr.type);\n        const structSize = layout?.size ?? fieldSize;\n        const buf = allocBuffer(8);\n        buf.writeInt8(OP_CPTOPSP, 0);\n        buf.writeInt8(0x01, 1);\n        // struct is below the top; offset from top into the struct payload\n        buf.writeInt32BE(-structSize + fieldOffset, 2);\n        buf.writeInt16BE(fieldSize, 6);\n        nextSp += fieldSize;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"storefield\": {\n        const layout =\n          (instr.parent && structLayouts[instr.parent]) ||\n          (instr.type.value && structLayouts[instr.type.value]) ||\n          undefined;\n        const fieldInfo = layout?.fields[instr.field];\n        const fieldSize = fieldInfo?.size ?? NWScriptIRBuilder.getTypeSize(instr.type);\n        const structSize = layout?.size ?? fieldSize;\n        const fieldOffset = fieldInfo?.offset ?? 0;\n        // value is on top, struct is beneath value\n        const buf = allocBuffer(8);\n        buf.writeInt8(OP_CPDOWNSP, 0);\n        buf.writeInt8(0x01, 1);\n        buf.writeInt32BE(-(structSize + fieldSize) + fieldOffset, 2);\n        buf.writeInt16BE(fieldSize, 6);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"loadindex\":\n      case \"storeindex\": {\n        const vecSize = instr.type.unary === 0x07 || instr.type.value === \"vector\" ? 12 : 4;\n        const eltSize = instr.type.unary === 0x07 || instr.type.value === \"vector\" ? 4 : instr.type.unary === 0x04 ? 4 : 4;\n        const idx = instr.indexLiteral ?? 0;\n        if (instr.op === \"loadindex\") {\n          const buf = allocBuffer(8);\n          buf.writeInt8(OP_CPTOPSP, 0);\n          buf.writeInt8(0x01, 1);\n          // stack: [ ... baseVec ][ index ]\n          const offset = -(vecSize + 4) + idx * eltSize;\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(eltSize, 6);\n          nextSp += eltSize;\n          return { buffer: buf, nextSp, nextBp };\n        } else {\n          const buf = allocBuffer(8);\n          buf.writeInt8(OP_CPDOWNSP, 0);\n          buf.writeInt8(0x01, 1);\n          // stack: [ ... baseVec ][ index ][ value ]\n          const offset = -(vecSize + 4 + eltSize) + idx * eltSize;\n          buf.writeInt32BE(offset, 2);\n          buf.writeInt16BE(eltSize, 6);\n          return { buffer: buf, nextSp, nextBp };\n        }\n      }\n      case \"cpdownsp\": {\n        const buf = allocBuffer(8);\n        buf.writeInt8(OP_CPDOWNSP, 0);\n        buf.writeInt8(0x01, 1);\n        buf.writeInt32BE(instr.offset, 2);\n        buf.writeInt16BE(instr.size, 6);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"jsr\": {\n        const buf = allocBuffer(6);\n        buf.writeInt8(OP_JSR, 0);\n        const target = labels[instr.target] ?? 0;\n        const disp = target - (pc + buf.length);\n        buf.writeInt32BE(disp, 2);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"jmp\":\n      case \"jz\":\n      case \"jnz\": {\n        const buf = allocBuffer(6);\n        const opcode = instr.op === \"jmp\" ? OP_JMP : instr.op === \"jz\" ? OP_JZ : OP_JNZ;\n        buf.writeInt8(opcode, 0);\n        const target = labels[instr.target] ?? 0;\n        const disp = target - (pc + buf.length);\n        buf.writeInt32BE(disp, 2);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"action\": {\n        const buf = allocBuffer(5);\n        buf.writeInt8(OP_ACTION, 0);\n        buf.writeInt8(0x00, 1);\n        buf.writeUInt16BE(instr.id, 2);\n        buf.writeInt8(instr.argc, 4);\n        nextSp += instr.returnSize - instr.argSize;\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"store_state\": {\n        // Size globals: globals offsets are negative; capture total span\n        const minGlobal = Math.min(0, ...Object.values(globals || {}).map((g) => g.offset));\n        const storeInstr = instr as Extract<IRInstruction, { op: \"store_state\" }>;\n        const bStackSize = storeInstr.bStackSize ?? -minGlobal;\n        const stackSize = storeInstr.stackSize ?? (sp - entrySp);\n        const buf = allocBuffer(6);\n        buf.writeInt8(OP_STORE_STATE, 0);\n        buf.writeInt8(0x00, 1);\n        buf.writeInt16BE(bStackSize, 2);\n        buf.writeInt16BE(stackSize, 4);\n        return { buffer: buf, nextSp, nextBp };\n      }\n      case \"return\": {\n        const bufs: Uint8Array[] = [];\n        // Restore BP\n        {\n          const b = allocBuffer(2);\n          b.writeInt8(OP_RESTOREBP, 0);\n          b.writeInt8(0x00, 1);\n          bufs.push(b);\n        }\n        if (stack.localsSize > 0) {\n          const m = allocBuffer(6);\n          m.writeInt8(OP_MOVSP, 0);\n          m.writeInt8(0x00, 1);\n          m.writeInt32BE(-stack.localsSize, 2);\n          bufs.push(m);\n        }\n        const r = allocBuffer(2);\n        r.writeInt8(OP_RETN, 0);\n        r.writeInt8(0x00, 1);\n        bufs.push(r);\n        nextSp = 0;\n        nextBp = 0;\n        return { buffer: concatBuffers(bufs), nextSp, nextBp };\n      }\n      case \"nop\":\n      default: {\n        const buf = allocBuffer(1);\n        buf.writeInt8(OP_NOP, 0);\n        return { buffer: buf, nextSp, nextBp };\n      }\n    }\n  }\n\n  private static getTypeCodeFromNode(dt: SemanticDataType | undefined, fallback: number): number {\n    if (!dt || typeof dt !== \"object\") return fallback;\n    const val = dt.value ?? dt;\n    switch (val) {\n      case \"int\":\n        return 0x20; // II\n      case \"float\":\n        return 0x21; // FF\n      case \"object\":\n        return 0x22; // OO\n      case \"string\":\n        return 0x23; // SS\n      case \"vector\":\n        return 0x3A; // VV\n      default:\n        // engine/struct types default to int-size compare/add variants\n        return fallback;\n    }\n  }\n\n  private static getBinaryOpTypeCode(op: string, left: SemanticDataType | { value?: string; unary?: number } | undefined, right: SemanticDataType | { value?: string; unary?: number } | undefined): number {\n    const l = left?.value ?? left;\n    const r = right?.value ?? right;\n    // Mixed numeric cases\n    if (op === \"mul\" || op === \"div\") {\n      if (l === \"vector\" && r === \"float\") return 0x3B; // VF\n      if (l === \"float\" && r === \"vector\") return 0x3C; // FV\n    }\n    if (l === \"vector\" && r === \"vector\") return 0x3A; // VV\n    if (l === \"int\" && r === \"float\") return 0x25; // IF\n    if (l === \"float\" && r === \"int\") return 0x26; // FI\n    if (l === \"float\" && r === \"float\") return 0x21; // FF\n    if (l === \"string\" && r === \"string\") return 0x23; // SS\n    if (l === \"object\" && r === \"object\") return 0x22; // OO\n    if (typeof left?.unary === \"number\" && left.unary >= 0x30 && left.unary <= 0x39) return left.unary; // engine\n    if (typeof right?.unary === \"number\" && right.unary >= 0x30 && right.unary <= 0x39) return right.unary;\n    return 0x20; // default int/int\n  }\n\n  private static getCompareTypeInfo(left: SemanticDataType | { value?: string; unary?: number; size?: number } | undefined, right: SemanticDataType | { value?: string; unary?: number } | undefined, dt: SemanticDataType | { value?: string; unary?: number; size?: number } | undefined): { typeCode: number; size?: number } {\n    const l = left?.value ?? left;\n    const r = right?.value ?? right;\n    const base = dt?.value ?? dt;\n    // Engine type support\n    if (typeof dt?.unary === \"number\" && dt.unary >= 0x30 && dt.unary <= 0x39) return { typeCode: dt.unary };\n    if (typeof left?.unary === \"number\" && left.unary >= 0x30 && left.unary <= 0x39)\n      return { typeCode: left.unary };\n    if (typeof right?.unary === \"number\" && right.unary >= 0x30 && right.unary <= 0x39)\n      return { typeCode: right.unary };\n\n    // Struct/vector => TT with size\n    if (l === \"vector\" || r === \"vector\" || base === \"vector\") return { typeCode: 0x24, size: 12 };\n    if (base === \"struct\") return { typeCode: 0x24, size: dt?.size ?? 0 };\n\n    // Standard types\n    if (l === \"float\" || r === \"float\" || base === \"float\") return { typeCode: 0x21 };\n    if (l === \"object\" || r === \"object\" || base === \"object\") return { typeCode: 0x22 };\n    if (l === \"string\" || r === \"string\" || base === \"string\") return { typeCode: 0x23 };\n\n    return { typeCode: 0x20 };\n  }\n\n  private static getUnaryTypeCode(op: string, dt: SemanticDataType | { value?: string; unary?: number } | undefined): number {\n    const val = dt?.value ?? dt;\n    if (op === \"not\") return 0x03; // NOTI uses int\n    if (val === \"float\") return 0x04; // NEGF\n    return 0x03; // default int\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptControlFlowGraph.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":903,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":903,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":927,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":927,"endColumn":44},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1090,"column":46,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1090,"endColumn":62},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1094,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1094,"endColumn":41},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1362,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1362,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1390,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1390,"endColumn":56},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1467,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1467,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1631,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1631,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1668,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1668,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1749,"column":39,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1749,"endColumn":58},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1749,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1749,"endColumn":83},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1751,"column":39,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1751,"endColumn":58},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1751,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1751,"endColumn":81},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1759,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1759,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":1948,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1948,"endColumn":34},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2215,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2215,"endColumn":49,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[77979,77980],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2278,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2278,"endColumn":44},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2284,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2284,"endColumn":48,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[80222,80223],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2476,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2476,"endColumn":32,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[85963,85964],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2534,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2534,"endColumn":26,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[87578,87579],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":2645,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":2645,"endColumn":37}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\r\nimport { NWScriptEdge, EdgeType } from \"@/nwscript/decompiler/NWScriptEdge\";\r\nimport type { NWScriptExpression } from \"@/nwscript/decompiler/NWScriptExpression\";\r\nimport type { NWScript } from \"@/nwscript/NWScript\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\r\nimport {\r\n  OP_JMP, OP_JSR, OP_JZ, OP_JNZ, OP_RETN, OP_STORE_STATE, OP_STORE_STATEALL\r\n} from \"@/nwscript/NWScriptOPCodes\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\n\r\n/** Serialized form of an NWScript instruction (for JSON export). */\r\nexport interface ISerializedNWScriptInstruction {\r\n  address: number;\r\n  code: number;\r\n  codeName: string;\r\n  codeHex: string;\r\n  type: number;\r\n  typeHex: string;\r\n  instructionSize?: number;\r\n  index?: number;\r\n  isArg?: boolean;\r\n  breakPoint?: boolean;\r\n  offset?: number;\r\n  bpOffset?: number;\r\n  spOffset?: number;\r\n  size?: number;\r\n  sizeToDestroy?: number;\r\n  offsetToSaveElement?: number;\r\n  sizeOfElementToSave?: number;\r\n  sizeOfStructure?: number;\r\n  action?: number;\r\n  argCount?: number;\r\n  integer?: number;\r\n  float?: number;\r\n  string?: string;\r\n  object?: number;\r\n  actionDefinition?: { name: string; comment?: string; type: number; args?: number[] };\r\n  nextInstructionAddress?: number;\r\n  prevInstructionAddress?: number;\r\n}\r\n\r\n/** Serializable condition expression (primitives or nested object for JSON). */\r\nexport type SerializedConditionExpression =\r\n  | { _error: string; _type: string }\r\n  | { _type?: string; _constructor?: string; [key: string]: string | number | boolean | null | SerializedConditionExpression | undefined };\r\n\r\n/** JSON-serializable value for CFG export. */\r\nexport type NWScriptCFGJsonValue =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | NWScriptCFGJsonValue[]\r\n  | { [key: string]: NWScriptCFGJsonValue };\r\n\r\n/** Top-level shape of CFG JSON export (structure is large; key names documented in toJSON()). */\r\nexport interface INWScriptCFGJSON {\r\n  [key: string]: NWScriptCFGJsonValue;\r\n}\r\n\r\n/**\r\n * Control Flow Graph for NCS-to-NSS conversion.\r\n * Represents the control flow structure of a compiled NCS script.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptControlFlowGraph.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptControlFlowGraph {\r\n  /**\r\n   * The script this CFG represents\r\n   */\r\n  script: NWScript;\r\n\r\n  /**\r\n   * All basic blocks in the graph\r\n   */\r\n  blocks: Map<number, NWScriptBasicBlock> = new Map();\r\n\r\n  /**\r\n   * Map from instruction address to basic block\r\n   */\r\n  instructionToBlock: Map<number, NWScriptBasicBlock> = new Map();\r\n\r\n  /**\r\n   * The entry block (first instruction)\r\n   */\r\n  entryBlock: NWScriptBasicBlock | null = null;\r\n\r\n  /**\r\n   * All exit blocks (blocks ending with RETN or EOF)\r\n   */\r\n  exitBlocks: Set<NWScriptBasicBlock> = new Set();\r\n\r\n  /**\r\n   * Blocks that are targets of jumps (used for identifying loop headers)\r\n   */\r\n  jumpTargets: Set<number> = new Set();\r\n\r\n  /**\r\n   * Leader addresses (instruction addresses that start basic blocks)\r\n   * Leaders include: entry, branch/call targets, callback entries, fallthrough after terminators, continuation after JSR\r\n   */\r\n  leaders: Set<number> = new Set();\r\n\r\n  /**\r\n   * Subroutine entry points (JSR targets)\r\n   */\r\n  subroutineEntries: Map<number, NWScriptBasicBlock> = new Map();\r\n\r\n  /**\r\n   * Subroutine return points (after JSR instructions)\r\n   */\r\n  subroutineReturns: Map<number, NWScriptBasicBlock | null> = new Map();\r\n\r\n  /**\r\n   * JMP targets that are part of STORE_STATE patterns (not function entries)\r\n   * These are addresses where STORE_STATE+JMP jumps to (where outer ACTION calls happen)\r\n   */\r\n  storeStateJmpTargets: Set<number> = new Set();\r\n\r\n  /**\r\n   * Targets of JSR (subroutine entries, subject to filtering)\r\n   */\r\n  private jsrTargets: Set<number> = new Set();\r\n\r\n  /**\r\n   * Callback entry points created by STORE_STATE\r\n   * Key: callback entry address (STORE_STATE_address + type)\r\n   * Value: { storeStateAddress, savedGlobals, savedLocals }\r\n   */\r\n  callbackEntries: Map<number, { storeStateAddress: number; savedGlobals: number; savedLocals: number }> = new Map();\r\n\r\n  /**\r\n   * All edges in the graph with metadata\r\n   */\r\n  edges: Set<NWScriptEdge> = new Set();\r\n\r\n  /**\r\n   * Ordered list of edges (for deterministic iteration)\r\n   */\r\n  orderedEdges: NWScriptEdge[] = [];\r\n\r\n  /**\r\n   * Map from block pairs to edges\r\n   */\r\n  edgeMap: Map<string, NWScriptEdge> = new Map();\r\n\r\n  /**\r\n   * Back edges (edges where target dominates source)\r\n   */\r\n  backEdges: Set<NWScriptEdge> = new Set();\r\n\r\n  /**\r\n   * Critical edges (from has multiple successors, to has multiple predecessors)\r\n   */\r\n  criticalEdges: Set<NWScriptEdge> = new Set();\r\n\r\n  /**\r\n   * Block depths from entry (number of edges from entry)\r\n   */\r\n  blockDepths: Map<NWScriptBasicBlock, number> = new Map();\r\n\r\n  /**\r\n   * Natural loops (header -> set of blocks in loop)\r\n   */\r\n  naturalLoops: Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> = new Map();\r\n\r\n  /**\r\n   * Dominance frontiers (block -> set of blocks in its dominance frontier)\r\n   */\r\n  dominanceFrontiers: Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> = new Map();\r\n\r\n  /**\r\n   * Control dependences (block -> set of blocks that are control-dependent on it)\r\n   */\r\n  controlDependences: Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> = new Map();\r\n\r\n  /**\r\n   * Reverse control flow graph (cached)\r\n   */\r\n  reverseCFG: NWScriptControlFlowGraph | null = null;\r\n\r\n  /**\r\n   * Loop nesting tree (block -> parent loop header, null if not in a loop)\r\n   */\r\n  loopNestingTree: Map<NWScriptBasicBlock, NWScriptBasicBlock | null> = new Map();\r\n\r\n  /**\r\n   * Loop depth for each block (0 = not in a loop, 1 = outermost loop, etc.)\r\n   */\r\n  loopDepth: Map<NWScriptBasicBlock, number> = new Map();\r\n\r\n  /**\r\n   * Cached reachability: block -> set of blocks reachable from it\r\n   */\r\n  reachableFrom: Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> = new Map();\r\n\r\n  /**\r\n   * Cached reverse reachability: block -> set of blocks that can reach it\r\n   */\r\n  reachesTo: Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> = new Map();\r\n\r\n  /**\r\n   * Call edges (explicit tracking)\r\n   */\r\n  callEdges: Set<NWScriptEdge> = new Set();\r\n\r\n  /**\r\n   * Return edges (explicit tracking)\r\n   */\r\n  returnEdges: Set<NWScriptEdge> = new Set();\r\n\r\n  /**\r\n   * Invalidation flags for cached computations\r\n   */\r\n  private invalidated: Set<string> = new Set();\r\n\r\n  constructor(script: NWScript) {\r\n    this.script = script;\r\n  }\r\n\r\n  /**\r\n   * Build the control flow graph from the script's instructions\r\n   */\r\n  build(): void {\r\n    this.blocks.clear();\r\n    this.instructionToBlock.clear();\r\n    this.jumpTargets.clear();\r\n    this.jsrTargets.clear();\r\n    this.leaders.clear();\r\n    this.subroutineEntries.clear();\r\n    this.subroutineReturns.clear();\r\n    this.exitBlocks.clear();\r\n    this.storeStateJmpTargets.clear();\r\n    this.callbackEntries.clear();\r\n    this.edges.clear();\r\n    this.orderedEdges = [];\r\n    this.edgeMap.clear();\r\n    this.backEdges.clear();\r\n    this.criticalEdges.clear();\r\n    this.blockDepths.clear();\r\n    this.naturalLoops.clear();\r\n    this.dominanceFrontiers.clear();\r\n    this.controlDependences.clear();\r\n    this.reverseCFG = null;\r\n    this.loopNestingTree.clear();\r\n    this.loopDepth.clear();\r\n    this.reachableFrom.clear();\r\n    this.reachesTo.clear();\r\n    this.callEdges.clear();\r\n    this.returnEdges.clear();\r\n    this.invalidated.clear();\r\n\r\n    if (!this.script.instructions || this.script.instructions.size === 0) {\r\n      return;\r\n    }\r\n\r\n    // Step 1: Identify all jump targets and subroutine entries\r\n    this.identifyJumpTargets();\r\n    \r\n    // Step 1.5: Identify STORE_STATE+JMP targets and callback entries (these are NOT function entries)\r\n    this.identifyStoreStateJmpTargets();\r\n    \r\n    // Step 1.6: Compute leader set (entry, branch/call targets, callback entries, fallthrough after terminators, continuation after JSR)\r\n    this.computeLeaders();\r\n\r\n    // Step 2: Build basic blocks using leaders\r\n    this.buildBasicBlocks();\r\n\r\n    // Step 2.5: Map JSR return blocks (must be done after all blocks are built)\r\n    this.mapJsrReturnBlocks();\r\n\r\n    // Step 3: Connect blocks with edges\r\n    this.connectBlocks();\r\n\r\n    // Step 4: Identify entry and exit blocks\r\n    this.identifyEntryAndExitBlocks();\r\n\r\n    // Step 5: Compute dominators (for loop detection and conversion)\r\n    // Note: Loop identification is done by NWScriptControlStructureBuilder, not here\r\n    this.computeDominators();\r\n\r\n    // Step 6: Compute post-dominators (for merge point detection and unreachable code)\r\n    this.computePostDominators();\r\n\r\n    // Step 7: Identify unreachable code\r\n    this.identifyUnreachableCode();\r\n\r\n    // Step 8: Build edge information with types\r\n    this.buildEdges();\r\n\r\n    // Step 9: Identify back edges\r\n    this.identifyBackEdges();\r\n\r\n    // Step 10: Identify critical edges\r\n    this.identifyCriticalEdges();\r\n\r\n    // Step 11: Compute block depths\r\n    this.computeBlockDepths();\r\n\r\n    // Step 12: Identify natural loops\r\n    this.identifyNaturalLoops();\r\n\r\n    // Step 13: Validate post-dominators\r\n    this.validatePostDominators();\r\n\r\n    // Step 14: Compute dominance frontiers\r\n    this.computeDominanceFrontiers();\r\n\r\n    // Step 15: Compute control dependences\r\n    this.computeControlDependences();\r\n\r\n    // Step 16: Build loop nesting tree\r\n    this.buildLoopNestingTree();\r\n\r\n    // Step 17: Cache reachability sets\r\n    this.computeReachabilitySets();\r\n\r\n    // Step 18: Track inter-procedural edges\r\n    this.trackInterProceduralEdges();\r\n  }\r\n\r\n  /**\r\n   * Identify all addresses that are targets of jumps\r\n   * According to documentation:\r\n   * - JMP: Jump to relative address\r\n   * - JSR: Jump to subroutine at relative address, return to next instruction\r\n   * - JZ: Jump if top of stack is zero\r\n   * - JNZ: Jump if top of stack is non-zero\r\n   */\r\n  private identifyJumpTargets(): void {\r\n    for (const instruction of this.script.instructions.values()) {\r\n      let targetAddress: number | null = null;\r\n\r\n      switch (instruction.code) {\r\n        case OP_JMP:\r\n        case OP_JSR:\r\n        case OP_JZ:\r\n        case OP_JNZ:\r\n          if (instruction.offset !== undefined) {\r\n            targetAddress = instruction.address + instruction.offset;\r\n            this.jumpTargets.add(targetAddress);\r\n            if (instruction.code === OP_JSR) {\r\n              this.jsrTargets.add(targetAddress);\r\n            }\r\n          }\r\n          break;\r\n      }\r\n\r\n      // For JSR, also mark the return point (next instruction)\r\n      if (instruction.code === OP_JSR && instruction.nextInstr) {\r\n        this.subroutineReturns.set(instruction.address, null);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify JMP targets and callback entries that are part of STORE_STATE patterns\r\n   * These should NOT be treated as function entries\r\n   * Documentation: \"STORE_STATE - Store the Current Stack State... This byte code is always followed by a JMP and then a block of code to be executed by a later function such as a DelayCommand.\"\r\n   * \r\n   * CRITICAL: The `type` field of STORE_STATE is the offset to the callback entry point.\r\n   * Callback entry = STORE_STATE_address + instruction.type\r\n   */\r\n  private identifyStoreStateJmpTargets(): void {\r\n    this.storeStateJmpTargets.clear();\r\n    this.callbackEntries.clear();\r\n    \r\n    for (const instruction of this.script.instructions.values()) {\r\n      if (instruction.code === OP_STORE_STATE || instruction.code === OP_STORE_STATEALL) {\r\n        // The type field is the callback offset\r\n        // Callback entry = STORE_STATE_address + type\r\n        const callbackEntry = instruction.address + instruction.type;\r\n        \r\n        // Track callback entry\r\n        if (instruction.code === OP_STORE_STATE) {\r\n          // STORE_STATE has bpOffset (saved globals) and spOffset (saved locals)\r\n          const savedGlobals = instruction.bpOffset || 0;\r\n          const savedLocals = instruction.spOffset || 0;\r\n          this.callbackEntries.set(callbackEntry, {\r\n            storeStateAddress: instruction.address,\r\n            savedGlobals: savedGlobals,\r\n            savedLocals: savedLocals\r\n          });\r\n        } else {\r\n          // STORE_STATEALL (obsolete, no size parameters)\r\n          this.callbackEntries.set(callbackEntry, {\r\n            storeStateAddress: instruction.address,\r\n            savedGlobals: 0,\r\n            savedLocals: 0\r\n          });\r\n        }\r\n        \r\n        // Track JMP target (where outer ACTION call happens)\r\n        const nextInstr = instruction.nextInstr;\r\n        if (nextInstr && nextInstr.code === OP_JMP && nextInstr.offset !== undefined) {\r\n          const jmpTarget = nextInstr.address + nextInstr.offset;\r\n          this.storeStateJmpTargets.add(jmpTarget);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute the leader set for basic block construction.\r\n   * Leaders are instruction addresses that start basic blocks:\r\n   * - Entry point (address 0)\r\n   * - All branch/call targets (JMP, JSR, JZ, JNZ targets)\r\n   * - Callback entries (from STORE_STATE)\r\n   * - Fallthrough after any terminator (JMP/JZ/JNZ/JSR/RETN/EOF)\r\n   * - Continuation after JSR (return point)\r\n   */\r\n  private computeLeaders(): void {\r\n    this.leaders.clear();\r\n\r\n    // Get all instructions sorted by address\r\n    const sortedInstructions = Array.from(this.script.instructions.values())\r\n      .sort((a, b) => a.address - b.address);\r\n\r\n    // 1. Entry point (address 0)\r\n    if (sortedInstructions.length > 0 && sortedInstructions[0].address === 0) {\r\n      this.leaders.add(0);\r\n    }\r\n\r\n    // 2. All branch/call targets\r\n    for (const addr of this.jumpTargets) {\r\n      this.leaders.add(addr);\r\n    }\r\n\r\n    // 3. Callback entries\r\n    for (const callbackEntry of this.callbackEntries.keys()) {\r\n      this.leaders.add(callbackEntry);\r\n    }\r\n\r\n    // 4. Fallthrough after terminators (JMP/JZ/JNZ/JSR/RETN/EOF)\r\n    // This includes continuation after JSR (return point)\r\n    for (const instruction of sortedInstructions) {\r\n      if (this.isTerminator(instruction)) {\r\n        // Add fallthrough (next instruction after terminator)\r\n        // For JSR, this is the return point\r\n        // For JMP, this is the unreachable fallthrough (but still a leader)\r\n        if (instruction.nextInstr) {\r\n          this.leaders.add(instruction.nextInstr.address);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 5. Continuation after JSR (return point)\r\n    // for (const instruction of sortedInstructions) {\r\n    //   if (instruction.code === OP_JSR && instruction.nextInstr) {\r\n    //     this.leaders.add(instruction.nextInstr.address);\r\n    //   }\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Check if an instruction is a terminator (ends a basic block)\r\n   */\r\n  private isTerminator(instruction: NWScriptInstruction): boolean {\r\n    return instruction.code === OP_JMP ||\r\n           instruction.code === OP_JSR ||\r\n           instruction.code === OP_JZ ||\r\n           instruction.code === OP_JNZ ||\r\n           instruction.code === OP_RETN;\r\n  }\r\n\r\n  /**\r\n   * Build basic blocks from instructions using leaders.\r\n   * A basic block is a sequence of instructions from a leader until:\r\n   * - A terminator (JMP/JZ/JNZ/JSR/RETN/EOF)\r\n   * - The next leader\r\n   * \r\n   * Special handling: STORE_STATE+JMP is consumed as a single block.\r\n   */\r\n  private buildBasicBlocks(): void {\r\n    let blockId = 0;\r\n\r\n    // Get instructions sorted by address and create address-to-instruction map\r\n    const sortedInstructions = Array.from(this.script.instructions.values())\r\n      .sort((a, b) => a.address - b.address);\r\n    const instructionMap = new Map<number, NWScriptInstruction>();\r\n    for (const instr of sortedInstructions) {\r\n      instructionMap.set(instr.address, instr);\r\n    }\r\n\r\n    // Get sorted leader addresses\r\n    const sortedLeaders = Array.from(this.leaders).sort((a, b) => a - b);\r\n\r\n    // Build blocks using index-based iteration over leaders\r\n    for (let i = 0; i < sortedLeaders.length; i++) {\r\n      const leaderAddr = sortedLeaders[i];\r\n      const leaderInstr = instructionMap.get(leaderAddr);\r\n      if (!leaderInstr) continue;\r\n\r\n      // Check if this is a STORE_STATE+JMP pattern\r\n      if (leaderInstr.code === OP_STORE_STATE || leaderInstr.code === OP_STORE_STATEALL) {\r\n        const nextInstr = leaderInstr.nextInstr;\r\n        if (nextInstr && nextInstr.code === OP_JMP) {\r\n          // Create block for STORE_STATE+JMP\r\n          const block = new NWScriptBasicBlock(blockId++, leaderInstr);\r\n          block.addInstruction(nextInstr);\r\n          block.endInstruction = nextInstr;\r\n          block.exitType = 'jump';\r\n          \r\n          this.blocks.set(block.id, block);\r\n          this.instructionToBlock.set(leaderInstr.address, block);\r\n          this.instructionToBlock.set(nextInstr.address, block);\r\n          \r\n          // Mark as entry if address 0\r\n          if (leaderInstr.address === 0) {\r\n            this.entryBlock = block;\r\n            block.isEntry = true;\r\n          }\r\n          \r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Create block starting at this leader\r\n      const block = new NWScriptBasicBlock(blockId++, leaderInstr);\r\n      this.blocks.set(block.id, block);\r\n      this.instructionToBlock.set(leaderAddr, block);\r\n\r\n      // Mark as entry if address 0\r\n      if (leaderAddr === 0) {\r\n        this.entryBlock = block;\r\n        block.isEntry = true;\r\n      }\r\n\r\n      // Check if this is a subroutine entry\r\n      if (this.jsrTargets.has(leaderAddr) && \r\n          !this.storeStateJmpTargets.has(leaderAddr) &&\r\n          !this.callbackEntries.has(leaderAddr)) {\r\n        this.subroutineEntries.set(leaderAddr, block);\r\n      }\r\n\r\n      // Add instructions to block until terminator or next leader\r\n      let currentInstr = leaderInstr;\r\n      const nextLeaderAddr = i + 1 < sortedLeaders.length ? sortedLeaders[i + 1] : null;\r\n\r\n      while (currentInstr) {\r\n        // Stop if we hit a terminator\r\n        if (this.isTerminator(currentInstr)) {\r\n          // Add the terminator instruction to the block before setting it as end\r\n          if (currentInstr !== leaderInstr) {\r\n            block.addInstruction(currentInstr);\r\n            this.instructionToBlock.set(currentInstr.address, block);\r\n          }\r\n          \r\n          block.endInstruction = currentInstr;\r\n          \r\n          switch (currentInstr.code) {\r\n            case OP_JMP:\r\n              block.exitType = 'jump';\r\n              break;\r\n            case OP_JSR:\r\n              block.exitType = 'call';\r\n              // Note: return block mapping will be done after all blocks are built\r\n              break;\r\n            case OP_JZ:\r\n            case OP_JNZ:\r\n              block.exitType = 'conditional';\r\n              block.conditionInstruction = currentInstr;\r\n              break;\r\n            case OP_RETN:\r\n              block.exitType = 'return';\r\n              block.isExit = true;\r\n              this.exitBlocks.add(block);\r\n              break;\r\n          }\r\n          break;\r\n        }\r\n\r\n        // Stop if we've reached the next leader\r\n        if (nextLeaderAddr !== null && currentInstr.nextInstr && \r\n            currentInstr.nextInstr.address >= nextLeaderAddr) {\r\n          block.endInstruction = currentInstr;\r\n          block.exitType = 'fallthrough';\r\n          break;\r\n        }\r\n\r\n        // Add instruction to block\r\n        if (currentInstr !== leaderInstr) {\r\n          block.addInstruction(currentInstr);\r\n          this.instructionToBlock.set(currentInstr.address, block);\r\n        }\r\n\r\n        // Move to next instruction\r\n        currentInstr = currentInstr.nextInstr;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map JSR return blocks after all blocks are built\r\n   * This ensures return blocks exist when we try to map them\r\n   */\r\n  private mapJsrReturnBlocks(): void {\r\n    for (const instruction of this.script.instructions.values()) {\r\n      if (instruction.code === OP_JSR && instruction.nextInstr) {\r\n        const returnBlock = this.instructionToBlock.get(instruction.nextInstr.address);\r\n        if (returnBlock) {\r\n          this.subroutineReturns.set(instruction.address, returnBlock);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect basic blocks with control flow edges using deterministic edge emission.\r\n   * Edges are created with explicit EdgeType and ordered successors.\r\n   * According to documentation:\r\n   * - JMP: Single successor (jump target)\r\n   * - JSR: Two successors (subroutine entry [CALL] and return point [RETURN])\r\n   * - JZ/JNZ: Two successors (jump target [TRUE_BRANCH/FALSE_BRANCH] and fallthrough)\r\n   * - RETN: No successors (returns to caller implicitly)\r\n   */\r\n  private connectBlocks(): void {\r\n    // Process blocks in deterministic order (by start address)\r\n    const sortedBlocks = Array.from(this.blocks.values())\r\n      .sort((a, b) => a.startInstruction.address - b.startInstruction.address);\r\n\r\n    for (const block of sortedBlocks) {\r\n      const lastInstr = block.endInstruction;\r\n      if (!lastInstr) continue;\r\n\r\n      const successors: { block: NWScriptBasicBlock; type: EdgeType; condition?: boolean }[] = [];\r\n\r\n      switch (lastInstr.code) {\r\n        case OP_JMP:\r\n          // Documentation: \"JMP - Jump to a New Location... Change the current execution address to the relative address given\"\r\n          if (lastInstr.offset !== undefined) {\r\n            const targetAddr = lastInstr.address + lastInstr.offset;\r\n            const targetBlock = this.instructionToBlock.get(targetAddr);\r\n            if (targetBlock) {\r\n              successors.push({ block: targetBlock, type: EdgeType.JUMP });\r\n            }\r\n          }\r\n          break;\r\n\r\n        case OP_JSR:\r\n          // Documentation: \"JSR - Jump to Subroutine... Jump to the subroutine at the relative address given in the instruction\"\r\n          // The JSR block should connect to:\r\n          // 1. The subroutine entry (JSR target) - CALL edge\r\n          // 2. The return point (next instruction after JSR) - RETURN edge\r\n          if (lastInstr.offset !== undefined) {\r\n            const targetAddr = lastInstr.address + lastInstr.offset;\r\n            const targetBlock = this.instructionToBlock.get(targetAddr);\r\n            if (targetBlock) {\r\n              successors.push({ block: targetBlock, type: EdgeType.CALL });\r\n            }\r\n          }\r\n          // Return point (next instruction after JSR)\r\n          if (lastInstr.nextInstr) {\r\n            const returnBlock = this.instructionToBlock.get(lastInstr.nextInstr.address);\r\n            if (returnBlock) {\r\n              successors.push({ block: returnBlock, type: EdgeType.RETURN });\r\n            }\r\n          }\r\n          break;\r\n\r\n        case OP_JZ:\r\n        case OP_JNZ:\r\n          // Documentation: \"JZ - Jump if Top of Stack is Zero... Change the current execution address... if the integer on the top of the stack is zero\"\r\n          // Documentation: \"JNZ - Jump if Top of Stack is Non-Zero... Change the current execution address... if the integer on the top of the stack is non-zero\"\r\n          // Conditional branch: add both true and false paths\r\n          // Order: jump target first (if condition true for JNZ, false for JZ), then fallthrough\r\n          if (lastInstr.offset !== undefined) {\r\n            const targetAddr = lastInstr.address + lastInstr.offset;\r\n            const targetBlock = this.instructionToBlock.get(targetAddr);\r\n            if (targetBlock) {\r\n              const isTrueBranch = lastInstr.code === OP_JNZ;\r\n              successors.push({ \r\n                block: targetBlock, \r\n                type: isTrueBranch ? EdgeType.TRUE_BRANCH : EdgeType.FALSE_BRANCH,\r\n                condition: isTrueBranch\r\n              });\r\n            }\r\n          }\r\n          // Fallthrough path\r\n          if (lastInstr.nextInstr) {\r\n            const fallthroughBlock = this.instructionToBlock.get(lastInstr.nextInstr.address);\r\n            if (fallthroughBlock) {\r\n              const isTrueBranch = lastInstr.code === OP_JZ;\r\n              successors.push({ \r\n                block: fallthroughBlock, \r\n                type: isTrueBranch ? EdgeType.TRUE_BRANCH : EdgeType.FALSE_BRANCH,\r\n                condition: isTrueBranch\r\n              });\r\n            }\r\n          }\r\n          break;\r\n\r\n        case OP_RETN:\r\n          // Documentation: \"RETN - Return from a JSR... Return from a JSR. All arguments used to invoke the subroutine should be removed prior to the RETN.\"\r\n          // RETN returns to the caller implicitly (no explicit edge needed in CFG)\r\n          // The return happens through the call stack, not through CFG edges\r\n          // No successors for return\r\n          break;\r\n\r\n        default:\r\n          // Fallthrough to next instruction\r\n          if (lastInstr.nextInstr) {\r\n            const nextBlock = this.instructionToBlock.get(lastInstr.nextInstr.address);\r\n            if (nextBlock) {\r\n              successors.push({ block: nextBlock, type: EdgeType.FALLTHROUGH });\r\n            }\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Schedule callback edges: STORE_STATE+JMP blocks should have edges to callback entries\r\n      // This is optional but useful for tracking callback relationships\r\n      if (block.startInstruction.code === OP_STORE_STATE || block.startInstruction.code === OP_STORE_STATEALL) {\r\n        const callbackEntry = block.startInstruction.address + block.startInstruction.type;\r\n        const callbackBlock = this.instructionToBlock.get(callbackEntry);\r\n        if (callbackBlock && !successors.some(s => s.block === callbackBlock)) {\r\n          // Add callback edge (using CALL type for now, could be a separate CALLBACK type)\r\n          successors.push({ block: callbackBlock, type: EdgeType.CALL });\r\n        }\r\n      }\r\n\r\n      // Add successors in deterministic order (by address)\r\n      successors.sort((a, b) => a.block.startInstruction.address - b.block.startInstruction.address);\r\n      \r\n      for (const succ of successors) {\r\n        block.addSuccessor(succ.block);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify entry and exit blocks\r\n   * Documentation:\r\n   * - Entry: First instruction (address 0)\r\n   * - Exit: Blocks ending with RETN or EOF, or blocks with no successors\r\n   */\r\n  private identifyEntryAndExitBlocks(): void {\r\n    // Entry block is already identified\r\n    // Exit blocks are blocks with no successors or ending with RETN\r\n    // Documentation: \"RETN - Return from a JSR\" marks the end of a subroutine\r\n    for (const block of this.blocks.values()) {\r\n      if (block.successors.size === 0 || block.isExit) {\r\n        this.exitBlocks.add(block);\r\n        block.isExit = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute dominators for each block, ignoring CALL edges (and optionally RETURN edges)\r\n   * A block A dominates block B if all intra-procedural paths from entry to B go through A\r\n   * @param excludeReturn Whether to also exclude RETURN edges (default: false)\r\n   */\r\n  private computeDominators(excludeReturn: boolean = false): void {\r\n    if (!this.entryBlock) return;\r\n\r\n    // Initialize: entry block dominates itself\r\n    for (const block of this.blocks.values()) {\r\n      if (block === this.entryBlock) {\r\n        block.dominators.add(block);\r\n      } else {\r\n        // Initially, all blocks are dominated by all blocks\r\n        for (const otherBlock of this.blocks.values()) {\r\n          block.dominators.add(otherBlock);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Iterative algorithm to compute dominators using intra-procedural edges only\r\n    let changed = true;\r\n    while (changed) {\r\n      changed = false;\r\n      for (const block of this.blocks.values()) {\r\n        if (block === this.entryBlock) continue;\r\n\r\n        const newDominators = new Set<NWScriptBasicBlock>();\r\n        // Intersection of all intra-procedural predecessors' dominators\r\n        const intraPreds = this.getIntraProceduralPredecessors(block, false);\r\n        if (intraPreds.length > 0) {\r\n          const firstPred = intraPreds[0];\r\n          for (const dom of firstPred.dominators) {\r\n            newDominators.add(dom);\r\n          }\r\n          \r\n          for (const pred of intraPreds) {\r\n            const toRemove: NWScriptBasicBlock[] = [];\r\n            for (const dom of newDominators) {\r\n              if (!pred.dominators.has(dom)) {\r\n                toRemove.push(dom);\r\n              }\r\n            }\r\n            for (const dom of toRemove) {\r\n              newDominators.delete(dom);\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Add self\r\n        newDominators.add(block);\r\n\r\n        if (newDominators.size !== block.dominators.size ||\r\n            !Array.from(newDominators).every(d => block.dominators.has(d))) {\r\n          block.dominators = newDominators;\r\n          changed = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Compute post-dominators for each block, ignoring CALL edges (and optionally RETURN edges)\r\n   * A block A post-dominates block B if all intra-procedural paths from B to any exit go through A\r\n   * This is the reverse of dominators - we work backwards from exit blocks\r\n   * @param excludeReturn Whether to also exclude RETURN edges (default: false)\r\n   */\r\n  private computePostDominators(excludeReturn: boolean = false): void {\r\n    if (this.exitBlocks.size === 0) return;\r\n\r\n    // Initialize: exit blocks post-dominate themselves\r\n    for (const block of this.blocks.values()) {\r\n      if (this.exitBlocks.has(block)) {\r\n        block.postDominators.add(block);\r\n      } else {\r\n        // Initially, all blocks are post-dominated by all blocks\r\n        for (const otherBlock of this.blocks.values()) {\r\n          block.postDominators.add(otherBlock);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Iterative algorithm to compute post-dominators using intra-procedural edges only\r\n    let changed = true;\r\n    while (changed) {\r\n      changed = false;\r\n      for (const block of this.blocks.values()) {\r\n        if (this.exitBlocks.has(block)) continue;\r\n\r\n        const newPostDominators = new Set<NWScriptBasicBlock>();\r\n        // Intersection of all intra-procedural successors' post-dominators\r\n        const intraSuccs = this.getIntraProceduralSuccessors(block, excludeReturn);\r\n        if (intraSuccs.length > 0) {\r\n          const firstSucc = intraSuccs[0];\r\n          for (const postDom of firstSucc.postDominators) {\r\n            newPostDominators.add(postDom);\r\n          }\r\n          \r\n          for (const succ of intraSuccs) {\r\n            const toRemove: NWScriptBasicBlock[] = [];\r\n            for (const postDom of newPostDominators) {\r\n              if (!succ.postDominators.has(postDom)) {\r\n                toRemove.push(postDom);\r\n              }\r\n            }\r\n            for (const postDom of toRemove) {\r\n              newPostDominators.delete(postDom);\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Add self\r\n        newPostDominators.add(block);\r\n\r\n        if (newPostDominators.size !== block.postDominators.size ||\r\n            !Array.from(newPostDominators).every(pd => block.postDominators.has(pd))) {\r\n          block.postDominators = newPostDominators;\r\n          changed = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify unreachable code (blocks that cannot be reached from the entry block)\r\n   */\r\n  private identifyUnreachableCode(): void {\r\n    if (!this.entryBlock) {\r\n      // If there's no entry block, mark all blocks as unreachable\r\n      for (const block of this.blocks.values()) {\r\n        block.isUnreachable = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Mark all blocks as unreachable initially\r\n    for (const block of this.blocks.values()) {\r\n      block.isUnreachable = true;\r\n    }\r\n\r\n    // BFS from entry block to mark all reachable blocks\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [this.entryBlock];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (visited.has(current)) continue;\r\n      visited.add(current);\r\n\r\n      // Mark as reachable\r\n      current.isUnreachable = false;\r\n\r\n      for (const successor of current.successors) {\r\n        if (!visited.has(successor)) {\r\n          queue.push(successor);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Also mark blocks reachable from subroutine entries as reachable\r\n    // (they're reachable via JSR calls)\r\n    for (const [entryAddress, entryBlock] of this.subroutineEntries) {\r\n      if (entryBlock.isUnreachable) {\r\n        // This subroutine might be called, so mark it as reachable\r\n        // We'll do a BFS from this entry point too\r\n        const subVisited = new Set<NWScriptBasicBlock>();\r\n        const subQueue: NWScriptBasicBlock[] = [entryBlock];\r\n\r\n        while (subQueue.length > 0) {\r\n          const current = subQueue.shift()!;\r\n          if (subVisited.has(current)) continue;\r\n          subVisited.add(current);\r\n\r\n          current.isUnreachable = false;\r\n\r\n          for (const successor of current.successors) {\r\n            if (!subVisited.has(successor)) {\r\n              subQueue.push(successor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a block is unreachable from the entry\r\n   * Uses the cached isUnreachable property for efficiency\r\n   */\r\n  isUnreachable(block: NWScriptBasicBlock): boolean {\r\n    return block.isUnreachable;\r\n  }\r\n\r\n  /**\r\n   * Get all unreachable blocks\r\n   */\r\n  getUnreachableBlocks(): NWScriptBasicBlock[] {\r\n    const unreachable: NWScriptBasicBlock[] = [];\r\n    for (const block of this.blocks.values()) {\r\n      if (this.isUnreachable(block)) {\r\n        unreachable.push(block);\r\n      }\r\n    }\r\n    return unreachable;\r\n  }\r\n\r\n  /**\r\n   * Check if an instruction is a control flow instruction\r\n   * According to documentation, control flow instructions are:\r\n   * - JMP: Unconditional jump\r\n   * - JSR: Subroutine call\r\n   * - JZ: Conditional jump (if zero)\r\n   * - JNZ: Conditional jump (if non-zero)\r\n   * - RETN: Return from subroutine\r\n   * - EOF: End of file\r\n   */\r\n  private isControlFlowInstruction(instruction: NWScriptInstruction): boolean {\r\n    return instruction.code === OP_JMP ||\r\n           instruction.code === OP_JSR ||\r\n           instruction.code === OP_JZ ||\r\n           instruction.code === OP_JNZ ||\r\n           instruction.code === OP_RETN;\r\n  }\r\n\r\n  /**\r\n   * Validate the CFG against the NCS format documentation\r\n   * Returns an array of validation errors (empty if valid)\r\n   */\r\n  validate(): string[] {\r\n    const errors: string[] = [];\r\n\r\n    // Validate entry block\r\n    if (!this.entryBlock) {\r\n      errors.push('CFG Validation Error: No entry block found (expected instruction at address 0)');\r\n    } else if (this.entryBlock.startInstruction.address !== 0) {\r\n      errors.push(`CFG Validation Error: Entry block should start at address 0, but starts at ${this.entryBlock.startInstruction.address}`);\r\n    }\r\n\r\n    // Validate exit blocks\r\n    if (this.exitBlocks.size === 0) {\r\n      errors.push('CFG Validation Error: No exit blocks found (expected at least one RETN or EOF)');\r\n    }\r\n\r\n    // Validate JSR connections\r\n    for (const [jsrAddress, returnBlock] of this.subroutineReturns) {\r\n      const jsrInstr = this.script.instructions.get(jsrAddress);\r\n      if (!jsrInstr) {\r\n        errors.push(`CFG Validation Error: JSR instruction at address ${jsrAddress} not found`);\r\n        continue;\r\n      }\r\n\r\n      if (jsrInstr.code !== OP_JSR) {\r\n        errors.push(`CFG Validation Error: Instruction at address ${jsrAddress} is not a JSR`);\r\n        continue;\r\n      }\r\n\r\n      // Check that JSR has a return point (next instruction)\r\n      if (!jsrInstr.nextInstr) {\r\n        errors.push(`CFG Validation Error: JSR at address ${jsrAddress} has no return point (next instruction)`);\r\n      } else if (!returnBlock) {\r\n        errors.push(`CFG Validation Error: JSR at address ${jsrAddress} has no return block mapped`);\r\n      }\r\n\r\n      // Check that JSR block connects to both subroutine entry and return point\r\n      const jsrBlock = this.instructionToBlock.get(jsrAddress);\r\n      if (jsrBlock) {\r\n        if (jsrInstr.offset !== undefined) {\r\n          const targetAddr = jsrInstr.address + jsrInstr.offset;\r\n          const targetBlock = this.instructionToBlock.get(targetAddr);\r\n          if (targetBlock && !jsrBlock.successors.has(targetBlock)) {\r\n            errors.push(`CFG Validation Error: JSR block at address ${jsrAddress} does not connect to subroutine entry at ${targetAddr}`);\r\n          }\r\n        }\r\n\r\n        if (jsrInstr.nextInstr && returnBlock && !jsrBlock.successors.has(returnBlock)) {\r\n          errors.push(`CFG Validation Error: JSR block at address ${jsrAddress} does not connect to return point at ${jsrInstr.nextInstr.address}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate STORE_STATE+JMP patterns\r\n    for (const instruction of this.script.instructions.values()) {\r\n      if (instruction.code === OP_STORE_STATE || instruction.code === OP_STORE_STATEALL) {\r\n        const nextInstr = instruction.nextInstr;\r\n        if (!nextInstr) {\r\n          errors.push(`CFG Validation Error: STORE_STATE/STORE_STATEALL at address ${instruction.address} is not followed by an instruction`);\r\n        } else if (nextInstr.code !== OP_JMP) {\r\n          errors.push(`CFG Validation Error: STORE_STATE/STORE_STATEALL at address ${instruction.address} is not followed by JMP (found ${nextInstr.codeName || nextInstr.code})`);\r\n        } else if (nextInstr.offset !== undefined) {\r\n          const jmpTarget = nextInstr.address + nextInstr.offset;\r\n          if (!this.storeStateJmpTargets.has(jmpTarget)) {\r\n            errors.push(`CFG Validation Error: STORE_STATE+JMP target at address ${jmpTarget} is not marked as a STORE_STATE target`);\r\n          }\r\n          // Check that STORE_STATE JMP target is not treated as a function entry\r\n          if (this.subroutineEntries.has(jmpTarget)) {\r\n            errors.push(`CFG Validation Error: STORE_STATE+JMP target at address ${jmpTarget} is incorrectly marked as a subroutine entry`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate RETN blocks have no successors\r\n    for (const block of this.blocks.values()) {\r\n      if (block.endInstruction && block.endInstruction.code === OP_RETN) {\r\n        if (block.successors.size > 0) {\r\n          errors.push(`CFG Validation Error: RETN block ${block.id} has ${block.successors.size} successors (should have 0)`);\r\n        }\r\n        if (!block.isExit) {\r\n          errors.push(`CFG Validation Error: RETN block ${block.id} is not marked as exit`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate all instructions are in blocks\r\n    for (const instruction of this.script.instructions.values()) {\r\n      if (!this.instructionToBlock.has(instruction.address)) {\r\n        errors.push(`CFG Validation Error: Instruction at address ${instruction.address} is not in any block`);\r\n      }\r\n    }\r\n\r\n    // Validate all leaders have corresponding blocks\r\n    for (const leaderAddr of this.leaders) {\r\n      if (!this.instructionToBlock.has(leaderAddr)) {\r\n        errors.push(`CFG Validation Error: Leader at address ${leaderAddr} does not have a corresponding block`);\r\n      }\r\n    }\r\n\r\n    // Validate unreachable code marking\r\n    if (this.entryBlock) {\r\n      for (const block of this.blocks.values()) {\r\n        // Recompute to validate cached property\r\n        const visited = new Set<NWScriptBasicBlock>();\r\n        const queue: NWScriptBasicBlock[] = [this.entryBlock!];\r\n        let computedUnreachable = true;\r\n\r\n        while (queue.length > 0) {\r\n          const current = queue.shift()!;\r\n          if (current === block) {\r\n            computedUnreachable = false;\r\n            break;\r\n          }\r\n          if (visited.has(current)) continue;\r\n          visited.add(current);\r\n\r\n          for (const successor of current.successors) {\r\n            if (!visited.has(successor)) {\r\n              queue.push(successor);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (block.isUnreachable !== computedUnreachable) {\r\n          errors.push(`CFG Validation Error: Block ${block.id} has inconsistent unreachable marking (marked: ${block.isUnreachable}, computed: ${computedUnreachable})`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate back edges\r\n    for (const backEdge of this.backEdges) {\r\n      if (!this.dominates(backEdge.to, backEdge.from)) {\r\n        errors.push(`CFG Validation Error: Edge ${backEdge.from.id}->${backEdge.to.id} is marked as back edge but target does not dominate source`);\r\n      }\r\n    }\r\n\r\n    // Validate natural loops\r\n    for (const [header, loopBlocks] of this.naturalLoops) {\r\n      if (!header.isLoopHeader) {\r\n        errors.push(`CFG Validation Error: Block ${header.id} has natural loop but is not marked as loop header`);\r\n      }\r\n      for (const block of loopBlocks) {\r\n        if (block !== header && !block.isLoopBody) {\r\n          errors.push(`CFG Validation Error: Block ${block.id} is in natural loop of ${header.id} but is not marked as loop body`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate block depths\r\n    if (this.entryBlock) {\r\n      const entryDepth = this.getBlockDepth(this.entryBlock);\r\n      if (entryDepth !== 0) {\r\n        errors.push(`CFG Validation Error: Entry block depth should be 0, but is ${entryDepth}`);\r\n      }\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Get the basic block containing a specific instruction address\r\n   */\r\n  getBlockForAddress(address: number): NWScriptBasicBlock | null {\r\n    return this.instructionToBlock.get(address) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all blocks in topological order (for conversion)\r\n   */\r\n  getTopologicalOrder(): NWScriptBasicBlock[] {\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const result: NWScriptBasicBlock[] = [];\r\n\r\n    const visit = (block: NWScriptBasicBlock) => {\r\n      if (visited.has(block)) return;\r\n      visited.add(block);\r\n\r\n      for (const successor of block.successors) {\r\n        visit(successor);\r\n      }\r\n\r\n      result.push(block);\r\n    };\r\n\r\n    if (this.entryBlock) {\r\n      visit(this.entryBlock);\r\n    }\r\n\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Get blocks in reverse post-order (for analysis)\r\n   */\r\n  getReversePostOrder(): NWScriptBasicBlock[] {\r\n    return this.getTopologicalOrder().reverse();\r\n  }\r\n\r\n  /**\r\n   * Find the immediate dominator of a block\r\n   */\r\n  getImmediateDominator(block: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    if (block === this.entryBlock) return null;\r\n\r\n    let idom: NWScriptBasicBlock | null = null;\r\n    for (const dom of block.dominators) {\r\n      if (dom === block) continue;\r\n      if (!idom || this.dominates(dom, idom)) {\r\n        idom = dom;\r\n      }\r\n    }\r\n    return idom;\r\n  }\r\n\r\n  /**\r\n   * Check if block A dominates block B\r\n   */\r\n  dominates(blockA: NWScriptBasicBlock, blockB: NWScriptBasicBlock): boolean {\r\n    return blockB.dominators.has(blockA);\r\n  }\r\n\r\n  /**\r\n   * Check if block A post-dominates block B\r\n   */\r\n  postDominates(blockA: NWScriptBasicBlock, blockB: NWScriptBasicBlock): boolean {\r\n    return blockB.postDominators.has(blockA);\r\n  }\r\n\r\n  /**\r\n   * Find the immediate post-dominator of a block\r\n   */\r\n  getImmediatePostDominator(block: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    if (this.exitBlocks.has(block)) return null;\r\n\r\n    let ipdom: NWScriptBasicBlock | null = null;\r\n    for (const postDom of block.postDominators) {\r\n      if (postDom === block) continue;\r\n      if (!ipdom || this.postDominates(postDom, ipdom)) {\r\n        ipdom = postDom;\r\n      }\r\n    }\r\n    return ipdom;\r\n  }\r\n\r\n  /**\r\n   * Build edge information with types and ordered edge list\r\n   * Uses edge type information from connectBlocks() when available\r\n   */\r\n  private buildEdges(): void {\r\n    this.edges.clear();\r\n    this.orderedEdges = [];\r\n    this.edgeMap.clear();\r\n\r\n    // Process blocks in deterministic order (by start address)\r\n    const sortedBlocks = Array.from(this.blocks.values())\r\n      .sort((a, b) => a.startInstruction.address - b.startInstruction.address);\r\n\r\n    for (const block of sortedBlocks) {\r\n      const lastInstr = block.endInstruction;\r\n      if (!lastInstr) continue;\r\n\r\n      // Get ordered successors (already sorted in connectBlocks)\r\n      const orderedSuccessors = this.getOrderedSuccessors(block);\r\n\r\n      for (const successor of orderedSuccessors) {\r\n        let edgeType: EdgeType = EdgeType.FALLTHROUGH;\r\n        let condition: boolean | undefined = undefined;\r\n\r\n        // Check if this is a callback edge first (STORE_STATE blocks)\r\n        if ((block.startInstruction.code === OP_STORE_STATE || block.startInstruction.code === OP_STORE_STATEALL) &&\r\n            this.callbackEntries.has(successor.startInstruction.address)) {\r\n          edgeType = EdgeType.CALL; // Callback edge\r\n        } else {\r\n          // Determine edge type based on block exit type\r\n          switch (block.exitType) {\r\n            case 'jump':\r\n              edgeType = EdgeType.JUMP;\r\n              break;\r\n            case 'call':\r\n              // Check if this is the call target or return point\r\n              if (lastInstr.code === OP_JSR && lastInstr.offset !== undefined) {\r\n                const targetAddr = lastInstr.address + lastInstr.offset;\r\n                if (successor.startInstruction.address === targetAddr) {\r\n                  edgeType = EdgeType.CALL;\r\n                } else {\r\n                  edgeType = EdgeType.RETURN;\r\n                }\r\n              }\r\n              break;\r\n            case 'conditional':\r\n              // Determine if this is true or false branch\r\n              if (lastInstr.code === OP_JZ || lastInstr.code === OP_JNZ) {\r\n                const targetAddr = lastInstr.offset !== undefined \r\n                  ? lastInstr.address + lastInstr.offset \r\n                  : null;\r\n                \r\n                if (targetAddr !== null && successor.startInstruction.address === targetAddr) {\r\n                  // This is the jump target\r\n                  edgeType = lastInstr.code === OP_JZ ? EdgeType.FALSE_BRANCH : EdgeType.TRUE_BRANCH;\r\n                  condition = lastInstr.code === OP_JNZ;\r\n                } else {\r\n                  // This is the fallthrough\r\n                  edgeType = lastInstr.code === OP_JZ ? EdgeType.TRUE_BRANCH : EdgeType.FALSE_BRANCH;\r\n                  condition = lastInstr.code === OP_JZ;\r\n                }\r\n              }\r\n              break;\r\n            case 'return':\r\n              edgeType = EdgeType.RETURN;\r\n              break;\r\n            default:\r\n              edgeType = EdgeType.FALLTHROUGH;\r\n          }\r\n        }\r\n\r\n        const edge = new NWScriptEdge(block, successor, edgeType);\r\n        if (condition !== undefined) {\r\n          edge.condition = condition;\r\n        }\r\n\r\n        this.edges.add(edge);\r\n        this.orderedEdges.push(edge);\r\n        const edgeKey = `${block.id}->${successor.id}`;\r\n        this.edgeMap.set(edgeKey, edge);\r\n\r\n        // Track call and return edges\r\n        if (edgeType === EdgeType.CALL) {\r\n          this.callEdges.add(edge);\r\n        } else if (edgeType === EdgeType.RETURN) {\r\n          this.returnEdges.add(edge);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify back edges (edges where target dominates source)\r\n   */\r\n  private identifyBackEdges(): void {\r\n    this.backEdges.clear();\r\n\r\n    for (const edge of this.edges) {\r\n      // A back edge is one where the target dominates the source\r\n      if (this.dominates(edge.to, edge.from)) {\r\n        edge.isBackEdge = true;\r\n        this.backEdges.add(edge);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify critical edges (from has multiple successors, to has multiple predecessors)\r\n   */\r\n  private identifyCriticalEdges(): void {\r\n    this.criticalEdges.clear();\r\n\r\n    for (const edge of this.edges) {\r\n      if (edge.from.successors.size > 1 && edge.to.predecessors.size > 1) {\r\n        edge.isCritical = true;\r\n        this.criticalEdges.add(edge);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute block depths from entry (number of edges from entry)\r\n   */\r\n  private computeBlockDepths(): void {\r\n    this.blockDepths.clear();\r\n\r\n    if (!this.entryBlock) return;\r\n\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: [NWScriptBasicBlock, number][] = [[this.entryBlock, 0]];\r\n\r\n    while (queue.length > 0) {\r\n      const [current, depth] = queue.shift()!;\r\n      if (visited.has(current)) continue;\r\n      visited.add(current);\r\n\r\n      this.blockDepths.set(current, depth);\r\n\r\n      for (const successor of current.successors) {\r\n        if (!visited.has(successor)) {\r\n          queue.push([successor, depth + 1]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify natural loops (all blocks in a loop for each loop header)\r\n   */\r\n  private identifyNaturalLoops(): void {\r\n    this.naturalLoops.clear();\r\n\r\n    for (const backEdge of this.backEdges) {\r\n      const header = backEdge.to;\r\n      const tail = backEdge.from;\r\n\r\n      if (!this.naturalLoops.has(header)) {\r\n        this.naturalLoops.set(header, new Set());\r\n      }\r\n\r\n      const loopBlocks = this.naturalLoops.get(header)!;\r\n      loopBlocks.add(header);\r\n      loopBlocks.add(tail);\r\n\r\n      // Add all blocks that can reach tail without going through header\r\n      this.addLoopBlocks(header, tail, loopBlocks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recursively add blocks to a natural loop\r\n   */\r\n  private addLoopBlocks(header: NWScriptBasicBlock, current: NWScriptBasicBlock, loopBlocks: Set<NWScriptBasicBlock>): void {\r\n    for (const pred of current.predecessors) {\r\n      if (pred !== header && !loopBlocks.has(pred)) {\r\n        loopBlocks.add(pred);\r\n        this.addLoopBlocks(header, pred, loopBlocks);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate post-dominators\r\n   */\r\n  private validatePostDominators(): void {\r\n    // Basic validation: check that exit blocks post-dominate themselves\r\n    for (const exitBlock of this.exitBlocks) {\r\n      if (!exitBlock.postDominators.has(exitBlock)) {\r\n        log.warn(`CFG Warning: Exit block ${exitBlock.id} does not post-dominate itself`);\r\n      }\r\n    }\r\n\r\n    // Validate that if A post-dominates B, then all paths from B to exit go through A\r\n    // This is a more complex check that would require path enumeration\r\n    // For now, we'll do a basic sanity check\r\n  }\r\n\r\n  /**\r\n   * Find all paths between two blocks\r\n   */\r\n  findAllPaths(from: NWScriptBasicBlock, to: NWScriptBasicBlock): NWScriptBasicBlock[][] {\r\n    const paths: NWScriptBasicBlock[][] = [];\r\n    const currentPath: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const dfs = (current: NWScriptBasicBlock) => {\r\n      if (current === to) {\r\n        paths.push([...currentPath, current]);\r\n        return;\r\n      }\r\n\r\n      if (visited.has(current)) return;\r\n      visited.add(current);\r\n      currentPath.push(current);\r\n\r\n      for (const successor of current.successors) {\r\n        dfs(successor);\r\n      }\r\n\r\n      currentPath.pop();\r\n      visited.delete(current);\r\n    };\r\n\r\n    dfs(from);\r\n    return paths;\r\n  }\r\n\r\n  /**\r\n   * Check if one block can reach another\r\n   */\r\n  canReach(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    if (from === to) return true;\r\n\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [from];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (current === to) return true;\r\n      if (visited.has(current)) continue;\r\n      visited.add(current);\r\n\r\n      for (const successor of current.successors) {\r\n        if (!visited.has(successor)) {\r\n          queue.push(successor);\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get DFS pre-order (visit node before children)\r\n   */\r\n  getDFSPreOrder(): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const dfs = (block: NWScriptBasicBlock) => {\r\n      if (visited.has(block)) return;\r\n      visited.add(block);\r\n      result.push(block);\r\n\r\n      for (const successor of block.successors) {\r\n        dfs(successor);\r\n      }\r\n    };\r\n\r\n    if (this.entryBlock) {\r\n      dfs(this.entryBlock);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get DFS post-order (visit children before node)\r\n   */\r\n  getDFSPostOrder(): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const dfs = (block: NWScriptBasicBlock) => {\r\n      if (visited.has(block)) return;\r\n      visited.add(block);\r\n\r\n      for (const successor of block.successors) {\r\n        dfs(successor);\r\n      }\r\n\r\n      result.push(block);\r\n    };\r\n\r\n    if (this.entryBlock) {\r\n      dfs(this.entryBlock);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get common dominator of multiple blocks\r\n   */\r\n  getCommonDominator(blocks: NWScriptBasicBlock[]): NWScriptBasicBlock | null {\r\n    if (blocks.length === 0) return null;\r\n    if (blocks.length === 1) return blocks[0];\r\n\r\n    // Start with dominators of first block\r\n    const common = new Set(blocks[0].dominators);\r\n\r\n    // Intersect with dominators of other blocks\r\n    for (let i = 1; i < blocks.length; i++) {\r\n      const toRemove: NWScriptBasicBlock[] = [];\r\n      for (const dom of common) {\r\n        if (!blocks[i].dominators.has(dom)) {\r\n          toRemove.push(dom);\r\n        }\r\n      }\r\n      for (const dom of toRemove) {\r\n        common.delete(dom);\r\n      }\r\n    }\r\n\r\n    // Find the immediate dominator (closest to blocks)\r\n    let idom: NWScriptBasicBlock | null = null;\r\n    for (const dom of common) {\r\n      if (blocks.every(b => b === dom || b.dominators.has(dom))) {\r\n        if (!idom || this.dominates(dom, idom)) {\r\n          idom = dom;\r\n        }\r\n      }\r\n    }\r\n\r\n    return idom;\r\n  }\r\n\r\n  /**\r\n   * Get common post-dominator of multiple blocks\r\n   */\r\n  getCommonPostDominator(blocks: NWScriptBasicBlock[]): NWScriptBasicBlock | null {\r\n    if (blocks.length === 0) return null;\r\n    if (blocks.length === 1) return blocks[0];\r\n\r\n    // Start with post-dominators of first block\r\n    const common = new Set(blocks[0].postDominators);\r\n\r\n    // Intersect with post-dominators of other blocks\r\n    for (let i = 1; i < blocks.length; i++) {\r\n      const toRemove: NWScriptBasicBlock[] = [];\r\n      for (const postDom of common) {\r\n        if (!blocks[i].postDominators.has(postDom)) {\r\n          toRemove.push(postDom);\r\n        }\r\n      }\r\n      for (const postDom of toRemove) {\r\n        common.delete(postDom);\r\n      }\r\n    }\r\n\r\n    // Find the immediate post-dominator (closest to blocks)\r\n    let ipdom: NWScriptBasicBlock | null = null;\r\n    for (const postDom of common) {\r\n      if (blocks.every(b => b === postDom || b.postDominators.has(postDom))) {\r\n        if (!ipdom || this.postDominates(postDom, ipdom)) {\r\n          ipdom = postDom;\r\n        }\r\n      }\r\n    }\r\n\r\n    return ipdom;\r\n  }\r\n\r\n  /**\r\n   * Get natural loop for a loop header\r\n   */\r\n  getNaturalLoop(header: NWScriptBasicBlock): Set<NWScriptBasicBlock> {\r\n    return this.naturalLoops.get(header) || new Set();\r\n  }\r\n\r\n  /**\r\n   * Check if an edge exists\r\n   */\r\n  hasEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    const edgeKey = `${from.id}->${to.id}`;\r\n    return this.edgeMap.has(edgeKey);\r\n  }\r\n\r\n  /**\r\n   * Get edge between two blocks\r\n   */\r\n  getEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): NWScriptEdge | null {\r\n    const edgeKey = `${from.id}->${to.id}`;\r\n    return this.edgeMap.get(edgeKey) || null;\r\n  }\r\n\r\n  /**\r\n   * Add an edge (and update block connections)\r\n   */\r\n  addEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock, type: EdgeType = EdgeType.FALLTHROUGH, weight: number = 1.0): NWScriptEdge {\r\n    if (this.hasEdge(from, to)) {\r\n      return this.getEdge(from, to)!;\r\n    }\r\n\r\n    const edge = new NWScriptEdge(from, to, type, weight);\r\n    from.addSuccessor(to);\r\n    this.edges.add(edge);\r\n    const edgeKey = `${from.id}->${to.id}`;\r\n    this.edgeMap.set(edgeKey, edge);\r\n\r\n    return edge;\r\n  }\r\n\r\n  /**\r\n   * Remove an edge (and update block connections)\r\n   */\r\n  removeEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    const edgeKey = `${from.id}->${to.id}`;\r\n    const edge = this.edgeMap.get(edgeKey);\r\n    if (!edge) return false;\r\n\r\n    from.removeSuccessor(to);\r\n    this.edges.delete(edge);\r\n    this.edgeMap.delete(edgeKey);\r\n    this.backEdges.delete(edge);\r\n    this.criticalEdges.delete(edge);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get reachable subgraph from a starting block\r\n   */\r\n  getReachableSubgraph(start: NWScriptBasicBlock): Set<NWScriptBasicBlock> {\r\n    const reachable = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [start];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (reachable.has(current)) continue;\r\n      reachable.add(current);\r\n\r\n      for (const successor of current.successors) {\r\n        if (!reachable.has(successor)) {\r\n          queue.push(successor);\r\n        }\r\n      }\r\n    }\r\n\r\n    return reachable;\r\n  }\r\n\r\n  /**\r\n   * Get subgraph containing only specified blocks\r\n   */\r\n  getSubgraph(blocks: Set<NWScriptBasicBlock>): NWScriptControlFlowGraph {\r\n    // Create a new CFG with only the specified blocks\r\n    const subgraph = new NWScriptControlFlowGraph(this.script);\r\n    \r\n    // Add blocks\r\n    for (const block of blocks) {\r\n      subgraph.blocks.set(block.id, block);\r\n      subgraph.instructionToBlock.set(block.startInstruction.address, block);\r\n      \r\n      // Add edges that are within the subgraph\r\n      for (const successor of block.successors) {\r\n        if (blocks.has(successor)) {\r\n          const edge = this.getEdge(block, successor);\r\n          if (edge) {\r\n            subgraph.addEdge(block, successor, edge.type);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Set entry block if it's in the subgraph\r\n    if (this.entryBlock && blocks.has(this.entryBlock)) {\r\n      subgraph.entryBlock = this.entryBlock;\r\n    }\r\n\r\n    // Set exit blocks that are in the subgraph\r\n    for (const exitBlock of this.exitBlocks) {\r\n      if (blocks.has(exitBlock)) {\r\n        subgraph.exitBlocks.add(exitBlock);\r\n      }\r\n    }\r\n\r\n    return subgraph;\r\n  }\r\n\r\n  /**\r\n   * Get critical edges\r\n   */\r\n  getCriticalEdges(): Array<[NWScriptBasicBlock, NWScriptBasicBlock]> {\r\n    return Array.from(this.criticalEdges).map(edge => [edge.from, edge.to]);\r\n  }\r\n\r\n  /**\r\n   * Get strongly connected components (SCC)\r\n   */\r\n  getStronglyConnectedComponents(): Set<NWScriptBasicBlock>[] {\r\n    const components: Set<NWScriptBasicBlock>[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const finished = new Set<NWScriptBasicBlock>();\r\n    const stack: NWScriptBasicBlock[] = [];\r\n    const index = new Map<NWScriptBasicBlock, number>();\r\n    const lowlink = new Map<NWScriptBasicBlock, number>();\r\n    let currentIndex = 0;\r\n\r\n    const strongConnect = (block: NWScriptBasicBlock) => {\r\n      index.set(block, currentIndex);\r\n      lowlink.set(block, currentIndex);\r\n      currentIndex++;\r\n      stack.push(block);\r\n      visited.add(block);\r\n\r\n      for (const successor of block.successors) {\r\n        if (!index.has(successor)) {\r\n          strongConnect(successor);\r\n          lowlink.set(block, Math.min(lowlink.get(block)!, lowlink.get(successor)!));\r\n        } else if (stack.includes(successor)) {\r\n          lowlink.set(block, Math.min(lowlink.get(block)!, index.get(successor)!));\r\n        }\r\n      }\r\n\r\n      if (lowlink.get(block) === index.get(block)) {\r\n        const component = new Set<NWScriptBasicBlock>();\r\n        let w: NWScriptBasicBlock;\r\n        do {\r\n          w = stack.pop()!;\r\n          component.add(w);\r\n          finished.add(w);\r\n        } while (w !== block);\r\n        components.push(component);\r\n      }\r\n    };\r\n\r\n    for (const block of this.blocks.values()) {\r\n      if (!index.has(block)) {\r\n        strongConnect(block);\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Get block depth from entry\r\n   */\r\n  getBlockDepth(block: NWScriptBasicBlock): number {\r\n    return this.blockDepths.get(block) ?? -1;\r\n  }\r\n\r\n  /**\r\n   * Check if an edge is a back edge\r\n   */\r\n  isBackEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    const edge = this.getEdge(from, to);\r\n    return edge ? edge.isBackEdge : false;\r\n  }\r\n\r\n  /**\r\n   * Check if an edge is a forward edge\r\n   */\r\n  isForwardEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    if (this.isBackEdge(from, to)) return false;\r\n    // Forward edge: target is reachable from source via DFS tree\r\n    return this.canReach(from, to);\r\n  }\r\n\r\n  /**\r\n   * Check if an edge is a cross edge\r\n   */\r\n  isCrossEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock): boolean {\r\n    if (this.isBackEdge(from, to)) return false;\r\n    if (this.isForwardEdge(from, to)) return false;\r\n    // Cross edge: connects nodes in different branches of DFS tree\r\n    return from.successors.has(to);\r\n  }\r\n\r\n  /**\r\n   * Get blocks ordered by dominance tree\r\n   */\r\n  getDominanceOrder(): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const visit = (block: NWScriptBasicBlock) => {\r\n      if (visited.has(block)) return;\r\n      visited.add(block);\r\n      result.push(block);\r\n\r\n      // Visit children in dominance tree (blocks dominated by this block)\r\n      const children = Array.from(this.blocks.values()).filter(b => \r\n        b !== block && \r\n        this.dominates(block, b) &&\r\n        this.getImmediateDominator(b) === block\r\n      );\r\n\r\n      for (const child of children.sort((a, b) => a.id - b.id)) {\r\n        visit(child);\r\n      }\r\n    };\r\n\r\n    if (this.entryBlock) {\r\n      visit(this.entryBlock);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get a string representation of the CFG\r\n   */\r\n  toString(): string {\r\n    const lines: string[] = [];\r\n    lines.push(`Control Flow Graph for ${this.script.name || 'script'}`);\r\n    lines.push(`Entry Block: ${this.entryBlock?.id ?? 'none'}`);\r\n    lines.push(`Exit Blocks: ${Array.from(this.exitBlocks).map(b => b.id).join(', ')}`);\r\n    lines.push(`Total Blocks: ${this.blocks.size}`);\r\n    lines.push(`Total Edges: ${this.edges.size}`);\r\n    lines.push(`Back Edges: ${this.backEdges.size}`);\r\n    lines.push(`Critical Edges: ${this.criticalEdges.size}`);\r\n    lines.push('');\r\n\r\n    for (const block of this.blocks.values()) {\r\n      lines.push(block.toString());\r\n      lines.push(`  Exit Type: ${block.exitType}`);\r\n      lines.push(`  Depth: ${this.getBlockDepth(block)}`);\r\n      lines.push(`  Successors: ${Array.from(block.successors).map(b => b.id).join(', ')}`);\r\n      lines.push(`  Predecessors: ${Array.from(block.predecessors).map(b => b.id).join(', ')}`);\r\n      if (block.isLoopHeader) {\r\n        lines.push(`  Loop Header`);\r\n        const loopBlocks = this.getNaturalLoop(block);\r\n        if (loopBlocks.size > 0) {\r\n          lines.push(`  Natural Loop: ${Array.from(loopBlocks).map(b => b.id).join(', ')}`);\r\n        }\r\n      }\r\n      if (block.isLoopBody) {\r\n        lines.push(`  Loop Body`);\r\n      }\r\n      if (block.isUnreachable) {\r\n        lines.push(`  Unreachable`);\r\n      }\r\n      lines.push('');\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Safely serialize an instruction without circular references\r\n   */\r\n  private serializeInstruction(instr: NWScriptInstruction): ISerializedNWScriptInstruction {\r\n    const result: ISerializedNWScriptInstruction = {\r\n      address: instr.address,\r\n      code: instr.code,\r\n      codeName: instr.codeName || `OP_${instr.code}`,\r\n      codeHex: instr.code_hex || `0x${instr.code.toString(16).padStart(2, '0')}`,\r\n      type: instr.type,\r\n      typeHex: instr.type_hex || `0x${instr.type.toString(16).padStart(2, '0')}`,\r\n      instructionSize: instr.instructionSize || 0,\r\n      index: instr.index ?? -1,\r\n      isArg: instr.isArg || false,\r\n      breakPoint: instr.break_point || false\r\n    };\r\n\r\n    // Add optional properties only if they exist and are not undefined\r\n    if (instr.offset !== undefined) result.offset = instr.offset;\r\n    if (instr.bpOffset !== undefined) result.bpOffset = instr.bpOffset;\r\n    if (instr.spOffset !== undefined) result.spOffset = instr.spOffset;\r\n    if (instr.size !== undefined) result.size = instr.size;\r\n    if (instr.sizeToDestroy !== undefined) result.sizeToDestroy = instr.sizeToDestroy;\r\n    if (instr.offsetToSaveElement !== undefined) result.offsetToSaveElement = instr.offsetToSaveElement;\r\n    if (instr.sizeOfElementToSave !== undefined) result.sizeOfElementToSave = instr.sizeOfElementToSave;\r\n    if (instr.sizeOfStructure !== undefined) result.sizeOfStructure = instr.sizeOfStructure;\r\n    if (instr.action !== undefined) result.action = instr.action;\r\n    if (instr.argCount !== undefined) result.argCount = instr.argCount;\r\n    if (instr.integer !== undefined) result.integer = instr.integer;\r\n    if (instr.float !== undefined) result.float = instr.float;\r\n    if (instr.string !== undefined) result.string = instr.string;\r\n    if (instr.object !== undefined) result.object = instr.object;\r\n\r\n    // Serialize actionDefinition if it exists (only primitive properties, exclude function)\r\n    if (instr.actionDefinition) {\r\n      result.actionDefinition = {\r\n        name: instr.actionDefinition.name,\r\n        comment: instr.actionDefinition.comment,\r\n        type: instr.actionDefinition.type,\r\n        args: instr.actionDefinition.args ? [...instr.actionDefinition.args] : []\r\n        // Note: action function is excluded to avoid circular references\r\n      };\r\n    }\r\n\r\n    // Add next/prev instruction addresses (not the objects themselves)\r\n    if (instr.nextInstr) result.nextInstructionAddress = instr.nextInstr.address;\r\n    if (instr.prevInstr) result.prevInstructionAddress = instr.prevInstr.address;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Safely serialize a condition expression (or return null if it's too complex)\r\n   */\r\n  private serializeConditionExpression(expr: NWScriptExpression | null | undefined): SerializedConditionExpression | null {\r\n    if (!expr) return null;\r\n\r\n    try {\r\n      if (typeof (expr as NWScriptExpression & { toJSON?: () => SerializedConditionExpression }).toJSON === \"function\") {\r\n        return (expr as NWScriptExpression & { toJSON: () => SerializedConditionExpression }).toJSON();\r\n      }\r\n\r\n      if (typeof expr === \"object\" && expr !== null) {\r\n        const keys = Object.keys(expr);\r\n        if (keys.length === 0) return null;\r\n\r\n        const simple: Record<string, string | number | boolean | null | SerializedConditionExpression> = {};\r\n        for (const key of keys) {\r\n          const value = expr[key];\r\n          if (value === null || value === undefined) continue;\r\n          if (typeof value === \"function\") continue;\r\n          if (typeof value === \"object\" && value !== null) {\r\n            if (value === expr) continue;\r\n            simple[key] = {\r\n              _type: typeof value,\r\n              _constructor: (value as { constructor?: { name?: string } }).constructor?.name ?? \"Object\"\r\n            };\r\n          } else {\r\n            simple[key] = value as string | number | boolean | null;\r\n          }\r\n        }\r\n        return Object.keys(simple).length > 0 ? (simple as SerializedConditionExpression) : null;\r\n      }\r\n\r\n      return null;\r\n    } catch (_e) {\r\n      return { _error: \"Could not serialize condition expression\", _type: typeof expr };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export CFG to comprehensive JSON format for AI analysis\r\n   * Includes all graph structure, analysis results, and metadata\r\n   */\r\n  toJSON(): INWScriptCFGJSON {\r\n    const sortedBlocks = this.getBlocksInOrder();\r\n    const graphMetrics = this.getGraphMetrics();\r\n\r\n    return {\r\n      // Script metadata\r\n      script: {\r\n        name: this.script.name || 'unnamed',\r\n        totalInstructions: this.script.instructions?.size || 0,\r\n        instructionAddresses: Array.from(this.script.instructions?.keys() || []).sort((a, b) => a - b)\r\n      },\r\n\r\n      // Graph structure\r\n      graph: {\r\n        entryBlockId: this.entryBlock?.id ?? null,\r\n        exitBlockIds: Array.from(this.exitBlocks).map(b => b.id).sort((a, b) => a - b),\r\n        totalBlocks: this.blocks.size,\r\n        totalEdges: this.edges.size,\r\n        leaders: Array.from(this.leaders).sort((a, b) => a - b),\r\n        jumpTargets: Array.from(this.jumpTargets).sort((a, b) => a - b),\r\n        storeStateJmpTargets: Array.from(this.storeStateJmpTargets).sort((a, b) => a - b)\r\n      },\r\n\r\n      // Subroutines and callbacks\r\n      subroutines: {\r\n        entries: Array.from(this.subroutineEntries.entries()).map(([addr, block]) => ({\r\n          address: addr,\r\n          blockId: block.id\r\n        })),\r\n        returns: Array.from(this.subroutineReturns.entries()).map(([jsrAddr, returnBlock]) => ({\r\n          jsrAddress: jsrAddr,\r\n          returnBlockId: returnBlock?.id ?? null\r\n        })),\r\n        callbacks: Array.from(this.callbackEntries.entries()).map(([entryAddr, info]) => ({\r\n          entryAddress: entryAddr,\r\n          storeStateAddress: info.storeStateAddress,\r\n          savedGlobals: info.savedGlobals,\r\n          savedLocals: info.savedLocals\r\n        }))\r\n      },\r\n\r\n      // Graph metrics\r\n      metrics: graphMetrics,\r\n\r\n      // Complete block information\r\n      blocks: sortedBlocks.map(block => {\r\n        const immediateDominator = this.getImmediateDominator(block);\r\n        const immediatePostDominator = this.getImmediatePostDominator(block);\r\n        const parentLoop = this.getParentLoop(block);\r\n        const childLoops = this.getChildLoops(block);\r\n        const dominanceFrontier = this.getDominanceFrontier(block);\r\n        const controlDependents = this.getControlDependents(block);\r\n        const naturalLoop = block.isLoopHeader ? this.getNaturalLoop(block) : null;\r\n        const reachableFrom = this.reachableFrom.get(block);\r\n        const reachesTo = this.reachesTo.get(block);\r\n\r\n        return {\r\n          // Basic information\r\n          id: block.id,\r\n          startAddress: block.startInstruction.address,\r\n          endAddress: block.endInstruction.address + (block.endInstruction.instructionSize || 0),\r\n          addressRange: {\r\n            start: block.startInstruction.address,\r\n            end: block.endInstruction.address + (block.endInstruction.instructionSize || 0),\r\n            size: (block.endInstruction.address + (block.endInstruction.instructionSize || 0)) - block.startInstruction.address\r\n          },\r\n          instructionCount: block.instructions.length,\r\n\r\n          // Block properties\r\n          properties: {\r\n            isEntry: block.isEntry,\r\n            isExit: block.isExit,\r\n            isLoopHeader: block.isLoopHeader,\r\n            isLoopBody: block.isLoopBody,\r\n            isUnreachable: block.isUnreachable,\r\n            exitType: block.exitType\r\n          },\r\n\r\n          // Control flow\r\n          controlFlow: {\r\n            depth: this.getBlockDepth(block),\r\n            loopDepth: this.getLoopDepth(block),\r\n            parentLoopId: parentLoop?.id ?? null,\r\n            childLoopIds: Array.from(childLoops).map(h => h.id).sort((a, b) => a - b),\r\n            naturalLoopBlockIds: naturalLoop ? Array.from(naturalLoop).map(b => b.id).sort((a, b) => a - b) : null,\r\n            successorIds: Array.from(block.successors).map(b => b.id).sort((a, b) => a - b),\r\n            predecessorIds: Array.from(block.predecessors).map(b => b.id).sort((a, b) => a - b)\r\n          },\r\n\r\n          // Dominance information\r\n          dominance: {\r\n            dominatorIds: Array.from(block.dominators).map(b => b.id).sort((a, b) => a - b),\r\n            immediateDominatorId: immediateDominator?.id ?? null,\r\n            postDominatorIds: Array.from(block.postDominators).map(b => b.id).sort((a, b) => a - b),\r\n            immediatePostDominatorId: immediatePostDominator?.id ?? null,\r\n            dominanceFrontierIds: Array.from(dominanceFrontier).map(b => b.id).sort((a, b) => a - b)\r\n          },\r\n\r\n          // Control dependence\r\n          controlDependence: {\r\n            dependentBlockIds: Array.from(controlDependents).map(b => b.id).sort((a, b) => a - b)\r\n          },\r\n\r\n          // Reachability\r\n          reachability: {\r\n            reachableFromIds: reachableFrom ? Array.from(reachableFrom).map(b => b.id).sort((a, b) => a - b) : [],\r\n            reachesToIds: reachesTo ? Array.from(reachesTo).map(b => b.id).sort((a, b) => a - b) : []\r\n          },\r\n\r\n          // Edges (detailed)\r\n          edges: this.getOrderedSuccessors(block).map(succ => {\r\n            const edge = this.getEdge(block, succ);\r\n            if (!edge) return null;\r\n            return {\r\n              toBlockId: succ.id,\r\n              type: edge.type,\r\n              isBackEdge: edge.isBackEdge,\r\n              isCritical: edge.isCritical,\r\n              condition: edge.condition,\r\n              weight: edge.weight,\r\n              conditionExpression: this.serializeConditionExpression(edge.conditionExpression)\r\n            };\r\n          }).filter(e => e !== null),\r\n\r\n          // Instructions (detailed, safely serialized)\r\n          instructions: block.instructions.map(instr => this.serializeInstruction(instr)),\r\n\r\n          // Condition instruction (if applicable, safely serialized)\r\n          conditionInstruction: block.conditionInstruction ? this.serializeInstruction(block.conditionInstruction) : null\r\n        };\r\n      }),\r\n\r\n      // Complete edge information\r\n      edges: Array.from(this.orderedEdges).map(edge => ({\r\n        fromBlockId: edge.from.id,\r\n        toBlockId: edge.to.id,\r\n        type: edge.type,\r\n        isBackEdge: edge.isBackEdge,\r\n        isCritical: edge.isCritical,\r\n        condition: edge.condition,\r\n        weight: edge.weight,\r\n        conditionExpression: edge.conditionExpression || null\r\n      })),\r\n\r\n      // Analysis results\r\n      analysis: {\r\n        // Back edges\r\n        backEdges: Array.from(this.backEdges).map(e => ({\r\n          fromBlockId: e.from.id,\r\n          toBlockId: e.to.id,\r\n          type: e.type\r\n        })),\r\n\r\n        // Critical edges\r\n        criticalEdges: Array.from(this.criticalEdges).map(e => ({\r\n          fromBlockId: e.from.id,\r\n          toBlockId: e.to.id,\r\n          type: e.type\r\n        })),\r\n\r\n        // Natural loops\r\n        naturalLoops: Array.from(this.naturalLoops.entries()).map(([header, loopBlocks]) => ({\r\n          headerBlockId: header.id,\r\n          blockIds: Array.from(loopBlocks).map(b => b.id).sort((a, b) => a - b),\r\n          size: loopBlocks.size\r\n        })),\r\n\r\n        // Loop nesting tree\r\n        loopNestingTree: Array.from(this.loopNestingTree.entries()).map(([block, parent]) => ({\r\n          blockId: block.id,\r\n          parentLoopHeaderId: parent?.id ?? null\r\n        })),\r\n\r\n        // Call and return edges\r\n        callEdges: Array.from(this.callEdges).map(e => ({\r\n          fromBlockId: e.from.id,\r\n          toBlockId: e.to.id\r\n        })),\r\n        returnEdges: Array.from(this.returnEdges).map(e => ({\r\n          fromBlockId: e.from.id,\r\n          toBlockId: e.to.id\r\n        })),\r\n\r\n        // Unreachable blocks\r\n        unreachableBlockIds: this.getUnreachableBlocks().map(b => b.id).sort((a, b) => a - b),\r\n\r\n        // Cycles\r\n        cycles: this.getAllCycles().map(cycle => cycle.map(b => b.id)),\r\n\r\n        // Strongly connected components\r\n        stronglyConnectedComponents: this.getStronglyConnectedComponents().map(scc => \r\n          Array.from(scc).map(b => b.id).sort((a, b) => a - b)\r\n        )\r\n      },\r\n\r\n      // Graph structure analysis\r\n      structure: {\r\n        isReducible: this.isReducible(),\r\n        irreducibleRegions: this.getIrreducibleRegions().map(region => \r\n          Array.from(region).map(b => b.id).sort((a, b) => a - b)\r\n        ),\r\n        mergeBlocks: sortedBlocks.filter(b => this.isMergeBlock(b)).map(b => b.id),\r\n        splitBlocks: sortedBlocks.filter(b => this.isSplitBlock(b)).map(b => b.id)\r\n      },\r\n\r\n      // Topological information\r\n      topological: {\r\n        dfsPreOrder: this.getDFSPreOrder().map(b => b.id),\r\n        dfsPostOrder: this.getDFSPostOrder().map(b => b.id),\r\n        topologicalOrder: this.getTopologicalOrder().map(b => b.id),\r\n        reversePostOrder: this.getReversePostOrder().map(b => b.id),\r\n        dominanceOrder: this.getDominanceOrder().map(b => b.id),\r\n        postDominanceOrder: this.getBlocksInPostDominanceOrder().map(b => b.id),\r\n        blocksByDepth: Array.from(this.getBlocksByDepth().entries()).map(([depth, blocks]) => ({\r\n          depth,\r\n          blockIds: blocks.map(b => b.id).sort((a, b) => a - b)\r\n        }))\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Compute dominance frontiers for all blocks\r\n   * The dominance frontier of block B is the set of blocks Y such that:\r\n   * - B dominates a predecessor of Y, but\r\n   * - B does not strictly dominate Y\r\n   */\r\n  private computeDominanceFrontiers(): void {\r\n    this.dominanceFrontiers.clear();\r\n\r\n    for (const block of this.blocks.values()) {\r\n      this.dominanceFrontiers.set(block, new Set());\r\n    }\r\n\r\n    for (const block of this.blocks.values()) {\r\n      // For each predecessor of block\r\n      for (const pred of block.predecessors) {\r\n        let runner = pred;\r\n        // Walk up the dominator tree until we reach block's immediate dominator\r\n        while (runner !== block && runner !== this.getImmediateDominator(block)) {\r\n          if (runner) {\r\n            this.dominanceFrontiers.get(runner)!.add(block);\r\n          }\r\n          runner = this.getImmediateDominator(runner);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the dominance frontier of a block\r\n   */\r\n  getDominanceFrontier(block: NWScriptBasicBlock): Set<NWScriptBasicBlock> {\r\n    return this.dominanceFrontiers.get(block) || new Set();\r\n  }\r\n\r\n  /**\r\n   * Compute iterated dominance frontier for a set of blocks\r\n   * This is the union of dominance frontiers, iterated until fixed point\r\n   */\r\n  getIteratedDominanceFrontier(blocks: Set<NWScriptBasicBlock>): Set<NWScriptBasicBlock> {\r\n    const df = new Set<NWScriptBasicBlock>();\r\n    const worklist = new Set(blocks);\r\n\r\n    while (worklist.size > 0) {\r\n      const current = Array.from(worklist)[0];\r\n      worklist.delete(current);\r\n\r\n      const frontier = this.getDominanceFrontier(current);\r\n      for (const block of frontier) {\r\n        if (!df.has(block)) {\r\n          df.add(block);\r\n          worklist.add(block);\r\n        }\r\n      }\r\n    }\r\n\r\n    return df;\r\n  }\r\n\r\n  /**\r\n   * Compute control dependences\r\n   * Block Y is control-dependent on block X if:\r\n   * - There exists a path from X to Y where all blocks except X and Y are post-dominated by Y\r\n   * - X is not post-dominated by Y\r\n   */\r\n  private computeControlDependences(): void {\r\n    this.controlDependences.clear();\r\n\r\n    for (const block of this.blocks.values()) {\r\n      this.controlDependences.set(block, new Set());\r\n    }\r\n\r\n    // For each block with multiple successors (control point)\r\n    for (const block of this.blocks.values()) {\r\n      if (block.successors.size <= 1) continue;\r\n\r\n      // For each successor\r\n      for (const succ of block.successors) {\r\n        // Find all blocks that are control-dependent on block via this successor\r\n        const visited = new Set<NWScriptBasicBlock>();\r\n        const worklist: NWScriptBasicBlock[] = [succ];\r\n\r\n        while (worklist.length > 0) {\r\n          const current = worklist.shift()!;\r\n          if (visited.has(current)) continue;\r\n          visited.add(current);\r\n\r\n          // If current is not post-dominated by block, it's control-dependent\r\n          if (!this.postDominates(block, current) && current !== block) {\r\n            this.controlDependences.get(block)!.add(current);\r\n          }\r\n\r\n          // Continue if current is post-dominated by block\r\n          if (this.postDominates(block, current)) {\r\n            for (const nextSucc of current.successors) {\r\n              if (!visited.has(nextSucc)) {\r\n                worklist.push(nextSucc);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get blocks that are control-dependent on the given block\r\n   */\r\n  getControlDependents(block: NWScriptBasicBlock): Set<NWScriptBasicBlock> {\r\n    return this.controlDependences.get(block) || new Set();\r\n  }\r\n\r\n  /**\r\n   * Get reverse control flow graph (edges reversed)\r\n   */\r\n  getReverseCFG(): NWScriptControlFlowGraph {\r\n    if (this.reverseCFG) {\r\n      return this.reverseCFG;\r\n    }\r\n\r\n    const reverse = new NWScriptControlFlowGraph(this.script);\r\n    \r\n    // Copy all blocks\r\n    for (const block of this.blocks.values()) {\r\n      reverse.blocks.set(block.id, block);\r\n      reverse.instructionToBlock.set(block.startInstruction.address, block);\r\n    }\r\n\r\n    // Reverse all edges\r\n    for (const edge of this.edges) {\r\n      const reverseEdge = reverse.addEdge(edge.to, edge.from, edge.type);\r\n      reverseEdge.isBackEdge = edge.isBackEdge;\r\n      reverseEdge.isCritical = edge.isCritical;\r\n      reverseEdge.condition = edge.condition;\r\n      reverseEdge.weight = edge.weight;\r\n    }\r\n\r\n    // Set entry/exit (swapped)\r\n    reverse.entryBlock = null; // Reverse has no single entry\r\n    for (const exitBlock of this.exitBlocks) {\r\n      // In reverse, exit blocks become potential entries\r\n      reverse.exitBlocks.add(exitBlock);\r\n    }\r\n\r\n    this.reverseCFG = reverse;\r\n    return reverse;\r\n  }\r\n\r\n  /**\r\n   * Build loop nesting tree and compute loop depths\r\n   */\r\n  private buildLoopNestingTree(): void {\r\n    this.loopNestingTree.clear();\r\n    this.loopDepth.clear();\r\n\r\n    // Initialize: no blocks are in loops\r\n    for (const block of this.blocks.values()) {\r\n      this.loopNestingTree.set(block, null);\r\n      this.loopDepth.set(block, 0);\r\n    }\r\n\r\n    // For each loop header, mark all blocks in its natural loop\r\n    for (const [header, loopBlocks] of this.naturalLoops) {\r\n      for (const block of loopBlocks) {\r\n        const currentParent = this.loopNestingTree.get(block);\r\n        const currentDepth = this.loopDepth.get(block) || 0;\r\n\r\n        // If block is already in a nested loop, check if this loop is more nested\r\n        if (currentParent && currentParent !== header) {\r\n          // Check if header is nested within currentParent's loop\r\n          const parentLoop = this.naturalLoops.get(currentParent);\r\n          if (parentLoop && parentLoop.has(header)) {\r\n            // This loop is more nested\r\n            this.loopNestingTree.set(block, header);\r\n            this.loopDepth.set(block, currentDepth + 1);\r\n          }\r\n        } else if (!currentParent) {\r\n          // Block not in any loop yet\r\n          this.loopNestingTree.set(block, header);\r\n          this.loopDepth.set(block, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get loop depth for a block (0 = not in a loop)\r\n   */\r\n  getLoopDepth(block: NWScriptBasicBlock): number {\r\n    return this.loopDepth.get(block) || 0;\r\n  }\r\n\r\n  /**\r\n   * Get parent loop header for a block (null if not in a loop)\r\n   */\r\n  getParentLoop(block: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    return this.loopNestingTree.get(block) || null;\r\n  }\r\n\r\n  /**\r\n   * Get child loops (nested loops) for a loop header\r\n   */\r\n  getChildLoops(header: NWScriptBasicBlock): Set<NWScriptBasicBlock> {\r\n    const children = new Set<NWScriptBasicBlock>();\r\n    \r\n    for (const [otherHeader, loopBlocks] of this.naturalLoops) {\r\n      if (otherHeader === header) continue;\r\n      \r\n      // Check if otherHeader's loop is nested within header's loop\r\n      const headerLoop = this.naturalLoops.get(header);\r\n      if (headerLoop && headerLoop.has(otherHeader)) {\r\n        children.add(otherHeader);\r\n      }\r\n    }\r\n\r\n    return children;\r\n  }\r\n\r\n  /**\r\n   * Compute and cache reachability sets\r\n   */\r\n  private computeReachabilitySets(): void {\r\n    this.reachableFrom.clear();\r\n    this.reachesTo.clear();\r\n\r\n    for (const block of this.blocks.values()) {\r\n      const reachable = this.getReachableSubgraph(block);\r\n      this.reachableFrom.set(block, reachable);\r\n\r\n      // Compute reverse reachability\r\n      const canReach = new Set<NWScriptBasicBlock>();\r\n      for (const otherBlock of this.blocks.values()) {\r\n        if (this.canReach(otherBlock, block)) {\r\n          canReach.add(otherBlock);\r\n        }\r\n      }\r\n      this.reachesTo.set(block, canReach);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track inter-procedural edges (call and return)\r\n   */\r\n  private trackInterProceduralEdges(): void {\r\n    // Already done in buildEdges(), but ensure they're tracked\r\n    this.callEdges.clear();\r\n    this.returnEdges.clear();\r\n\r\n    for (const edge of this.edges) {\r\n      if (edge.type === EdgeType.CALL) {\r\n        this.callEdges.add(edge);\r\n      } else if (edge.type === EdgeType.RETURN) {\r\n        this.returnEdges.add(edge);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all call edges\r\n   */\r\n  getCallEdges(): Set<NWScriptEdge> {\r\n    return this.callEdges;\r\n  }\r\n\r\n  /**\r\n   * Get all return edges\r\n   */\r\n  getReturnEdges(): Set<NWScriptEdge> {\r\n    return this.returnEdges;\r\n  }\r\n\r\n  /**\r\n   * Get call graph (graph of function calls)\r\n   */\r\n  getCallGraph(): Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>> {\r\n    const callGraph = new Map<NWScriptBasicBlock, Set<NWScriptBasicBlock>>();\r\n\r\n    for (const edge of this.callEdges) {\r\n      if (!callGraph.has(edge.from)) {\r\n        callGraph.set(edge.from, new Set());\r\n      }\r\n      callGraph.get(edge.from)!.add(edge.to);\r\n    }\r\n\r\n    return callGraph;\r\n  }\r\n\r\n  /**\r\n   * Get graph metrics/statistics\r\n   */\r\n  getGraphMetrics(): {\r\n    totalBlocks: number;\r\n    totalEdges: number;\r\n    cyclomaticComplexity: number;\r\n    averageBranchingFactor: number;\r\n    maxDepth: number;\r\n    loopCount: number;\r\n    unreachableBlocks: number;\r\n    criticalEdges: number;\r\n    backEdges: number;\r\n  } {\r\n    let totalSuccessors = 0;\r\n    let maxDepthValue = 0;\r\n\r\n    for (const block of this.blocks.values()) {\r\n      totalSuccessors += block.successors.size;\r\n      const depth = this.getBlockDepth(block);\r\n      if (depth > maxDepthValue) {\r\n        maxDepthValue = depth;\r\n      }\r\n    }\r\n\r\n    const cyclomaticComplexity = this.edges.size - this.blocks.size + 2;\r\n    const averageBranchingFactor = this.blocks.size > 0 ? totalSuccessors / this.blocks.size : 0;\r\n\r\n    return {\r\n      totalBlocks: this.blocks.size,\r\n      totalEdges: this.edges.size,\r\n      cyclomaticComplexity,\r\n      averageBranchingFactor,\r\n      maxDepth: maxDepthValue,\r\n      loopCount: this.naturalLoops.size,\r\n      unreachableBlocks: this.getUnreachableBlocks().length,\r\n      criticalEdges: this.criticalEdges.size,\r\n      backEdges: this.backEdges.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get blocks grouped by depth level\r\n   */\r\n  getBlocksByDepth(): Map<number, NWScriptBasicBlock[]> {\r\n    const byDepth = new Map<number, NWScriptBasicBlock[]>();\r\n\r\n    for (const block of this.blocks.values()) {\r\n      const depth = this.getBlockDepth(block);\r\n      if (!byDepth.has(depth)) {\r\n        byDepth.set(depth, []);\r\n      }\r\n      byDepth.get(depth)!.push(block);\r\n    }\r\n\r\n    return byDepth;\r\n  }\r\n\r\n  /**\r\n   * Get blocks in post-dominance order\r\n   */\r\n  getBlocksInPostDominanceOrder(): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const visit = (block: NWScriptBasicBlock) => {\r\n      if (visited.has(block)) return;\r\n      visited.add(block);\r\n\r\n      // Visit post-dominator children first\r\n      const children = Array.from(this.blocks.values()).filter(b =>\r\n        b !== block &&\r\n        this.postDominates(block, b) &&\r\n        this.getImmediatePostDominator(b) === block\r\n      );\r\n\r\n      for (const child of children.sort((a, b) => a.id - b.id)) {\r\n        visit(child);\r\n      }\r\n\r\n      result.push(block);\r\n    };\r\n\r\n    // Start from exit blocks\r\n    for (const exitBlock of this.exitBlocks) {\r\n      visit(exitBlock);\r\n    }\r\n\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Find all simple paths (paths without cycles) between two blocks\r\n   */\r\n  findAllSimplePaths(from: NWScriptBasicBlock, to: NWScriptBasicBlock): NWScriptBasicBlock[][] {\r\n    const paths: NWScriptBasicBlock[][] = [];\r\n    const currentPath: NWScriptBasicBlock[] = [];\r\n\r\n    const dfs = (current: NWScriptBasicBlock) => {\r\n      if (currentPath.includes(current)) {\r\n        return; // Cycle detected, skip\r\n      }\r\n\r\n      currentPath.push(current);\r\n\r\n      if (current === to) {\r\n        paths.push([...currentPath]);\r\n      } else {\r\n        for (const successor of current.successors) {\r\n          dfs(successor);\r\n        }\r\n      }\r\n\r\n      currentPath.pop();\r\n    };\r\n\r\n    dfs(from);\r\n    return paths;\r\n  }\r\n\r\n  /**\r\n   * Find all paths avoiding certain blocks\r\n   */\r\n  findAllPathsAvoiding(from: NWScriptBasicBlock, to: NWScriptBasicBlock, avoidBlocks: Set<NWScriptBasicBlock>): NWScriptBasicBlock[][] {\r\n    const paths: NWScriptBasicBlock[][] = [];\r\n    const currentPath: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const dfs = (current: NWScriptBasicBlock) => {\r\n      if (avoidBlocks.has(current) || visited.has(current)) return;\r\n\r\n      if (current === to) {\r\n        paths.push([...currentPath, current]);\r\n        return;\r\n      }\r\n\r\n      visited.add(current);\r\n      currentPath.push(current);\r\n\r\n      for (const successor of current.successors) {\r\n        dfs(successor);\r\n      }\r\n\r\n      currentPath.pop();\r\n      visited.delete(current);\r\n    };\r\n\r\n    dfs(from);\r\n    return paths;\r\n  }\r\n\r\n  /**\r\n   * Find shortest path between two blocks (BFS-based)\r\n   */\r\n  findShortestPath(from: NWScriptBasicBlock, to: NWScriptBasicBlock): NWScriptBasicBlock[] | null {\r\n    if (from === to) return [from];\r\n\r\n    const queue: NWScriptBasicBlock[] = [from];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const parent = new Map<NWScriptBasicBlock, NWScriptBasicBlock | null>();\r\n    parent.set(from, null);\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (visited.has(current)) continue;\r\n      visited.add(current);\r\n\r\n      if (current === to) {\r\n        // Reconstruct path\r\n        const path: NWScriptBasicBlock[] = [];\r\n        let node: NWScriptBasicBlock | null = to;\r\n        while (node !== null) {\r\n          path.unshift(node);\r\n          node = parent.get(node) || null;\r\n        }\r\n        return path;\r\n      }\r\n\r\n      for (const successor of current.successors) {\r\n        if (!visited.has(successor) && !parent.has(successor)) {\r\n          parent.set(successor, current);\r\n          queue.push(successor);\r\n        }\r\n      }\r\n    }\r\n\r\n    return null; // No path found\r\n  }\r\n\r\n  /**\r\n   * Get all cycles in the graph\r\n   */\r\n  getAllCycles(): NWScriptBasicBlock[][] {\r\n    const cycles: NWScriptBasicBlock[][] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const recStack = new Set<NWScriptBasicBlock>();\r\n    const path: NWScriptBasicBlock[] = [];\r\n\r\n    const dfs = (block: NWScriptBasicBlock) => {\r\n      if (recStack.has(block)) {\r\n        // Found a cycle\r\n        const cycleStart = path.indexOf(block);\r\n        if (cycleStart !== -1) {\r\n          cycles.push([...path.slice(cycleStart), block]);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (visited.has(block)) return;\r\n\r\n      visited.add(block);\r\n      recStack.add(block);\r\n      path.push(block);\r\n\r\n      for (const successor of block.successors) {\r\n        dfs(successor);\r\n      }\r\n\r\n      path.pop();\r\n      recStack.delete(block);\r\n    };\r\n\r\n    for (const block of this.blocks.values()) {\r\n      if (!visited.has(block)) {\r\n        dfs(block);\r\n      }\r\n    }\r\n\r\n    return cycles;\r\n  }\r\n\r\n  /**\r\n   * Check if a block is in a cycle\r\n   */\r\n  isInCycle(block: NWScriptBasicBlock): boolean {\r\n    const cycles = this.getAllCycles();\r\n    return cycles.some(cycle => cycle.includes(block));\r\n  }\r\n\r\n  /**\r\n   * Get ordered successors (by address)\r\n   */\r\n  getOrderedSuccessors(block: NWScriptBasicBlock): NWScriptBasicBlock[] {\r\n    return Array.from(block.successors).sort((a, b) => \r\n      a.startInstruction.address - b.startInstruction.address\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get ordered predecessors (by address)\r\n   */\r\n  getOrderedPredecessors(block: NWScriptBasicBlock): NWScriptBasicBlock[] {\r\n    return Array.from(block.predecessors).sort((a, b) =>\r\n      a.startInstruction.address - b.startInstruction.address\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get all blocks in deterministic order (by start address)\r\n   */\r\n  getBlocksInOrder(): NWScriptBasicBlock[] {\r\n    return Array.from(this.blocks.values())\r\n      .sort((a, b) => a.startInstruction.address - b.startInstruction.address);\r\n  }\r\n\r\n  /**\r\n   * Get intra-procedural successors (excluding CALL edges)\r\n   * @param block The block to get successors for\r\n   * @param excludeReturn Whether to also exclude RETURN edges (default: false)\r\n   */\r\n  getIntraProceduralSuccessors(block: NWScriptBasicBlock, excludeReturn: boolean = false): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    for (const succ of this.getOrderedSuccessors(block)) {\r\n      const edge = this.getEdge(block, succ);\r\n      if (edge) {\r\n        if (edge.type === EdgeType.CALL) {\r\n          continue; // Skip call edges\r\n        }\r\n        if (excludeReturn && edge.type === EdgeType.RETURN) {\r\n          continue; // Skip return edges if requested\r\n        }\r\n        result.push(succ);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get intra-procedural predecessors (excluding RETURN edges)\r\n   * @param block The block to get predecessors for\r\n   * @param excludeCall Whether to also exclude CALL edges (default: false)\r\n   */\r\n  getIntraProceduralPredecessors(block: NWScriptBasicBlock, excludeCall: boolean = false): NWScriptBasicBlock[] {\r\n    const result: NWScriptBasicBlock[] = [];\r\n    for (const pred of this.getOrderedPredecessors(block)) {\r\n      const edge = this.getEdge(pred, block);\r\n      if (edge) {\r\n        if (edge.type === EdgeType.RETURN) {\r\n          continue; // Skip return edges\r\n        }\r\n        if (excludeCall && edge.type === EdgeType.CALL) {\r\n          continue; // Skip call edges if requested\r\n        }\r\n        result.push(pred);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get condition expression for an edge (if available)\r\n   */\r\n  getConditionExpression(edge: NWScriptEdge): NWScriptExpression | null {\r\n    return edge.conditionExpression ?? null;\r\n  }\r\n\r\n  /**\r\n   * Set condition expression for an edge\r\n   */\r\n  setConditionExpression(edge: NWScriptEdge, expression: NWScriptExpression | null): void {\r\n    edge.conditionExpression = expression ?? undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a block is a merge block (multiple predecessors, single successor)\r\n   */\r\n  isMergeBlock(block: NWScriptBasicBlock): boolean {\r\n    return block.predecessors.size > 1 && block.successors.size === 1;\r\n  }\r\n\r\n  /**\r\n   * Check if a block is a split block (single predecessor, multiple successors)\r\n   */\r\n  isSplitBlock(block: NWScriptBasicBlock): boolean {\r\n    return block.predecessors.size === 1 && block.successors.size > 1;\r\n  }\r\n\r\n  /**\r\n   * Check if CFG is reducible\r\n   * A reducible CFG can be reduced to a single node by repeatedly:\r\n   * - Removing self-loops\r\n   * - Merging nodes with single predecessor\r\n   * - Removing nodes with no predecessors (except entry)\r\n   */\r\n  isReducible(): boolean {\r\n    // A CFG is reducible if all loops are natural loops (have a single entry point)\r\n    // Check if all back edges have their target as a loop header\r\n    for (const backEdge of this.backEdges) {\r\n      const header = backEdge.to;\r\n      if (!header.isLoopHeader) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Additional check: try to reduce the graph\r\n    const worklist = new Set(this.blocks.values());\r\n    let changed = true;\r\n\r\n    while (changed && worklist.size > 0) {\r\n      changed = false;\r\n\r\n      for (const block of Array.from(worklist)) {\r\n        // Remove self-loops\r\n        if (block.successors.has(block)) {\r\n          this.removeEdge(block, block);\r\n          changed = true;\r\n        }\r\n\r\n        // Merge nodes with single predecessor (except entry)\r\n        if (block !== this.entryBlock && block.predecessors.size === 1) {\r\n          const pred = Array.from(block.predecessors)[0];\r\n          // Can merge if pred has single successor\r\n          if (pred.successors.size === 1) {\r\n            // Merge logic would go here (complex, simplified check)\r\n            worklist.delete(block);\r\n            changed = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return worklist.size <= 1; // Should reduce to entry block\r\n  }\r\n\r\n  /**\r\n   * Get irreducible regions (regions that cannot be reduced)\r\n   */\r\n  getIrreducibleRegions(): Set<NWScriptBasicBlock>[] {\r\n    const regions: Set<NWScriptBasicBlock>[] = [];\r\n    \r\n    if (this.isReducible()) {\r\n      return regions;\r\n    }\r\n\r\n    // Find strongly connected components that are not natural loops\r\n    const sccs = this.getStronglyConnectedComponents();\r\n    \r\n    for (const scc of sccs) {\r\n      if (scc.size > 1) {\r\n        // Check if this SCC is a natural loop\r\n        let isNaturalLoop = false;\r\n        for (const [header, loopBlocks] of this.naturalLoops) {\r\n          if (scc.has(header) && Array.from(scc).every(b => loopBlocks.has(b))) {\r\n            isNaturalLoop = true;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (!isNaturalLoop) {\r\n          regions.push(scc);\r\n        }\r\n      }\r\n    }\r\n\r\n    return regions;\r\n  }\r\n\r\n  /**\r\n   * Add a block to the CFG (for incremental updates)\r\n   */\r\n  addBlock(block: NWScriptBasicBlock): void {\r\n    this.blocks.set(block.id, block);\r\n    this.instructionToBlock.set(block.startInstruction.address, block);\r\n    this.invalidateCaches();\r\n  }\r\n\r\n  /**\r\n   * Remove a block from the CFG (for incremental updates)\r\n   */\r\n  removeBlock(block: NWScriptBasicBlock): void {\r\n    // Remove all edges connected to this block\r\n    for (const succ of Array.from(block.successors)) {\r\n      this.removeEdge(block, succ);\r\n    }\r\n    for (const pred of Array.from(block.predecessors)) {\r\n      this.removeEdge(pred, block);\r\n    }\r\n\r\n    this.blocks.delete(block.id);\r\n    this.instructionToBlock.delete(block.startInstruction.address);\r\n    this.invalidateCaches();\r\n  }\r\n\r\n  /**\r\n   * Update an edge (for incremental updates)\r\n   */\r\n  updateEdge(from: NWScriptBasicBlock, to: NWScriptBasicBlock, type?: EdgeType, weight?: number): void {\r\n    const edge = this.getEdge(from, to);\r\n    if (edge) {\r\n      if (type !== undefined) {\r\n        edge.type = type;\r\n      }\r\n      if (weight !== undefined) {\r\n        edge.weight = weight;\r\n      }\r\n      this.invalidateCaches();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate cached computations\r\n   */\r\n  private invalidateCaches(): void {\r\n    this.invalidated.add('dominance');\r\n    this.invalidated.add('postDominance');\r\n    this.invalidated.add('reachability');\r\n    this.invalidated.add('loops');\r\n    this.reverseCFG = null;\r\n  }\r\n\r\n  /**\r\n   * Static method to deserialize CFG from JSON\r\n   */\r\n  /** Rebuild CFG from script; json is from external source (e.g. JSON.parse). */\r\n  static fromJSON(json: unknown, script: NWScript): NWScriptControlFlowGraph {\r\n    const cfg = new NWScriptControlFlowGraph(script);\r\n    \r\n    // Note: This is a simplified deserialization\r\n    // Full deserialization would require reconstructing instructions and blocks\r\n    // For now, we'll just rebuild the CFG from the script\r\n    cfg.build();\r\n    \r\n    return cfg;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptControlNodeToASTConverter.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":268,"column":46,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":268,"endColumn":103},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":431,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":431,"endColumn":58},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":469,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":469,"endColumn":93}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\nimport { NWScriptANDChainDetector } from \"@/nwscript/decompiler/NWScriptANDChainDetector\";\nimport { NWScriptAST, NWScriptASTNodeType, type NWScriptASTNode, type NWScriptProgramNode, type NWScriptFunctionNode, type NWScriptBlockNode, type NWScriptIfNode, type NWScriptIfElseNode, type NWScriptWhileNode, type NWScriptDoWhileNode, type NWScriptForNode, type NWScriptSwitchNode, type NWScriptSwitchCaseNode, type NWScriptSwitchDefaultNode, type NWScriptExpressionStatementNode, type NWScriptAssignmentNode, type NWScriptReturnNode, type NWScriptBreakNode, type NWScriptContinueNode, NWScriptGlobalVariableDeclarationNode, NWScriptVariableDeclarationNode } from \"@/nwscript/decompiler/NWScriptAST\";\nimport type { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\nimport type { NWScriptControlFlowGraph } from \"@/nwscript/decompiler/NWScriptControlFlowGraph\";\nimport type { ControlNode, BasicBlockNode, IfNode, IfElseNode, WhileNode, DoWhileNode, ForNode, SwitchNode, SequenceNode , NWScriptControlStructureBuilder } from \"@/nwscript/decompiler/NWScriptControlStructureBuilder\";\nimport { NWScriptExpression } from \"@/nwscript/decompiler/NWScriptExpression\";\nimport { NWScriptExpressionBuilder } from \"@/nwscript/decompiler/NWScriptExpressionBuilder\";\nimport type { NWScriptFunction } from \"@/nwscript/decompiler/NWScriptFunctionAnalyzer\";\nimport type { NWScriptGlobalInit } from \"@/nwscript/decompiler/NWScriptGlobalVariableAnalyzer\";\nimport type { NWScriptLocalInit } from \"@/nwscript/decompiler/NWScriptLocalVariableAnalyzer\";\nimport { NWScriptStackSimulator } from \"@/nwscript/decompiler/NWScriptStackSimulator\";\nimport type { NWScriptInstruction } from '@/nwscript/NWScriptInstruction';\nimport { OP_RETN, OP_JMP, OP_CPDOWNSP, OP_MOVSP, OP_RSADD, OP_CPTOPSP, OP_CPTOPBP, OP_EQUAL, OP_NEQUAL, OP_GT, OP_GEQ, OP_LT, OP_LEQ, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_LOGANDII, OP_LOGORII, OP_JSR, OP_JZ, OP_JNZ, OP_CONST, OP_ACTION } from '@/nwscript/NWScriptOPCodes';\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\n\n\nconst log = createScopedLogger(LogScope.NWScript);\n\n/**\n * Converts ControlNode tree to NWScriptASTNode tree.\n * This is the bridge between the control flow structure and the abstract syntax tree.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file NWScriptControlNodeToASTConverter.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class NWScriptControlNodeToASTConverter {\n  private cfg: NWScriptControlFlowGraph;\n  private functions: NWScriptFunction[];\n  private globalInits: NWScriptGlobalInit[];\n  private localInits: NWScriptLocalInit[];\n  private expressionBuilder: NWScriptExpressionBuilder;\n  private stackSimulator: NWScriptStackSimulator;\n  private andChainDetector: NWScriptANDChainDetector;\n\n  /**\n   * Map from blocks to their function context (for variable resolution)\n   */\n  private blockToFunction: Map<NWScriptBasicBlock, NWScriptFunction | null> = new Map();\n\n  /**\n   * Map from blocks to statements (cached)\n   */\n  private blockStatements: Map<NWScriptBasicBlock, NWScriptASTNode[]> = new Map();\n\n  /**\n   * Map from RETN blocks to their return value expressions\n   * Used to preserve return values across blocks\n   */\n  private returnValueExpressions: Map<NWScriptBasicBlock, NWScriptExpression> = new Map();\n\n  /**\n   * Map from function to the return value stack position offset\n   * The return value position is where RSADD reserved space before the JSR that calls the function\n   * This is stored as an offset from the function's entry stack pointer\n   * Key: function (null for main function)\n   * Value: offset from function entry stack pointer where return value should be written\n   */\n  private functionReturnValueOffsets: Map<NWScriptFunction | null, number> = new Map();\n\n  /**\n   * Map from function to the function entry stack pointer\n   * Used to calculate absolute return value position from offset\n   */\n  private functionEntryStackPointers: Map<NWScriptFunction | null, number> = new Map();\n\n  /**\n   * Track where variables live on the stack per function\n   * Maps function -> stack position -> variable index\n   * Key: stack position (absolute address where variable lives)\n   * Value: variable index in localInits array\n   */\n  private functionVariableStackPositions: Map<NWScriptFunction | null, Map<number, number>> = new Map();\n\n  /**\n   * Track variable allocations per function\n   * Maps function to the number of variables allocated so far\n   */\n  private functionVariableCounts: Map<NWScriptFunction | null, number> = new Map();\n\n  /**\n   * Track the current function being processed\n   * Used to maintain stack state across blocks\n   */\n  private currentFunction: NWScriptFunction | null = null;\n\n  /**\n   * Track if stack has been initialized for current function\n   * Prevents re-initialization when processing multiple blocks\n   */\n  private functionStackInitialized: Set<NWScriptFunction | null> = new Set();\n\n  constructor(\n    cfg: NWScriptControlFlowGraph,\n    functions: NWScriptFunction[] = [],\n    globalInits: NWScriptGlobalInit[] = [],\n    localInits: NWScriptLocalInit[] = []\n  ) {\n    this.cfg = cfg;\n    this.functions = functions;\n    this.globalInits = globalInits;\n    this.localInits = localInits;\n\n    // Initialize expression builder and stack simulator with variable mappings\n    this.expressionBuilder = new NWScriptExpressionBuilder();\n    this.stackSimulator = new NWScriptStackSimulator();\n    this.andChainDetector = new NWScriptANDChainDetector();\n\n    this.setupVariableMappings();\n    this.buildBlockToFunctionMap();\n  }\n\n  /**\n   * Setup variable mappings for expression builder and stack simulator\n   */\n  private setupVariableMappings(): void {\n    // Setup global variables\n    const globalVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n    for (let i = 0; i < this.globalInits.length; i++) {\n      const init = this.globalInits[i];\n      const varName = `globalVar_${i}`;\n      const offsetSigned = init.offset > 0x7FFFFFFF ? init.offset - 0x100000000 : init.offset;\n      globalVarMap.set(offsetSigned, { name: varName, dataType: init.dataType });\n    }\n    this.expressionBuilder.setGlobalVariables(globalVarMap);\n    this.stackSimulator.setGlobalVariables(globalVarMap);\n\n    // Setup local variables (per function)\n    // This will be done per-function when processing\n  }\n\n  /**\n   * Set function parameters for expression builder and stack simulator\n   */\n  private setFunctionParametersForBuilders(func: NWScriptFunction): void {\n    // Both ExpressionBuilder and StackSimulator expect an array\n    this.expressionBuilder.setFunctionParameters(func.parameters);\n    this.stackSimulator.setFunctionParameters(func.parameters);\n  }\n\n  /**\n   * Build map from blocks to their containing function\n   */\n  private buildBlockToFunctionMap(): void {\n    this.blockToFunction.clear();\n\n    for (const func of this.functions) {\n      for (const block of func.bodyBlocks) {\n        this.blockToFunction.set(block, func);\n      }\n    }\n  }\n\n  /**\n   * Convert ControlNode tree to AST Program node\n   * @param mainControlNode The ControlNode tree for the main function\n   * @param structureBuilder The structure builder (needed to build ControlNode trees for functions)\n   */\n  convertToAST(mainControlNode: ControlNode, structureBuilder: NWScriptControlStructureBuilder): NWScriptProgramNode {\n    // Build global variable declarations\n    const globalVars = this.buildGlobalVariableDeclarations();\n\n    // Build function nodes (including main function)\n    // The main function should be output as a function, not as mainBody\n    const functionNodes = this.buildFunctionNodes(structureBuilder, mainControlNode);\n\n    // Main body should only be used if there's code outside of functions\n    // For now, we'll leave it undefined since all code is in functions\n    const mainBody: NWScriptBlockNode | undefined = undefined;\n\n    // Create program node\n    const program = NWScriptAST.createProgram(globalVars, functionNodes, mainBody);\n\n    // Build parent relationships\n    NWScriptAST.buildParentRelationships(program);\n\n    return program;\n  }\n\n  /**\n   * Convert a ControlNode to an AST Block node\n   */\n  convertControlNodeToBlock(controlNode: ControlNode, functionContext: NWScriptFunction | null): NWScriptBlockNode {\n    const statements: NWScriptASTNode[] = [];\n\n    // Initialize stack state for this function if not already done\n    // This ensures stack state persists across blocks within the same function\n    if (functionContext !== this.currentFunction) {\n      // New function - reset stack state\n      this.currentFunction = functionContext;\n      this.stackSimulator.clear();\n      this.functionStackInitialized.delete(functionContext);\n\n      // Initialize variable tracking for this function\n      if (!this.functionVariableCounts.has(functionContext)) {\n        this.functionVariableCounts.set(functionContext, 0);\n      }\n      if (!this.functionVariableStackPositions.has(functionContext)) {\n        this.functionVariableStackPositions.set(functionContext, new Map());\n      }\n    }\n\n    // Setup function context for variable resolution\n    if (functionContext && !this.functionStackInitialized.has(functionContext)) {\n      this.setupFunctionContext(functionContext);\n      this.functionStackInitialized.add(functionContext);\n    }\n\n    // Convert the control node to statements\n    this.convertControlNode(controlNode, functionContext, statements);\n\n    return NWScriptAST.createBlock(statements);\n  }\n\n  /**\n   * Convert a ControlNode to AST nodes (recursive)\n   */\n  private convertControlNode(\n    controlNode: ControlNode,\n    functionContext: NWScriptFunction | null,\n    statements: NWScriptASTNode[]\n  ): void {\n    log.info(`[ControlNode] Converting ${controlNode.type} node`);\n    switch (controlNode.type) {\n      case 'basic_block':\n        log.info(`[ControlNode] Processing basic_block node, block ID: ${controlNode.block.id}, instructions: ${controlNode.block.instructions.length}`);\n        this.convertBasicBlock(controlNode, functionContext, statements);\n        break;\n\n      case 'if':\n        // CRITICAL: Process header block first to handle RSADD and assignments\n        // The header block may contain variable declarations before the condition\n        // We need to process these BEFORE the if statement is created\n        const ifNode = controlNode as IfNode;\n        if (ifNode.condition.type === 'basic_block') {\n          const headerBlock = ifNode.condition.block;\n          const conditionInstr = headerBlock.conditionInstruction;\n\n          if (conditionInstr) {\n            // Process instructions BEFORE the condition instruction\n            // These are variable declarations, assignments, etc.\n            const preConditionInstructions = headerBlock.instructions.filter(instr =>\n              instr.address < conditionInstr.address\n            );\n\n            if (preConditionInstructions.length > 0) {\n              log.info(`[ControlNode] Processing ${preConditionInstructions.length} pre-condition instructions in if header block ${headerBlock.id}`);\n\n              // Process these instructions using convertBasicBlock logic\n              // But we need to process them in the context of the current function\n              // Create a temporary basic block node for just the pre-condition instructions\n              // Actually, we should just process them directly using the same logic as convertBasicBlock\n\n              // Initialize if needed\n              if (!this.functionVariableCounts.has(functionContext)) {\n                this.functionVariableCounts.set(functionContext, 0);\n              }\n              if (!this.functionVariableStackPositions.has(functionContext)) {\n                this.functionVariableStackPositions.set(functionContext, new Map());\n              }\n\n              // Get the variable stack positions map for this function\n              const variableStackPositions = this.functionVariableStackPositions.get(functionContext)!;\n\n              const preConditionStatements: NWScriptASTNode[] = [];\n\n              // Process each pre-condition instruction\n              // Update stack simulator's variable position map for stack-aware resolution\n              this.stackSimulator.setVariableStackPositions(variableStackPositions);\n              this.stackSimulator.setLocalVariableInits(this.localInits);\n\n              // Also update expression builder for consistency\n              this.expressionBuilder.setVariableStackPositions(variableStackPositions);\n              this.expressionBuilder.setLocalVariableInits(this.localInits);\n              this.expressionBuilder.setStackPointer(this.stackSimulator.getStackPointer());\n\n              for (const instr of preConditionInstructions) {\n                // Track RSADD BEFORE processing\n                let isRsadd = false;\n                if (instr.code === OP_RSADD) {\n                  isRsadd = true;\n                  const stackPosBeforeRsadd = this.stackSimulator.getStackPointer();\n                  const currentCount = this.functionVariableCounts.get(functionContext) || 0;\n\n                  log.info(`[RSADD] Address: 0x${instr.address.toString(16).padStart(8, '0')}, SP before: ${stackPosBeforeRsadd}, Variable index: ${currentCount}`);\n\n                  variableStackPositions.set(stackPosBeforeRsadd, currentCount);\n                  this.functionVariableCounts.set(functionContext, currentCount + 1);\n\n                  // Update the stack simulator's map after recording the new variable\n                  this.stackSimulator.setVariableStackPositions(variableStackPositions);\n                  this.expressionBuilder.setVariableStackPositions(variableStackPositions);\n                  this.expressionBuilder.setStackPointer(this.stackSimulator.getStackPointer());\n\n                  // Process RSADD instruction\n                  this.stackSimulator.processInstruction(instr);\n                  continue; // Skip creating statements for RSADD\n                }\n\n                // Check for CPDOWNSP assignments\n                // CRITICAL: Calculate target position BEFORE processing the instruction\n                // CPDOWNSP writes to stack[SP + offset] where SP is BEFORE the instruction\n                if (instr.code === OP_CPDOWNSP) {\n                  // Get SP BEFORE processing the instruction\n                  const spBefore = this.stackSimulator.getStackPointer();\n                  const offset = instr.offset || 0;\n                  const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\n                  const targetStackPos = spBefore + offsetSigned;\n\n                  // Now process the instruction\n                  const processedExpr = this.stackSimulator.processInstruction(instr);\n                  const valueExpr = processedExpr || this.stackSimulator.peek()?.expression;\n                  if (valueExpr) {\n                    log.info(`[CPDOWNSP] Pre-condition: Address: 0x${instr.address.toString(16).padStart(8, '0')}, SP before: ${spBefore}, Offset: ${offsetSigned}, Target pos: ${targetStackPos}`);\n                    log.info(`[CPDOWNSP] Pre-condition: Variable positions:`, Array.from(variableStackPositions.entries()).map(([pos, idx]) => `pos ${pos} -> var ${idx}`).join(', '));\n\n                    const varIndex = variableStackPositions.get(targetStackPos);\n                    log.info(`[CPDOWNSP] Pre-condition: Looking up variable at position ${targetStackPos}: found index ${varIndex}`);\n\n                    if (varIndex !== undefined && varIndex >= 0 && varIndex < this.localInits.length) {\n                      const varName = `localVar_${varIndex}`;\n                      log.info(`[CPDOWNSP] Pre-condition:  Creating assignment: ${varName} = <expression>`);\n                      preConditionStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n                      continue;\n                    }\n\n                    // Try nearby positions (stack-aware tolerance)\n                    for (let delta = -4; delta <= 4; delta += 4) {\n                      const nearbyPos = targetStackPos + delta;\n                      const nearbyVarIndex = variableStackPositions.get(nearbyPos);\n                      if (nearbyVarIndex !== undefined && nearbyVarIndex >= 0 && nearbyVarIndex < this.localInits.length) {\n                        const varName = `localVar_${nearbyVarIndex}`;\n                        log.info(`[CPDOWNSP] Pre-condition:  Found nearby variable at position ${nearbyPos} (delta ${delta}): ${varName}`);\n                        preConditionStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n                        continue;\n                      }\n                    }\n\n                    // Stack-aware fallback: Check all variable positions with tolerance\n                    // The stack may have grown between RSADD and CPDOWNSP, so check all recorded positions\n                    for (const [varPos, varIndex] of variableStackPositions.entries()) {\n                      const distance = Math.abs(targetStackPos - varPos);\n                      // Allow tolerance (8 bytes) since the stack may have grown\n                      if (distance <= 8 && varIndex >= 0 && varIndex < this.localInits.length) {\n                        const varName = `localVar_${varIndex}`;\n                        log.info(`[CPDOWNSP] Pre-condition:  Found variable by position proximity: ${varName} (distance: ${distance})`);\n                        preConditionStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n                        continue;\n                      }\n                    }\n\n                    log.info(`[CPDOWNSP] Pre-condition:  No variable found for assignment at position ${targetStackPos}`);\n                  }\n                  continue; // Skip adding as expression statement\n                }\n\n                // Process other instructions\n                const expr = this.stackSimulator.processInstruction(instr);\n\n                // Skip creating expression statements for intermediate values in pre-condition processing\n                // These are typically:\n                // - String constants (function parameters)\n                // - Function call results that will be assigned\n                // - Intermediate expressions that are part of larger expressions\n                // We only want to output statements that are meaningful (assignments, function calls with side effects, etc.)\n                // For now, skip all expression statements in pre-condition processing\n                // They will be handled as part of assignments or condition extraction\n                // The condition expression will be extracted separately\n              }\n\n              // Add pre-condition statements to parent\n              statements.push(...preConditionStatements);\n              log.info(`[ControlNode] Added ${preConditionStatements.length} pre-condition statements before if`);\n            }\n          }\n        }\n\n        // Now create the if node (condition extraction will work correctly)\n        // But we need to prevent duplicate processing of the header block\n        statements.push(this.convertIfNode(controlNode, functionContext));\n        break;\n\n      case 'if_else':\n        statements.push(this.convertIfElseNode(controlNode, functionContext));\n        break;\n\n      case 'while':\n        statements.push(this.convertWhileNode(controlNode, functionContext));\n        break;\n\n      case 'do_while':\n        statements.push(this.convertDoWhileNode(controlNode, functionContext));\n        break;\n\n      case 'for':\n        statements.push(this.convertForNode(controlNode, functionContext));\n        break;\n\n      case 'switch':\n        statements.push(this.convertSwitchNode(controlNode, functionContext));\n        break;\n\n      case 'sequence':\n        // Convert each node in sequence\n        log.info(`[ControlNode] Processing sequence node with ${controlNode.nodes.length} nodes`);\n        for (let i = 0; i < controlNode.nodes.length; i++) {\n          log.info(`[ControlNode] Sequence node ${i + 1}/${controlNode.nodes.length}: ${controlNode.nodes[i].type}`);\n          this.convertControlNode(controlNode.nodes[i], functionContext, statements);\n        }\n        break;\n    }\n  }\n\n  /**\n   * Convert a basic block to AST statements\n   */\n  private convertBasicBlock(\n    blockNode: BasicBlockNode,\n    functionContext: NWScriptFunction | null,\n    statements: NWScriptASTNode[]\n  ): void {\n    const block = blockNode.block;\n\n    // Check if we've already processed this block\n    if (this.blockStatements.has(block)) {\n      statements.push(...this.blockStatements.get(block)!);\n      return;\n    }\n\n    // Setup function context if available\n    if (!functionContext) {\n      functionContext = this.blockToFunction.get(block) || null;\n      if (functionContext) {\n        this.setupFunctionContext(functionContext);\n      }\n    }\n\n    // Process instructions in the block\n    const blockStatements: NWScriptASTNode[] = [];\n\n    // IMPORTANT: Do NOT clear the stack simulator between blocks in the same function\n    // Stack state must persist across blocks so that:\n    // 1. Variables allocated in earlier blocks remain accessible\n    // 2. Stack positions remain consistent\n    // 3. Variable-to-stack-position mappings remain valid\n    //\n    // Stack is only cleared when entering a new function (handled in convertControlNodeToBlock)\n\n    // Ensure function context is set up (should already be done, but double-check)\n    if (functionContext && !this.functionStackInitialized.has(functionContext)) {\n      this.setupFunctionContext(functionContext);\n      this.functionStackInitialized.add(functionContext);\n    }\n\n    // Initialize variable tracking for this function if not already set\n    if (!this.functionVariableCounts.has(functionContext)) {\n      this.functionVariableCounts.set(functionContext, 0);\n    }\n    if (!this.functionVariableStackPositions.has(functionContext)) {\n      this.functionVariableStackPositions.set(functionContext, new Map());\n    }\n\n    // Get the variable stack positions map for this function\n    const variableStackPositions = this.functionVariableStackPositions.get(functionContext)!;\n\n    // Update the stack simulator's variable position map for stack-aware CPTOPSP resolution\n    // This must be done at the start of each block to ensure accurate variable resolution\n    this.stackSimulator.setVariableStackPositions(variableStackPositions);\n    this.stackSimulator.setLocalVariableInits(this.localInits);\n\n    // Also update expression builder for consistency (if it's used)\n    this.expressionBuilder.setVariableStackPositions(variableStackPositions);\n    this.expressionBuilder.setLocalVariableInits(this.localInits);\n    this.expressionBuilder.setStackPointer(this.stackSimulator.getStackPointer());\n\n    log.info(`[Block] Processing block ${block.id} (${block.instructions.length} instructions), Function: ${functionContext?.name || 'main'}`);\n    log.info(`[Block] Initial stack state - SP: ${this.stackSimulator.getStackPointer()}, Stack size: ${this.stackSimulator.getStackSize()}`);\n    log.info(`[Block] Variable count: ${this.functionVariableCounts.get(functionContext) || 0}`);\n    log.info(`[Block] Variable positions:`, Array.from(variableStackPositions.entries()).map(([pos, idx]) => `pos ${pos} -> var ${idx}`).join(', ') || 'none');\n\n    // Track if we're processing a return value assignment\n    let returnValueExpr: NWScriptExpression | undefined = undefined;\n    const retnBlock: NWScriptBasicBlock | null = null;\n\n    log.info(`[Block] Block ${block.id} instructions:`, block.instructions.map(instr => `0x${instr.address.toString(16).padStart(8, '0')} ${instr.code === OP_RSADD ? 'RSADD' : instr.code === OP_CPDOWNSP ? 'CPDOWNSP' : 'other'}`).join(', '));\n\n    for (let i = 0; i < block.instructions.length; i++) {\n      const instruction = block.instructions[i];\n\n      // Track variable allocations (RSADD reserves space for a variable)\n      // IMPORTANT: Do this BEFORE processing the instruction, so we capture the stack position\n      // where the variable will live (before RSADD pushes the default value)\n      let isRsadd = false;\n      if (instruction.code === OP_RSADD) {\n        isRsadd = true;\n        // RSADD pushes a default value onto the stack (0, 0.0, '', etc.)\n        // The variable lives at the current stack position (before RSADD executes)\n        // After RSADD, SP moves up by 4, and the variable is at the old SP position\n        const stackPosBeforeRsadd = this.stackSimulator.getStackPointer();\n        const currentCount = this.functionVariableCounts.get(functionContext) || 0;\n\n        log.info(`[RSADD] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, SP before: ${stackPosBeforeRsadd}, Variable index: ${currentCount}, Function: ${functionContext?.name || 'main'}`);\n\n        // Record where this variable lives on the stack\n        // Variable index = currentCount (0-based)\n        variableStackPositions.set(stackPosBeforeRsadd, currentCount);\n        this.functionVariableCounts.set(functionContext, currentCount + 1);\n\n        // Update both simulators' variable position maps\n        this.stackSimulator.setVariableStackPositions(variableStackPositions);\n        this.expressionBuilder.setVariableStackPositions(variableStackPositions);\n\n        log.info(`[RSADD] Recorded variable ${currentCount} at stack position ${stackPosBeforeRsadd}`);\n        log.info(`[RSADD] Variable stack positions map:`, Array.from(variableStackPositions.entries()).map(([pos, idx]) => `pos ${pos} -> var ${idx}`).join(', '));\n      }\n\n      // For CPDOWNSP, we need to calculate the target stack position BEFORE processing\n      // because processing will modify the stack state\n      let cpdownspSpBefore: number | undefined = undefined;\n      let cpdownspTargetPos: number | undefined = undefined;\n      if (instruction.code === OP_CPDOWNSP) {\n        cpdownspSpBefore = this.stackSimulator.getStackPointer();\n        const offset = instruction.offset || 0;\n        const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\n        cpdownspTargetPos = cpdownspSpBefore + offsetSigned;\n        log.info(`[CPDOWNSP-PRE] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, SP before: ${cpdownspSpBefore}, Offset: ${offsetSigned}, Target pos: ${cpdownspTargetPos}`);\n      }\n\n      // Process instruction through stack simulator\n      // This ensures the stack state is correct when we check for return values\n      const expr = this.stackSimulator.processInstruction(instruction);\n\n      // Keep expression builder's stack pointer in sync after each instruction\n      this.expressionBuilder.setStackPointer(this.stackSimulator.getStackPointer());\n\n      // Skip creating statements for RSADD (it's just variable allocation)\n      if (isRsadd) {\n        continue;\n      }\n\n      // Check if this CPDOWNSP is writing to the return value position\n      // The return value position is where RSADD reserved space before the JSR that calls this function\n      let isReturnWrite = false;\n      if (instruction.code === OP_CPDOWNSP && cpdownspTargetPos !== undefined && cpdownspSpBefore !== undefined) {\n        // Get the return value offset and entry stack pointer\n        const returnValueOffset = this.functionReturnValueOffsets.get(functionContext);\n        const entrySP = this.functionEntryStackPointers.get(functionContext);\n\n        log.info(`[RETURN-DETECT-CHECK] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, CPDOWNSP SP before: ${cpdownspSpBefore}, Target pos: ${cpdownspTargetPos}`);\n        log.info(`[RETURN-DETECT-CHECK] Function: ${functionContext?.name || 'main'}, Return value offset: ${returnValueOffset}, Entry SP: ${entrySP}`);\n\n        if (returnValueOffset !== undefined && entrySP !== undefined) {\n          // The return value position is an absolute position (where RSADD reserved space)\n          // We stored it as an offset from entry SP, so we need to reconstruct the absolute position\n          // But actually, we should compare absolute positions directly\n          // The return value absolute position = entrySP + returnValueOffset\n          const returnValueAbsolutePos = entrySP + returnValueOffset;\n\n          // The CPDOWNSP target position is also absolute (cpdownspSpBefore + offset)\n          // So we should compare absolute positions directly\n          log.info(`[RETURN-DETECT-CHECK] Return value absolute position: ${entrySP} + ${returnValueOffset} = ${returnValueAbsolutePos}`);\n          log.info(`[RETURN-DETECT-CHECK] CPDOWNSP absolute target position: ${cpdownspTargetPos}`);\n          log.info(`[RETURN-DETECT-CHECK] Comparing absolute positions: ${cpdownspTargetPos} === ${returnValueAbsolutePos}? ${cpdownspTargetPos === returnValueAbsolutePos}`);\n          log.info(`[RETURN-DETECT-CHECK] Current SP: ${cpdownspSpBefore}, CPDOWNSP offset: ${instruction.offset ? (instruction.offset > 0x7FFFFFFF ? instruction.offset - 0x100000000 : instruction.offset) : 'undefined'}`);\n\n          // Check if this CPDOWNSP writes to the absolute return value position\n          if (cpdownspTargetPos === returnValueAbsolutePos) {\n            isReturnWrite = true;\n            log.info(`[RETURN-DETECT]  MATCH! Address: 0x${instruction.address.toString(16).padStart(8, '0')}, Current SP: ${cpdownspSpBefore}, Target pos: ${cpdownspTargetPos}, Entry SP: ${entrySP}, Return offset: ${returnValueOffset}, Return value absolute pos: ${returnValueAbsolutePos}`);\n\n            // Get the return value expression from the stack\n            returnValueExpr = this.stackSimulator.peek()?.expression;\n            log.info(`[RETURN-DETECT] Stack top expression: ${returnValueExpr ? returnValueExpr.toNSS() : 'undefined'}`);\n\n            // Create the return statement immediately (not wait for RETN)\n            if (returnValueExpr) {\n              blockStatements.push(NWScriptAST.createReturn(returnValueExpr));\n              log.info(`[RETURN-DETECT]  Created return statement with expression: ${returnValueExpr.toNSS()}`);\n            } else {\n              log.info(`[RETURN-DETECT]  WARNING: No expression on stack for return value`);\n            }\n          } else {\n            log.info(`[RETURN-DETECT-CHECK]  No match: CPDOWNSP absolute target ${cpdownspTargetPos} !== Return value absolute pos ${returnValueAbsolutePos} (difference: ${cpdownspTargetPos - returnValueAbsolutePos})`);\n            log.info(`[RETURN-DETECT-CHECK] This suggests the return value position calculation may be incorrect, or this CPDOWNSP is writing to a different location`);\n          }\n        } else {\n          log.info(`[RETURN-DETECT-CHECK]  Missing data: returnValueOffset=${returnValueOffset}, entrySP=${entrySP}`);\n        }\n      }\n\n      // Fallback: If CPDOWNSP target does not map to a local variable and the block (or its immediate successors) returns,\n      // treat this as a return value write based on control-flow, not magic offsets.\n      if (\n        instruction.code === OP_CPDOWNSP &&\n        !isReturnWrite &&\n        cpdownspTargetPos !== undefined &&\n        variableStackPositions.get(cpdownspTargetPos) === undefined\n      ) {\n        const hasReturnSuccessor = block.exitType === 'return' ||\n          Array.from(block.successors).some(succ => succ.exitType === 'return' || (succ.endInstruction && succ.endInstruction.code === OP_RETN));\n        if (hasReturnSuccessor) {\n          isReturnWrite = true;\n          returnValueExpr = this.stackSimulator.peek()?.expression;\n          log.info(`[RETURN-DETECT-FLOW] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, target pos: ${cpdownspTargetPos} not mapped to local, block leads to return -> treating as return write`);\n          if (returnValueExpr) {\n            blockStatements.push(NWScriptAST.createReturn(returnValueExpr));\n            log.info(`[RETURN-DETECT-FLOW]  Created return statement with expression: ${returnValueExpr.toNSS()}`);\n          } else {\n            log.info(`[RETURN-DETECT-FLOW]  WARNING: No expression on stack for return value`);\n          }\n        }\n      }\n\n      // Check for special instructions\n      if (instruction.code === OP_RETN) {\n        // RETN just tells the program to return to the address after the last JSR\n        // The actual return statement was already created when we saw the CPDOWNSP\n        // But if we didn't see a CPDOWNSP (void function), we still need to create a return\n        if (!isReturnWrite && !returnValueExpr) {\n          // Void return (no value)\n          blockStatements.push(NWScriptAST.createReturn(undefined));\n        }\n        // RETN doesn't pop anything - it just returns control\n        continue;\n      }\n\n      // Skip creating statements for return value assignments (already handled above)\n      if (isReturnWrite) {\n        continue;\n      }\n\n      // Check if CPDOWNSP is writing to a local variable (assignment)\n      if (instruction.code === OP_CPDOWNSP) {\n        log.info(`[CPDOWNSP-HANDLE] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, isReturnWrite: ${isReturnWrite}, cpdownspTargetPos: ${cpdownspTargetPos}`);\n      }\n      if (instruction.code === OP_CPDOWNSP && !isReturnWrite && cpdownspTargetPos !== undefined) {\n        // We already calculated targetStackPos before processing the instruction\n        const targetStackPos = cpdownspTargetPos;\n\n        log.info(`[CPDOWNSP] Address: 0x${instruction.address.toString(16).padStart(8, '0')}, SP before: ${cpdownspSpBefore}, Offset: ${instruction.offset ? ((instruction.offset > 0x7FFFFFFF ? instruction.offset - 0x100000000 : instruction.offset)) : 0} (0x${instruction.offset?.toString(16)}), Target pos: ${targetStackPos}`);\n\n        log.info(`[CPDOWNSP] Stack size after: ${this.stackSimulator.getStackSize()}, Has expr: ${!!expr}`);\n\n        // Get the expression from the stack (CPDOWNSP copies from top of stack)\n        // The instruction was already processed at line 501, so use that result\n        const valueExpr = expr || this.stackSimulator.peek()?.expression;\n\n        if (!valueExpr) {\n          log.info(`[CPDOWNSP] No expression found - skipping assignment`);\n          // No value to assign - skip\n          continue;\n        }\n\n        log.info(`[CPDOWNSP] Expression type: ${valueExpr.type}, Value: ${JSON.stringify(valueExpr).substring(0, 100)}`);\n        log.info(`[CPDOWNSP] Variable stack positions map:`, Array.from(variableStackPositions.entries()).map(([pos, idx]) => `pos ${pos} -> var ${idx}`).join(', '));\n\n        // Look up which variable lives at this stack position\n        const varIndex = variableStackPositions.get(targetStackPos);\n\n        log.info(`[CPDOWNSP] Looking up variable at position ${targetStackPos}: found index ${varIndex}`);\n\n        if (varIndex !== undefined && varIndex >= 0 && varIndex < this.localInits.length) {\n          // This is an assignment to a local variable\n          const varName = `localVar_${varIndex}`;\n          log.info(`[CPDOWNSP]  Creating assignment: ${varName} = <expression>`);\n          blockStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n          continue;\n        }\n\n        log.info(`[CPDOWNSP] No exact match at position ${targetStackPos}, trying nearby positions...`);\n\n        // Fallback: If we didn't find it by exact stack position, try nearby positions\n        // Sometimes stack positions might be off by a few bytes due to intermediate operations\n        // Check positions within 4 bytes\n        for (let delta = -4; delta <= 4; delta += 4) {\n          const nearbyPos = targetStackPos + delta;\n          const nearbyVarIndex = variableStackPositions.get(nearbyPos);\n          if (nearbyVarIndex !== undefined && nearbyVarIndex >= 0 && nearbyVarIndex < this.localInits.length) {\n            const varName = `localVar_${nearbyVarIndex}`;\n            log.info(`[CPDOWNSP]  Found nearby variable at position ${nearbyPos} (delta ${delta}): ${varName}`);\n            blockStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n            continue;\n          }\n        }\n\n        // Stack-aware fallback: Check all variable positions with tolerance\n        // Sometimes the stack has grown between RSADD and CPDOWNSP, so the exact position doesn't match\n        // Try to find the variable by checking all recorded positions\n        log.info(`[CPDOWNSP] Trying stack-aware fallback: checking all variable positions...`);\n        for (const [varPos, varIndex] of variableStackPositions.entries()) {\n          // Check if the target position is close to any variable position\n          // Allow some tolerance (8 bytes) since the stack may have grown\n          const distance = Math.abs(targetStackPos - varPos);\n          if (distance <= 8 && varIndex >= 0 && varIndex < this.localInits.length) {\n            const varName = `localVar_${varIndex}`;\n            log.info(`[CPDOWNSP]  Found variable by position proximity: ${varName} (distance: ${distance})`);\n            blockStatements.push(NWScriptAST.createAssignment(varName, valueExpr, false));\n            continue;\n          }\n        }\n\n        log.info(`[CPDOWNSP]  No variable found for assignment at position ${targetStackPos}`);\n      }\n\n      // Check if CPTOPSP is reading from a local variable\n      // CPTOPSP reads a variable and pushes it to the stack\n      // The stack simulator now handles stack-aware variable resolution internally\n      // The variable position map is already updated at the start of the block\n      if (instruction.code === OP_CPTOPSP) {\n        // Process the instruction - it will resolve variables using stack-aware logic\n        this.stackSimulator.processInstruction(instruction);\n\n        // Skip creating a statement for variable reads (they're intermediate values)\n        continue;\n      }\n\n      // Check for break/continue (these would be in JMP instructions to specific targets)\n      // For now, we'll handle these when we process control structures\n\n      // If we got an expression, it might be an assignment or expression statement\n      // However, we should filter out intermediate expressions that are:\n      // - String constants (function parameters)\n      // - Variable reads (intermediate values)\n      // - Simple integer constants (0, 1) that are intermediate values\n      // - Binary operations that are intermediate (part of larger expressions)\n      if (expr) {\n        // Skip string constants (they're typically function parameters)\n        if (expr.type === 'constant' && expr.dataType === NWScriptDataType.STRING) {\n          continue;\n        }\n\n        // Skip variable reads - they're intermediate values used in larger expressions\n        // Variable reads are typically intermediate - skip them\n        if (expr.type === 'variable') {\n          continue;\n        }\n\n        // Skip simple integer constants that are likely intermediate values\n        if (expr.type === 'constant' && expr.dataType === NWScriptDataType.INTEGER &&\n            (expr.value === 0 || expr.value === 1)) {\n          // These are often intermediate values (like comparison results, boolean values)\n          continue;\n        }\n\n        // Skip binary operations, comparisons, and logical operations\n        // These are typically intermediate (part of conditions or larger expressions)\n        // BUT: If the next instruction is CPDOWNSP, this is the value being assigned, not intermediate\n        if (expr.type === 'binary_op' || expr.type === 'comparison' || expr.type === 'logical') {\n          // Check if this expression is being assigned to a variable (next instruction is CPDOWNSP)\n          // If so, don't skip it - let the CPDOWNSP handler create the assignment\n          let isBeingAssigned = false;\n          if (i + 1 < block.instructions.length) {\n            const nextInstr = block.instructions[i + 1];\n            if (nextInstr.code === OP_CPDOWNSP) {\n              isBeingAssigned = true;\n            }\n          }\n\n          // Only skip if it's NOT being assigned\n          if (!isBeingAssigned) {\n            // Binary operations, comparisons, and logical operations are typically intermediate\n            // They'll be part of conditions, assignments, or other expressions\n            continue;\n          }\n          // If it IS being assigned, fall through to let CPDOWNSP handler process it\n        }\n\n        // For function calls, only create an expression statement if they're not part of a larger expression\n        // We need to look ahead to see if this function call result is consumed by a later instruction\n        // Patterns to detect:\n        // - ACTION -> CONST -> EQUAL (comparison)\n        // - ACTION -> (any op that consumes stack) -> CPDOWNSP (assignment)\n        // - ACTION -> (any op) -> (comparison/binary op)\n        if (expr.type === 'function_call') {\n          // Look ahead to see if this function call is part of a larger expression\n          // Check up to 5 instructions ahead for patterns that consume the function result\n          let isPartOfExpression = false;\n          const lookAheadLimit = Math.min(i + 6, block.instructions.length);\n\n          for (let j = i + 1; j < lookAheadLimit; j++) {\n            const futureInstr = block.instructions[j];\n\n            // If we find a comparison, binary op, or assignment, the function call is part of an expression\n            if (futureInstr.code === OP_EQUAL || futureInstr.code === OP_NEQUAL ||\n                futureInstr.code === OP_GT || futureInstr.code === OP_GEQ ||\n                futureInstr.code === OP_LT || futureInstr.code === OP_LEQ ||\n                futureInstr.code === OP_ADD || futureInstr.code === OP_SUB ||\n                futureInstr.code === OP_MUL || futureInstr.code === OP_DIV ||\n                futureInstr.code === OP_LOGANDII || futureInstr.code === OP_LOGORII ||\n                futureInstr.code === OP_CPDOWNSP) {\n              isPartOfExpression = true;\n              break;\n            }\n\n            // If we hit a terminator (JMP, JZ, JNZ, RETN, JSR), stop looking ahead\n            // The function call is not part of an expression in this block\n            if (futureInstr.code === OP_JMP || futureInstr.code === OP_RETN ||\n                futureInstr.code === OP_JSR || futureInstr.code === OP_JZ ||\n                futureInstr.code === OP_JNZ) {\n              break;\n            }\n          }\n\n          // Only create expression statement if it's not part of a larger expression\n          if (!isPartOfExpression) {\n            blockStatements.push(NWScriptAST.createExpressionStatement(expr));\n          }\n        }\n        // For other expression types, be conservative and skip them\n        // Most expressions are intermediate values\n      }\n    }\n\n    // Cache the statements\n    this.blockStatements.set(block, blockStatements);\n    statements.push(...blockStatements);\n  }\n\n  /**\n   * Convert IfNode to AST\n   */\n  private convertIfNode(node: IfNode, functionContext: NWScriptFunction | null): NWScriptIfNode {\n    // NOTE: Pre-condition instructions (RSADD, CPDOWNSP, etc.) are already processed\n    // in convertControlNode before this method is called. We only need to extract the condition.\n    // DO NOT process the header block again here - it would duplicate work and corrupt stack state.\n\n    log.info(`[convertIfNode] Extracting condition from if node, condition type: ${node.condition.type}`);\n\n    // Extract condition from condition block\n    // The stack state should already be correct from pre-condition processing\n    let condition = this.extractConditionFromBlock(node.condition, functionContext, node);\n\n    log.info(`[convertIfNode] Initial condition extracted, type: ${condition.type}`);\n    if (condition.type === 'variable') {\n      log.info(`[convertIfNode] Variable name: ${condition.variableName}`);\n    } else if (condition.type === 'comparison') {\n      log.info(`[convertIfNode] Comparison operator: ${condition.operator}`);\n    } else if (condition.type === 'logical') {\n      log.info(`[convertIfNode] Logical operator: ${condition.operator}`);\n    }\n\n    // Check if the body contains a LOGANDII that combines with the outer condition\n    // This handles cross-block AND chains where the LOGANDII is in the body block\n    const actualBodyNode: ControlNode = node.body;\n    if (node.body.type === 'basic_block') {\n      const bodyBlock = node.body.block;\n      // Check if body block contains LOGANDII\n      const hasLogAndII = bodyBlock.instructions.some(instr => instr.code === OP_LOGANDII);\n      log.info(`[convertIfNode] Body block ${bodyBlock.id} has LOGANDII: ${hasLogAndII}`);\n      if (hasLogAndII && node.condition.type === 'basic_block') {\n        log.info(`[convertIfNode] Attempting cross-block AND condition extraction from block ${node.condition.block.id} through block ${bodyBlock.id}`);\n        // Try to extract the full AND condition by processing blocks together\n        const combinedCondition = this.extractCrossBlockANDCondition(\n          node.condition.block,\n          bodyBlock,\n          functionContext\n        );\n        if (combinedCondition) {\n          log.info(`[convertIfNode] Cross-block AND condition extracted, type: ${combinedCondition.type}`);\n          if (combinedCondition.type === 'logical') {\n            log.info(`[convertIfNode] Logical operator: ${combinedCondition.operator}`);\n          }\n          condition = combinedCondition;\n\n          // If we successfully extracted a cross-block condition, the body block is actually part of the condition\n          // Check if the body block's successor is a control structure that should be the actual body\n          // This handles cases where: if (cond1 && cond2) { if-else structure }\n          const successorsArray = Array.from(bodyBlock.successors);\n          if (successorsArray.length > 0) {\n            const nextBlock = successorsArray[0];\n            log.info(`[convertIfNode] Body block ${bodyBlock.id} has successor block ${nextBlock.id}, checking for nested structure...`);\n\n            // Try to find a control structure starting from the next block\n            // This would be the actual body (e.g., an inner if-else)\n            // For now, we'll check if the next block is a conditional block (has a condition instruction)\n            if (nextBlock.conditionInstruction) {\n              log.info(`[convertIfNode] Successor block ${nextBlock.id} has condition instruction, likely a nested if structure`);\n              // The actual body should be the nested structure starting from nextBlock\n              // But we need to find the ControlNode for this structure\n              // For now, we'll convert the body block as-is, but it should be empty\n              // The nested structure will be converted separately in the sequence\n            }\n          }\n        } else {\n          log.info(`[convertIfNode] Cross-block AND condition extraction returned null`);\n        }\n      }\n    }\n\n    // Convert body\n    const thenBody = this.convertControlNodeToBlock(actualBodyNode, functionContext);\n\n    // If the body is empty and we extracted a cross-block condition, the body block was part of the condition\n    // In this case, the actual body should be the nested structure (e.g., inner if-else) that follows\n    // This will be handled at the sequence level, but we log it here for debugging\n    if (thenBody.statements.length === 0 && node.body.type === 'basic_block') {\n      const bodyBlock = node.body.block;\n      const hasLogAndII = bodyBlock.instructions.some(instr => instr.code === OP_LOGANDII);\n      if (hasLogAndII) {\n        log.info(`[convertIfNode] WARNING: Body block ${bodyBlock.id} contains LOGANDII and generated empty body. The actual body should be the nested structure starting from block ${Array.from(bodyBlock.successors)[0]?.id || 'unknown'}`);\n      }\n    }\n\n    // Get header block for metadata (if condition is a basic block)\n    const headerBlock = node.condition.type === 'basic_block' ? node.condition.block : undefined;\n\n    return NWScriptAST.createIf(condition, thenBody, undefined, headerBlock) as NWScriptIfNode;\n  }\n\n  /**\n   * Convert IfElseNode to AST\n   */\n  private convertIfElseNode(node: IfElseNode, functionContext: NWScriptFunction | null): NWScriptIfElseNode {\n    // Extract condition from condition block\n    let condition = this.extractConditionFromBlock(node.condition, functionContext);\n\n    // Check if we need to look at predecessor blocks for cross-block AND chains\n    // This handles cases where the LOGANDII is in a previous block\n    if (node.condition.type === 'basic_block') {\n      const headerBlock = node.condition.block;\n      // Find the path from a conditional predecessor through a LOGANDII block to this block\n      // This handles the pattern: block1 (condition) -> block2 (LOGANDII) -> block3 (final condition)\n      for (const predecessor of headerBlock.predecessors) {\n        const hasLogAndII = predecessor.instructions.some(instr => instr.code === OP_LOGANDII);\n        if (hasLogAndII) {\n          // Check if this predecessor has a conditional predecessor (the first condition)\n          for (const predPred of predecessor.predecessors) {\n            if (predPred.conditionInstruction) {\n              // Found the path: predPred -> predecessor (LOGANDII) -> headerBlock\n              const combinedCondition = this.extractCrossBlockANDCondition(\n                predPred,\n                headerBlock,\n                functionContext\n              );\n              if (combinedCondition) {\n                condition = combinedCondition;\n                break;\n              }\n            }\n          }\n          if (condition !== this.extractConditionFromBlock(node.condition, functionContext)) {\n            break; // Found and set combined condition\n          }\n        }\n      }\n    }\n\n    // Convert bodies\n    const thenBody = this.convertControlNodeToBlock(node.thenBody, functionContext);\n    const elseBody = this.convertControlNodeToBlock(node.elseBody, functionContext);\n\n    // Get header block for metadata (if condition is a basic block)\n    const headerBlock = node.condition.type === 'basic_block' ? node.condition.block : undefined;\n\n    return NWScriptAST.createIf(condition, thenBody, elseBody, headerBlock) as NWScriptIfElseNode;\n  }\n\n  /**\n   * Convert WhileNode to AST\n   */\n  private convertWhileNode(node: WhileNode, functionContext: NWScriptFunction | null): NWScriptWhileNode {\n    // Extract condition from condition block\n    const condition = this.extractConditionFromBlock(node.condition, functionContext);\n\n    // Convert body\n    const body = this.convertControlNodeToBlock(node.body, functionContext);\n\n    // Get header block for metadata (if condition is a basic block)\n    const headerBlock = node.condition.type === 'basic_block' ? node.condition.block : undefined;\n\n    return NWScriptAST.createWhile(condition, body, headerBlock);\n  }\n\n  /**\n   * Convert DoWhileNode to AST\n   */\n  private convertDoWhileNode(node: DoWhileNode, functionContext: NWScriptFunction | null): NWScriptDoWhileNode {\n    // Extract condition from condition block\n    const condition = this.extractConditionFromBlock(node.condition, functionContext);\n\n    // Convert body\n    const body = this.convertControlNodeToBlock(node.body, functionContext);\n\n    // Get header block for metadata (if condition is a basic block)\n    const headerBlock = node.condition.type === 'basic_block' ? node.condition.block : undefined;\n\n    // Note: createDoWhile signature is: (body, condition, headerBlock?)\n    return NWScriptAST.createDoWhile(body, condition, headerBlock);\n  }\n\n  /**\n   * Convert ForNode to AST\n   */\n  private convertForNode(node: ForNode, functionContext: NWScriptFunction | null): NWScriptForNode {\n    // Extract condition from condition block\n    const condition = this.extractConditionFromBlock(node.condition, functionContext);\n\n    // Convert init, body, and increment\n    const init = node.init ? this.convertControlNodeToBlock(node.init, functionContext) : undefined;\n    const body = this.convertControlNodeToBlock(node.body, functionContext);\n    const increment = node.increment ? this.convertControlNodeToBlock(node.increment, functionContext) : undefined;\n\n    // Get header block for metadata (if condition is a basic block)\n    const headerBlock = node.condition.type === 'basic_block' ? node.condition.block : undefined;\n\n    // Note: createFor signature is: (body, init?, condition?, increment?, headerBlock?)\n    return NWScriptAST.createFor(body, init, condition, increment, headerBlock);\n  }\n\n  /**\n   * Convert SwitchNode to AST\n   */\n  private convertSwitchNode(node: SwitchNode, functionContext: NWScriptFunction | null): NWScriptSwitchNode {\n    // Extract expression from expression block\n    const expression = this.extractExpressionFromBlock(node.expression, functionContext);\n\n    // Convert cases\n    const cases: NWScriptSwitchCaseNode[] = [];\n    for (const switchCase of node.cases) {\n      const caseBody = this.convertControlNodeToBlock(switchCase.body, functionContext);\n      // createSwitchCase expects an expression for the value\n      const caseValueExpr = NWScriptExpression.constant(switchCase.value, NWScriptDataType.INTEGER);\n      cases.push(NWScriptAST.createSwitchCase(caseValueExpr, caseBody));\n    }\n\n    // Convert default case\n    const defaultCase = node.defaultCase\n      ? NWScriptAST.createSwitchDefault(this.convertControlNodeToBlock(node.defaultCase, functionContext))\n      : undefined;\n\n    // Get header block for metadata (if expression is a basic block)\n    const headerBlock = node.expression.type === 'basic_block' ? node.expression.block : undefined;\n\n    return NWScriptAST.createSwitch(expression, cases, defaultCase, headerBlock);\n  }\n\n  /**\n   * Extract condition expression from a condition ControlNode\n   */\n  private extractConditionFromBlock(\n    conditionNode: ControlNode,\n    functionContext: NWScriptFunction | null,\n    parentNode?: IfNode | IfElseNode\n  ): NWScriptExpression {\n    // If it's a basic block, extract condition from the block\n    if (conditionNode.type === 'basic_block') {\n      const block = conditionNode.block;\n\n      // Setup function context\n      if (!functionContext) {\n        functionContext = this.blockToFunction.get(block) || null;\n        if (functionContext) {\n          this.setupFunctionContext(functionContext);\n        }\n      }\n\n      // Find the condition instruction (JZ/JNZ)\n      if (block.conditionInstruction) {\n        // Setup AND chain detector with function context\n        if (functionContext) {\n          this.andChainDetector.setFunctionParameters(functionContext.parameters);\n          const globalVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n          for (let i = 0; i < this.globalInits.length; i++) {\n            const init = this.globalInits[i];\n            const varName = `globalVar_${i}`;\n            const offsetSigned = init.offset > 0x7FFFFFFF ? init.offset - 0x100000000 : init.offset;\n            globalVarMap.set(offsetSigned, { name: varName, dataType: init.dataType });\n          }\n          this.andChainDetector.setGlobalVariables(globalVarMap);\n\n          const localVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n          for (let i = 0; i < this.localInits.length; i++) {\n            const init = this.localInits[i];\n            const varName = `localVar_${i}`;\n            localVarMap.set(init.offset, { name: varName, dataType: init.dataType });\n          }\n          this.andChainDetector.setLocalVariables(localVarMap);\n        }\n\n        // Try AND chain detection first\n        const andChainExpr = this.andChainDetector.detectANDChain(block);\n        if (andChainExpr) {\n          log.info(`[extractConditionFromBlock] Detected AND chain in block ${block.id}`);\n          return andChainExpr;\n        }\n\n        // CRITICAL: Do NOT clear the stack here - pre-condition instructions have already\n        // been processed and the stack state is correct. The condition expression should\n        // already be on the stack from pre-condition processing.\n        //\n        // However, there might be instructions between the last pre-condition instruction\n        // and the condition instruction that build up the condition expression. We need\n        // to process those, but we don't know which instructions were pre-condition ones.\n        //\n        // For now, let's check if the condition is already on the stack. If not, we'll\n        // need to process instructions from the last pre-condition instruction to the condition.\n        // But since we don't track which instructions were pre-condition, we'll process\n        // from the beginning of the block to the condition, which will re-process\n        // pre-condition instructions. This is not ideal, but it should work.\n        //\n        // Actually, a better approach: Since pre-condition instructions were already\n        // processed, the stack should have the condition value on it. Let's check first.\n        const conditionInstr = block.conditionInstruction;\n\n        // Check if condition is already on the stack\n        const stackTop = this.stackSimulator.peek();\n        if (stackTop) {\n          // The condition is already on the stack from pre-condition processing\n          log.info(`[extractConditionFromBlock] Condition already on stack from pre-condition processing`);\n          log.info(`[extractConditionFromBlock] Stack top expression type: ${stackTop.expression.type}`);\n          if (stackTop.expression.type === 'variable') {\n            log.info(`[extractConditionFromBlock] Variable name: ${stackTop.expression.variableName}`);\n          } else if (stackTop.expression.type === 'comparison') {\n            log.info(`[extractConditionFromBlock] Comparison operator: ${stackTop.expression.operator}`);\n          } else if (stackTop.expression.type === 'logical') {\n            log.info(`[extractConditionFromBlock] Logical operator: ${stackTop.expression.operator}`);\n          }\n          log.info(`[extractConditionFromBlock] Stack size: ${this.stackSimulator.getStackSize()}, SP: ${this.stackSimulator.getStackPointer()}`);\n\n          // Check if this is just a variable (which might be wrong)\n          if (stackTop.expression.type === 'variable') {\n            log.info(`[extractConditionFromBlock] WARNING: Condition is just a variable ${stackTop.expression.variableName}, might be incorrect`);\n            log.info(`[extractConditionFromBlock] Block ${block.id} instructions:`, block.instructions.map((instr: NWScriptInstruction) =>\n              `${instr.address.toString(16).padStart(8, '0')} ${instr.codeName}`\n            ).join(', '));\n            const blockRange = block.getAddressRange();\n            log.info(`[extractConditionFromBlock] Block ${block.id} startAddress: ${blockRange.start.toString(16)}, endAddress: ${blockRange.end.toString(16)}`);\n            log.info(`[extractConditionFromBlock] Condition instruction at: ${conditionInstr.address.toString(16).padStart(8, '0')} ${conditionInstr.codeName}`);\n\n            // Check if we need to look at instructions before the condition to reconstruct the full condition\n            // The issue is that CPTOPSP at 130 overwrote the EQUAL result, so we need to reconstruct it\n            const conditionIndex = block.instructions.indexOf(conditionInstr);\n            log.info(`[extractConditionFromBlock] Condition instruction index: ${conditionIndex}`);\n            if (conditionIndex > 0) {\n              const instructionsBeforeCondition = block.instructions.slice(0, conditionIndex);\n              log.info(`[extractConditionFromBlock] Instructions before condition:`, instructionsBeforeCondition.map((instr: NWScriptInstruction) =>\n                `${instr.address.toString(16).padStart(8, '0')} ${instr.codeName}`\n              ).join(', '));\n\n              // Check if there's an EQUAL before CPTOPSP\n              const equalIndex = instructionsBeforeCondition.findIndex((instr: NWScriptInstruction) => instr.code === OP_EQUAL);\n              const cptopspIndex = instructionsBeforeCondition.findIndex((instr: NWScriptInstruction) =>\n                instr.code === OP_CPTOPSP &&\n                (equalIndex >= 0 ? instr.address > instructionsBeforeCondition[equalIndex].address : true)\n              );\n              if (equalIndex >= 0 && cptopspIndex >= 0 && cptopspIndex > equalIndex) {\n                log.info(`[extractConditionFromBlock] Found EQUAL at index ${equalIndex} followed by CPTOPSP at index ${cptopspIndex} - this is a short-circuit pattern`);\n                log.info(`[extractConditionFromBlock] Need to reconstruct condition from EQUAL result, not CPTOPSP result`);\n\n                // Check if parent node's body block contains LOGANDII (only for IfNode, not IfElseNode)\n                if (parentNode && parentNode.type === 'if' && parentNode.body && parentNode.body.type === 'basic_block') {\n                  const bodyBlock = parentNode.body.block;\n                  const bodyRange = bodyBlock.getAddressRange();\n                  log.info(`[extractConditionFromBlock] Body block ${bodyBlock.id} startAddress: ${bodyRange.start.toString(16)}, endAddress: ${bodyRange.end.toString(16)}`);\n                  log.info(`[extractConditionFromBlock] Body block ${bodyBlock.id} instructions:`, bodyBlock.instructions.map((instr: NWScriptInstruction) =>\n                    `${instr.address.toString(16).padStart(8, '0')} ${instr.codeName}`\n                  ).join(', '));\n                  let hasLogAndII = bodyBlock.instructions.some((instr: NWScriptInstruction) => instr.code === OP_LOGANDII);\n                  log.info(`[extractConditionFromBlock] Body block ${bodyBlock.id} has LOGANDII in instruction list: ${hasLogAndII}`);\n\n                  // Also check if LOGANDII is between body block end and next block start\n                  // LOGANDII might be at address 162, which is between block 3 (ends 164) and block 4 (starts 164)\n                  const logAndIIAddr = 0x162;\n                  if (bodyRange.end >= logAndIIAddr && bodyRange.start <= logAndIIAddr) {\n                    log.info(`[extractConditionFromBlock] LOGANDII at ${logAndIIAddr.toString(16)} is within body block ${bodyBlock.id} address range`);\n                    // Check if it's in the instruction list\n                    const logAndIIInstr = bodyBlock.instructions.find((instr: NWScriptInstruction) => instr.address === logAndIIAddr);\n                    if (!logAndIIInstr) {\n                      log.info(`[extractConditionFromBlock] WARNING: LOGANDII at ${logAndIIAddr.toString(16)} is in address range but not in instruction list!`);\n                      // Try to find it in the CFG\n                      const allInstrs = Array.from(this.cfg.script.instructions.values());\n                      const logAndII = allInstrs.find(instr => instr.address === logAndIIAddr);\n                      if (logAndII) {\n                        log.info(`[extractConditionFromBlock] Found LOGANDII instruction in CFG at ${logAndIIAddr.toString(16)}`);\n                        // Force cross-block extraction\n                        hasLogAndII = true;\n                      }\n                    }\n                  }\n\n                  if (hasLogAndII) {\n                    log.info(`[extractConditionFromBlock] Attempting cross-block AND condition extraction...`);\n                    // Try cross-block extraction\n                    const combinedCondition = this.extractCrossBlockANDCondition(block, bodyBlock, functionContext);\n                    if (combinedCondition) {\n                      log.info(`[extractConditionFromBlock] Successfully extracted cross-block AND condition: ${combinedCondition.toNSS()}`);\n                      return combinedCondition;\n                    }\n                  }\n\n                  // If cross-block extraction failed, try to reconstruct the first condition from EQUAL\n                  // and combine with the second condition from the body block\n                  log.info(`[extractConditionFromBlock] Attempting to reconstruct condition from EQUAL and body block...`);\n\n                  // Reconstruct first condition: process instructions up to and including EQUAL\n                  const equalInstr = instructionsBeforeCondition[equalIndex];\n                  const equalInstrIndex = block.instructions.indexOf(equalInstr);\n                  if (equalInstrIndex >= 0) {\n                    // Use a temporary stack simulator to track stack pointer correctly\n                    // IMPORTANT: Use the variable stack positions map that was already built\n                    // during pre-condition processing, not a new one!\n                    const varStackPositions = this.functionVariableStackPositions.get(functionContext) || new Map<number, number>();\n\n                    const tempStackSim = new NWScriptStackSimulator();\n                    if (functionContext) {\n                      tempStackSim.setFunctionParameters(functionContext.parameters);\n                    }\n                    tempStackSim.setGlobalVariables(this.stackSimulator.getGlobalVariables());\n                    tempStackSim.setLocalVariables(this.stackSimulator.getLocalVariables());\n                    // Use the existing variable stack positions map\n                    tempStackSim.setVariableStackPositions(varStackPositions);\n                    tempStackSim.setLocalVariableInits(this.localInits);\n\n                    const tempExprBuilder = new NWScriptExpressionBuilder();\n                    if (functionContext) {\n                      tempExprBuilder.setFunctionParameters(functionContext.parameters);\n                    }\n                    tempExprBuilder.setGlobalVariables(this.stackSimulator.getGlobalVariables());\n                    tempExprBuilder.setLocalVariables(this.stackSimulator.getLocalVariables());\n                    // Use the existing variable stack positions map\n                    tempExprBuilder.setVariableStackPositions(varStackPositions);\n                    tempExprBuilder.setLocalVariableInits(this.localInits);\n\n                    // Process all instructions up to and including EQUAL through both simulators\n                    // The variable stack positions map is already correct from pre-condition processing\n                    log.info(`[extractConditionFromBlock] Starting condition reconstruction with varStackPositions:`, Array.from(varStackPositions.entries()).map(([pos, idx]) => `pos ${pos} -> var ${idx}`).join(', '));\n                    for (let i = 0; i <= equalInstrIndex; i++) {\n                      const instr = block.instructions[i];\n\n                      // Log expression stack state before processing key instructions\n                      if (instr.code === OP_CPTOPSP || instr.code === OP_CONST || instr.code === OP_EQUAL) {\n                        const exprStackBefore = tempExprBuilder.getStackSize();\n                        log.info(`[extractConditionFromBlock] Before ${instr.codeName} at ${instr.address.toString(16).padStart(8, '0')}: expression stack size=${exprStackBefore}`);\n                        if (exprStackBefore > 0) {\n                          const topExpr = tempExprBuilder.peek();\n                          if (topExpr) {\n                            log.info(`[extractConditionFromBlock]   Top expression: ${topExpr.toNSS()}`);\n                          }\n                        }\n                      }\n\n                      // Log CPTOPSP instructions to debug variable resolution\n                      if (instr.code === OP_CPTOPSP) {\n                        const spBefore = tempStackSim.getStackPointer();\n                        const offset = instr.offset || 0;\n                        const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\n                        const sourceStackPos = spBefore + offsetSigned;\n                        log.info(`[extractConditionFromBlock] CPTOPSP at ${instr.address.toString(16).padStart(8, '0')}: SP=${spBefore}, offset=${offsetSigned}, sourcePos=${sourceStackPos}`);\n                        const varIdx = varStackPositions.get(sourceStackPos);\n                        if (varIdx !== undefined) {\n                          log.info(`[extractConditionFromBlock] CPTOPSP will resolve to localVar_${varIdx}`);\n                        } else {\n                          log.info(`[extractConditionFromBlock] CPTOPSP: No variable found at position ${sourceStackPos}`);\n                        }\n                      }\n\n                      // CRITICAL: Get stack pointer BEFORE processing the instruction\n                      // This is the stack pointer that CPTOPSP will use to calculate source position\n                      const spBeforeInstr = tempStackSim.getStackPointer();\n\n                      // Process through stack simulator to track stack pointer\n                      tempStackSim.processInstruction(instr);\n\n                      // Set expression builder's stack pointer to the value BEFORE the instruction\n                      // This ensures CPTOPSP uses the correct stack pointer to calculate source position\n                      tempExprBuilder.setStackPointer(spBeforeInstr);\n\n                      // Process through expression builder to build expressions\n                      // For CPTOPSP, it needs the stack pointer BEFORE the instruction executes\n                      if (instr.code === OP_CONST || instr.code === OP_ACTION ||\n                          instr.code === OP_CPTOPSP || instr.code === OP_CPTOPBP ||\n                          instr.code === OP_EQUAL || instr.code === OP_NEQUAL ||\n                          instr.code === OP_GT || instr.code === OP_GEQ ||\n                          instr.code === OP_LT || instr.code === OP_LEQ ||\n                          instr.code === OP_ADD || instr.code === OP_SUB ||\n                          instr.code === OP_MUL || instr.code === OP_DIV ||\n                          instr.code === OP_LOGANDII || instr.code === OP_LOGORII) {\n                        tempExprBuilder.processInstruction(instr);\n\n                        // Log expression stack state after processing key instructions\n                        if (instr.code === OP_CPTOPSP || instr.code === OP_CONST || instr.code === OP_EQUAL) {\n                          const exprStackAfter = tempExprBuilder.getStackSize();\n                          log.info(`[extractConditionFromBlock] After ${instr.codeName} at ${instr.address.toString(16).padStart(8, '0')}: expression stack size=${exprStackAfter}`);\n                          if (exprStackAfter > 0) {\n                            const topExpr = tempExprBuilder.peek();\n                            if (topExpr) {\n                              log.info(`[extractConditionFromBlock]   Top expression: ${topExpr.toNSS()}`);\n                            }\n                          }\n                          if (instr.code === OP_EQUAL && exprStackAfter > 0) {\n                            // Log both operands for EQUAL\n                            const topExpr = tempExprBuilder.peek();\n                            if (topExpr && topExpr.type === 'comparison' && topExpr.left && topExpr.right) {\n                              log.info(`[extractConditionFromBlock]   EQUAL left: ${topExpr.left.toNSS()}, right: ${topExpr.right.toNSS()}`);\n                            }\n                          }\n                        }\n                      }\n                    }\n\n                    const firstCondition = tempExprBuilder.peek();\n                    if (firstCondition) {\n                      log.info(`[extractConditionFromBlock] Reconstructed first condition from EQUAL: ${firstCondition.toNSS()}`);\n\n                      // Extract second condition from body block\n                      // Continue from where tempStackSim left off (after EQUAL and CPTOPSP)\n                      // The stack state should be correct after processing all instructions up to EQUAL\n                      const bodyStartSP = tempStackSim.getStackPointer();\n\n                      const bodyStackSim = new NWScriptStackSimulator();\n                      if (functionContext) {\n                        bodyStackSim.setFunctionParameters(functionContext.parameters);\n                      }\n                      bodyStackSim.setGlobalVariables(this.stackSimulator.getGlobalVariables());\n                      bodyStackSim.setLocalVariables(this.stackSimulator.getLocalVariables());\n                      // Use the existing variable stack positions map (same as tempStackSim)\n                      bodyStackSim.setVariableStackPositions(varStackPositions);\n                      bodyStackSim.setLocalVariableInits(this.localInits);\n\n                      // Re-process all instructions from the start to get the correct stack state\n                      // This ensures MOVSP and other stack manipulation instructions are tracked\n                      for (let i = 0; i <= equalInstrIndex; i++) {\n                        const instr = block.instructions[i];\n                        bodyStackSim.processInstruction(instr);\n                      }\n\n                      const bodyExprBuilder = new NWScriptExpressionBuilder();\n                      if (functionContext) {\n                        bodyExprBuilder.setFunctionParameters(functionContext.parameters);\n                      }\n                      bodyExprBuilder.setGlobalVariables(this.stackSimulator.getGlobalVariables());\n                      bodyExprBuilder.setLocalVariables(this.stackSimulator.getLocalVariables());\n                      // Use the existing variable stack positions map\n                      bodyExprBuilder.setVariableStackPositions(varStackPositions);\n                      bodyExprBuilder.setLocalVariableInits(this.localInits);\n\n                      // Process body block instructions up to GT\n                      log.info(`[extractConditionFromBlock] Processing body block instructions for second condition...`);\n                      for (const instr of bodyBlock.instructions) {\n                        // Log expression stack state before processing key instructions\n                        if (instr.code === OP_CPTOPSP || instr.code === OP_GT) {\n                          const exprStackBefore = bodyExprBuilder.getStackSize();\n                          log.info(`[extractConditionFromBlock] Body: Before ${instr.codeName} at ${instr.address.toString(16).padStart(8, '0')}: expression stack size=${exprStackBefore}`);\n                          if (exprStackBefore > 0) {\n                            const topExpr = bodyExprBuilder.peek();\n                            if (topExpr) {\n                              log.info(`[extractConditionFromBlock] Body:   Top expression: ${topExpr.toNSS()}`);\n                            }\n                          }\n                        }\n\n                        // Log CPTOPSP instructions in body block\n                        if (instr.code === OP_CPTOPSP) {\n                          const spBefore = bodyStackSim.getStackPointer();\n                          const offset = instr.offset || 0;\n                          const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\n                          const sourceStackPos = spBefore + offsetSigned;\n                          log.info(`[extractConditionFromBlock] Body: CPTOPSP at ${instr.address.toString(16).padStart(8, '0')}: SP=${spBefore}, offset=${offsetSigned}, sourcePos=${sourceStackPos}`);\n                          const varIdx = varStackPositions.get(sourceStackPos);\n                          if (varIdx !== undefined) {\n                            log.info(`[extractConditionFromBlock] Body: CPTOPSP will resolve to localVar_${varIdx}`);\n                          } else {\n                            log.info(`[extractConditionFromBlock] Body: CPTOPSP: No variable found at position ${sourceStackPos}`);\n                          }\n                        }\n\n                        // CRITICAL: Get stack pointer BEFORE processing the instruction\n                        const bodySpBeforeInstr = bodyStackSim.getStackPointer();\n\n                        bodyStackSim.processInstruction(instr);\n\n                        // Set expression builder's stack pointer to the value BEFORE the instruction\n                        bodyExprBuilder.setStackPointer(bodySpBeforeInstr);\n\n                        if (instr.code === OP_GT) {\n                          bodyExprBuilder.processInstruction(instr);\n\n                          // Log after GT\n                          const exprStackAfter = bodyExprBuilder.getStackSize();\n                          log.info(`[extractConditionFromBlock] Body: After GT at ${instr.address.toString(16).padStart(8, '0')}: expression stack size=${exprStackAfter}`);\n                          if (exprStackAfter > 0) {\n                            const topExpr = bodyExprBuilder.peek();\n                            if (topExpr) {\n                              log.info(`[extractConditionFromBlock] Body:   Top expression: ${topExpr.toNSS()}`);\n                              if (topExpr.type === 'comparison' && topExpr.left && topExpr.right) {\n                                log.info(`[extractConditionFromBlock] Body:   GT left: ${topExpr.left.toNSS()}, right: ${topExpr.right.toNSS()}`);\n                              }\n                            }\n                          }\n                          break;\n                        } else if (instr.code === OP_CONST || instr.code === OP_ACTION ||\n                                   instr.code === OP_CPTOPSP || instr.code === OP_CPTOPBP ||\n                                   instr.code === OP_EQUAL || instr.code === OP_NEQUAL ||\n                                   instr.code === OP_GEQ || instr.code === OP_LT ||\n                                   instr.code === OP_LEQ || instr.code === OP_ADD ||\n                                   instr.code === OP_SUB || instr.code === OP_MUL ||\n                                   instr.code === OP_DIV || instr.code === OP_LOGANDII ||\n                                   instr.code === OP_LOGORII) {\n                          bodyExprBuilder.processInstruction(instr);\n\n                          // Log after CPTOPSP in body block\n                          if (instr.code === OP_CPTOPSP) {\n                            const exprStackAfter = bodyExprBuilder.getStackSize();\n                            log.info(`[extractConditionFromBlock] Body: After CPTOPSP at ${instr.address.toString(16).padStart(8, '0')}: expression stack size=${exprStackAfter}`);\n                            if (exprStackAfter > 0) {\n                              const topExpr = bodyExprBuilder.peek();\n                              if (topExpr) {\n                                log.info(`[extractConditionFromBlock] Body:   Top expression: ${topExpr.toNSS()}`);\n                              }\n                            }\n                          }\n                        }\n\n                        // Update expression builder's stack pointer AFTER processing (for next instruction)\n                        bodyExprBuilder.setStackPointer(bodyStackSim.getStackPointer());\n                      }\n\n                      const secondCondition = bodyExprBuilder.peek();\n                      if (secondCondition) {\n                        log.info(`[extractConditionFromBlock] Extracted second condition from body block: ${secondCondition.toNSS()}`);\n\n                        // Combine with LOGANDII\n                        const combined = NWScriptExpression.logical('&&', firstCondition, secondCondition);\n                        log.info(`[extractConditionFromBlock] Combined condition: ${combined.toNSS()}`);\n                        return combined;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          return stackTop.expression;\n        }\n\n        // If not on stack, we need to process instructions that build the condition.\n        // Since we don't know which instructions were pre-condition, we'll process\n        // from the beginning to the condition. This will re-process pre-condition\n        // instructions, but that's okay - they should be idempotent (RSADD, CPDOWNSP, etc.).\n        // Actually, this might cause issues. Let's process from the last instruction\n        // before the condition to the condition.\n        const conditionIndex = block.instructions.indexOf(conditionInstr);\n        if (conditionIndex > 0) {\n          // Process instructions from the last instruction before the condition\n          // This assumes the condition expression is built by the last few instructions\n          // before the condition instruction\n          const lastInstrBeforeCondition = block.instructions[conditionIndex - 1];\n\n          // Process from the last instruction before condition to the condition\n          // Actually, let's just process the last instruction before the condition\n          // and see if that gives us the condition on the stack\n          this.stackSimulator.processInstruction(lastInstrBeforeCondition);\n\n          const stackTopAfter = this.stackSimulator.peek();\n          if (stackTopAfter) {\n            return stackTopAfter.expression;\n          }\n        }\n\n        // Fallback: process all instructions up to the condition\n        // This will re-process pre-condition instructions, but should work\n        // Create a temporary expression builder to extract the condition\n        const tempExprBuilder = new NWScriptExpressionBuilder();\n        if (functionContext) {\n          tempExprBuilder.setFunctionParameters(functionContext.parameters);\n          const globalVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n          for (let i = 0; i < this.globalInits.length; i++) {\n            const init = this.globalInits[i];\n            const varName = `globalVar_${i}`;\n            const offsetSigned = init.offset > 0x7FFFFFFF ? init.offset - 0x100000000 : init.offset;\n            globalVarMap.set(offsetSigned, { name: varName, dataType: init.dataType });\n          }\n          tempExprBuilder.setGlobalVariables(globalVarMap);\n\n          const localVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n          for (let i = 0; i < this.localInits.length; i++) {\n            const init = this.localInits[i];\n            const varName = `localVar_${i}`;\n            localVarMap.set(init.offset, { name: varName, dataType: init.dataType });\n          }\n          tempExprBuilder.setLocalVariables(localVarMap);\n        }\n\n        // Get variable stack positions for this function\n        const variableStackPositions = this.functionVariableStackPositions.get(functionContext) ?? new Map<number, number>();\n        tempExprBuilder.setVariableStackPositions(variableStackPositions);\n        tempExprBuilder.setLocalVariableInits(this.localInits);\n\n        // Process instructions up to the condition\n        for (const instr of block.instructions) {\n          if (instr === conditionInstr) {\n            break;\n          }\n          tempExprBuilder.processInstruction(instr);\n        }\n\n        // The condition should now be on the stack\n        const stackTopFinal = tempExprBuilder.peek();\n        if (stackTopFinal) {\n          return stackTopFinal;\n        }\n      }\n    }\n\n    // Fallback: return a default expression\n    return NWScriptExpression.constant(1, NWScriptDataType.INTEGER);\n  }\n\n  /**\n   * Extract cross-block AND condition when LOGANDII spans multiple blocks\n   * This handles cases where the first condition is in one block and the LOGANDII is in another\n   */\n  private extractCrossBlockANDCondition(\n    firstBlock: NWScriptBasicBlock,\n    secondBlock: NWScriptBasicBlock,\n    functionContext: NWScriptFunction | null\n  ): NWScriptExpression | null {\n    log.info(`[extractCrossBlockANDCondition] Starting extraction from block ${firstBlock.id} to block ${secondBlock.id}`);\n\n    // Check if second block contains LOGANDII or if we need to look at its predecessors\n    let logAndIIBlock: NWScriptBasicBlock | null = null;\n    let logAndIIIndex = -1;\n\n    // First check second block\n    logAndIIIndex = secondBlock.instructions.findIndex(instr => instr.code === OP_LOGANDII);\n    if (logAndIIIndex >= 0) {\n      logAndIIBlock = secondBlock;\n      log.info(`[extractCrossBlockANDCondition] Found LOGANDII in block ${secondBlock.id} at index ${logAndIIIndex}`);\n    } else {\n      // Check predecessors of second block\n      log.info(`[extractCrossBlockANDCondition] LOGANDII not in block ${secondBlock.id}, checking predecessors:`, Array.from(secondBlock.predecessors).map((b: NWScriptBasicBlock) => b.id).join(', '));\n      for (const predecessor of secondBlock.predecessors) {\n        const idx = predecessor.instructions.findIndex(instr => instr.code === OP_LOGANDII);\n        if (idx >= 0) {\n          logAndIIBlock = predecessor;\n          logAndIIIndex = idx;\n          log.info(`[extractCrossBlockANDCondition] Found LOGANDII in predecessor block ${predecessor.id} at index ${idx}`);\n          break;\n        }\n      }\n    }\n\n    if (!logAndIIBlock || logAndIIIndex < 0) {\n      log.info(`[extractCrossBlockANDCondition] No LOGANDII found, returning null`);\n      return null;\n    }\n\n    // Setup expression builder\n    const tempExprBuilder = new NWScriptExpressionBuilder();\n    if (functionContext) {\n      tempExprBuilder.setFunctionParameters(functionContext.parameters);\n      const globalVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n      for (let i = 0; i < this.globalInits.length; i++) {\n        const init = this.globalInits[i];\n        const varName = `globalVar_${i}`;\n        const offsetSigned = init.offset > 0x7FFFFFFF ? init.offset - 0x100000000 : init.offset;\n        globalVarMap.set(offsetSigned, { name: varName, dataType: init.dataType });\n      }\n      tempExprBuilder.setGlobalVariables(globalVarMap);\n\n      const localVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n      for (let i = 0; i < this.localInits.length; i++) {\n        const init = this.localInits[i];\n        const varName = `localVar_${i}`;\n        localVarMap.set(init.offset, { name: varName, dataType: init.dataType });\n      }\n      tempExprBuilder.setLocalVariables(localVarMap);\n    }\n\n    // Get variable stack positions for this function\n    const variableStackPositions = this.functionVariableStackPositions.get(functionContext) ?? new Map<number, number>();\n    tempExprBuilder.setVariableStackPositions(variableStackPositions);\n    tempExprBuilder.setLocalVariableInits(this.localInits);\n\n    // Process all instructions from first block up to its condition instruction\n    if (firstBlock.conditionInstruction) {\n      const conditionIndex = firstBlock.instructions.indexOf(firstBlock.conditionInstruction);\n      for (let i = 0; i <= conditionIndex; i++) {\n        tempExprBuilder.processInstruction(firstBlock.instructions[i]);\n      }\n    } else {\n      // Process all instructions in first block\n      for (const instr of firstBlock.instructions) {\n        tempExprBuilder.processInstruction(instr);\n      }\n    }\n\n    // Process instructions from LOGANDII block up to and including LOGANDII\n    if (logAndIIBlock !== secondBlock) {\n      // LOGANDII is in a predecessor block, process it\n      for (let i = 0; i <= logAndIIIndex; i++) {\n        tempExprBuilder.processInstruction(logAndIIBlock.instructions[i]);\n      }\n    } else {\n      // LOGANDII is in second block\n      for (let i = 0; i <= logAndIIIndex; i++) {\n        tempExprBuilder.processInstruction(logAndIIBlock.instructions[i]);\n      }\n    }\n\n    // If second block has a condition instruction, process up to it\n    if (secondBlock.conditionInstruction && logAndIIBlock === secondBlock) {\n      const conditionIndex = secondBlock.instructions.indexOf(secondBlock.conditionInstruction);\n      // Process instructions after LOGANDII up to condition\n      for (let i = logAndIIIndex + 1; i <= conditionIndex; i++) {\n        tempExprBuilder.processInstruction(secondBlock.instructions[i]);\n      }\n    }\n\n    // The combined AND condition should now be on the stack\n    const combinedExpr = tempExprBuilder.peek();\n    if (combinedExpr) {\n      // Check if this is an AND expression with multiple comparisons\n      const comparisons = this.extractComparisonsFromExpression(combinedExpr);\n      if (comparisons.length >= 2) {\n        // Build AND expression from comparisons\n        let result = comparisons[0];\n        for (let i = 1; i < comparisons.length; i++) {\n          result = NWScriptExpression.logical('&&', result, comparisons[i]);\n        }\n        return result;\n      }\n      return combinedExpr;\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract all comparison expressions from an expression tree\n   */\n  private extractComparisonsFromExpression(expr: NWScriptExpression): NWScriptExpression[] {\n    const comparisons: NWScriptExpression[] = [];\n\n    const collect = (e: NWScriptExpression | null): void => {\n      if (!e) return;\n\n      if (e.type === 'logical' && e.operator === '&&') {\n        // Recursively collect from left and right of AND expression\n        collect(e.left);\n        collect(e.right);\n      } else if (e.type === 'comparison') {\n        // This is a comparison - add it to the list\n        comparisons.push(e);\n      }\n      // For other types, don't collect (they're not part of the AND chain)\n    };\n\n    collect(expr);\n    return comparisons;\n  }\n\n  /**\n   * Extract expression from a block (for switch expressions)\n   */\n  private extractExpressionFromBlock(\n    expressionNode: ControlNode,\n    functionContext: NWScriptFunction | null\n  ): NWScriptExpression {\n    // Similar to extractConditionFromBlock but for switch expressions\n    if (expressionNode.type === 'basic_block') {\n      const block = expressionNode.block;\n\n      // Setup function context\n      if (!functionContext) {\n        functionContext = this.blockToFunction.get(block) || null;\n        if (functionContext) {\n          this.setupFunctionContext(functionContext);\n        }\n      }\n\n      // Process all instructions in the block\n      this.stackSimulator.clear();\n      if (functionContext) {\n        this.setupFunctionContext(functionContext);\n      }\n      for (const instr of block.instructions) {\n        this.stackSimulator.processInstruction(instr);\n      }\n\n      // The expression should be on the stack\n      const stackTop = this.stackSimulator.peek();\n      if (stackTop) {\n        // stackTop.expression is already an NWScriptExpression\n        return stackTop.expression;\n      }\n    }\n\n    // Fallback: return a default expression\n    return NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\n  }\n\n  /**\n   * Setup function context for variable resolution\n   *\n   * NOTE: CPTOPSP (variable reads) are now resolved using stack-aware resolution\n   * in NWScriptStackSimulator, which uses the actual stack state and variable\n   * position map. This method only sets up CPDOWNSP offsets (for writes) as\n   * a fallback, and provides variable info for the stack simulator.\n   */\n  private setupFunctionContext(func: NWScriptFunction): void {\n    // Setup local variables for this function\n    // We only need to map CPDOWNSP offsets (for writes) - CPTOPSP uses stack-aware resolution\n    const localVarMap = new Map<number, { name: string, dataType: NWScriptDataType }>();\n\n    for (let i = 0; i < this.localInits.length; i++) {\n      const init = this.localInits[i];\n      const varName = `localVar_${i}`;\n\n      // Map by the CPDOWNSP offset (for writes) - this is static and known from the analyzer\n      const cpdownspOffset = init.offset;\n      localVarMap.set(cpdownspOffset, { name: varName, dataType: init.dataType });\n    }\n\n    // Set local variables in both builders (for backward compatibility and CPDOWNSP writes)\n    // The stack simulator will use stack-aware resolution for CPTOPSP reads\n    this.expressionBuilder.setLocalVariables(localVarMap);\n    this.stackSimulator.setLocalVariables(localVarMap);\n\n    // Setup function parameters\n    this.setFunctionParametersForBuilders(func);\n\n    // Calculate and track the return value stack position\n    // The return value position is where RSADD reserved space before the JSR that calls this function\n    if (!this.functionReturnValueOffsets.has(func)) {\n      log.info(`[setupFunctionContext] Calculating return value position for function ${func.name}...`);\n\n      // First, simulate stack to function entry to get entry stack pointer\n      const entrySP = this.calculateFunctionEntryStackPointer(func);\n      log.info(`[setupFunctionContext] Function ${func.name}: Calculated entry SP = ${entrySP}`);\n      if (entrySP !== undefined) {\n        this.functionEntryStackPointers.set(func, entrySP);\n      }\n\n      // Then calculate return value position and convert to offset from entry\n      const returnValuePos = this.calculateReturnValuePosition(func);\n      log.info(`[setupFunctionContext] Function ${func.name}: Calculated return value absolute position = ${returnValuePos}`);\n\n      if (returnValuePos !== undefined && entrySP !== undefined) {\n        const returnValueOffset = returnValuePos - entrySP;\n        this.functionReturnValueOffsets.set(func, returnValueOffset);\n        log.info(`[setupFunctionContext]  Function ${func.name}: Entry SP = ${entrySP}, Return value absolute pos = ${returnValuePos}, Return value offset = ${returnValueOffset}`);\n      } else {\n        log.info(`[setupFunctionContext]  Function ${func.name}: Missing entrySP (${entrySP}) or returnValuePos (${returnValuePos})`);\n      }\n    } else {\n      const existingOffset = this.functionReturnValueOffsets.get(func);\n      const existingEntrySP = this.functionEntryStackPointers.get(func);\n      log.info(`[setupFunctionContext] Function ${func.name}: Using cached return value offset = ${existingOffset}, entry SP = ${existingEntrySP}`);\n    }\n  }\n\n  /**\n   * Calculate the function entry stack pointer\n   * This is the stack pointer value when the function starts executing\n   * For functions called via JSR, this is the SP at the JSR instruction (before jumping)\n   * For main function, this is the SP at the function's first instruction\n   */\n  private calculateFunctionEntryStackPointer(func: NWScriptFunction): number | undefined {\n    const tempSim = new NWScriptStackSimulator();\n    const entryBlock = this.cfg.entryBlock;\n    if (!entryBlock) {\n      return undefined;\n    }\n\n    if (func.jsrInstruction) {\n      // For functions called via JSR, the entry SP is the SP at the JSR instruction\n      // (the function starts executing at the JSR target, with the same stack state as at JSR)\n      const jsrInstr = func.jsrInstruction;\n      let simCurrent = entryBlock.startInstruction;\n\n      while (simCurrent && simCurrent.address < jsrInstr.address) {\n        tempSim.processInstruction(simCurrent);\n        simCurrent = simCurrent.nextInstr;\n      }\n\n      const entrySP = tempSim.getStackPointer();\n      log.info(`[calculateFunctionEntryStackPointer] Function ${func.name}: JSR at ${jsrInstr.address.toString(16)}, Entry SP (at JSR) = ${entrySP}`);\n      return entrySP;\n    } else {\n      // For main function, check if there's a JSR that calls it\n      // If the function has a return type, it was likely called via JSR with RSADD before it\n      // Find the JSR that targets this function's entry address\n      const funcEntryAddress = func.entryBlock.startInstruction.address;\n      let jsrInstr: NWScriptInstruction | null = null;\n\n      // Search for JSR that targets this function\n      for (const instruction of this.cfg.script.instructions.values()) {\n        if (instruction.code === OP_JSR && instruction.offset !== undefined) {\n          const jsrTarget = instruction.address + instruction.offset;\n          if (jsrTarget === funcEntryAddress) {\n            jsrInstr = instruction;\n            break;\n          }\n        }\n      }\n\n      if (jsrInstr) {\n        // Found JSR that calls this function - use SP at JSR\n        let simCurrent = entryBlock.startInstruction;\n        while (simCurrent && simCurrent.address < jsrInstr.address) {\n          tempSim.processInstruction(simCurrent);\n          simCurrent = simCurrent.nextInstr;\n        }\n        const entrySP = tempSim.getStackPointer();\n        log.info(`[calculateFunctionEntryStackPointer] Function ${func.name}: Found JSR at ${jsrInstr.address.toString(16)} calling entry ${funcEntryAddress.toString(16)}, Entry SP (at JSR) = ${entrySP}`);\n        return entrySP;\n      } else {\n        // No JSR found - simulate to function entry\n        let simCurrent = entryBlock.startInstruction;\n        while (simCurrent && simCurrent.address < funcEntryAddress) {\n          tempSim.processInstruction(simCurrent);\n          simCurrent = simCurrent.nextInstr;\n        }\n        const entrySP = tempSim.getStackPointer();\n        log.info(`[calculateFunctionEntryStackPointer] Function ${func.name}: Entry address = ${funcEntryAddress.toString(16)}, Entry SP = ${entrySP}`);\n        return entrySP;\n      }\n    }\n  }\n\n  /**\n   * Calculate the return value stack position for a function\n   * This is the stack position where RSADD reserved space before the JSR that calls the function\n   */\n  private calculateReturnValuePosition(func: NWScriptFunction): number | undefined {\n    if (!func.jsrInstruction) {\n      // Main function or function without JSR - check if there's an entry RSADD\n      // For main function, the entry RSADD (if present) reserves space for return value\n      if (func.isMain && func.entryBlock) {\n        // Look for RSADD before the first instruction in entry block\n        let current = func.entryBlock.startInstruction;\n        let rsaddInstr: NWScriptInstruction | null = null;\n\n        // Search backwards from entry to find RSADD\n        while (current && current.prevInstr) {\n          current = current.prevInstr;\n          if (current.code === OP_RSADD) {\n            rsaddInstr = current;\n            break;\n          }\n        }\n\n        if (rsaddInstr) {\n          // Simulate stack up to RSADD to get the stack position\n          const tempSim = new NWScriptStackSimulator();\n          let simCurrent = this.cfg.entryBlock?.startInstruction;\n          const spBeforeRsadd = tempSim.getStackPointer();\n          log.info(`[calculateReturnValuePosition] Main function: SP before RSADD at ${rsaddInstr.address.toString(16)} = ${spBeforeRsadd}`);\n          while (simCurrent && simCurrent.address < rsaddInstr.address) {\n            tempSim.processInstruction(simCurrent);\n            simCurrent = simCurrent.nextInstr;\n          }\n          const spAtRsadd = tempSim.getStackPointer();\n          // RSADD reserves space at the current SP (before it pushes)\n          const returnValuePos = spAtRsadd;\n          log.info(`[calculateReturnValuePosition] Main function: SP at RSADD = ${spAtRsadd}, return value position = ${returnValuePos}`);\n          // Process RSADD to see what SP becomes after\n          tempSim.processInstruction(rsaddInstr);\n          const spAfterRsadd = tempSim.getStackPointer();\n          log.info(`[calculateReturnValuePosition] Main function: SP after RSADD = ${spAfterRsadd}`);\n          return returnValuePos;\n        }\n      }\n      return undefined;\n    }\n\n    // For functions called via JSR, find the RSADD before the JSR\n    const jsrInstr = func.jsrInstruction;\n    const jsrBlock = this.cfg.getBlockForAddress(jsrInstr.address);\n    if (!jsrBlock) {\n      return undefined;\n    }\n\n    // Look backwards from JSR to find RSADD\n    let current: NWScriptInstruction | null = jsrInstr.prevInstr;\n    let rsaddInstr: NWScriptInstruction | null = null;\n\n    // Search within the same block first\n    while (current && current.address >= jsrBlock.startInstruction.address) {\n      if (current.code === OP_RSADD) {\n        rsaddInstr = current;\n        break;\n      }\n      current = current.prevInstr;\n    }\n\n    if (!rsaddInstr) {\n      // RSADD might be in a previous block - check predecessors\n      for (const pred of jsrBlock.predecessors) {\n        if (pred.endInstruction && pred.endInstruction.code !== OP_JMP &&\n            pred.endInstruction.code !== OP_JZ && pred.endInstruction.code !== OP_JNZ) {\n          // Check the last few instructions of predecessor\n          let checkInstr = pred.endInstruction;\n          let checkCount = 0;\n          while (checkInstr && checkCount < 5) {\n            if (checkInstr.code === OP_RSADD) {\n              rsaddInstr = checkInstr;\n              break;\n            }\n            checkInstr = checkInstr.prevInstr;\n            checkCount++;\n          }\n          if (rsaddInstr) break;\n        }\n      }\n    }\n\n    if (!rsaddInstr) {\n      log.info(`[calculateReturnValuePosition] Function ${func.name}: No RSADD found before JSR at ${jsrInstr.address.toString(16)}`);\n      return undefined;\n    }\n\n    // Simulate stack up to RSADD to get the stack position\n    // We need to simulate from the entry block to the RSADD instruction\n    const tempSim = new NWScriptStackSimulator();\n    const entryBlock = this.cfg.entryBlock;\n    if (!entryBlock) {\n      return undefined;\n    }\n\n    // Simulate from entry to RSADD\n    let simCurrent = entryBlock.startInstruction;\n    while (simCurrent && simCurrent.address < rsaddInstr.address) {\n      tempSim.processInstruction(simCurrent);\n      simCurrent = simCurrent.nextInstr;\n    }\n\n    const spAtRsadd = tempSim.getStackPointer();\n    // RSADD reserves space at the current SP (before it pushes)\n    const returnValuePos = spAtRsadd;\n    log.info(`[calculateReturnValuePosition] Function ${func.name}: SP at RSADD (before RSADD executes) = ${spAtRsadd}`);\n    // Process RSADD to see what SP becomes after\n    tempSim.processInstruction(rsaddInstr);\n    const spAfterRsadd = tempSim.getStackPointer();\n    log.info(`[calculateReturnValuePosition] Function ${func.name}: SP after RSADD = ${spAfterRsadd}`);\n    // Continue to JSR to see SP at function entry\n    while (simCurrent && simCurrent.address < jsrInstr.address) {\n      tempSim.processInstruction(simCurrent);\n      simCurrent = simCurrent.nextInstr;\n    }\n    // Process JSR (it doesn't change SP, just jumps)\n    const spAtJsr = tempSim.getStackPointer();\n    log.info(`[calculateReturnValuePosition] Function ${func.name}: SP at JSR = ${spAtJsr}`);\n    log.info(`[calculateReturnValuePosition] Function ${func.name}: Found RSADD at ${rsaddInstr.address.toString(16)} before JSR at ${jsrInstr.address.toString(16)}, return value position = ${returnValuePos}`);\n    return returnValuePos;\n  }\n\n  /**\n   * Build global variable declarations\n   */\n  private buildGlobalVariableDeclarations(): NWScriptGlobalVariableDeclarationNode[] {\n    return this.globalInits.map((init, index) => {\n      const name = `globalVar_${index}`;\n      const initializer = init.hasInitializer && init.initialValue !== undefined\n        ? NWScriptExpression.constant(init.initialValue, init.dataType)\n        : undefined;\n\n      return NWScriptAST.createGlobalVariableDeclaration(name, init.dataType, initializer);\n    });\n  }\n\n  /**\n   * Build function nodes from functions\n   * @param mainControlNode The ControlNode tree for the main function (if it exists)\n   */\n  private buildFunctionNodes(structureBuilder: NWScriptControlStructureBuilder, mainControlNode?: ControlNode): NWScriptFunctionNode[] {\n    const functionNodes: NWScriptFunctionNode[] = [];\n\n    // First, add the main function if it exists\n    const mainFunction = this.functions.find(f => f.isMain);\n    if (mainFunction && mainControlNode) {\n      const body = this.convertControlNodeToBlock(mainControlNode, mainFunction);\n      const locals = this.buildLocalVariableDeclarations(mainFunction, body);\n      functionNodes.push(NWScriptAST.createFunction(\n        mainFunction.name,\n        mainFunction.returnType,\n        mainFunction.parameters.map(p => ({ name: p.name, type: p.dataType })),\n        body,\n        locals,\n        mainFunction.entryBlock\n      ));\n    }\n\n    // Then add all other functions\n    return this.functions\n      .filter(func => !func.isMain) // Exclude main function (already added)\n      .map(func => {\n        // Build ControlNode tree for this function\n        const functionControlNode = structureBuilder.buildProcedure(func.entryBlock);\n\n        // Convert ControlNode tree to block\n        const body = this.convertControlNodeToBlock(functionControlNode, func);\n\n        // Build local variable declarations (merge with assignments)\n        const locals = this.buildLocalVariableDeclarations(func, body);\n\n        return NWScriptAST.createFunction(\n          func.name,\n          func.returnType,\n          func.parameters.map(p => ({ name: p.name, type: p.dataType })), // dataType -> type mapping\n          body, // body comes before locals\n          locals,\n          func.entryBlock\n        );\n      })\n      .concat(functionNodes); // Add main function at the end\n  }\n\n  /**\n   * Build local variable declarations for a function\n   * Merges declarations with their first assignment if they occur together\n   */\n  private buildLocalVariableDeclarations(\n    func: NWScriptFunction,\n    body?: NWScriptBlockNode\n  ): NWScriptVariableDeclarationNode[] {\n    // Filter local variables by function - only include variables whose RSADD instruction\n    // is within this function's body blocks\n    const functionLocalInits = this.localInits.filter(init => {\n      // Check if the RSADD instruction address is within any of the function's body blocks\n      for (const block of func.bodyBlocks) {\n        if (block.containsAddress(init.instructionAddress)) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const declarations = functionLocalInits.map((init, index) => {\n      const name = `localVar_${index}`;\n      const initializer = init.hasInitializer && init.initialValue !== undefined\n        ? NWScriptExpression.constant(init.initialValue, init.dataType)\n        : undefined;\n\n      return NWScriptAST.createVariableDeclaration(name, init.dataType, initializer);\n    });\n\n    // If body is provided, merge declarations with their first assignment\n    if (body && body.statements) {\n      const assignmentsToRemove: number[] = [];\n\n      for (let i = 0; i < declarations.length; i++) {\n        const decl = declarations[i];\n        const varName = decl.name;\n\n        // Find the first assignment to this variable in the body\n        for (let j = 0; j < body.statements.length; j++) {\n          const stmt = body.statements[j];\n          if (stmt.type === NWScriptASTNodeType.ASSIGNMENT) {\n            const assignStmt = stmt as NWScriptAssignmentNode;\n            if (assignStmt.variable === varName &&\n                !assignmentsToRemove.includes(j) &&\n                !decl.initializer) { // Only merge if declaration doesn't already have an initializer\n              // Found first assignment - merge into declaration\n              decl.initializer = assignStmt.value;\n              assignmentsToRemove.push(j);\n              break; // Only merge the first assignment\n            }\n          }\n        }\n      }\n\n      // Remove merged assignments from body (in reverse order to maintain indices)\n      assignmentsToRemove.sort((a, b) => b - a);\n      for (const index of assignmentsToRemove) {\n        body.statements.splice(index, 1);\n      }\n    }\n\n    return declarations;\n  }\n\n  /**\n   * Check if a CPDOWNSP instruction is writing a return value\n   * Pattern: CPDOWNSP -> MOVSP -> (intermediate instructions) -> (JMP ->) RETN\n   *\n   * We need to look ahead past intermediate instructions (CPTOPSP, other CPDOWNSP, etc.)\n   * to find RETN or JMP to RETN. If we see too many intermediate instructions or\n   * instructions that indicate this is NOT a return value (like another CPDOWNSP to a variable),\n   * we return false.\n   */\n  private isReturnValueWrite(cpdownsp: NWScriptInstruction, block: NWScriptBasicBlock, cpdownspIndex: number): boolean {\n    // Check if CPDOWNSP is followed by MOVSP\n    if (cpdownspIndex + 1 >= block.instructions.length) {\n      return false;\n    }\n\n    const movsp = block.instructions[cpdownspIndex + 1];\n    if (movsp.code !== OP_MOVSP) {\n      return false;\n    }\n\n    // Look ahead past intermediate instructions to find RETN or JMP to RETN\n    // Intermediate instructions that we can skip: CPTOPSP, other CPDOWNSP (to different locations), MOVSP\n    // Limit: look ahead up to 5 instructions to avoid false positives\n    const lookAheadLimit = Math.min(cpdownspIndex + 7, block.instructions.length);\n    for (let i = cpdownspIndex + 2; i < lookAheadLimit; i++) {\n      const instr = block.instructions[i];\n\n      // If we find RETN directly, this is a return value write\n      if (instr.code === OP_RETN) {\n        return true;\n      }\n\n      // If we find JMP, check if it targets RETN\n      if (instr.code === OP_JMP && instr.offset !== undefined) {\n        const jmpTarget = instr.address + instr.offset;\n        const targetBlock = this.cfg.getBlockForAddress(jmpTarget);\n        if (targetBlock) {\n          // Check if target block ends with RETN\n          if (targetBlock.endInstruction && targetBlock.endInstruction.code === OP_RETN) {\n            return true;\n          }\n          // Check if target block starts with RETN\n          if (targetBlock.instructions.length > 0 && targetBlock.instructions[0].code === OP_RETN) {\n            return true;\n          }\n        }\n        // JMP found but doesn't target RETN - not a return value write\n        return false;\n      }\n\n      // If we find another CPDOWNSP before RETN/JMP, this is NOT a return value write\n      // (it means there's another assignment happening)\n      if (instr.code === OP_CPDOWNSP) {\n        return false;\n      }\n\n      // If we find a terminator that's not RETN or JMP, this is not a return value write\n      if (instr.code === OP_JSR || instr.code === OP_JZ || instr.code === OP_JNZ) {\n        return false;\n      }\n\n      // Continue looking for RETN/JMP (skip intermediate instructions like CPTOPSP, MOVSP)\n    }\n\n    // If we didn't find RETN or JMP to RETN within the look-ahead limit,\n    // this is NOT a return value write\n    return false;\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptControlStructureBuilder.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1238,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1238,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1334,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1334,"endColumn":40},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1352,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1352,"endColumn":40},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1479,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1479,"endColumn":37}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\nimport type { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\r\nimport type { NWScriptControlFlowGraph } from \"@/nwscript/decompiler/NWScriptControlFlowGraph\";\r\nimport { EdgeType } from \"@/nwscript/decompiler/NWScriptEdge\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\nimport { OP_JZ, OP_JNZ, OP_JMP, OP_INCISP, OP_DECIBP, OP_INCIBP, OP_DECISP, OP_CPTOPSP, OP_CPDOWNSP, OP_CPTOPBP, OP_CPDOWNBP, OP_EQUAL, OP_CONST } from '@/nwscript/NWScriptOPCodes';\r\n\r\n/** JSON-serializable debug info for control structure analysis. */\r\nexport interface ControlStructureDebugInfo {\r\n  totalBlocks: number;\r\n  conditionalBlocks: number;\r\n  loopHeaders: number;\r\n  blocksWithTwoSuccessors: number;\r\n  conditionalWithTwoSuccessors: number;\r\n  conditionalWithConditionInstr: number;\r\n  structuresFound: number;\r\n  conditionalBlockDetails: Array<{ id: number; exitType: string; hasConditionInstr: boolean; conditionCode?: number; successors: number; successorIds: number[]; intraProceduralSuccessors: number; intraProceduralSuccessorIds: number[] }>;\r\n  nonConditionalWithTwoSuccessors: Array<{ id: number; exitType: string; startAddress: number; successors: number; successorIds: number[]; edgeTypes: string[]; intraProceduralSuccessors: number; intraProceduralSuccessorIds: number[] }>;\r\n}\r\n\r\n/** JSON-serializable control structure (for toJSON). Nested structures use the same shape. */\r\nexport interface SerializedControlStructure {\r\n  index: number;\r\n  type: ControlStructureType;\r\n  headerBlockId: number;\r\n  headerBlockAddress: number;\r\n  exitBlockId: number;\r\n  exitBlockAddress: number;\r\n  bodyBlockIds: number[];\r\n  bodyBlockAddresses: number[];\r\n  elseBlockIds?: number[];\r\n  elseBlockAddresses?: number[];\r\n  conditionBlockId?: number;\r\n  conditionBlockAddress?: number;\r\n  incrementBlockId?: number;\r\n  incrementBlockAddress?: number;\r\n  initBlockId?: number;\r\n  initBlockAddress?: number;\r\n  switchCases?: Array<{ value: number; blockId: number; blockAddress: number; hasFallThrough: boolean }>;\r\n  defaultBlockId?: number;\r\n  defaultBlockAddress?: number;\r\n  switchCaseFallThrough?: Array<{ value: number; hasFallThrough: boolean }>;\r\n  elseIfBlocks?: Array<{ blockId: number; blockAddress: number; conditionBlockId: number; conditionBlockAddress: number }>;\r\n  breakBlockIds?: number[];\r\n  breakBlockAddresses?: number[];\r\n  continueBlockIds?: number[];\r\n  continueBlockAddresses?: number[];\r\n  nestedStructures?: SerializedControlStructure[];\r\n  blocks?: Record<string, Array<{ id: number; startAddress: number; endAddress: number; exitType: string; isUnreachable?: boolean; isLoopHeader?: boolean; isLoopBody?: boolean; isExit?: boolean; instructionCount: number }>>;\r\n}\r\n\r\n/** Return type of toJSON() for control structure builder. */\r\nexport interface ControlStructureBuilderJSON {\r\n  script: { name: string; totalStructures: number };\r\n  structures: SerializedControlStructure[];\r\n  statistics: ControlStructureDebugInfo;\r\n}\r\n\r\n/**\r\n * ControlNode represents a node in the control flow tree.\r\n * This is a hierarchical representation of control structures.\r\n */\r\nexport type ControlNode =\r\n  | BasicBlockNode\r\n  | IfNode\r\n  | IfElseNode\r\n  | WhileNode\r\n  | DoWhileNode\r\n  | ForNode\r\n  | SwitchNode\r\n  | SequenceNode;\r\n\r\n/**\r\n * A basic block node (leaf node)\r\n */\r\nexport interface BasicBlockNode {\r\n  type: 'basic_block';\r\n  block: NWScriptBasicBlock;\r\n}\r\n\r\n/**\r\n * If statement node\r\n */\r\nexport interface IfNode {\r\n  type: 'if';\r\n  condition: ControlNode; // Condition block\r\n  body: ControlNode; // Then body\r\n}\r\n\r\n/**\r\n * If-else statement node\r\n */\r\nexport interface IfElseNode {\r\n  type: 'if_else';\r\n  condition: ControlNode; // Condition block\r\n  thenBody: ControlNode; // Then body\r\n  elseBody: ControlNode; // Else body\r\n}\r\n\r\n/**\r\n * While loop node\r\n */\r\nexport interface WhileNode {\r\n  type: 'while';\r\n  condition: ControlNode; // Condition block\r\n  body: ControlNode; // Loop body\r\n}\r\n\r\n/**\r\n * Do-while loop node\r\n */\r\nexport interface DoWhileNode {\r\n  type: 'do_while';\r\n  body: ControlNode; // Loop body\r\n  condition: ControlNode; // Condition block\r\n}\r\n\r\n/**\r\n * For loop node\r\n */\r\nexport interface ForNode {\r\n  type: 'for';\r\n  init: ControlNode | null; // Initialization\r\n  condition: ControlNode; // Condition block\r\n  increment: ControlNode | null; // Increment block\r\n  body: ControlNode; // Loop body\r\n}\r\n\r\n/**\r\n * Switch statement node\r\n */\r\nexport interface SwitchNode {\r\n  type: 'switch';\r\n  expression: ControlNode; // Switch expression\r\n  cases: SwitchCase[]; // Case blocks\r\n  defaultCase: ControlNode | null; // Default case\r\n}\r\n\r\n/**\r\n * Switch case\r\n */\r\nexport interface SwitchCase {\r\n  value: number; // Case value\r\n  body: ControlNode; // Case body\r\n}\r\n\r\n/**\r\n * Sequence of control nodes (linear execution)\r\n */\r\nexport interface SequenceNode {\r\n  type: 'sequence';\r\n  nodes: ControlNode[]; // Sequence of nodes\r\n}\r\n\r\n/**\r\n * Region helper: represents a region of blocks with entry and exit points\r\n */\r\nexport interface Region {\r\n  blocks: Set<NWScriptBasicBlock>; // All blocks in the region\r\n  entry: NWScriptBasicBlock; // Entry block\r\n  exits: Set<NWScriptBasicBlock>; // Exit blocks\r\n}\r\n\r\n/**\r\n * Procedure wrapper: represents a procedure/function with entry, blocks, and exits\r\n */\r\nexport interface Procedure {\r\n  entry: NWScriptBasicBlock; // Entry block\r\n  blocks: Set<NWScriptBasicBlock>; // All blocks in the procedure\r\n  exitBlocks: Set<NWScriptBasicBlock>; // Exit blocks (RETN blocks)\r\n}\r\n\r\n/**\r\n * Represents a control structure in the reconstructed script.\r\n */\r\nexport enum ControlStructureType {\r\n  IF = 'if',\r\n  IF_ELSE = 'if_else',\r\n  WHILE = 'while',\r\n  DO_WHILE = 'do_while',\r\n  FOR = 'for',\r\n  SWITCH = 'switch'\r\n}\r\n\r\nexport interface NWScriptControlStructure {\r\n  type: ControlStructureType;\r\n  headerBlock: NWScriptBasicBlock;\r\n  bodyBlocks: NWScriptBasicBlock[];\r\n  elseBlocks?: NWScriptBasicBlock[];\r\n  conditionBlock?: NWScriptBasicBlock;\r\n  incrementBlock?: NWScriptBasicBlock;\r\n  initBlock?: NWScriptBasicBlock; // For loop initialization block\r\n  exitBlock: NWScriptBasicBlock;\r\n  nestedStructures: NWScriptControlStructure[];\r\n  // Switch-specific fields\r\n  switchCases?: Map<number, NWScriptBasicBlock>; // Case value -> case block\r\n  defaultBlock?: NWScriptBasicBlock; // Default case block\r\n  switchCaseFallThrough?: Map<number, boolean>; // Case value -> has fall-through (no break)\r\n  // Else-if chain fields\r\n  elseIfBlocks?: Array<{ block: NWScriptBasicBlock; conditionBlock: NWScriptBasicBlock }>; // Else-if blocks in chain\r\n  // Break/Continue fields\r\n  breakBlocks?: NWScriptBasicBlock[]; // Blocks containing break statements\r\n  continueBlocks?: NWScriptBasicBlock[]; // Blocks containing continue statements\r\n}\r\n\r\n/**\r\n * Reconstructs high-level control structures from the control flow graph.\r\n * Identifies if/else, loops, and other control flow patterns.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptControlStructureBuilder.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptControlStructureBuilder {\r\n  private cfg: NWScriptControlFlowGraph;\r\n  private structures: NWScriptControlStructure[] = [];\r\n  private processedBlocks: Set<NWScriptBasicBlock> = new Set();\r\n\r\n  constructor(cfg: NWScriptControlFlowGraph) {\r\n    this.cfg = cfg;\r\n  }\r\n\r\n  /**\r\n   * Analyze the CFG and identify all control structures\r\n   */\r\n  analyze(): NWScriptControlStructure[] {\r\n    this.structures = [];\r\n    this.processedBlocks.clear();\r\n\r\n    if (!this.cfg.entryBlock) {\r\n      return [];\r\n    }\r\n\r\n    // First, identify loops using dominator information from CFG\r\n    this.identifyLoops();\r\n\r\n    // Process blocks in reverse post-order to handle nested structures\r\n    const blocks = this.cfg.getReversePostOrder();\r\n\r\n    for (const block of blocks) {\r\n      if (this.processedBlocks.has(block)) {\r\n        continue;\r\n      }\r\n\r\n      // Try to identify different control structures\r\n      // Try loops first (they're more specific)\r\n      const loop = this.identifyLoop(block);\r\n      if (loop) {\r\n        // Recursively find nested structures within the loop\r\n        this.findNestedStructures(loop);\r\n        this.structures.push(loop);\r\n        // Only mark header and exit as processed - body blocks may contain nested structures\r\n        this.processedBlocks.add(loop.headerBlock);\r\n        if (loop.exitBlock) {\r\n          this.processedBlocks.add(loop.exitBlock);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Then try switch (before if/else, as switch is more specific)\r\n      const switchStruct = this.identifySwitch(block);\r\n      if (switchStruct) {\r\n        // Recursively find nested structures within the switch\r\n        this.findNestedStructures(switchStruct);\r\n        this.structures.push(switchStruct);\r\n        // Only mark header and exit as processed - body blocks may contain nested structures\r\n        this.processedBlocks.add(switchStruct.headerBlock);\r\n        if (switchStruct.exitBlock) {\r\n          this.processedBlocks.add(switchStruct.exitBlock);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Then try if/else\r\n      const ifElse = this.identifyIfElse(block);\r\n      if (ifElse) {\r\n        // Recursively find nested structures within the if/else\r\n        this.findNestedStructures(ifElse);\r\n        this.structures.push(ifElse);\r\n        // Only mark header and exit as processed - body blocks may contain nested structures\r\n        this.processedBlocks.add(ifElse.headerBlock);\r\n        if (ifElse.exitBlock) {\r\n          this.processedBlocks.add(ifElse.exitBlock);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return this.structures;\r\n  }\r\n\r\n  /**\r\n   * Identify loops in the control flow graph using dominator information\r\n   * A loop is identified when a block is dominated by one of its successors\r\n   * This uses the dominators computed by the CFG\r\n   */\r\n  private identifyLoops(): void {\r\n    // Clear any existing loop markings\r\n    for (const block of this.cfg.blocks.values()) {\r\n      block.isLoopHeader = false;\r\n      block.isLoopBody = false;\r\n    }\r\n\r\n    // A loop is identified when a block is dominated by one of its successors\r\n    // The successor that dominates the block is the loop header\r\n    for (const block of this.cfg.blocks.values()) {\r\n      for (const successor of block.successors) {\r\n        // If the successor dominates this block, we have a loop\r\n        // The successor is the loop header, and this block is part of the loop body\r\n        // Note: We check if successor dominates block (not mutual domination)\r\n        if (successor.dominators.has(block) && successor !== block) {\r\n          successor.isLoopHeader = true;\r\n          block.isLoopBody = true;\r\n          \r\n          // Mark all blocks in the loop body\r\n          this.markLoopBody(block, successor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recursively mark blocks as part of a loop body\r\n   */\r\n  private markLoopBody(block: NWScriptBasicBlock, loopHeader: NWScriptBasicBlock): void {\r\n    block.isLoopBody = true;\r\n    for (const pred of block.predecessors) {\r\n      if (!pred.isLoopBody && pred !== loopHeader) {\r\n        this.markLoopBody(pred, loopHeader);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recursively find nested control structures within a parent structure\r\n   */\r\n  private findNestedStructures(structure: NWScriptControlStructure): void {\r\n    // Create a set of all blocks in this structure (for boundary checking)\r\n    const structureBlocks = new Set<NWScriptBasicBlock>();\r\n    structureBlocks.add(structure.headerBlock);\r\n    structure.bodyBlocks.forEach(b => structureBlocks.add(b));\r\n    if (structure.elseBlocks) {\r\n      structure.elseBlocks.forEach(b => structureBlocks.add(b));\r\n    }\r\n    if (structure.exitBlock) {\r\n      structureBlocks.add(structure.exitBlock);\r\n    }\r\n\r\n    // Find nested structures in the body blocks\r\n    // Process blocks in order to find nested structures\r\n    for (const bodyBlock of structure.bodyBlocks) {\r\n      // Skip if this block is already part of a nested structure we found\r\n      const isInNested = structure.nestedStructures.some(nested =>\r\n        nested.headerBlock === bodyBlock ||\r\n        nested.bodyBlocks.includes(bodyBlock) ||\r\n        nested.elseBlocks?.includes(bodyBlock)\r\n      );\r\n      if (isInNested) {\r\n        continue;\r\n      }\r\n\r\n      // Try to find nested loops\r\n      const nestedLoop = this.identifyLoop(bodyBlock);\r\n      if (nestedLoop) {\r\n        // Verify the nested loop is actually within this structure\r\n        if (structureBlocks.has(nestedLoop.headerBlock) && \r\n            nestedLoop.bodyBlocks.every(b => structureBlocks.has(b))) {\r\n          this.findNestedStructures(nestedLoop);\r\n          structure.nestedStructures.push(nestedLoop);\r\n          // Don't mark as processed - let the code generator handle it\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Try to find nested if/else\r\n      const nestedIfElse = this.identifyIfElse(bodyBlock);\r\n      if (nestedIfElse) {\r\n        // Verify the nested if/else is actually within this structure\r\n        if (structureBlocks.has(nestedIfElse.headerBlock) &&\r\n            nestedIfElse.bodyBlocks.every(b => structureBlocks.has(b)) &&\r\n            (!nestedIfElse.elseBlocks || nestedIfElse.elseBlocks.every(b => structureBlocks.has(b)))) {\r\n          this.findNestedStructures(nestedIfElse);\r\n          structure.nestedStructures.push(nestedIfElse);\r\n          // Don't mark as processed - let the code generator handle it\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Try to find nested switch\r\n      const nestedSwitch = this.identifySwitch(bodyBlock);\r\n      if (nestedSwitch) {\r\n        // Verify the nested switch is actually within this structure\r\n        if (structureBlocks.has(nestedSwitch.headerBlock) &&\r\n            nestedSwitch.bodyBlocks.every(b => structureBlocks.has(b))) {\r\n          this.findNestedStructures(nestedSwitch);\r\n          structure.nestedStructures.push(nestedSwitch);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Find nested structures in else blocks\r\n    if (structure.elseBlocks) {\r\n      for (const elseBlock of structure.elseBlocks) {\r\n        // Skip if this block is already part of a nested structure we found\r\n        const isInNested = structure.nestedStructures.some(nested =>\r\n          nested.headerBlock === elseBlock ||\r\n          nested.bodyBlocks.includes(elseBlock) ||\r\n          nested.elseBlocks?.includes(elseBlock)\r\n        );\r\n        if (isInNested) {\r\n          continue;\r\n        }\r\n\r\n        // Try to find nested loops\r\n        const nestedLoop = this.identifyLoop(elseBlock);\r\n        if (nestedLoop) {\r\n          if (structureBlocks.has(nestedLoop.headerBlock) && \r\n              nestedLoop.bodyBlocks.every(b => structureBlocks.has(b))) {\r\n            this.findNestedStructures(nestedLoop);\r\n            structure.nestedStructures.push(nestedLoop);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // Try to find nested if/else\r\n        const nestedIfElse = this.identifyIfElse(elseBlock);\r\n        if (nestedIfElse) {\r\n          if (structureBlocks.has(nestedIfElse.headerBlock) &&\r\n              nestedIfElse.bodyBlocks.every(b => structureBlocks.has(b)) &&\r\n              (!nestedIfElse.elseBlocks || nestedIfElse.elseBlocks.every(b => structureBlocks.has(b)))) {\r\n            this.findNestedStructures(nestedIfElse);\r\n            structure.nestedStructures.push(nestedIfElse);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // Try to find nested switch\r\n        const nestedSwitch = this.identifySwitch(elseBlock);\r\n        if (nestedSwitch) {\r\n          if (structureBlocks.has(nestedSwitch.headerBlock) &&\r\n              nestedSwitch.bodyBlocks.every(b => structureBlocks.has(b))) {\r\n            this.findNestedStructures(nestedSwitch);\r\n            structure.nestedStructures.push(nestedSwitch);\r\n          }\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify if/else structure\r\n   * Pattern: Block with JZ/JNZ -> two successor paths\r\n   */\r\n  private identifyIfElse(block: NWScriptBasicBlock): NWScriptControlStructure | null {\r\n    if (block.exitType !== 'conditional') {\r\n      return null;\r\n    }\r\n\r\n    const conditionInstr = block.conditionInstruction;\r\n    if (!conditionInstr || (conditionInstr.code !== OP_JZ && conditionInstr.code !== OP_JNZ)) {\r\n      return null;\r\n    }\r\n\r\n    // Get intra-procedural successors only (exclude CALL/RETURN edges)\r\n    // This ensures we only look at actual conditional branches, not function call edges\r\n    const successors = this.cfg.getIntraProceduralSuccessors(block, false);\r\n    if (successors.length !== 2) {\r\n      // If not exactly 2 successors, it's not a simple if/else\r\n      return null;\r\n    }\r\n\r\n    // Use CFG edge types to determine true and false paths\r\n    // The CFG already correctly identifies TRUE_BRANCH and FALSE_BRANCH edges\r\n    let truePath: NWScriptBasicBlock | null = null;\r\n    let falsePath: NWScriptBasicBlock | null = null;\r\n\r\n    for (const successor of successors) {\r\n      const edge = this.cfg.getEdge(block, successor);\r\n      if (edge) {\r\n        if (edge.type === EdgeType.TRUE_BRANCH) {\r\n          truePath = successor;\r\n        } else if (edge.type === EdgeType.FALSE_BRANCH) {\r\n          falsePath = successor;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fallback: If edge types aren't available, use address-based detection\r\n    if (!truePath || !falsePath) {\r\n      const isJZ = conditionInstr.code === OP_JZ;\r\n      const jumpTarget = conditionInstr.offset !== undefined \r\n        ? conditionInstr.address + conditionInstr.offset \r\n        : null;\r\n      \r\n      const succ1 = successors[0];\r\n      const succ2 = successors[1];\r\n      \r\n      if (jumpTarget !== null) {\r\n        if (succ1.startInstruction.address === jumpTarget) {\r\n          if (isJZ) {\r\n            falsePath = succ1; // JZ jumps on false\r\n            truePath = succ2;   // Fallthrough is true\r\n          } else {\r\n            truePath = succ1;   // JNZ jumps on true\r\n            falsePath = succ2;  // Fallthrough is false\r\n          }\r\n        } else if (succ2.startInstruction.address === jumpTarget) {\r\n          if (isJZ) {\r\n            falsePath = succ2; // JZ jumps on false\r\n            truePath = succ1;   // Fallthrough is true\r\n          } else {\r\n            truePath = succ2;   // JNZ jumps on true\r\n            falsePath = succ1;  // Fallthrough is false\r\n          }\r\n        } else {\r\n          // Can't determine from addresses, use heuristic based on instruction type\r\n          if (isJZ) {\r\n            truePath = succ1;   // JZ: first is usually fallthrough (true)\r\n            falsePath = succ2;  // Second is usually jump (false)\r\n          } else {\r\n            truePath = succ1;   // JNZ: first is usually jump (true)\r\n            falsePath = succ2;  // Second is usually fallthrough (false)\r\n          }\r\n        }\r\n      } else {\r\n        // No jump target, use heuristic\r\n        if (isJZ) {\r\n          truePath = succ1;\r\n          falsePath = succ2;\r\n        } else {\r\n          truePath = succ1;\r\n          falsePath = succ2;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!truePath || !falsePath) {\r\n      return null;\r\n    }\r\n\r\n    // Find the merge point (where both paths converge)\r\n    const mergePoint = this.findMergePoint(truePath, falsePath);\r\n    if (!mergePoint) {\r\n      // If no merge point found, check if one or both paths exit (RETN)\r\n      // Determine which path exits and which continues\r\n      const truePathExits = this.collectBlocksBetween(truePath, null).some(b => b.isExit);\r\n      const falsePathExits = this.collectBlocksBetween(falsePath, null).some(b => b.isExit);\r\n      \r\n      if (truePathExits && !falsePathExits) {\r\n        // True path returns, false path continues\r\n        const structure: NWScriptControlStructure = {\r\n          type: ControlStructureType.IF,\r\n          headerBlock: block,\r\n          bodyBlocks: this.collectBlocksBetween(truePath, null),\r\n          exitBlock: falsePath, // False path continues after if\r\n          nestedStructures: []\r\n        };\r\n        return structure;\r\n      } else if (!truePathExits && falsePathExits) {\r\n        // False path returns, true path continues\r\n        const structure: NWScriptControlStructure = {\r\n          type: ControlStructureType.IF,\r\n          headerBlock: block,\r\n          bodyBlocks: this.collectBlocksBetween(falsePath, null),\r\n          exitBlock: truePath, // True path continues after if\r\n          nestedStructures: []\r\n        };\r\n        return structure;\r\n      } else {\r\n        // Both paths exit or neither exits - use post-dominator if available\r\n        // For now, use the first exit block found or the later block\r\n        const structure: NWScriptControlStructure = {\r\n          type: ControlStructureType.IF,\r\n          headerBlock: block,\r\n          bodyBlocks: this.collectBlocksBetween(truePath, null),\r\n          exitBlock: falsePath, // Default fallback\r\n          nestedStructures: []\r\n        };\r\n        return structure;\r\n      }\r\n    }\r\n\r\n    // Collect body blocks\r\n    const trueBodyBlocks = this.collectBlocksBetween(truePath, mergePoint);\r\n    const falseBodyBlocks = this.collectBlocksBetween(falsePath, mergePoint);\r\n\r\n    const structure: NWScriptControlStructure = {\r\n      type: falseBodyBlocks.length > 0 ? ControlStructureType.IF_ELSE : ControlStructureType.IF,\r\n      headerBlock: block,\r\n      bodyBlocks: trueBodyBlocks,\r\n      elseBlocks: falseBodyBlocks.length > 0 ? falseBodyBlocks : undefined,\r\n      exitBlock: mergePoint,\r\n      nestedStructures: []\r\n    };\r\n\r\n    // Detect else-if chains\r\n    this.detectElseIfChain(structure);\r\n\r\n    // Mark break/continue blocks\r\n    this.markBreakContinueBlocks(structure);\r\n\r\n    return structure;\r\n  }\r\n\r\n  /**\r\n   * Detect else-if chains in an if/else structure\r\n   * Else-if chains compile as: if -> JZ to else-if -> JMP to end, else-if -> JZ to next/else -> JMP to end\r\n   */\r\n  private detectElseIfChain(structure: NWScriptControlStructure): void {\r\n    if (!structure.elseBlocks || structure.elseBlocks.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const elseIfBlocks: Array<{ block: NWScriptBasicBlock; conditionBlock: NWScriptBasicBlock }> = [];\r\n    let currentElseBlock = structure.elseBlocks[0];\r\n\r\n    // Check if the else block starts with another if/else\r\n    while (currentElseBlock) {\r\n      // Check if this else block contains a conditional (else-if)\r\n      if (currentElseBlock.exitType === 'conditional' && currentElseBlock.conditionInstruction) {\r\n        const nestedIf = this.identifyIfElse(currentElseBlock);\r\n        if (nestedIf) {\r\n          // Check if this nested if has a JMP to the same exit as the parent\r\n          // This indicates it's part of an else-if chain\r\n          const hasJMPToExit = this.hasJMPToBlock(currentElseBlock, structure.exitBlock);\r\n          if (hasJMPToExit) {\r\n            elseIfBlocks.push({\r\n              block: nestedIf.bodyBlocks[0] || currentElseBlock,\r\n              conditionBlock: nestedIf.headerBlock\r\n            });\r\n\r\n            // Continue with the nested if's else block (if any)\r\n            if (nestedIf.elseBlocks && nestedIf.elseBlocks.length > 0) {\r\n              currentElseBlock = nestedIf.elseBlocks[0];\r\n            } else {\r\n              break;\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        } else {\r\n          break;\r\n        }\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (elseIfBlocks.length > 0) {\r\n      structure.elseIfBlocks = elseIfBlocks;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a block has a JMP instruction that targets a specific block\r\n   */\r\n  private hasJMPToBlock(block: NWScriptBasicBlock, targetBlock: NWScriptBasicBlock): boolean {\r\n    for (const instr of block.instructions) {\r\n      if (instr.code === OP_JMP && instr.offset !== undefined) {\r\n        const targetAddr = instr.address + instr.offset;\r\n        const target = this.cfg.getBlockForAddress(targetAddr);\r\n        if (target === targetBlock) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Mark blocks that contain break or continue statements\r\n   */\r\n  private markBreakContinueBlocks(structure: NWScriptControlStructure): void {\r\n    const breakBlocks: NWScriptBasicBlock[] = [];\r\n    const continueBlocks: NWScriptBasicBlock[] = [];\r\n\r\n    // Check all body blocks for break/continue\r\n    const allBodyBlocks = [\r\n      ...structure.bodyBlocks,\r\n      ...(structure.elseBlocks || []),\r\n      ...(structure.switchCases ? Array.from(structure.switchCases.values()) : []),\r\n      ...(structure.defaultBlock ? [structure.defaultBlock] : [])\r\n    ];\r\n\r\n    for (const bodyBlock of allBodyBlocks) {\r\n      // Check for break: JMP to exit block\r\n      if (this.hasJMPToBlock(bodyBlock, structure.exitBlock)) {\r\n        breakBlocks.push(bodyBlock);\r\n      }\r\n\r\n      // Check for continue: JMP to loop header (for loops/while loops)\r\n      if (structure.type === ControlStructureType.WHILE || \r\n          structure.type === ControlStructureType.DO_WHILE ||\r\n          structure.type === ControlStructureType.FOR) {\r\n        // Continue jumps to condition/increment (for loops) or header (while loops)\r\n        const continueTarget = structure.type === ControlStructureType.FOR && structure.incrementBlock\r\n          ? structure.incrementBlock\r\n          : structure.headerBlock;\r\n        \r\n        if (this.hasJMPToBlock(bodyBlock, continueTarget)) {\r\n          continueBlocks.push(bodyBlock);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (breakBlocks.length > 0) {\r\n      structure.breakBlocks = breakBlocks;\r\n    }\r\n    if (continueBlocks.length > 0) {\r\n      structure.continueBlocks = continueBlocks;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify switch statement structure\r\n   * Pattern: Block with multiple JNZ instructions (case comparisons) followed by JMP (to default/end)\r\n   * Switch compilation pattern:\r\n   *   1. Evaluate switch expression (push to stack)\r\n   *   2. For each case: CPTOPSP + CONST (case value) + EQUAL + JNZ (to case block)\r\n   *   3. JMP (to default or end)\r\n   *   4. Case blocks\r\n   *   5. Default block (optional)\r\n   */\r\n  private identifySwitch(block: NWScriptBasicBlock): NWScriptControlStructure | null {\r\n    // Switch statements typically have multiple JNZ instructions in sequence\r\n    // Look for pattern: CPTOPSP + CONST + EQUAL + JNZ (repeated) + JMP\r\n    \r\n    const instructions = block.instructions;\r\n    if (instructions.length < 4) {\r\n      return null; // Need at least one case (CPTOPSP + CONST + EQUAL + JNZ) + JMP\r\n    }\r\n\r\n    // Find all JNZ instructions that might be case comparisons\r\n    const caseJNZs: Array<{ instr: NWScriptInstruction; caseValue: number | null; caseBlock: NWScriptBasicBlock | null }> = [];\r\n    let defaultJMP: NWScriptInstruction | null = null;\r\n    let defaultTarget: NWScriptBasicBlock | null = null;\r\n\r\n    // Scan instructions for switch pattern\r\n    // Pattern: CPTOPSP + CONST (case value) + EQUAL + JNZ (to case block)\r\n    // This pattern repeats for each case, then ends with JMP (to default/end)\r\n    for (let i = 0; i < instructions.length - 3; i++) {\r\n      const instr = instructions[i];\r\n      \r\n      // Look for pattern: CPTOPSP + CONST + EQUAL + JNZ\r\n      if (instr.code === OP_CPTOPSP) {\r\n        // Check if we have enough instructions remaining\r\n        if (i + 3 >= instructions.length) {\r\n          break;\r\n        }\r\n        \r\n        const constInstr = instructions[i + 1];\r\n        const equalInstr = instructions[i + 2];\r\n        const jnzInstr = instructions[i + 3];\r\n        \r\n        // Check if this matches the switch case pattern\r\n        if (constInstr.code === OP_CONST && \r\n            constInstr.type === 3 && // INTEGER\r\n            equalInstr.code === OP_EQUAL &&\r\n            (jnzInstr.code === OP_JNZ || jnzInstr.code === OP_JZ)) {\r\n          \r\n          // Get case value\r\n          const caseValue = constInstr.integer;\r\n          if (caseValue === undefined) {\r\n            i += 3; // Skip this pattern even if value is undefined\r\n            continue;\r\n          }\r\n          \r\n          // Get case block (target of JNZ)\r\n          const caseTargetAddr = jnzInstr.offset !== undefined \r\n            ? jnzInstr.address + jnzInstr.offset \r\n            : null;\r\n          \r\n          let caseBlock: NWScriptBasicBlock | null = null;\r\n          if (caseTargetAddr !== null) {\r\n            caseBlock = this.cfg.getBlockForAddress(caseTargetAddr);\r\n          }\r\n          \r\n          if (caseBlock) {\r\n            caseJNZs.push({\r\n              instr: jnzInstr,\r\n              caseValue: caseValue,\r\n              caseBlock: caseBlock\r\n            });\r\n          }\r\n          \r\n          // Skip past this pattern (will increment by 1 in for loop, so skip 3 more)\r\n          i += 3;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Need at least 2 cases to be considered a switch (could be 1, but that's more likely an if)\r\n    if (caseJNZs.length < 2) {\r\n      return null;\r\n    }\r\n\r\n    // Find the JMP after all case comparisons (should be right after the last JNZ)\r\n    const lastCaseJNZ = caseJNZs[caseJNZs.length - 1].instr;\r\n    const lastCaseJNZIndex = instructions.indexOf(lastCaseJNZ);\r\n    \r\n    if (lastCaseJNZIndex >= 0 && lastCaseJNZIndex + 1 < instructions.length) {\r\n      const nextInstr = instructions[lastCaseJNZIndex + 1];\r\n      if (nextInstr.code === OP_JMP && nextInstr.offset !== undefined) {\r\n        defaultJMP = nextInstr;\r\n        const defaultTargetAddr = nextInstr.address + nextInstr.offset;\r\n        defaultTarget = this.cfg.getBlockForAddress(defaultTargetAddr);\r\n      }\r\n    }\r\n\r\n    if (!defaultJMP) {\r\n      return null; // Switch must have a JMP to default/end\r\n    }\r\n\r\n    // Collect all case blocks\r\n    const caseBlocks = new Set<NWScriptBasicBlock>();\r\n    const caseValueMap = new Map<number, NWScriptBasicBlock>();\r\n    \r\n    for (const caseJNZ of caseJNZs) {\r\n      if (caseJNZ.caseBlock && caseJNZ.caseValue !== null) {\r\n        caseBlocks.add(caseJNZ.caseBlock);\r\n        caseValueMap.set(caseJNZ.caseValue, caseJNZ.caseBlock);\r\n      }\r\n    }\r\n\r\n    if (caseBlocks.size === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Find the exit block (where all cases converge)\r\n    // This is typically the block after the switch, or the default block if no break statements\r\n    const exitBlock = this.findSwitchExit(Array.from(caseBlocks), defaultTarget, block);\r\n\r\n    if (!exitBlock) {\r\n      return null;\r\n    }\r\n\r\n    // Collect all body blocks (case blocks + default if it exists)\r\n    const bodyBlocks: NWScriptBasicBlock[] = Array.from(caseBlocks);\r\n    if (defaultTarget && defaultTarget !== exitBlock) {\r\n      bodyBlocks.push(defaultTarget);\r\n    }\r\n\r\n    // Remove exit block from body blocks if it's included\r\n    const filteredBodyBlocks = bodyBlocks.filter(b => b !== exitBlock);\r\n\r\n    const structure: NWScriptControlStructure = {\r\n      type: ControlStructureType.SWITCH,\r\n      headerBlock: block,\r\n      bodyBlocks: filteredBodyBlocks,\r\n      exitBlock: exitBlock,\r\n      nestedStructures: [],\r\n      switchCases: caseValueMap,\r\n      defaultBlock: defaultTarget && defaultTarget !== exitBlock ? defaultTarget : undefined\r\n    };\r\n\r\n    // Detect switch case fall-through (cases without break)\r\n    this.detectSwitchFallThrough(structure);\r\n\r\n    // Mark break blocks in switch\r\n    this.markBreakContinueBlocks(structure);\r\n\r\n    return structure;\r\n  }\r\n\r\n  /**\r\n   * Detect switch case fall-through\r\n   * Cases without break statements (JMP to exit) fall through to the next case\r\n   */\r\n  private detectSwitchFallThrough(structure: NWScriptControlStructure): void {\r\n    if (!structure.switchCases || structure.switchCases.size === 0) {\r\n      return;\r\n    }\r\n\r\n    const fallThroughMap = new Map<number, boolean>();\r\n\r\n    // Sort cases by value to check fall-through in order\r\n    const sortedCases = Array.from(structure.switchCases.entries())\r\n      .sort((a, b) => a[0] - b[0]);\r\n\r\n    for (let i = 0; i < sortedCases.length; i++) {\r\n      const [caseValue, caseBlock] = sortedCases[i];\r\n      \r\n      // Check if this case has a break (JMP to exit block)\r\n      const hasBreak = this.hasJMPToBlock(caseBlock, structure.exitBlock);\r\n      \r\n      // If no break, it falls through to the next case (or default)\r\n      fallThroughMap.set(caseValue, !hasBreak);\r\n    }\r\n\r\n    // Also check default block for break\r\n    if (structure.defaultBlock) {\r\n      // Default doesn't need break (it's the last), but we can still mark it\r\n      const hasBreak = this.hasJMPToBlock(structure.defaultBlock, structure.exitBlock);\r\n      // Default typically doesn't have break, but we track it anyway\r\n    }\r\n\r\n    if (fallThroughMap.size > 0) {\r\n      structure.switchCaseFallThrough = fallThroughMap;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the exit block of a switch statement\r\n   * Cases may have break statements (JMP to exit) or fall through\r\n   */\r\n  private findSwitchExit(caseBlocks: NWScriptBasicBlock[], defaultBlock: NWScriptBasicBlock | null, headerBlock: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    // Try to find a common exit point\r\n    // Cases with break will have JMP to exit\r\n    // Cases without break will fall through to next case or default\r\n    \r\n    // First, check if there's a post-dominator\r\n    const ipdom = this.cfg.getImmediatePostDominator(headerBlock);\r\n    if (ipdom && !caseBlocks.includes(ipdom) && ipdom !== defaultBlock) {\r\n      return ipdom;\r\n    }\r\n\r\n    // Check case blocks for JMP to exit\r\n    const exitCandidates = new Set<NWScriptBasicBlock>();\r\n    \r\n    for (const caseBlock of caseBlocks) {\r\n      // Check if case block has JMP (break statement)\r\n      const lastInstr = caseBlock.endInstruction;\r\n      if (lastInstr && lastInstr.code === OP_JMP && lastInstr.offset !== undefined) {\r\n        const exitAddr = lastInstr.address + lastInstr.offset;\r\n        const exitBlock = this.cfg.getBlockForAddress(exitAddr);\r\n        if (exitBlock && !caseBlocks.includes(exitBlock) && exitBlock !== defaultBlock) {\r\n          exitCandidates.add(exitBlock);\r\n        }\r\n      }\r\n    }\r\n\r\n    // If all cases have the same exit, that's the switch exit\r\n    if (exitCandidates.size === 1) {\r\n      return Array.from(exitCandidates)[0];\r\n    }\r\n\r\n    // If default exists and is different from cases, use it as exit\r\n    if (defaultBlock && !caseBlocks.includes(defaultBlock)) {\r\n      return defaultBlock;\r\n    }\r\n\r\n    // Fallback: use the first case block's successor that's not another case\r\n    for (const caseBlock of caseBlocks) {\r\n      const intraSuccs = this.cfg.getIntraProceduralSuccessors(caseBlock, false);\r\n      for (const succ of intraSuccs) {\r\n        if (!caseBlocks.includes(succ) && succ !== defaultBlock) {\r\n          return succ;\r\n        }\r\n      }\r\n    }\r\n\r\n    return defaultBlock || null;\r\n  }\r\n\r\n  /**\r\n   * Identify loop structure\r\n   * Pattern: Block that is a loop header (dominated by a successor)\r\n   */\r\n  private identifyLoop(block: NWScriptBasicBlock): NWScriptControlStructure | null {\r\n    if (!block.isLoopHeader) {\r\n      return null;\r\n    }\r\n\r\n    // Find the back edge (edge from loop body back to header)\r\n    let backEdgeBlock: NWScriptBasicBlock | null = null;\r\n    for (const pred of block.predecessors) {\r\n      if (pred.isLoopBody && pred.successors.has(block)) {\r\n        backEdgeBlock = pred;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!backEdgeBlock) {\r\n      return null;\r\n    }\r\n\r\n    // Determine loop type\r\n    // If condition is at the header, it's a while loop\r\n    // If condition is after the body, it's a do-while loop\r\n    const isDoWhile = block.exitType !== 'conditional';\r\n    const isWhile = block.exitType === 'conditional';\r\n\r\n    // Collect loop body blocks\r\n    const bodyBlocks = this.collectLoopBody(block, backEdgeBlock);\r\n    \r\n    // Find exit block\r\n    const exitBlock = this.findLoopExit(block, bodyBlocks);\r\n\r\n    if (!exitBlock) {\r\n      return null;\r\n    }\r\n\r\n    const structure: NWScriptControlStructure = {\r\n      type: isDoWhile ? ControlStructureType.DO_WHILE : ControlStructureType.WHILE,\r\n      headerBlock: block,\r\n      bodyBlocks: bodyBlocks,\r\n      exitBlock: exitBlock,\r\n      nestedStructures: []\r\n    };\r\n\r\n    // Mark break/continue blocks\r\n    this.markBreakContinueBlocks(structure);\r\n\r\n    // Check if it might be a for loop (has initialization and increment)\r\n    const forLoop = this.identifyForLoop(structure);\r\n    if (forLoop) {\r\n      return forLoop;\r\n    }\r\n\r\n    return structure;\r\n  }\r\n\r\n  /**\r\n   * Attempt to identify a for loop pattern\r\n   * Pattern: initialization -> condition -> body -> increment -> JMP back to condition\r\n   * \r\n   * For loop compilation pattern:\r\n   *   1. Initializer block (before header)\r\n   *   2. Condition block (header) with JZ to exit\r\n   *   3. Body blocks\r\n   *   4. Increment block (in body, before back edge)\r\n   *   5. JMP back to condition (back edge)\r\n   */\r\n  private identifyForLoop(whileLoop: NWScriptControlStructure): NWScriptControlStructure | null {\r\n    // Look for initialization block before the loop header\r\n    const headerPreds = Array.from(whileLoop.headerBlock.predecessors);\r\n    if (headerPreds.length < 2) {\r\n      return null; // Need at least init and back edge\r\n    }\r\n\r\n    // Find the initialization block (not part of loop body, not the back edge)\r\n    // The init block should be a predecessor that's not in the loop body\r\n    let initBlock: NWScriptBasicBlock | null = null;\r\n    for (const pred of headerPreds) {\r\n      if (!pred.isLoopBody && pred !== whileLoop.headerBlock) {\r\n        // Check if this predecessor has a path to the header that doesn't go through the loop body\r\n        // This helps distinguish init blocks from other predecessors\r\n        const intraSuccs = this.cfg.getIntraProceduralSuccessors(pred, false);\r\n        if (intraSuccs.includes(whileLoop.headerBlock)) {\r\n          initBlock = pred;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!initBlock) {\r\n      return null;\r\n    }\r\n\r\n    // Find the increment block in the loop body\r\n    // The increment block should be the last block before the back edge to the header\r\n    // It should contain increment/decrement operations and have a JMP back to header\r\n    const incrementBlock = this.findIncrementBlock(whileLoop.bodyBlocks, whileLoop.headerBlock);\r\n\r\n    if (incrementBlock) {\r\n      // Verify that increment block connects back to header (back edge)\r\n      const incrementSuccs = this.cfg.getIntraProceduralSuccessors(incrementBlock, false);\r\n      if (!incrementSuccs.includes(whileLoop.headerBlock)) {\r\n        // Increment block doesn't connect back to header - not a for loop\r\n        return null;\r\n      }\r\n\r\n      // Validate that init, condition, and increment reference the same variable\r\n      // This reduces false positives (e.g., while loops with unrelated increments)\r\n      if (!this.validateForLoopVariable(initBlock, whileLoop.headerBlock, incrementBlock)) {\r\n        // Variables don't match - likely not a for loop\r\n        return null;\r\n      }\r\n\r\n      // Create for loop structure\r\n      const forLoop: NWScriptControlStructure = {\r\n        type: ControlStructureType.FOR,\r\n        headerBlock: whileLoop.headerBlock,\r\n        bodyBlocks: whileLoop.bodyBlocks,\r\n        conditionBlock: whileLoop.headerBlock, // Condition is at header\r\n        initBlock: initBlock, // Initialization block\r\n        incrementBlock: incrementBlock,\r\n        exitBlock: whileLoop.exitBlock,\r\n        nestedStructures: []\r\n      };\r\n\r\n      // Mark break/continue blocks\r\n      this.markBreakContinueBlocks(forLoop);\r\n\r\n      return forLoop;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Validate that init, condition, and increment blocks reference the same variable\r\n   * This helps reduce false positives where a while loop has an unrelated increment\r\n   */\r\n  private validateForLoopVariable(\r\n    initBlock: NWScriptBasicBlock,\r\n    conditionBlock: NWScriptBasicBlock,\r\n    incrementBlock: NWScriptBasicBlock\r\n  ): boolean {\r\n    // Extract variable offsets from each block\r\n    const initOffsets = this.extractVariableOffsets(initBlock);\r\n    const conditionOffsets = this.extractVariableOffsets(conditionBlock);\r\n    const incrementOffsets = this.extractVariableOffsets(incrementBlock);\r\n\r\n    // Check if there's a common offset between init, condition, and increment\r\n    // For a valid for loop, the same variable should be:\r\n    // - Written in init (CPDOWNSP/CPDOWNBP)\r\n    // - Read in condition (CPTOPSP/CPTOPBP)\r\n    // - Modified in increment (INCISP/DECISP/INCIBP/DECIBP or CPDOWNSP/CPDOWNBP)\r\n\r\n    // Find common offsets\r\n    const initSet = new Set(initOffsets);\r\n    const conditionSet = new Set(conditionOffsets);\r\n    const incrementSet = new Set(incrementOffsets);\r\n\r\n    // Check if there's overlap between all three\r\n    for (const offset of initSet) {\r\n      if (conditionSet.has(offset) && incrementSet.has(offset)) {\r\n        return true; // Found a common variable\r\n      }\r\n    }\r\n\r\n    // Also check if increment modifies a variable that's read in condition\r\n    // (init might not write to the same variable if it's already initialized)\r\n    for (const offset of incrementSet) {\r\n      if (conditionSet.has(offset)) {\r\n        return true; // Increment and condition share a variable\r\n      }\r\n    }\r\n\r\n    // If no common variable found, it's likely not a for loop\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Extract variable offsets from a block\r\n   * Returns array of offsets (can be SP or BP offsets)\r\n   */\r\n  private extractVariableOffsets(block: NWScriptBasicBlock): number[] {\r\n    const offsets: number[] = [];\r\n\r\n    for (const instr of block.instructions) {\r\n      // Variable read/write operations\r\n      if (instr.code === OP_CPTOPSP || instr.code === OP_CPDOWNSP ||\r\n          instr.code === OP_CPTOPBP || instr.code === OP_CPDOWNBP) {\r\n        if (instr.offset !== undefined) {\r\n          offsets.push(instr.offset);\r\n        }\r\n      }\r\n      // Increment/decrement operations\r\n      else if (instr.code === OP_INCISP || instr.code === OP_DECISP ||\r\n               instr.code === OP_INCIBP || instr.code === OP_DECIBP) {\r\n        if (instr.offset !== undefined) {\r\n          offsets.push(instr.offset);\r\n        }\r\n      }\r\n    }\r\n\r\n    return offsets;\r\n  }\r\n\r\n  /**\r\n   * Find increment/decrement block in loop body\r\n   * The increment block should be the last block before the back edge to the header\r\n   * It should contain increment/decrement operations and have a JMP back to header\r\n   */\r\n  private findIncrementBlock(bodyBlocks: NWScriptBasicBlock[], loopHeader: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    // Look for blocks with increment/decrement operations that connect back to header\r\n    // The increment block is typically the last block in the loop body before the back edge\r\n    const candidates: Array<{ block: NWScriptBasicBlock; hasIncrement: boolean; connectsToHeader: boolean }> = [];\r\n    \r\n    for (const block of bodyBlocks) {\r\n      // Check if block has increment/decrement operations\r\n      let hasIncrement = false;\r\n      for (const instr of block.instructions) {\r\n        if (instr.code === OP_INCISP || instr.code === OP_DECISP ||\r\n            instr.code === OP_INCIBP || instr.code === OP_DECIBP) {\r\n          hasIncrement = true;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      // Check if block connects back to header (back edge)\r\n      const intraSuccs = this.cfg.getIntraProceduralSuccessors(block, false);\r\n      const connectsToHeader = intraSuccs.includes(loopHeader);\r\n      \r\n      // Also check if block ends with JMP to header\r\n      const endsWithJMPToHeader = block.endInstruction.code === OP_JMP &&\r\n        block.endInstruction.offset !== undefined &&\r\n        this.cfg.getBlockForAddress(block.endInstruction.address + block.endInstruction.offset) === loopHeader;\r\n      \r\n      if (hasIncrement && (connectsToHeader || endsWithJMPToHeader)) {\r\n        candidates.push({ block, hasIncrement, connectsToHeader: connectsToHeader || endsWithJMPToHeader });\r\n      }\r\n    }\r\n    \r\n    if (candidates.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    // Prefer blocks that directly connect to header\r\n    const directConnections = candidates.filter(c => c.connectsToHeader);\r\n    if (directConnections.length > 0) {\r\n      // If multiple candidates, prefer the one closest to the header (lowest address)\r\n      directConnections.sort((a, b) => \r\n        a.block.startInstruction.address - b.block.startInstruction.address\r\n      );\r\n      return directConnections[0].block;\r\n    }\r\n    \r\n    // Fallback: return first candidate\r\n    return candidates[0].block;\r\n  }\r\n\r\n  /**\r\n   * Collect blocks between start and end (excluding end)\r\n   * If end is null, collect all reachable blocks\r\n   */\r\n  /**\r\n   * Collect all blocks between start and end (exclusive of end)\r\n   * Uses BFS to collect blocks in a more predictable order\r\n   * Only follows intra-procedural edges (excludes CALL/RETURN edges)\r\n   */\r\n  private collectBlocksBetween(start: NWScriptBasicBlock, end: NWScriptBasicBlock | null): NWScriptBasicBlock[] {\r\n    const blocks: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [start];\r\n\r\n    // Use BFS instead of DFS for more predictable ordering\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      \r\n      if (current === end || visited.has(current)) {\r\n        continue;\r\n      }\r\n\r\n      // Skip unreachable blocks\r\n      if (current.isUnreachable) {\r\n        continue;\r\n      }\r\n\r\n      visited.add(current);\r\n      blocks.push(current);\r\n\r\n      // Only follow intra-procedural successors (exclude CALL/RETURN edges)\r\n      const intraSuccs = this.cfg.getIntraProceduralSuccessors(current, false);\r\n      for (const successor of intraSuccs) {\r\n        if (end === null || successor !== end) {\r\n          if (!visited.has(successor)) {\r\n            queue.push(successor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Note: Blocks are collected in BFS order, but will be re-sorted by CFG execution order\r\n    // in buildStructureBody for correct statement ordering\r\n    return blocks;\r\n  }\r\n\r\n  /**\r\n   * Collect loop body blocks\r\n   * Only follows intra-procedural edges\r\n   */\r\n  private collectLoopBody(header: NWScriptBasicBlock, backEdge: NWScriptBasicBlock): NWScriptBasicBlock[] {\r\n    const bodyBlocks: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n\r\n    const collect = (current: NWScriptBasicBlock) => {\r\n      if (current === header || visited.has(current)) {\r\n        return;\r\n      }\r\n\r\n      visited.add(current);\r\n      if (current.isLoopBody && !current.isUnreachable) {\r\n        bodyBlocks.push(current);\r\n      }\r\n\r\n      // Only follow intra-procedural successors\r\n      const intraSuccs = this.cfg.getIntraProceduralSuccessors(current, false);\r\n      for (const successor of intraSuccs) {\r\n        // Continue if it's not the header, or if it's the back edge connecting to header\r\n        if (successor !== header || current === backEdge) {\r\n          collect(successor);\r\n        }\r\n      }\r\n    };\r\n\r\n    // Start from header's intra-procedural successors\r\n    const headerIntraSuccs = this.cfg.getIntraProceduralSuccessors(header, false);\r\n    for (const successor of headerIntraSuccs) {\r\n      if (successor.isLoopBody) {\r\n        collect(successor);\r\n      }\r\n    }\r\n\r\n    return bodyBlocks;\r\n  }\r\n\r\n  /**\r\n   * Find the merge point where two paths converge\r\n   * Uses BFS to find the first common block reachable from both paths\r\n   * Only follows intra-procedural edges (excludes CALL/RETURN edges)\r\n   * Uses post-dominator information if available for more accurate results\r\n   */\r\n  private findMergePoint(path1: NWScriptBasicBlock, path2: NWScriptBasicBlock): NWScriptBasicBlock | null {\r\n    // First, try using post-dominator analysis for more accurate results\r\n    // The merge point should be the immediate post-dominator of the conditional block\r\n    // that is reachable from both paths\r\n    \r\n    // Use BFS to find common reachable block (intra-procedural only)\r\n    const visited1 = new Set<NWScriptBasicBlock>();\r\n    const visited2 = new Set<NWScriptBasicBlock>();\r\n\r\n    const queue1: NWScriptBasicBlock[] = [path1];\r\n    const queue2: NWScriptBasicBlock[] = [path2];\r\n\r\n    // Limit search depth to avoid infinite loops\r\n    const maxDepth = 100;\r\n    let depth = 0;\r\n\r\n    while ((queue1.length > 0 || queue2.length > 0) && depth < maxDepth) {\r\n      depth++;\r\n\r\n      // Process path1\r\n      if (queue1.length > 0) {\r\n        const current = queue1.shift()!;\r\n        if (visited2.has(current)) {\r\n          return current; // Found merge point\r\n        }\r\n        if (!visited1.has(current)) {\r\n          visited1.add(current);\r\n          // Only follow intra-procedural successors\r\n          const intraSuccs = this.cfg.getIntraProceduralSuccessors(current, false);\r\n          for (const successor of intraSuccs) {\r\n            if (!visited1.has(successor)) {\r\n              queue1.push(successor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Process path2\r\n      if (queue2.length > 0) {\r\n        const current = queue2.shift()!;\r\n        if (visited1.has(current)) {\r\n          return current; // Found merge point\r\n        }\r\n        if (!visited2.has(current)) {\r\n          visited2.add(current);\r\n          // Only follow intra-procedural successors\r\n          const intraSuccs = this.cfg.getIntraProceduralSuccessors(current, false);\r\n          for (const successor of intraSuccs) {\r\n            if (!visited2.has(successor)) {\r\n              queue2.push(successor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Find the exit block of a loop\r\n   * Uses post-dominator analysis for more accurate results\r\n   */\r\n  private findLoopExit(header: NWScriptBasicBlock, bodyBlocks: NWScriptBasicBlock[]): NWScriptBasicBlock | null {\r\n    // First, try to use post-dominator information\r\n    // The immediate post-dominator of the header (that's not in the loop) is the exit\r\n    const ipdom = this.cfg.getImmediatePostDominator(header);\r\n    if (ipdom && !ipdom.isLoopBody && !bodyBlocks.includes(ipdom)) {\r\n      return ipdom;\r\n    }\r\n\r\n    // Fallback: Exit is typically a block that:\r\n    // 1. Is reached from the loop but not part of the loop body\r\n    // 2. Or is a successor of the header that's not in the loop body\r\n    // Only check intra-procedural successors\r\n    const headerIntraSuccs = this.cfg.getIntraProceduralSuccessors(header, false);\r\n    for (const successor of headerIntraSuccs) {\r\n      if (!successor.isLoopBody && !bodyBlocks.includes(successor)) {\r\n        return successor;\r\n      }\r\n    }\r\n\r\n    // Check body blocks for exits (intra-procedural only)\r\n    for (const bodyBlock of bodyBlocks) {\r\n      const bodyIntraSuccs = this.cfg.getIntraProceduralSuccessors(bodyBlock, false);\r\n      for (const successor of bodyIntraSuccs) {\r\n        if (!successor.isLoopBody && !bodyBlocks.includes(successor) && successor !== header) {\r\n          return successor;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Mark all blocks in a structure as processed\r\n   */\r\n  private markBlocksProcessed(structure: NWScriptControlStructure): void {\r\n    this.processedBlocks.add(structure.headerBlock);\r\n    this.processedBlocks.add(structure.exitBlock);\r\n    \r\n    for (const block of structure.bodyBlocks) {\r\n      this.processedBlocks.add(block);\r\n    }\r\n\r\n    if (structure.elseBlocks) {\r\n      for (const block of structure.elseBlocks) {\r\n        this.processedBlocks.add(block);\r\n      }\r\n    }\r\n\r\n    if (structure.incrementBlock) {\r\n      this.processedBlocks.add(structure.incrementBlock);\r\n    }\r\n\r\n    if (structure.initBlock) {\r\n      this.processedBlocks.add(structure.initBlock);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all identified structures\r\n   */\r\n  getStructures(): NWScriptControlStructure[] {\r\n    return this.structures;\r\n  }\r\n\r\n  /**\r\n   * Build a ControlNode tree for a procedure starting at the given entry block.\r\n   * This creates a hierarchical representation of the control flow.\r\n   * \r\n   * Note: This method will automatically call identifyLoops() if loops haven't been\r\n   * identified yet, as loop detection depends on isLoopHeader/isLoopBody flags.\r\n   * \r\n   * @param entry The entry block of the procedure\r\n   * @returns A ControlNode tree representing the procedure's control flow\r\n   */\r\n  buildProcedure(entry: NWScriptBasicBlock): ControlNode {\r\n    // Ensure loops have been identified (needed for identifyLoop() to work)\r\n    // Check if any blocks have loop flags set - if not, identify loops first\r\n    const hasLoopFlags = Array.from(this.cfg.blocks.values()).some(b => b.isLoopHeader || b.isLoopBody);\r\n    if (!hasLoopFlags) {\r\n      this.identifyLoops();\r\n    }\r\n    \r\n    // First, identify the procedure region\r\n    const procedure = this.identifyProcedure(entry);\r\n    \r\n    // Build the control node tree for this procedure\r\n    return this.buildControlNodeTree(procedure);\r\n  }\r\n\r\n  /**\r\n   * Identify a procedure from its entry block.\r\n   * Collects all blocks reachable from the entry until exit blocks (RETN).\r\n   */\r\n  private identifyProcedure(entry: NWScriptBasicBlock): Procedure {\r\n    const blocks = new Set<NWScriptBasicBlock>();\r\n    log.info(`[identifyProcedure] Starting from entry block ${entry.id}`);\r\n    const exitBlocks = new Set<NWScriptBasicBlock>();\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [entry];\r\n\r\n    // BFS to collect all reachable blocks\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (visited.has(current)) {\r\n        continue;\r\n      }\r\n      visited.add(current);\r\n      blocks.add(current);\r\n      \r\n      log.info(`[identifyProcedure] Processing block ${current.id} (${current.instructions.length} instructions), isExit: ${current.isExit}, exitType: ${current.exitType}`);\r\n\r\n      // Check if this is an exit block\r\n      if (current.isExit || current.exitType === 'return') {\r\n        log.info(`[identifyProcedure] Block ${current.id} is an exit block, stopping traversal`);\r\n        exitBlocks.add(current);\r\n        continue; // Don't follow successors of exit blocks\r\n      }\r\n\r\n      // Add intra-procedural successors (exclude CALL edges)\r\n      const intraSuccs = this.cfg.getIntraProceduralSuccessors(current, false);\r\n      const allSuccs = Array.from(current.successors);\r\n      log.info(`[identifyProcedure] Block ${current.id} has ${allSuccs.length} total successors:`, allSuccs.map(s => `block ${s.id} (exitType: ${s.exitType})`).join(', '));\r\n      log.info(`[identifyProcedure] Block ${current.id} has ${intraSuccs.length} intra-procedural successors:`, intraSuccs.map(s => `block ${s.id}`).join(', '));\r\n      for (const succ of intraSuccs) {\r\n        if (!visited.has(succ)) {\r\n          log.info(`[identifyProcedure] Adding block ${succ.id} to queue`);\r\n          queue.push(succ);\r\n        } else {\r\n          log.info(`[identifyProcedure] Block ${succ.id} already visited, skipping`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    log.info(`[identifyProcedure] Found ${blocks.size} blocks total:`, Array.from(blocks).map(b => `block ${b.id}`).join(', '));\r\n    log.info(`[identifyProcedure] Found ${exitBlocks.size} exit blocks:`, Array.from(exitBlocks).map(b => `block ${b.id}`).join(', '));\r\n\r\n    return {\r\n      entry,\r\n      blocks,\r\n      exitBlocks\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build a ControlNode tree from a procedure.\r\n   * Recursively identifies control structures and builds the tree.\r\n   */\r\n  private buildControlNodeTree(procedure: Procedure): ControlNode {\r\n    const processed = new Set<NWScriptBasicBlock>();\r\n\r\n    // Process blocks in execution order\r\n    const orderedBlocks = this.cfg.getTopologicalOrder()\r\n      .filter(block => procedure.blocks.has(block));\r\n\r\n    log.info(`[buildControlNodeTree] Ordered blocks: ${orderedBlocks.length}`, orderedBlocks.map(b => `block ${b.id}`).join(', '));\r\n\r\n    // Build control nodes starting from entry\r\n    // Start with the entry block and build recursively\r\n    const rootNode = this.buildNodeFromBlock(procedure.entry, procedure, processed);\r\n    \r\n    log.info(`[buildControlNodeTree] After buildNodeFromBlock(entry), processed: ${processed.size} blocks`);\r\n    log.info(`[buildControlNodeTree] Processed blocks:`, Array.from(processed).map(b => `block ${b.id}`).join(', '));\r\n    \r\n    // If we have remaining unprocessed blocks, create a sequence\r\n    const remainingBlocks = orderedBlocks.filter(b => !processed.has(b));\r\n    log.info(`[buildControlNodeTree] Remaining blocks: ${remainingBlocks.length}`, remainingBlocks.map(b => `block ${b.id}`).join(', '));\r\n    \r\n    if (remainingBlocks.length > 0) {\r\n      const remainingNodes = remainingBlocks.map(b => \r\n        this.buildNodeFromBlock(b, procedure, processed) || { type: 'basic_block' as const, block: b }\r\n      );\r\n      \r\n      if (rootNode) {\r\n        log.info(`[buildControlNodeTree] Creating sequence with root + ${remainingNodes.length} remaining nodes`);\r\n        return {\r\n          type: 'sequence',\r\n          nodes: [rootNode, ...remainingNodes]\r\n        };\r\n      } else {\r\n        log.info(`[buildControlNodeTree] No root node, returning ${remainingNodes.length} remaining nodes`);\r\n        return remainingNodes.length === 1 \r\n          ? remainingNodes[0]\r\n          : { type: 'sequence', nodes: remainingNodes };\r\n      }\r\n    }\r\n\r\n    // If no structure found, return a sequence of basic blocks\r\n    if (!rootNode) {\r\n      log.info(`[buildControlNodeTree] No root node, building sequence from all ordered blocks`);\r\n      return this.buildSequenceNode(orderedBlocks, procedure, processed);\r\n    }\r\n\r\n    log.info(`[buildControlNodeTree] Returning root node only (type: ${rootNode.type})`);\r\n    return rootNode;\r\n  }\r\n\r\n  /**\r\n   * Build a control node starting from a given block.\r\n   */\r\n  private buildNodeFromBlock(\r\n    block: NWScriptBasicBlock,\r\n    procedure: Procedure,\r\n    processed: Set<NWScriptBasicBlock>\r\n  ): ControlNode | null {\r\n    if (processed.has(block)) {\r\n      log.info(`[buildNodeFromBlock] Block ${block.id} already processed, skipping`);\r\n      return null;\r\n    }\r\n\r\n    // Check if block is in procedure\r\n    if (!procedure.blocks.has(block)) {\r\n      log.info(`[buildNodeFromBlock] Block ${block.id} not in procedure, skipping`);\r\n      return null;\r\n    }\r\n    \r\n    log.info(`[buildNodeFromBlock] Processing block ${block.id} (${block.instructions.length} instructions)`);\r\n\r\n    // Try to identify control structures\r\n    const ifElse = this.identifyIfElse(block);\r\n    if (ifElse && this.isStructureInProcedure(ifElse, procedure)) {\r\n      // Only mark header and exit as processed - body blocks will be processed by buildIfElseNode\r\n      processed.add(ifElse.headerBlock);\r\n      if (ifElse.exitBlock) {\r\n        processed.add(ifElse.exitBlock);\r\n      }\r\n      return this.buildIfElseNode(ifElse, procedure, processed);\r\n    }\r\n\r\n    const loop = this.identifyLoop(block);\r\n    if (loop && this.isStructureInProcedure(loop, procedure)) {\r\n      // Only mark header and exit as processed - body blocks will be processed by buildLoopNode\r\n      processed.add(loop.headerBlock);\r\n      if (loop.exitBlock) {\r\n        processed.add(loop.exitBlock);\r\n      }\r\n      return this.buildLoopNode(loop, procedure, processed);\r\n    }\r\n\r\n    const switchStruct = this.identifySwitch(block);\r\n    if (switchStruct && this.isStructureInProcedure(switchStruct, procedure)) {\r\n      // Only mark header and exit as processed - body blocks will be processed by buildSwitchNode\r\n      processed.add(switchStruct.headerBlock);\r\n      if (switchStruct.exitBlock) {\r\n        processed.add(switchStruct.exitBlock);\r\n      }\r\n      return this.buildSwitchNode(switchStruct, procedure, processed);\r\n    }\r\n\r\n    // No structure found, return basic block node\r\n    processed.add(block);\r\n    return { type: 'basic_block', block };\r\n  }\r\n\r\n  /**\r\n   * Check if a control structure is within the procedure.\r\n   */\r\n  private isStructureInProcedure(\r\n    structure: NWScriptControlStructure,\r\n    procedure: Procedure\r\n  ): boolean {\r\n    if (!procedure.blocks.has(structure.headerBlock)) {\r\n      return false;\r\n    }\r\n    if (structure.exitBlock && !procedure.blocks.has(structure.exitBlock)) {\r\n      return false;\r\n    }\r\n    return structure.bodyBlocks.every(b => procedure.blocks.has(b));\r\n  }\r\n\r\n  /**\r\n   * Build an if-else node from a control structure.\r\n   */\r\n  private buildIfElseNode(\r\n    structure: NWScriptControlStructure,\r\n    procedure: Procedure,\r\n    processed: Set<NWScriptBasicBlock>\r\n  ): ControlNode {\r\n    const conditionNode: ControlNode = { type: 'basic_block', block: structure.headerBlock };\r\n    \r\n    // Build then body\r\n    const thenBody = this.buildSequenceNode(structure.bodyBlocks, procedure, processed);\r\n    \r\n    if (structure.elseBlocks && structure.elseBlocks.length > 0) {\r\n      // If-else\r\n      const elseBody = this.buildSequenceNode(structure.elseBlocks, procedure, processed);\r\n      return {\r\n        type: 'if_else',\r\n        condition: conditionNode,\r\n        thenBody,\r\n        elseBody\r\n      };\r\n    } else {\r\n      // If only\r\n      return {\r\n        type: 'if',\r\n        condition: conditionNode,\r\n        body: thenBody\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a loop node from a control structure.\r\n   */\r\n  private buildLoopNode(\r\n    structure: NWScriptControlStructure,\r\n    procedure: Procedure,\r\n    processed: Set<NWScriptBasicBlock>\r\n  ): ControlNode {\r\n    const conditionNode: ControlNode = { type: 'basic_block', block: structure.headerBlock };\r\n    const body = this.buildSequenceNode(structure.bodyBlocks, procedure, processed);\r\n\r\n    switch (structure.type) {\r\n      case ControlStructureType.WHILE:\r\n        return {\r\n          type: 'while',\r\n          condition: conditionNode,\r\n          body\r\n        };\r\n      case ControlStructureType.DO_WHILE:\r\n        return {\r\n          type: 'do_while',\r\n          body,\r\n          condition: conditionNode\r\n        };\r\n      case ControlStructureType.FOR:\r\n        const initNode = structure.initBlock \r\n          ? { type: 'basic_block' as const, block: structure.initBlock }\r\n          : null;\r\n        const incrementNode = structure.incrementBlock\r\n          ? { type: 'basic_block' as const, block: structure.incrementBlock }\r\n          : null;\r\n        return {\r\n          type: 'for',\r\n          init: initNode,\r\n          condition: conditionNode,\r\n          increment: incrementNode,\r\n          body\r\n        };\r\n      default:\r\n        // Fallback to while\r\n        return {\r\n          type: 'while',\r\n          condition: conditionNode,\r\n          body\r\n        };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a switch node from a control structure.\r\n   */\r\n  private buildSwitchNode(\r\n    structure: NWScriptControlStructure,\r\n    procedure: Procedure,\r\n    processed: Set<NWScriptBasicBlock>\r\n  ): ControlNode {\r\n    const expressionNode: ControlNode = { type: 'basic_block', block: structure.headerBlock };\r\n    \r\n    // Build case nodes\r\n    const cases: SwitchCase[] = [];\r\n    if (structure.switchCases) {\r\n      for (const [caseValue, caseBlock] of structure.switchCases.entries()) {\r\n        const caseBody = this.buildSequenceNode([caseBlock], procedure, processed);\r\n        cases.push({\r\n          value: caseValue,\r\n          body: caseBody\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Build default case if it exists\r\n    const defaultCase = structure.defaultBlock\r\n      ? this.buildSequenceNode([structure.defaultBlock], procedure, processed)\r\n      : null;\r\n    \r\n    return {\r\n      type: 'switch',\r\n      expression: expressionNode,\r\n      cases: cases,\r\n      defaultCase: defaultCase\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build a sequence node from a list of blocks.\r\n   */\r\n  private buildSequenceNode(\r\n    blocks: NWScriptBasicBlock[],\r\n    procedure: Procedure,\r\n    processed: Set<NWScriptBasicBlock>\r\n  ): ControlNode {\r\n    const nodes: ControlNode[] = [];\r\n\r\n    // Sort blocks by execution order\r\n    const orderedBlocks = blocks\r\n      .filter(b => procedure.blocks.has(b))\r\n      .sort((a, b) => a.startInstruction.address - b.startInstruction.address);\r\n\r\n    for (const block of orderedBlocks) {\r\n      if (processed.has(block)) {\r\n        continue;\r\n      }\r\n\r\n      const node = this.buildNodeFromBlock(block, procedure, processed);\r\n      if (node) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n\r\n    if (nodes.length === 0) {\r\n      // Empty sequence - return a placeholder\r\n      return { type: 'basic_block', block: blocks[0] || procedure.entry };\r\n    }\r\n\r\n    if (nodes.length === 1) {\r\n      return nodes[0];\r\n    }\r\n\r\n    return {\r\n      type: 'sequence',\r\n      nodes\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a Region from a set of blocks.\r\n   * Identifies entry and exit points automatically.\r\n   */\r\n  createRegion(blocks: Set<NWScriptBasicBlock>): Region {\r\n    let entry: NWScriptBasicBlock | null = null;\r\n    const exits = new Set<NWScriptBasicBlock>();\r\n\r\n    // Find entry (block with no predecessors in the region, or earliest address)\r\n    for (const block of blocks) {\r\n      const hasPredInRegion = Array.from(block.predecessors).some(p => blocks.has(p));\r\n      if (!hasPredInRegion) {\r\n        if (!entry || block.startInstruction.address < entry.startInstruction.address) {\r\n          entry = block;\r\n        }\r\n      }\r\n\r\n      // Find exits (blocks with successors outside the region, or exit blocks)\r\n      if (block.isExit || block.exitType === 'return') {\r\n        exits.add(block);\r\n      } else {\r\n        const hasSuccOutsideRegion = Array.from(block.successors).some(s => !blocks.has(s));\r\n        if (hasSuccOutsideRegion) {\r\n          exits.add(block);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fallback: use earliest block as entry\r\n    if (!entry) {\r\n      const sorted = Array.from(blocks).sort((a, b) => \r\n        a.startInstruction.address - b.startInstruction.address\r\n      );\r\n      entry = sorted[0];\r\n    }\r\n\r\n    return {\r\n      blocks,\r\n      entry,\r\n      exits\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export control structures to JSON format for validation\r\n   * Returns a comprehensive JSON object suitable for stringification\r\n   * All object references are converted to IDs to avoid circular references\r\n   * \r\n   * Note: This method will automatically call analyze() if structures haven't been identified yet\r\n   */\r\n  toJSON(): ControlStructureBuilderJSON {\r\n    // Ensure structures have been analyzed\r\n    if (this.structures.length === 0 && this.cfg.entryBlock) {\r\n      this.analyze();\r\n    }\r\n    \r\n    return {\r\n      script: {\r\n        name: this.cfg.script.name || 'unnamed',\r\n        totalStructures: this.structures.length\r\n      },\r\n      structures: this.structures.map((structure, index) => this.serializeStructure(structure, index)),\r\n      statistics: this.getDebugInfo()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Serialize a control structure to JSON (avoiding circular references)\r\n   */\r\n  private serializeStructure(structure: NWScriptControlStructure, index: number): SerializedControlStructure {\r\n    const result: SerializedControlStructure = {\r\n      index: index,\r\n      type: structure.type,\r\n      headerBlockId: structure.headerBlock.id,\r\n      headerBlockAddress: structure.headerBlock.startInstruction.address,\r\n      exitBlockId: structure.exitBlock.id,\r\n      exitBlockAddress: structure.exitBlock.startInstruction.address,\r\n      bodyBlockIds: structure.bodyBlocks.map(b => b.id).sort((a, b) => a - b),\r\n      bodyBlockAddresses: structure.bodyBlocks.map(b => b.startInstruction.address).sort((a, b) => a - b)\r\n    };\r\n\r\n    if (structure.elseBlocks && structure.elseBlocks.length > 0) {\r\n      result.elseBlockIds = structure.elseBlocks.map(b => b.id).sort((a, b) => a - b);\r\n      result.elseBlockAddresses = structure.elseBlocks.map(b => b.startInstruction.address).sort((a, b) => a - b);\r\n    }\r\n\r\n    if (structure.conditionBlock) {\r\n      result.conditionBlockId = structure.conditionBlock.id;\r\n      result.conditionBlockAddress = structure.conditionBlock.startInstruction.address;\r\n    }\r\n\r\n    if (structure.incrementBlock) {\r\n      result.incrementBlockId = structure.incrementBlock.id;\r\n      result.incrementBlockAddress = structure.incrementBlock.startInstruction.address;\r\n    }\r\n\r\n    if (structure.initBlock) {\r\n      result.initBlockId = structure.initBlock.id;\r\n      result.initBlockAddress = structure.initBlock.startInstruction.address;\r\n    }\r\n\r\n    if (structure.switchCases && structure.switchCases.size > 0) {\r\n      result.switchCases = Array.from(structure.switchCases.entries()).map(([value, block]) => ({\r\n        value: value,\r\n        blockId: block.id,\r\n        blockAddress: block.startInstruction.address,\r\n        hasFallThrough: structure.switchCaseFallThrough?.get(value) || false\r\n      })).sort((a, b) => a.value - b.value);\r\n    }\r\n\r\n    if (structure.defaultBlock) {\r\n      result.defaultBlockId = structure.defaultBlock.id;\r\n      result.defaultBlockAddress = structure.defaultBlock.startInstruction.address;\r\n    }\r\n\r\n    if (structure.switchCaseFallThrough && structure.switchCaseFallThrough.size > 0) {\r\n      result.switchCaseFallThrough = Array.from(structure.switchCaseFallThrough.entries())\r\n        .map(([value, hasFallThrough]) => ({ value, hasFallThrough }))\r\n        .sort((a, b) => a.value - b.value);\r\n    }\r\n\r\n    if (structure.elseIfBlocks && structure.elseIfBlocks.length > 0) {\r\n      result.elseIfBlocks = structure.elseIfBlocks.map(elseIf => ({\r\n        blockId: elseIf.block.id,\r\n        blockAddress: elseIf.block.startInstruction.address,\r\n        conditionBlockId: elseIf.conditionBlock.id,\r\n        conditionBlockAddress: elseIf.conditionBlock.startInstruction.address\r\n      }));\r\n    }\r\n\r\n    if (structure.breakBlocks && structure.breakBlocks.length > 0) {\r\n      result.breakBlockIds = structure.breakBlocks.map(b => b.id).sort((a, b) => a - b);\r\n      result.breakBlockAddresses = structure.breakBlocks.map(b => b.startInstruction.address).sort((a, b) => a - b);\r\n    }\r\n\r\n    if (structure.continueBlocks && structure.continueBlocks.length > 0) {\r\n      result.continueBlockIds = structure.continueBlocks.map(b => b.id).sort((a, b) => a - b);\r\n      result.continueBlockAddresses = structure.continueBlocks.map(b => b.startInstruction.address).sort((a, b) => a - b);\r\n    }\r\n\r\n    // Serialize nested structures\r\n    if (structure.nestedStructures && structure.nestedStructures.length > 0) {\r\n      result.nestedStructures = structure.nestedStructures.map((nested, nestedIndex) => \r\n        this.serializeStructure(nested, nestedIndex)\r\n      );\r\n    }\r\n\r\n    // Add block details for validation\r\n    result.blocks = {\r\n      header: {\r\n        id: structure.headerBlock.id,\r\n        startAddress: structure.headerBlock.startInstruction.address,\r\n        endAddress: structure.headerBlock.endInstruction.address + (structure.headerBlock.endInstruction.instructionSize || 0),\r\n        exitType: structure.headerBlock.exitType,\r\n        isLoopHeader: structure.headerBlock.isLoopHeader,\r\n        isLoopBody: structure.headerBlock.isLoopBody,\r\n        instructionCount: structure.headerBlock.instructions.length\r\n      },\r\n      exit: {\r\n        id: structure.exitBlock.id,\r\n        startAddress: structure.exitBlock.startInstruction.address,\r\n        endAddress: structure.exitBlock.endInstruction.address + (structure.exitBlock.endInstruction.instructionSize || 0),\r\n        exitType: structure.exitBlock.exitType,\r\n        isExit: structure.exitBlock.isExit,\r\n        instructionCount: structure.exitBlock.instructions.length\r\n      },\r\n      body: structure.bodyBlocks.map(b => ({\r\n        id: b.id,\r\n        startAddress: b.startInstruction.address,\r\n        endAddress: b.endInstruction.address + (b.endInstruction.instructionSize || 0),\r\n        exitType: b.exitType,\r\n        isUnreachable: b.isUnreachable,\r\n        instructionCount: b.instructions.length\r\n      })).sort((a, b) => a.startAddress - b.startAddress)\r\n    };\r\n\r\n    if (structure.elseBlocks && structure.elseBlocks.length > 0) {\r\n      result.blocks.else = structure.elseBlocks.map(b => ({\r\n        id: b.id,\r\n        startAddress: b.startInstruction.address,\r\n        endAddress: b.endInstruction.address + (b.endInstruction.instructionSize || 0),\r\n        exitType: b.exitType,\r\n        isUnreachable: b.isUnreachable,\r\n        instructionCount: b.instructions.length\r\n      })).sort((a, b) => a.startAddress - b.startAddress);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Debug method: Get statistics about blocks and why structures might not be found\r\n   */\r\n  getDebugInfo(): ControlStructureDebugInfo {\r\n    const blocks = Array.from(this.cfg.blocks.values());\r\n    const conditionalBlocks = blocks.filter(b => b.exitType === 'conditional');\r\n    const loopHeaders = blocks.filter(b => b.isLoopHeader);\r\n    const blocksWithTwoSuccessors = blocks.filter(b => b.successors.size === 2);\r\n    \r\n    const conditionalWithTwoSuccessors = conditionalBlocks.filter(b => b.successors.size === 2);\r\n    const conditionalWithConditionInstr = conditionalBlocks.filter(b => b.conditionInstruction !== null);\r\n    \r\n    // Check blocks with 2 successors that aren't conditional (might be JSR blocks)\r\n    const nonConditionalWithTwoSuccessors = blocks.filter(b => \r\n      b.successors.size === 2 && b.exitType !== 'conditional'\r\n    );\r\n\r\n    return {\r\n      totalBlocks: blocks.length,\r\n      conditionalBlocks: conditionalBlocks.length,\r\n      loopHeaders: loopHeaders.length,\r\n      blocksWithTwoSuccessors: blocksWithTwoSuccessors.length,\r\n      conditionalWithTwoSuccessors: conditionalWithTwoSuccessors.length,\r\n      conditionalWithConditionInstr: conditionalWithConditionInstr.length,\r\n      structuresFound: this.structures.length,\r\n      conditionalBlockDetails: conditionalBlocks.map(b => ({\r\n        id: b.id,\r\n        exitType: b.exitType,\r\n        hasConditionInstr: b.conditionInstruction !== null,\r\n        conditionCode: b.conditionInstruction?.code,\r\n        successors: b.successors.size,\r\n        successorIds: Array.from(b.successors).map(s => s.id),\r\n        intraProceduralSuccessors: this.cfg.getIntraProceduralSuccessors(b, false).length,\r\n        intraProceduralSuccessorIds: this.cfg.getIntraProceduralSuccessors(b, false).map(s => s.id)\r\n      })),\r\n      nonConditionalWithTwoSuccessors: nonConditionalWithTwoSuccessors.map(b => ({\r\n        id: b.id,\r\n        exitType: b.exitType,\r\n        startAddress: b.startInstruction.address,\r\n        successors: b.successors.size,\r\n        successorIds: Array.from(b.successors).map(s => s.id),\r\n        edgeTypes: Array.from(b.successors).map(s => {\r\n          const edge = this.cfg.getEdge(b, s);\r\n          return edge ? edge.type : 'unknown';\r\n        }),\r\n        intraProceduralSuccessors: this.cfg.getIntraProceduralSuccessors(b, false).length,\r\n        intraProceduralSuccessorIds: this.cfg.getIntraProceduralSuccessors(b, false).map(s => s.id)\r\n      }))\r\n    };\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptExpressionBuilder.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":179,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":179,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":180,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":180,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":205,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":205,"endColumn":47},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":214,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":214,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":215,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":215,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":237,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":237,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":238,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":238,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":260,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":260,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":261,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":261,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":290,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":290,"endColumn":46},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":291,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":291,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":319,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":319,"endColumn":48},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":345,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":345,"endColumn":47},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":380,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":380,"endColumn":65},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":386,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":386,"endColumn":66},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":435,"column":30,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":435,"endColumn":70}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\nimport { NWScriptExpression, NWScriptExpressionType } from \"@/nwscript/decompiler/NWScriptExpression\";\r\nimport type { NWScriptFunctionParameter } from \"@/nwscript/decompiler/NWScriptFunctionAnalyzer\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\r\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\nimport {\r\n  OP_CONST, OP_ACTION, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MODII,\r\n  OP_EQUAL, OP_NEQUAL, OP_GT, OP_GEQ, OP_LT, OP_LEQ,\r\n  OP_LOGANDII, OP_LOGORII, OP_BOOLANDII, OP_INCORII, OP_EXCORII,\r\n  OP_SHLEFTII, OP_SHRIGHTII, OP_USHRIGHTII,\r\n  OP_NEG, OP_COMPI, OP_NOTI,\r\n  OP_CPTOPBP, OP_CPTOPSP\r\n} from '@/nwscript/NWScriptOPCodes';\r\n\r\n/**\r\n * Builds expressions from stack-based instructions.\r\n * Tracks the stack state and reconstructs expression trees.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptExpressionBuilder.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptExpressionBuilder {\r\n  /**\r\n   * Stack of expressions (simulating the NWScript stack)\r\n   */\r\n  private expressionStack: NWScriptExpression[] = [];\r\n\r\n  /**\r\n   * Variable name generator\r\n   */\r\n  private variableCounter: number = 0;\r\n\r\n  /**\r\n   * Function parameters (for mapping CPTOPBP offsets to parameter names)\r\n   */\r\n  private functionParameters: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Global variables (for mapping CPTOPBP positive offsets to global variable names)\r\n   */\r\n  private globalVariables: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Local variables (for mapping CPTOPSP offsets to local variable names)\r\n   * This is a static mapping - kept for backward compatibility\r\n   * For stack-aware resolution, use variableStackPositions instead\r\n   */\r\n  private localVariables: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Stack position to variable index mapping (for dynamic stack-aware variable resolution)\r\n   * Key: stack position (absolute), Value: variable index\r\n   * Set by the converter for accurate CPTOPSP resolution\r\n   */\r\n  private variableStackPositions: Map<number, number> = new Map();\r\n  \r\n  /**\r\n   * Local variable initializations (for looking up variable info by index)\r\n   * Set by the converter to provide variable names and types\r\n   */\r\n  private localVariableInits: Array<{ offset: number, dataType: NWScriptDataType, hasInitializer: boolean, initialValue?: number | string | boolean }> = [];\r\n  \r\n  /**\r\n   * Current stack pointer (for calculating source positions in CPTOPSP)\r\n   */\r\n  private stackPointer: number = 0;\r\n\r\n  /**\r\n   * Process an instruction and update the expression stack\r\n   */\r\n  processInstruction(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    switch (instruction.code) {\r\n      case OP_CONST:\r\n        return this.handleConst(instruction);\r\n      \r\n      case OP_ADD:\r\n      case OP_SUB:\r\n      case OP_MUL:\r\n      case OP_DIV:\r\n      case OP_MODII:\r\n        return this.handleBinaryOp(instruction);\r\n      \r\n      case OP_EQUAL:\r\n      case OP_NEQUAL:\r\n      case OP_GT:\r\n      case OP_GEQ:\r\n      case OP_LT:\r\n      case OP_LEQ:\r\n        return this.handleComparison(instruction);\r\n      \r\n      case OP_LOGANDII:\r\n      case OP_LOGORII:\r\n      case OP_BOOLANDII:\r\n        return this.handleLogical(instruction);\r\n      \r\n      case OP_INCORII:\r\n      case OP_EXCORII:\r\n        return this.handleBitwise(instruction);\r\n      \r\n      case OP_SHLEFTII:\r\n      case OP_SHRIGHTII:\r\n      case OP_USHRIGHTII:\r\n        return this.handleShiftOp(instruction);\r\n      \r\n      case OP_NEG:\r\n      case OP_COMPI:\r\n      case OP_NOTI:\r\n        return this.handleUnaryOp(instruction);\r\n      \r\n      case OP_ACTION:\r\n        return this.handleAction(instruction);\r\n      \r\n      case OP_CPTOPBP:\r\n      case OP_CPTOPSP:\r\n        return this.handleVariableRead(instruction);\r\n      \r\n      default:\r\n        // Other instructions don't produce expressions directly\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle CONST instruction (push constant onto stack)\r\n   */\r\n  private handleConst(instruction: NWScriptInstruction): NWScriptExpression {\r\n    let value: number | string;\r\n    let dataType: NWScriptDataType;\r\n\r\n    switch (instruction.type) {\r\n      case 3: // INTEGER\r\n        value = instruction.integer;\r\n        dataType = NWScriptDataType.INTEGER;\r\n        break;\r\n      case 4: // FLOAT\r\n        value = instruction.float;\r\n        dataType = NWScriptDataType.FLOAT;\r\n        break;\r\n      case 5: // STRING\r\n        value = instruction.string;\r\n        dataType = NWScriptDataType.STRING;\r\n        break;\r\n      case 6: // OBJECT\r\n        value = instruction.object;\r\n        dataType = NWScriptDataType.OBJECT;\r\n        break;\r\n      default:\r\n        value = 0;\r\n        dataType = NWScriptDataType.INTEGER;\r\n    }\r\n\r\n    const expr = NWScriptExpression.constant(value, dataType);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle binary arithmetic operations\r\n   */\r\n  private handleBinaryOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.expressionStack.length < 2) {\r\n      // Not enough operands - create placeholder\r\n      const right = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = this.getBinaryOperator(instruction.code);\r\n      const dataType = this.getResultType(instruction.type);\r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, dataType);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.expressionStack.pop()!;\r\n    const left = this.expressionStack.pop()!;\r\n    const operator = this.getBinaryOperator(instruction.code);\r\n    const dataType = this.getResultType(instruction.type);\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left, right, dataType);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle comparison operations\r\n   */\r\n  private handleComparison(instruction: NWScriptInstruction): NWScriptExpression {\r\n    // Safeguard: if stack is empty, create placeholder expressions\r\n    if (this.expressionStack.length === 0) {\r\n      const left = NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const right = NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const operator = this.getComparisonOperator(instruction.code);\r\n      const expr = NWScriptExpression.comparison(operator, left, right);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    // If only one element, create a comparison with a default right side\r\n    if (this.expressionStack.length === 1) {\r\n      const left = this.expressionStack.pop()!;\r\n      const right = NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const operator = this.getComparisonOperator(instruction.code);\r\n      const expr = NWScriptExpression.comparison(operator, left, right);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    // Normal case: pop two elements\r\n    const right = this.expressionStack.pop()!;\r\n    const left = this.expressionStack.pop()!;\r\n    const operator = this.getComparisonOperator(instruction.code);\r\n    \r\n    const expr = NWScriptExpression.comparison(operator, left, right);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle logical operations\r\n   */\r\n  private handleLogical(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.expressionStack.length < 2) {\r\n      const right = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = this.getLogicalOperator(instruction.code);\r\n      const expr = NWScriptExpression.logical(operator, left, right);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.expressionStack.pop()!;\r\n    const left = this.expressionStack.pop()!;\r\n    const operator = this.getLogicalOperator(instruction.code);\r\n    \r\n    const expr = NWScriptExpression.logical(operator, left, right);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle bitwise operations\r\n   */\r\n  private handleBitwise(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.expressionStack.length < 2) {\r\n      const right = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = instruction.code === OP_INCORII ? '|' : '^';\r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.expressionStack.pop()!;\r\n    const left = this.expressionStack.pop()!;\r\n    const operator = instruction.code === OP_INCORII ? '|' : '^';\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle shift operations\r\n   */\r\n  private handleShiftOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.expressionStack.length < 2) {\r\n      const right = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.expressionStack.pop() || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      let operator: string;\r\n      switch (instruction.code) {\r\n        case OP_SHLEFTII: operator = '<<'; break;\r\n        case OP_SHRIGHTII: operator = '>>'; break;\r\n        case OP_USHRIGHTII: operator = '>>>'; break;\r\n        default: operator = '?';\r\n      }\r\n      \r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.expressionStack.pop()!;\r\n    const left = this.expressionStack.pop()!;\r\n    \r\n    let operator: string;\r\n    switch (instruction.code) {\r\n      case OP_SHLEFTII: operator = '<<'; break;\r\n      case OP_SHRIGHTII: operator = '>>'; break;\r\n      case OP_USHRIGHTII: operator = '>>>'; break;\r\n      default: operator = '?';\r\n    }\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle unary operations\r\n   */\r\n  private handleUnaryOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.expressionStack.length < 1) {\r\n      const operand = NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const operator = this.getUnaryOperator(instruction.code);\r\n      const dataType = instruction.type === 0x03 ? NWScriptDataType.INTEGER : NWScriptDataType.FLOAT;\r\n      const expr = NWScriptExpression.unaryOp(operator, operand, dataType);\r\n      this.expressionStack.push(expr);\r\n      return expr;\r\n    }\r\n\r\n    const operand = this.expressionStack.pop()!;\r\n    const operator = this.getUnaryOperator(instruction.code);\r\n    const dataType = instruction.type === 0x03 ? NWScriptDataType.INTEGER : NWScriptDataType.FLOAT;\r\n    \r\n    const expr = NWScriptExpression.unaryOp(operator, operand, dataType);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle ACTION (function call)\r\n   */\r\n  private handleAction(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    if (!instruction.actionDefinition) {\r\n      return null;\r\n    }\r\n\r\n    const actionDef = instruction.actionDefinition;\r\n    const argCount = instruction.argCount || 0;\r\n    const args: NWScriptExpression[] = [];\r\n\r\n    // Pop arguments from stack\r\n    // In NWScript, arguments appear to be pushed in forward order (first arg first)\r\n    // So when we pop them, we get them in reverse order (last arg first)\r\n    // We use push to collect them, then reverse to get correct order\r\n    for (let i = 0; i < argCount && this.expressionStack.length > 0; i++) {\r\n      args.unshift(this.expressionStack.pop()!);\r\n      // args.push(this.expressionStack.pop()!); // Push to array (will be in reverse order)\r\n    }\r\n    \r\n    // Reverse to get correct argument order (first arg first)\r\n    args.reverse();\r\n\r\n    const functionName = actionDef.name || `Action_${instruction.action}`;\r\n    const returnType = actionDef.type || NWScriptDataType.VOID;\r\n    \r\n    const expr = NWScriptExpression.functionCall(functionName, args, returnType);\r\n    \r\n    // Push return value if not void\r\n    if (returnType !== NWScriptDataType.VOID) {\r\n      this.expressionStack.push(expr);\r\n    }\r\n    \r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle variable read (CPTOPBP/CPTOPSP)\r\n   */\r\n  private handleVariableRead(instruction: NWScriptInstruction): NWScriptExpression {\r\n    const isGlobal = instruction.code === OP_CPTOPBP;\r\n    let varName: string;\r\n    let dataType: NWScriptDataType;\r\n    \r\n    if (isGlobal && instruction.offset !== undefined) {\r\n      // Check if this is a function parameter (negative offset)\r\n      const offset = instruction.offset;\r\n      const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n      \r\n      if (offsetSigned < 0 && this.functionParameters.has(offsetSigned)) {\r\n        // This is a function parameter (negative offset relative to BP)\r\n        const param = this.functionParameters.get(offsetSigned)!;\r\n        varName = param.name;\r\n        dataType = param.dataType;\r\n      } else if (offsetSigned < 0 && this.globalVariables.has(offsetSigned)) {\r\n        // This is a global variable (negative offset relative to BP)\r\n        // ALL stack offsets are negative - we're always looking down from the top\r\n        const globalVar = this.globalVariables.get(offsetSigned)!;\r\n        varName = globalVar.name;\r\n        dataType = globalVar.dataType;\r\n      } else {\r\n        // Unknown - generate a generic name\r\n        varName = this.generateVariableName(true, offset);\r\n        dataType = NWScriptDataType.INTEGER; // Default, could be improved\r\n      }\r\n    } else {\r\n      // Local variable (CPTOPSP)\r\n      // CRITICAL: CPTOPSP reads from stack[SP + offset] where SP is the CURRENT stack pointer\r\n      // We should resolve this dynamically using the actual stack state, not static offsets\r\n      const offset = instruction.offset || 0;\r\n      const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n      \r\n      // Calculate the actual stack position this instruction reads from\r\n      const sourceStackPos = this.stackPointer + offsetSigned;\r\n      \r\n      // First, try to resolve using the dynamic stack position map (stack-aware)\r\n      const varIndex = this.variableStackPositions.get(sourceStackPos);\r\n      log.info(`[ExpressionBuilder.handleVariableRead] CPTOPSP: SP=${this.stackPointer}, offset=${offsetSigned}, sourcePos=${sourceStackPos}, varIndex=${varIndex}`);\r\n      if (varIndex !== undefined && this.localVariableInits[varIndex]) {\r\n        // Found variable using stack-aware resolution\r\n        const init = this.localVariableInits[varIndex];\r\n        varName = `localVar_${varIndex}`;\r\n        dataType = init.dataType;\r\n        log.info(`[ExpressionBuilder.handleVariableRead] Resolved to ${varName} using stack-aware resolution`);\r\n      } else {\r\n        // Stack-aware fallback: Check all variable positions with tolerance\r\n        // The stack may have grown between RSADD and CPTOPSP, so check all recorded positions\r\n        let foundVar = false;\r\n        for (const [varPos, idx] of this.variableStackPositions.entries()) {\r\n          const distance = Math.abs(sourceStackPos - varPos);\r\n          // Allow tolerance (8 bytes) since the stack may have grown\r\n          if (distance <= 8 && this.localVariableInits[idx]) {\r\n            const init = this.localVariableInits[idx];\r\n            varName = `localVar_${idx}`;\r\n            dataType = init.dataType;\r\n            foundVar = true;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (!foundVar) {\r\n          // Last resort: Fallback to static offset-based mapping (for backward compatibility)\r\n          // This should rarely be needed if stack-aware tracking is working correctly\r\n          const offsetUnsigned = offset < 0 ? offset + 0x100000000 : offset;\r\n          if (this.localVariables.has(offsetUnsigned)) {\r\n            // Use mapped local variable name from static mapping\r\n            const localVar = this.localVariables.get(offsetUnsigned)!;\r\n            varName = localVar.name;\r\n            dataType = localVar.dataType;\r\n            log.info(`[ExpressionBuilder.handleVariableRead] Resolved to ${varName} using static offset mapping (offset=${offsetUnsigned.toString(16)})`);\r\n          } else {\r\n            // Generate a generic name as absolute last resort\r\n            varName = this.generateVariableName(false, offset);\r\n            dataType = NWScriptDataType.INTEGER; // Default, could be improved\r\n            log.info(`[ExpressionBuilder.handleVariableRead] Generated generic name: ${varName}`);\r\n          }\r\n        } else {\r\n          log.info(`[ExpressionBuilder.handleVariableRead] Resolved to ${varName} using fallback tolerance search`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const expr = NWScriptExpression.variable(varName, dataType, isGlobal);\r\n    this.expressionStack.push(expr);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Get binary operator string\r\n   */\r\n  private getBinaryOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_ADD: return '+';\r\n      case OP_SUB: return '-';\r\n      case OP_MUL: return '*';\r\n      case OP_DIV: return '/';\r\n      case OP_MODII: return '%';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get comparison operator string\r\n   */\r\n  private getComparisonOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_EQUAL: return '==';\r\n      case OP_NEQUAL: return '!=';\r\n      case OP_GT: return '>';\r\n      case OP_GEQ: return '>=';\r\n      case OP_LT: return '<';\r\n      case OP_LEQ: return '<=';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get logical operator string\r\n   */\r\n  private getLogicalOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_LOGANDII: return '&&';\r\n      case OP_LOGORII: return '||';\r\n      case OP_BOOLANDII: return '&';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get unary operator string\r\n   */\r\n  private getUnaryOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_NEG: return '-';\r\n      case OP_COMPI: return '~';\r\n      case OP_NOTI: return '!';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get result data type from instruction type\r\n   */\r\n  private getResultType(type: number): NWScriptDataType {\r\n    // This is a simplified version - actual type inference is more complex\r\n    if (type >= 0x20 && type <= 0x26) {\r\n      // Binary type operations\r\n      if (type === 0x20 || type === 0x25 || type === 0x26) return NWScriptDataType.INTEGER;\r\n      if (type === 0x21) return NWScriptDataType.FLOAT;\r\n      if (type === 0x23) return NWScriptDataType.STRING;\r\n    }\r\n    return NWScriptDataType.INTEGER;\r\n  }\r\n\r\n  /**\r\n   * Generate a variable name\r\n   */\r\n  private generateVariableName(isGlobal: boolean, offset: number): string {\r\n    if (isGlobal) {\r\n      return `g_var_${offset}`;\r\n    } else {\r\n      return `var_${this.variableCounter++}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push an expression onto the stack\r\n   */\r\n  push(expr: NWScriptExpression): void {\r\n    this.expressionStack.push(expr);\r\n  }\r\n\r\n  /**\r\n   * Pop an expression from the stack\r\n   */\r\n  pop(): NWScriptExpression | null {\r\n    return this.expressionStack.pop() || null;\r\n  }\r\n\r\n  /**\r\n   * Peek at the top of the stack\r\n   */\r\n  peek(): NWScriptExpression | null {\r\n    return this.expressionStack.length > 0 ? this.expressionStack[this.expressionStack.length - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Clear the expression stack\r\n   */\r\n  clear(): void {\r\n    this.expressionStack = [];\r\n    this.variableCounter = 0;\r\n    this.functionParameters.clear();\r\n  }\r\n\r\n  /**\r\n   * Set function parameters for parameter name mapping\r\n   */\r\n  setFunctionParameters(parameters: NWScriptFunctionParameter[]): void {\r\n    this.functionParameters.clear();\r\n    for (const param of parameters) {\r\n      this.functionParameters.set(param.offset, { name: param.name, dataType: param.dataType });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Set global variables for variable name mapping\r\n   * Maps BP offsets (positive) to global variable names\r\n   */\r\n  setGlobalVariables(globalVars: Map<number, { name: string, dataType: NWScriptDataType }>): void {\r\n    this.globalVariables = globalVars;\r\n  }\r\n  \r\n  /**\r\n   * Set local variables for variable name mapping\r\n   * Maps SP offsets to local variable names\r\n   */\r\n  setLocalVariables(localVars: Map<number, { name: string, dataType: NWScriptDataType }>): void {\r\n    this.localVariables = localVars;\r\n  }\r\n  \r\n  /**\r\n   * Set the stack position to variable index mapping for dynamic variable resolution\r\n   * This allows CPTOPSP to resolve variables based on actual stack state, not static offsets\r\n   */\r\n  setVariableStackPositions(positions: Map<number, number>): void {\r\n    this.variableStackPositions = positions;\r\n  }\r\n  \r\n  /**\r\n   * Set local variable initializations for variable info lookup\r\n   */\r\n  setLocalVariableInits(inits: Array<{ offset: number, dataType: NWScriptDataType, hasInitializer: boolean, initialValue?: number | string | boolean }>): void {\r\n    this.localVariableInits = inits;\r\n  }\r\n  \r\n  /**\r\n   * Set current stack pointer (for calculating source positions in CPTOPSP)\r\n   */\r\n  setStackPointer(sp: number): void {\r\n    this.stackPointer = sp;\r\n  }\r\n\r\n  /**\r\n   * Get current stack size\r\n   */\r\n  getStackSize(): number {\r\n    return this.expressionStack.length;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptFunctionAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":231,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":231,"endColumn":35},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":265,"column":33,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":265,"endColumn":56},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":504,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":504,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":658,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":658,"endColumn":49}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\nimport type { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\r\nimport type { NWScriptControlFlowGraph } from \"@/nwscript/decompiler/NWScriptControlFlowGraph\";\r\nimport type { NWScriptGlobalInit } from \"@/nwscript/decompiler/NWScriptGlobalVariableAnalyzer\";\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\nimport { OP_JSR, OP_RETN, OP_RSADD, OP_STORE_STATE, OP_STORE_STATEALL, OP_JMP, OP_SAVEBP, OP_RESTOREBP, OP_MOVSP, OP_CPTOPBP } from '@/nwscript/NWScriptOPCodes';\n\r\n\r\n\r\n/**\r\n * Represents a function/subroutine in the reconstructed script.\r\n */\r\nexport interface NWScriptFunction {\r\n  name: string;\r\n  entryBlock: NWScriptBasicBlock;\r\n  returnBlock: NWScriptBasicBlock | null;\r\n  bodyBlocks: NWScriptBasicBlock[];\r\n  parameters: NWScriptFunctionParameter[];\r\n  returnType: NWScriptDataType;\r\n  isMain: boolean;\r\n  jsrInstruction: NWScriptInstruction | null; // The JSR that calls this function\r\n}\r\n\r\nexport interface NWScriptFunctionParameter {\r\n  name: string;\r\n  dataType: NWScriptDataType;\r\n  offset: number; // Stack offset\r\n}\r\n\r\n/**\r\n * Analyzes functions and subroutines in the control flow graph.\r\n * Identifies function boundaries, parameters, and return types.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptFunctionAnalyzer.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptFunctionAnalyzer {\r\n  private cfg: NWScriptControlFlowGraph;\r\n  private functions: Map<number, NWScriptFunction> = new Map();\r\n  private mainFunction: NWScriptFunction | null = null;\r\n  private globalInits: NWScriptGlobalInit[] = [];\r\n  private initAddresses: Set<number> = new Set();\r\n  private nestedCallAddresses: Set<number> = new Set(); // Addresses in nested call code (between STORE_STATE+JMP and JMP target)\r\n  private globalInitFunctionAddress: number | null = null; // Entry address of global init function (if exists)\r\n\r\n  constructor(cfg: NWScriptControlFlowGraph, globalInits: NWScriptGlobalInit[] = []) {\r\n    this.cfg = cfg;\r\n    this.globalInits = globalInits;\r\n    // Build set of initialization addresses for quick lookup\r\n    for (const init of globalInits) {\r\n      this.initAddresses.add(init.instructionAddress);\r\n      // Also mark the following instructions (CONST, CPDOWNSP, MOVSP)\r\n      const rsadd = this.cfg.script.instructions.get(init.instructionAddress);\r\n      if (rsadd) {\r\n        let current = rsadd.nextInstr;\r\n        let count = 0;\r\n        while (current && count < 5) {\r\n          this.initAddresses.add(current.address);\r\n          if (current.code === 0x1B) break; // MOVSP\r\n          current = current.nextInstr;\r\n          count++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Identify nested call code (between STORE_STATE+JMP and JMP target)\r\n    this.identifyNestedCallCode();\r\n  }\r\n  \r\n  /**\r\n   * Identify all addresses that are part of nested call code\r\n   * CRITICAL: The callback entry is at STORE_STATE_address + instruction.type\r\n   * The callback code is between the callback entry and the JMP target\r\n   * (where the outer ACTION call happens)\r\n   */\r\n  private identifyNestedCallCode(): void {\r\n    for (const instruction of this.cfg.script.instructions.values()) {\r\n      if (instruction.code === OP_STORE_STATE || instruction.code === OP_STORE_STATEALL) {\r\n        // The type field is the callback offset\r\n        // Callback entry = STORE_STATE_address + type\r\n        const callbackEntry = instruction.address + instruction.type;\r\n        \r\n        const nextInstr = instruction.nextInstr;\r\n        if (nextInstr && nextInstr.code === OP_JMP && nextInstr.offset !== undefined) {\r\n          const jmpTarget = nextInstr.address + nextInstr.offset;\r\n          \r\n          // Mark all instructions between callback entry and JMP target as callback code\r\n          // This is the code that will be executed later by DelayCommand\r\n          let current = this.cfg.script.instructions.get(callbackEntry);\r\n          while (current && current.address < jmpTarget) {\r\n            this.nestedCallAddresses.add(current.address);\r\n            if (current.code === OP_RETN) {\r\n              break;\r\n            }\r\n            current = current.nextInstr;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze all functions in the script\r\n   */\r\n  analyze(): NWScriptFunction[] {\r\n    this.functions.clear();\r\n    this.mainFunction = null;\r\n    this.globalInitFunctionAddress = null; // Reset before analysis\r\n\r\n    // Identify main function (entry block)\r\n    if (this.cfg.entryBlock) {\r\n      this.mainFunction = this.analyzeMainFunction();\r\n      if (this.mainFunction) {\r\n        this.functions.set(this.mainFunction.entryBlock.startInstruction.address, this.mainFunction);\r\n      }\r\n    }\r\n\r\n    // Identify all subroutines (JSR targets)\r\n    // Use a Set to track processed entry addresses to avoid duplicates\r\n    const processedAddresses = new Set<number>();\r\n    \r\n    for (const [entryAddress, entryBlock] of this.cfg.subroutineEntries) {\r\n      // Skip if we've already processed this entry address\r\n      if (processedAddresses.has(entryAddress)) {\r\n        continue;\r\n      }\r\n      \r\n      // Skip if this is the main function's entry address (already processed)\r\n      if (this.mainFunction && this.mainFunction.entryBlock.startInstruction.address === entryAddress) {\r\n        continue;\r\n      }\r\n      \r\n      // Skip if this is a STORE_STATE JMP target (not a real function)\r\n      if (this.cfg.storeStateJmpTargets.has(entryAddress)) {\r\n        continue;\r\n      }\r\n      \r\n      // Skip if this is a callback entry (created by STORE_STATE, not a real function)\r\n      if (this.cfg.callbackEntries.has(entryAddress)) {\r\n        continue;\r\n      }\r\n      \r\n      // Skip if this is the global init function (contains only global variable initializations)\r\n      if (this.globalInitFunctionAddress !== null && entryAddress === this.globalInitFunctionAddress) {\r\n        continue;\r\n      }\r\n      \r\n      const func = this.analyzeSubroutine(entryBlock, entryAddress);\r\n      if (func) {\r\n        // Only add if we don't already have a function at this entry address\r\n        if (!this.functions.has(entryAddress)) {\r\n          this.functions.set(entryAddress, func);\r\n          processedAddresses.add(entryAddress);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Assign proper function names (sub1, sub2, etc.)\r\n    this.assignFunctionNames();\r\n\r\n    // Return unique functions only (by entry address)\r\n    return Array.from(this.functions.values());\r\n  }\r\n\r\n  /**\r\n   * Analyze the main function\r\n   * In NWScript, the entry point can be:\r\n   * 1. A single JSR -> void main()\r\n   * 2. RSADD + JSR -> int StartingConditional()\r\n   * \r\n   * Special case: If we see SAVEBP -> JSR -> RESTOREBP -> MOVSP -> RETN pattern,\r\n   * the JSR target is for global variable initialization, and we need to find\r\n   * the next JSR that points to the actual main/StartingConditional function.\r\n   */\r\n  private analyzeMainFunction(): NWScriptFunction | null {\r\n    if (!this.cfg.entryBlock) {\r\n      return null;\r\n    }\r\n\r\n    // CRITICAL: Entry RSADDI (if present) indicates return type of REAL StartingConditional.\r\n    // This is the ONLY place where RSADD indicates StartingConditional. After the entry JSR,\r\n    // all RSADD patterns are either global variable initializations or part of normal\r\n    // function definitions (RSADD + JSR = function with return type).\r\n    \r\n    // Search through entry block for first RSADD and JSR\r\n    // The entry block may start with T instruction, so we need to search\r\n    // Pattern: [T] [RSADD] JSR RETN\r\n    let entryRSADD: NWScriptInstruction | null = null;\r\n    let firstJSR: NWScriptInstruction | null = null;\r\n    \r\n    let current = this.cfg.entryBlock.startInstruction;\r\n    while (current && current.address <= this.cfg.entryBlock.endInstruction.address) {\r\n      // Check for RSADD (must come before JSR if present)\r\n      if (current.code === OP_RSADD && !entryRSADD && !firstJSR) {\r\n        entryRSADD = current;\r\n      }\r\n      // Check for JSR (required)\r\n      if (current.code === OP_JSR && current.offset !== undefined && !firstJSR) {\r\n        firstJSR = current;\r\n        // Once we find JSR, we can stop (RSADD must come before JSR if present)\r\n        break;\r\n      }\r\n      current = current.nextInstr;\r\n    }\r\n    \r\n    if (!firstJSR) {\r\n      return null;\r\n    }\r\n    \r\n    const firstJSRTarget = firstJSR.address + firstJSR.offset;\r\n    const firstJSRBlock = this.cfg.getBlockForAddress(firstJSRTarget);\r\n    \r\n    if (!firstJSRBlock) {\r\n      return null;\r\n    }\r\n    \r\n    // Check if first JSR target contains SAVEBP -> JSR pattern\r\n    // If yes, it's a global init function, and we need to find the second JSR\r\n    let hasGlobals = false;\r\n    let realMainJSRTarget: number | null = null;\r\n    let isStartingConditional = false;\r\n    \r\n    // Search for SAVEBP -> JSR pattern in first JSR target\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [firstJSRBlock];\r\n    \r\n    while (queue.length > 0 && !hasGlobals) {\r\n      const block = queue.shift()!;\r\n      if (visited.has(block)) continue;\r\n      visited.add(block);\r\n      \r\n      for (const instr of block.instructions) {\r\n        if (instr.code === OP_SAVEBP) {\r\n          // Found SAVEBP - now search for JSR that comes after it\r\n          // JSR might be in the same block or a successor block\r\n          \r\n          // First check within the same block\r\n          let foundJSR = false;\r\n          let next = instr.nextInstr;\r\n          while (next && next.address <= block.endInstruction.address) {\r\n            if (next.code === OP_JSR && next.offset !== undefined) {\r\n              // Found SAVEBP -> JSR pattern - first JSR is global init\r\n              hasGlobals = true;\r\n              realMainJSRTarget = next.address + next.offset;\r\n              isStartingConditional = entryRSADD !== null;\r\n              foundJSR = true;\r\n              break;\r\n            }\r\n            if (next.code === OP_RESTOREBP) {\r\n              // Hit RESTOREBP before JSR - invalid pattern\r\n              break;\r\n            }\r\n            next = next.nextInstr;\r\n          }\r\n          \r\n          // If not found in same block, search successor blocks\r\n          if (!foundJSR) {\r\n            const jsrSearchVisited = new Set<NWScriptBasicBlock>();\r\n            const jsrSearchQueue: NWScriptBasicBlock[] = Array.from(block.successors);\r\n            \r\n            while (jsrSearchQueue.length > 0 && !foundJSR) {\r\n              const succBlock = jsrSearchQueue.shift()!;\r\n              if (jsrSearchVisited.has(succBlock)) continue;\r\n              jsrSearchVisited.add(succBlock);\r\n              \r\n              // Check if this block contains JSR after SAVEBP\r\n              for (const succInstr of succBlock.instructions) {\r\n                if (succInstr.code === OP_JSR && succInstr.offset !== undefined && succInstr.address > instr.address) {\r\n                  // Found JSR in successor after SAVEBP\r\n                  hasGlobals = true;\r\n                  realMainJSRTarget = succInstr.address + succInstr.offset;\r\n                  isStartingConditional = entryRSADD !== null;\r\n                  foundJSR = true;\r\n                  break;\r\n                }\r\n                if (succInstr.code === OP_RESTOREBP && succInstr.address > instr.address) {\r\n                  // Hit RESTOREBP before JSR - invalid pattern\r\n                  break;\r\n                }\r\n              }\r\n              \r\n              // Continue searching if we haven't found JSR yet\r\n              if (!foundJSR) {\r\n                for (const succSucc of succBlock.successors) {\r\n                  if (!jsrSearchVisited.has(succSucc)) {\r\n                    const hasRetn = succSucc.instructions.some(i => i.code === OP_RETN);\r\n                    if (!hasRetn) {\r\n                      jsrSearchQueue.push(succSucc);\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          \r\n          if (hasGlobals) break;\r\n        }\r\n      }\r\n      \r\n      // Continue searching if we haven't found SAVEBP yet\r\n      if (!hasGlobals) {\r\n        for (const successor of block.successors) {\r\n          if (!visited.has(successor)) {\r\n            const hasRetn = successor.instructions.some(instr => instr.code === OP_RETN);\r\n            if (!hasRetn) {\r\n              queue.push(successor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Determine the actual main/StartingConditional function\r\n    let jsrInstruction: NWScriptInstruction | null = null;\r\n    let mainEntryBlock: NWScriptBasicBlock | null = null;\r\n    let mainEntryAddress: number | null = null;\r\n    \r\n    if (hasGlobals) {\r\n      // First JSR is global init, second JSR (after SAVEBP) is real main/StartingConditional\r\n      // Store the global init function address so we can exclude it from subroutines\r\n      this.globalInitFunctionAddress = firstJSRTarget;\r\n      \r\n      if (realMainJSRTarget !== null) {\r\n        mainEntryBlock = this.cfg.getBlockForAddress(realMainJSRTarget);\r\n        if (mainEntryBlock) {\r\n          mainEntryAddress = realMainJSRTarget;\r\n          // Find the JSR instruction that calls this (it's after SAVEBP in global init)\r\n          jsrInstruction = this.findJSRInstruction(realMainJSRTarget);\r\n          isStartingConditional = entryRSADD !== null;\r\n        }\r\n      }\r\n    } else {\r\n      // No globals - clear any previous global init address\r\n      this.globalInitFunctionAddress = null;\r\n      // No globals - first JSR is main/StartingConditional\r\n      mainEntryBlock = firstJSRBlock;\r\n      mainEntryAddress = firstJSRTarget;\r\n      jsrInstruction = firstJSR;\r\n      isStartingConditional = entryRSADD !== null;\r\n    }\r\n    \r\n    if (!mainEntryBlock || mainEntryAddress === null) {\r\n      return null;\r\n    }\r\n    \r\n    // Use the determined main/StartingConditional entry\r\n    const entryBlock = mainEntryBlock;\r\n    const entryAddress = mainEntryAddress;\r\n    \r\n    // Collect all blocks reachable from entry that aren't part of subroutines\r\n    const bodyBlocks = this.collectFunctionBody(entryBlock);\r\n    const returnBlock = this.findReturnBlock(entryBlock, bodyBlocks);\r\n\r\n    // Determine function name and return type\r\n    const functionName = isStartingConditional ? 'StartingConditional' : 'main';\r\n\r\n    // Use entry RSADD as the return-type hint even when globals are present.\r\n    // In the globals case, the entry block (or the RSADD just before the inner JSR)\r\n    // still describes the real function's return type.\r\n    let returnType: NWScriptDataType;\r\n    if (entryRSADD) {\r\n      switch (entryRSADD.type) {\r\n        case 3: returnType = NWScriptDataType.INTEGER; break;\r\n        case 4: returnType = NWScriptDataType.FLOAT; break;\r\n        case 5: returnType = NWScriptDataType.STRING; break;\r\n        case 6: returnType = NWScriptDataType.OBJECT; break;\r\n        default: returnType = isStartingConditional ? NWScriptDataType.INTEGER : NWScriptDataType.VOID; break;\r\n      }\r\n    } else {\r\n      returnType = isStartingConditional ? NWScriptDataType.INTEGER : NWScriptDataType.VOID;\r\n    }\r\n\r\n    // Analyze parameters from CPTOPBP instructions in function body\r\n    const parameters = this.analyzeParameters(jsrInstruction, bodyBlocks);\r\n\r\n    return {\r\n      name: functionName,\r\n      entryBlock: entryBlock,\r\n      returnBlock: returnBlock,\r\n      bodyBlocks: bodyBlocks,\r\n      parameters: parameters,\r\n      returnType: returnType,\r\n      isMain: true,\r\n      jsrInstruction: jsrInstruction\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if a block contains the global initialization pattern:\r\n   * SAVEBP -> JSR -> RESTOREBP -> MOVSP -> RETN\r\n   */\r\n  private checkGlobalInitPattern(block: NWScriptBasicBlock): boolean {\r\n    let current = block.startInstruction;\r\n    let foundSAVEBP = false;\r\n    let foundJSR = false;\r\n    let foundRESTOREBP = false;\r\n    let foundMOVSP = false;\r\n    \r\n    // Look for the pattern in the block's instructions\r\n    while (current && current.address <= block.endInstruction.address) {\r\n      if (!foundSAVEBP && current.code === OP_SAVEBP) {\r\n        foundSAVEBP = true;\r\n      } else if (foundSAVEBP && !foundJSR && current.code === OP_JSR) {\r\n        foundJSR = true;\r\n      } else if (foundJSR && !foundRESTOREBP && current.code === OP_RESTOREBP) {\r\n        foundRESTOREBP = true;\r\n      } else if (foundRESTOREBP && !foundMOVSP && current.code === OP_MOVSP) {\r\n        foundMOVSP = true;\r\n      } else if (foundMOVSP && current.code === OP_RETN) {\r\n        // Found the complete pattern\r\n        return true;\r\n      }\r\n      \r\n      // If we've started the pattern but hit something unexpected, reset\r\n      if (foundSAVEBP && current.code !== OP_SAVEBP && \r\n          current.code !== OP_JSR && \r\n          current.code !== OP_RESTOREBP && \r\n          current.code !== OP_MOVSP && \r\n          current.code !== OP_RETN &&\r\n          !foundRESTOREBP) {\r\n        // Reset if we haven't found RESTOREBP yet\r\n        foundSAVEBP = false;\r\n        foundJSR = false;\r\n      }\r\n      \r\n      current = current.nextInstr;\r\n      if (!current) break;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Analyze a subroutine (function called via JSR)\r\n   */\r\n  private analyzeSubroutine(entryBlock: NWScriptBasicBlock, entryAddress: number): NWScriptFunction | null {\r\n    // Find the JSR instruction that calls this function\r\n    // Note: A function might be called from multiple places, so we find the first JSR\r\n    // If no JSR is found, it might still be a valid function (e.g., called indirectly)\r\n    const jsrInstruction = this.findJSRInstruction(entryAddress);\r\n\r\n    // Collect function body blocks\r\n    const bodyBlocks = this.collectFunctionBody(entryBlock);\r\n    \r\n    // If no body blocks collected and no JSR, this might not be a valid function\r\n    if (bodyBlocks.length === 0 && !jsrInstruction) {\r\n      return null;\r\n    }\r\n    \r\n    // Find return block\r\n    const returnBlock = this.findReturnBlock(entryBlock, bodyBlocks);\r\n\r\n    // Analyze parameters from CPTOPBP instructions in function body\r\n    // Parameters are identified from the function body, not from the JSR instruction\r\n    // If we don't have a JSR, we can still analyze parameters from the body\r\n    const parameters = jsrInstruction \r\n      ? this.analyzeParameters(jsrInstruction, bodyBlocks)\r\n      : this.analyzeParameters(entryBlock.startInstruction, bodyBlocks);\r\n\r\n    // Analyze return type (stack usage after RETN)\r\n    const returnType = this.analyzeReturnType(entryBlock, bodyBlocks);\r\n\r\n    // Generate function name\r\n    const functionName = this.generateFunctionName(entryAddress);\r\n\r\n    return {\r\n      name: functionName,\r\n      entryBlock: entryBlock,\r\n      returnBlock: returnBlock,\r\n      bodyBlocks: bodyBlocks,\r\n      parameters: parameters,\r\n      returnType: returnType,\r\n      isMain: false,\r\n      jsrInstruction: jsrInstruction\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find the JSR instruction that targets a specific address\r\n   */\r\n  private findJSRInstruction(targetAddress: number): NWScriptInstruction | null {\r\n    for (const instruction of this.cfg.script.instructions.values()) {\r\n      if (instruction.code === OP_JSR &&\r\n          instruction.offset !== undefined &&\r\n          instruction.address + instruction.offset === targetAddress) {\r\n        return instruction;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Collect all blocks that are part of a function body\r\n   */\r\n  private collectFunctionBody(entryBlock: NWScriptBasicBlock): NWScriptBasicBlock[] {\r\n    const bodyBlocks: NWScriptBasicBlock[] = [];\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [entryBlock];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift()!;\r\n      if (visited.has(current)) continue;\r\n      visited.add(current);\r\n\r\n      // Skip blocks that are entirely initialization sequences\r\n      if (this.isInitializationBlock(current)) {\r\n        continue;\r\n      }\r\n\r\n      // Skip blocks that are part of nested call code (STORE_STATE+JMP pattern)\r\n      if (this.isNestedCallBlock(current)) {\r\n        continue;\r\n      }\r\n\r\n      // Don't follow into other functions\r\n      // But allow STORE_STATE+JMP targets (they're part of the same function, not separate functions)\r\n      if (current !== entryBlock && \r\n          this.cfg.subroutineEntries.has(current.startInstruction.address) &&\r\n          !this.cfg.storeStateJmpTargets.has(current.startInstruction.address)) {\r\n        continue;\r\n      }\r\n\r\n      // Add block if it's not just initialization or nested call code\r\n      if (!this.isInitializationBlock(current) && !this.isNestedCallBlock(current)) {\r\n        bodyBlocks.push(current);\r\n      }\r\n\r\n      // Follow successors until we hit a RETN or another function\r\n      for (const successor of current.successors) {\r\n        if (!visited.has(successor)) {\r\n          // Check if this is a return point\r\n          if (successor.endInstruction && successor.endInstruction.code === OP_RETN) {\r\n            // Only add if it's not nested call code\r\n            if (!this.isInitializationBlock(successor) && !this.isNestedCallBlock(successor)) {\r\n              bodyBlocks.push(successor);\r\n            }\r\n            continue;\r\n          }\r\n\r\n          // Check if this is another function entry\r\n          // But allow STORE_STATE+JMP targets (they're part of the same function)\r\n          if (this.cfg.subroutineEntries.has(successor.startInstruction.address) &&\r\n              !this.cfg.storeStateJmpTargets.has(successor.startInstruction.address)) {\r\n            continue;\r\n          }\r\n\r\n          queue.push(successor);\r\n        }\r\n      }\r\n    }\r\n\r\n    return bodyBlocks;\r\n  }\r\n  \r\n  /**\r\n   * Check if a block is part of nested call code (between STORE_STATE+JMP and JMP target)\r\n   */\r\n  private isNestedCallBlock(block: NWScriptBasicBlock): boolean {\r\n    // Check if any instruction in the block is part of nested call code\r\n    for (const instruction of block.instructions) {\r\n      if (this.nestedCallAddresses.has(instruction.address)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a block is entirely an initialization sequence\r\n   */\r\n  private isInitializationBlock(block: NWScriptBasicBlock): boolean {\r\n    // Check if all instructions in the block are initialization instructions\r\n    const allInit = true;\r\n    let hasNonInit = false;\r\n\r\n    for (const instruction of block.instructions) {\r\n      if (this.initAddresses.has(instruction.address)) {\r\n        // This is an init instruction\r\n      } else if (instruction.code !== OP_RSADD && \r\n                 instruction.code !== 0x04 && // CONST\r\n                 instruction.code !== 0x01 && // CPDOWNSP\r\n                 instruction.code !== 0x1B && // MOVSP\r\n                 instruction.code !== 0x19) { // NEG\r\n        hasNonInit = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If block has only initialization instructions, it's an init block\r\n    return !hasNonInit && block.instructions.length > 0 && \r\n           block.instructions.some(instr => this.initAddresses.has(instr.address));\r\n  }\r\n\r\n  /**\r\n   * Find the return block(s) of a function\r\n   */\r\n  private findReturnBlock(entryBlock: NWScriptBasicBlock, bodyBlocks: NWScriptBasicBlock[]): NWScriptBasicBlock | null {\r\n    // Look for blocks ending with RETN\r\n    for (const block of bodyBlocks) {\r\n      if (block.endInstruction && block.endInstruction.code === OP_RETN) {\r\n        return block;\r\n      }\r\n    }\r\n\r\n    // If no RETN found, function might not return (or reaches end of script)\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Analyze function parameters from CPTOPBP instructions within the function body\r\n   * Parameters are accessed via CPTOPBP with negative offsets\r\n   */\r\n  private analyzeParameters(jsrInstruction: NWScriptInstruction, bodyBlocks: NWScriptBasicBlock[]): NWScriptFunctionParameter[] {\r\n    const parameterOffsets = new Map<number, { dataType: NWScriptDataType, count: number }>();\r\n    \r\n    // Scan all instructions in function body for CPTOPBP with negative offsets\r\n    for (const block of bodyBlocks) {\r\n      for (const instruction of block.instructions) {\r\n        if (instruction.code === OP_CPTOPBP && instruction.offset !== undefined) {\r\n          const offset = instruction.offset;\r\n          // Convert to signed 32-bit integer\r\n          const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n          \r\n          // Negative offsets are function parameters (accessed relative to BP)\r\n          if (offsetSigned < 0) {\r\n            // Infer data type from instruction type\r\n            let dataType = NWScriptDataType.INTEGER;\r\n            if (instruction.type === 4) dataType = NWScriptDataType.FLOAT;\r\n            else if (instruction.type === 5) dataType = NWScriptDataType.STRING;\r\n            else if (instruction.type === 6) dataType = NWScriptDataType.OBJECT;\r\n            \r\n            const existing = parameterOffsets.get(offsetSigned);\r\n            if (existing) {\r\n              existing.count++;\r\n              // Prefer more specific types\r\n              if (dataType !== NWScriptDataType.INTEGER && existing.dataType === NWScriptDataType.INTEGER) {\r\n                existing.dataType = dataType;\r\n              }\r\n            } else {\r\n              parameterOffsets.set(offsetSigned, { dataType, count: 1 });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Convert offsets to sorted parameter list\r\n    // Parameters are accessed with negative offsets relative to BP\r\n    // We need to sort them by offset (most negative = first parameter, least negative = last parameter)\r\n    const sortedOffsets = Array.from(parameterOffsets.keys()).sort((a, b) => a - b); // Ascending (most negative first)\r\n    \r\n    const parameters: NWScriptFunctionParameter[] = [];\r\n    for (let i = 0; i < sortedOffsets.length; i++) {\r\n      const offset = sortedOffsets[i];\r\n      const info = parameterOffsets.get(offset)!;\r\n      \r\n      // Parameter index (0 = first parameter, accessed with most negative offset)\r\n      const paramIndex = i;\r\n      \r\n      // Generate parameter name based on type\r\n      const typePrefix = this.getTypePrefix(info.dataType);\r\n      const paramName = `${typePrefix}Param${paramIndex + 1}`; // param1, param2, param3, etc.\r\n      \r\n      parameters.push({\r\n        name: paramName,\r\n        dataType: info.dataType,\r\n        offset: offset\r\n      });\r\n    }\r\n    \r\n    return parameters;\r\n  }\r\n  \r\n  /**\r\n   * Get type prefix for parameter naming\r\n   */\r\n  private getTypePrefix(dataType: NWScriptDataType): string {\r\n    switch (dataType) {\r\n      case NWScriptDataType.INTEGER: return 'int';\r\n      case NWScriptDataType.FLOAT: return 'float';\r\n      case NWScriptDataType.STRING: return 'string';\r\n      case NWScriptDataType.OBJECT: return 'object';\r\n      default: return 'int';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze return type from stack usage\r\n   */\r\n  private analyzeReturnType(entryBlock: NWScriptBasicBlock, bodyBlocks: NWScriptBasicBlock[]): NWScriptDataType {\r\n    // Look for RSADD at the start (indicates return type)\r\n    for (const instruction of entryBlock.instructions) {\r\n      if (instruction.code === OP_RSADD) {\r\n        // Map type to return type\r\n        switch (instruction.type) {\r\n          case 3: return NWScriptDataType.INTEGER;\r\n          case 4: return NWScriptDataType.FLOAT;\r\n          case 5: return NWScriptDataType.STRING;\r\n          case 6: return NWScriptDataType.OBJECT;\r\n          default: return NWScriptDataType.VOID;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Default to void if no RSADD found\r\n    return NWScriptDataType.VOID;\r\n  }\r\n\r\n  /**\r\n   * Generate a function name\r\n   * Functions are named sub1, sub2, etc., in order of their entry addresses\r\n   * (excluding main/StartingConditional which keep their special names)\r\n   */\r\n  private generateFunctionName(entryAddress: number): string {\r\n    // This will be called during analysis, so we need to generate names based on order\r\n    // We'll assign names after all functions are identified\r\n    // For now, return a placeholder that will be replaced\r\n    return `__sub_${entryAddress}__`;\r\n  }\r\n\r\n  /**\r\n   * Assign proper function names (sub1, sub2, etc.) after all functions are identified\r\n   */\r\n  private assignFunctionNames(): void {\r\n    // Get all functions except main, sorted by entry address\r\n    const subroutines = Array.from(this.functions.values())\r\n      .filter(func => !func.isMain)\r\n      .sort((a, b) => a.entryBlock.startInstruction.address - b.entryBlock.startInstruction.address);\r\n\r\n    // Assign names: sub1, sub2, sub3, etc.\r\n    for (let i = 0; i < subroutines.length; i++) {\r\n      subroutines[i].name = `sub${i + 1}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all functions\r\n   */\r\n  getFunctions(): NWScriptFunction[] {\r\n    return Array.from(this.functions.values());\r\n  }\r\n\r\n  /**\r\n   * Get the main function\r\n   */\r\n  getMainFunction(): NWScriptFunction | null {\r\n    return this.mainFunction;\r\n  }\r\n\r\n  /**\r\n   * Get a function by entry address\r\n   */\r\n  getFunction(entryAddress: number): NWScriptFunction | null {\r\n    return this.functions.get(entryAddress) || null;\r\n  }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptGlobalVariableAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":522,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":522,"endColumn":35},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":558,"column":33,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":558,"endColumn":56},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":652,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":652,"endColumn":40},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":658,"column":26,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":658,"endColumn":40},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":701,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":701,"endColumn":43}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\r\nimport type { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\r\nimport type { NWScriptControlFlowGraph } from \"@/nwscript/decompiler/NWScriptControlFlowGraph\";\r\nimport { EdgeType } from '@/nwscript/decompiler/NWScriptEdge';\r\nimport type { NWScript } from \"@/nwscript/NWScript\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\r\nimport { OP_RSADD, OP_CONST, OP_CPDOWNSP, OP_CPDOWNBP, OP_MOVSP, OP_NEG, OP_ACTION, OP_SAVEBP, OP_JSR, OP_RESTOREBP, OP_RETN } from '@/nwscript/NWScriptOPCodes';\r\n\r\n/**\r\n * Represents a detected global variable initialization\r\n */\r\nexport interface NWScriptGlobalInit {\r\n  offset: number; // BP offset for the global variable\r\n  dataType: NWScriptDataType;\r\n  initialValue: number | string | boolean;\r\n  hasInitializer: boolean; // Whether this variable has an explicit initializer\r\n  instructionAddress: number; // Address of the RSADD instruction\r\n}\r\n\r\n/**\r\n * Analyzes global variable initializations from the instruction stream.\r\n * Detects the pattern: RSADD -> CONST -> CPDOWNSP -> MOVSP\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptGlobalVariableAnalyzer.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptGlobalVariableAnalyzer {\r\n  private script: NWScript;\r\n  private cfg: NWScriptControlFlowGraph | null = null;\r\n  private globalInits: NWScriptGlobalInit[] = [];\r\n  private processedAddresses: Set<number> = new Set();\r\n\r\n  constructor(script: NWScript, cfg?: NWScriptControlFlowGraph) {\r\n    this.script = script;\r\n    this.cfg = cfg || null;\r\n  }\r\n\r\n  /**\r\n   * Analyze and detect all global variable initializations\r\n   * If CFG is provided, only analyzes blocks within the global initialization function\r\n   */\r\n  analyze(): NWScriptGlobalInit[] {\r\n    this.globalInits = [];\r\n    this.processedAddresses.clear();\r\n\r\n    if (!this.script.instructions) {\r\n      return [];\r\n    }\r\n\r\n    // If CFG is available, identify and analyze only the global initialization block\r\n    let globalInitBlocks: NWScriptBasicBlock[] = [];\r\n    let savebpAddress: number | null = null;\r\n    if (this.cfg) {\r\n      const result = this.identifyGlobalInitBlocks();\r\n      globalInitBlocks = result.blocks;\r\n      savebpAddress = result.savebpAddress;\r\n    }\r\n\r\n    // CRITICAL FIX: If there's no SAVEBP pattern, there are NO global variables\r\n    // Variables in the first JSR block are only globals if that block contains SAVEBP\r\n    // before JSRing to the real void main or int StartingConditional\r\n    if (this.cfg && globalInitBlocks.length === 0) {\r\n      // No global init function found - return empty (no globals)\r\n      return [];\r\n    }\r\n\r\n    // Get instructions to analyze\r\n    let instructionsToAnalyze: NWScriptInstruction[] = [];\r\n    \r\n    if (globalInitBlocks.length > 0) {\r\n      // Only analyze instructions within the global init blocks\r\n      // AND before SAVEBP address (if SAVEBP exists)\r\n      // CRITICAL: Include instructions from blocks that contain SAVEBP, but only those before SAVEBP\r\n      for (const block of globalInitBlocks) {\r\n        for (const instr of block.instructions) {\r\n          // Only include instructions before SAVEBP\r\n          // This allows us to include RSADD -> CONST -> CPDOWNSP -> MOVSP patterns\r\n          // that are in the same block as SAVEBP\r\n          if (!savebpAddress || instr.address < savebpAddress) {\r\n            instructionsToAnalyze.push(instr);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // No CFG available - fallback to analyzing all instructions (old behavior)\r\n      // This should rarely happen in practice\r\n      instructionsToAnalyze = Array.from(this.script.instructions.values());\r\n    }\r\n\r\n    // Sort instructions by address\r\n    const sortedInstructions = instructionsToAnalyze.sort((a, b) => a.address - b.address);\r\n\r\n    // Track all RSADD instructions to find uninitialized ones later\r\n    const allRSADD: NWScriptInstruction[] = [];\r\n\r\n    // First pass: Look for initialization patterns by following instruction chains\r\n    for (const rsadd of sortedInstructions) {\r\n      if (rsadd.code !== OP_RSADD) continue;\r\n      allRSADD.push(rsadd);\r\n      \r\n      if (this.processedAddresses.has(rsadd.address)) continue;\r\n\r\n      // Follow the instruction chain to find the pattern\r\n      let current = rsadd.nextInstr;\r\n      if (!current) continue;\r\n\r\n      // Find CONST\r\n      while (current && current.code !== OP_CONST && current.address < rsadd.address + 50) {\r\n        current = current.nextInstr;\r\n      }\r\n      if (!current || current.code !== OP_CONST) continue;\r\n      const constInstr = current;\r\n\r\n      // Check for NEG after CONST\r\n      let hasNeg = false;\r\n      if (constInstr.nextInstr && constInstr.nextInstr.code === OP_NEG) {\r\n        hasNeg = true;\r\n        current = constInstr.nextInstr.nextInstr;\r\n      } else {\r\n        current = constInstr.nextInstr;\r\n      }\r\n\r\n      // CRITICAL FIX: Skip if there's an ACTION call between CONST and CPDOWNSP\r\n      // This indicates a function call (e.g., GetGlobalNumber), not a constant initialization\r\n      let hasAction = false;\r\n      let searchCurrent = current;\r\n      while (searchCurrent && searchCurrent.code !== OP_CPDOWNSP && searchCurrent.address < constInstr.address + 50) {\r\n        if (searchCurrent.code === OP_ACTION) {\r\n          hasAction = true;\r\n          break;\r\n        }\r\n        searchCurrent = searchCurrent.nextInstr;\r\n      }\r\n      \r\n      // If we found an ACTION call, this is NOT a global variable initialization\r\n      // It's a function call that should be in the function body\r\n      if (hasAction) {\r\n        continue;\r\n      }\r\n\r\n      // Find CPDOWNSP\r\n      while (current && current.code !== OP_CPDOWNSP && current.address < constInstr.address + 30) {\r\n        current = current.nextInstr;\r\n      }\r\n      if (!current || current.code !== OP_CPDOWNSP) continue;\r\n      const cpdownsp = current;\r\n\r\n      // Check CPDOWNSP parameters\r\n      // CPDOWNSP FFFFFFF8 means offset -8 (writing to the space reserved by RSADD)\r\n      // The offset is a signed 32-bit integer (e.g. -8)\r\n      const cpdownspOffset = cpdownsp.offset;\r\n      const cpdownspOffsetSigned = cpdownspOffset > 0x7FFFFFFF ? cpdownspOffset - 0x100000000 : cpdownspOffset;\r\n      if (cpdownspOffsetSigned !== -8 || cpdownsp.size !== 4) continue;\r\n\r\n      // Find MOVSP\r\n      current = cpdownsp.nextInstr;\r\n      while (current && current.code !== OP_MOVSP && current.address < cpdownsp.address + 20) {\r\n        current = current.nextInstr;\r\n      }\r\n      if (!current || current.code !== OP_MOVSP) continue;\r\n      const movsp = current;\r\n\r\n      // Check MOVSP offset\r\n      // MOVSP FFFFFFFC means offset -4 (cleaning up the stack)\r\n      const movspOffset = movsp.offset;\r\n      const movspOffsetSigned = movspOffset > 0x7FFFFFFF ? movspOffset - 0x100000000 : movspOffset;\r\n      if (movspOffsetSigned !== -4) continue;\r\n\r\n      // Extract initialization\r\n      const init = this.extractInitialization(rsadd, constInstr, cpdownsp, hasNeg);\r\n      if (init) {\r\n        this.globalInits.push(init);\r\n        // Mark all instructions as processed\r\n        this.processedAddresses.add(rsadd.address);\r\n        this.processedAddresses.add(constInstr.address);\r\n        if (hasNeg && constInstr.nextInstr) {\r\n          this.processedAddresses.add(constInstr.nextInstr.address);\r\n        }\r\n        this.processedAddresses.add(cpdownsp.address);\r\n        this.processedAddresses.add(movsp.address);\r\n      }\r\n    }\r\n\r\n    // Second pass: Find uninitialized globals (RSADD without initialization pattern)\r\n    // Only consider writes that are part of a complete initialization pattern\r\n    for (const rsadd of allRSADD) {\r\n      if (this.processedAddresses.has(rsadd.address)) continue;\r\n\r\n      // Check if there's a complete initialization pattern for this RSADD\r\n      // Pattern: RSADD -> CONST -> [NEG] -> CPDOWNSP -> MOVSP\r\n      // We search within a very limited window and verify the complete pattern\r\n      let hasInitialization = false;\r\n      let current = rsadd.nextInstr;\r\n      \r\n      // Very limited search window - initialization patterns are immediate\r\n      // Stop immediately if we hit another RSADD (new variable declaration)\r\n      const maxSearchDistance = 20; // Only search within immediate initialization context\r\n      let searchLimit = 0;\r\n      \r\n      while (current && searchLimit < maxSearchDistance) {\r\n        // Stop if we hit another RSADD - that's a new variable, not initialization of this one\r\n        if (current.code === OP_RSADD && current.address !== rsadd.address) {\r\n          break;\r\n        }\r\n        \r\n        // Look for the initialization pattern: CONST -> [NEG] -> CPDOWNSP -> MOVSP\r\n        if (current.code === OP_CONST) {\r\n          const constInstr = current;\r\n          \r\n          // Check for NEG after CONST\r\n          let hasNeg = false;\r\n          let nextAfterConst = constInstr.nextInstr;\r\n          if (nextAfterConst && nextAfterConst.code === OP_NEG) {\r\n            hasNeg = true;\r\n            nextAfterConst = nextAfterConst.nextInstr;\r\n          }\r\n          \r\n          // CRITICAL FIX: Skip if there's an ACTION call between CONST and CPDOWNSP\r\n          // This indicates a function call, not a constant initialization\r\n          let hasAction = false;\r\n          let actionCheck = nextAfterConst;\r\n          while (actionCheck && actionCheck.code !== OP_CPDOWNSP && actionCheck.code !== OP_CPDOWNBP && actionCheck.address < constInstr.address + 50) {\r\n            if (actionCheck.code === OP_ACTION) {\r\n              hasAction = true;\r\n              break;\r\n            }\r\n            actionCheck = actionCheck.nextInstr;\r\n          }\r\n          \r\n          if (hasAction) {\r\n            // This is a function call pattern, not a global initialization\r\n            current = current.nextInstr;\r\n            continue;\r\n          }\r\n          \r\n          // Look for CPDOWNSP after CONST (or NEG)\r\n          let cpdownspInstr = nextAfterConst;\r\n          let cpdownspSearchLimit = 0;\r\n          while (cpdownspInstr && cpdownspSearchLimit < 10) {\r\n            if (cpdownspInstr.code === OP_CPDOWNSP || cpdownspInstr.code === OP_CPDOWNBP) {\r\n              const offset = cpdownspInstr.offset;\r\n              const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n              \r\n              // CPDOWNSP -8 writes to the space reserved by the most recent RSADD\r\n              // But we need to verify this is actually for our RSADD\r\n              // The pattern should be: RSADD -> CONST -> CPDOWNSP -8 -> MOVSP -4\r\n              if (offsetSigned === -8 && cpdownspInstr.size === 4) {\r\n                // Check for MOVSP -4 after CPDOWNSP\r\n                let movspInstr = cpdownspInstr.nextInstr;\r\n                let movspSearchLimit = 0;\r\n                while (movspInstr && movspSearchLimit < 10) {\r\n                  if (movspInstr.code === OP_MOVSP && movspInstr.offset !== undefined) {\r\n                    const movspOffset = movspInstr.offset;\r\n                    const movspOffsetSigned = movspOffset > 0x7FFFFFFF ? movspOffset - 0x100000000 : movspOffset;\r\n                    \r\n                    // MOVSP -4 after CPDOWNSP completes the initialization pattern\r\n                    if (movspOffsetSigned === -4) {\r\n                      // Verify this pattern is for our RSADD by checking the sequence\r\n                      // The instructions should be sequential: RSADD -> CONST -> CPDOWNSP -> MOVSP\r\n                      if (constInstr.address > rsadd.address &&\r\n                          cpdownspInstr.address > constInstr.address &&\r\n                          movspInstr.address > cpdownspInstr.address) {\r\n                        hasInitialization = true;\r\n                        break;\r\n                      }\r\n                    }\r\n                  }\r\n                  movspInstr = movspInstr.nextInstr;\r\n                  movspSearchLimit++;\r\n                }\r\n                \r\n                if (hasInitialization) {\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Stop if we hit another RSADD or CONST (different pattern)\r\n            if (cpdownspInstr.code === OP_RSADD || cpdownspInstr.code === OP_CONST) {\r\n              break;\r\n            }\r\n            \r\n            cpdownspInstr = cpdownspInstr.nextInstr;\r\n            cpdownspSearchLimit++;\r\n          }\r\n          \r\n          if (hasInitialization) {\r\n            break;\r\n          }\r\n        }\r\n        \r\n        current = current.nextInstr;\r\n        searchLimit++;\r\n      }\r\n\r\n      // If no initialization pattern found, this is an uninitialized global\r\n      if (!hasInitialization) {\r\n        // Determine data type from RSADD type\r\n        let dataType: NWScriptDataType;\r\n        switch (rsadd.type) {\r\n          case 3: dataType = NWScriptDataType.INTEGER; break;\r\n          case 4: dataType = NWScriptDataType.FLOAT; break;\r\n          case 5: dataType = NWScriptDataType.STRING; break;\r\n          case 6: dataType = NWScriptDataType.OBJECT; break;\r\n          default: continue; // Skip unknown types\r\n        }\r\n\r\n        // Calculate global variable BP offset (will be recalculated after all globals are found)\r\n        // For now, use a placeholder - we'll fix it in a second pass\r\n        const offset = 0; // Placeholder, will be recalculated\r\n\r\n        this.globalInits.push({\r\n          offset: offset,\r\n          dataType: dataType,\r\n          initialValue: undefined,\r\n          hasInitializer: false,\r\n          instructionAddress: rsadd.address\r\n        });\r\n\r\n        // Mark RSADD as processed\r\n        this.processedAddresses.add(rsadd.address);\r\n      }\r\n    }\r\n\r\n    // CRITICAL FIX: Recalculate BP offsets now that we know the total count\r\n    // After SAVEBP, BP points to the \"top\" of globals (just after the last global)\r\n    // Global 0 (first) is at BP - (N*4), Global 1 is at BP - ((N-1)*4), etc.\r\n    // Global i is at BP - ((N-i)*4) where N = total globals\r\n    const totalGlobals = this.globalInits.length;\r\n    for (let i = 0; i < this.globalInits.length; i++) {\r\n      const globalIndex = i;\r\n      const offset = -4 * (totalGlobals - globalIndex);\r\n      this.globalInits[i].offset = offset;\r\n    }\r\n\r\n    return this.globalInits;\r\n  }\r\n\r\n  /**\r\n   * Check if a sequence of instructions matches the initialization pattern\r\n   */\r\n  private isInitializationPattern(\r\n    rsadd: NWScriptInstruction,\r\n    constInstr: NWScriptInstruction,\r\n    cpdownsp: NWScriptInstruction,\r\n    movsp: NWScriptInstruction\r\n  ): boolean {\r\n    // Check RSADD\r\n    if (rsadd.code !== OP_RSADD) return false;\r\n    if (this.processedAddresses.has(rsadd.address)) return false;\r\n\r\n    // Check CONST\r\n    if (constInstr.code !== OP_CONST) return false;\r\n    if (constInstr.address <= rsadd.address) return false;\r\n\r\n    // Check CPDOWNSP with offset FFFFFFF8 (which is -8, writing to the reserved space)\r\n    if (cpdownsp.code !== OP_CPDOWNSP) return false;\r\n    if (cpdownsp.offset !== -8 || cpdownsp.size !== 4) return false;\r\n    if (cpdownsp.address <= constInstr.address) return false;\r\n\r\n    // Check MOVSP with offset FFFFFFFC (which is -4, cleaning up the stack)\r\n    if (movsp.code !== OP_MOVSP) return false;\r\n    if (movsp.offset !== -4) return false;\r\n    if (movsp.address <= cpdownsp.address) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Extract initialization information from the pattern\r\n   */\r\n  private extractInitialization(\r\n    rsadd: NWScriptInstruction,\r\n    constInstr: NWScriptInstruction,\r\n    cpdownsp: NWScriptInstruction,\r\n    hasNeg: boolean = false\r\n  ): NWScriptGlobalInit | null {\r\n    // Determine data type from RSADD type\r\n    let dataType: NWScriptDataType;\r\n    switch (rsadd.type) {\r\n      case 3: dataType = NWScriptDataType.INTEGER; break;\r\n      case 4: dataType = NWScriptDataType.FLOAT; break;\r\n      case 5: dataType = NWScriptDataType.STRING; break;\r\n      case 6: dataType = NWScriptDataType.OBJECT; break;\r\n      default: return null;\r\n    }\r\n\r\n    // Extract value from CONST instruction\r\n    let initialValue: number | string | undefined;\r\n    let hasInitializer = true;\r\n    \r\n    switch (constInstr.type) {\r\n      case 3: // INTEGER\r\n        initialValue = constInstr.integer;\r\n        // Integer values are always valid initializers (including 0 and 1)\r\n        // The presence of CPDOWNSP writing to the reserved space indicates initialization\r\n        break;\r\n      case 4: // FLOAT\r\n        initialValue = constInstr.float;\r\n        // Float values are always valid initializers (including 0.0)\r\n        break;\r\n      case 5: // STRING\r\n        initialValue = constInstr.string;\r\n        // Empty string is a valid initializer\r\n        break;\r\n      case 6: // OBJECT\r\n        initialValue = constInstr.object;\r\n        // Object value 0 means OBJECT_INVALID, which typically means no initializer\r\n        // Also, value 1 might be a default/placeholder that shouldn't be treated as initializer\r\n        if (initialValue === 0 || initialValue === undefined || initialValue === 1) {\r\n          hasInitializer = false;\r\n          initialValue = undefined;\r\n        }\r\n        break;\r\n      default:\r\n        return null;\r\n    }\r\n\r\n    // Apply negation if NEG instruction was present\r\n    if (hasNeg) {\r\n      if (dataType === NWScriptDataType.INTEGER || dataType === NWScriptDataType.FLOAT) {\r\n        initialValue = -initialValue;\r\n      }\r\n    }\r\n\r\n    // For objects, if the value is 0, 1, or undefined after processing, treat as no initializer\r\n    // Value 1 for objects is often OBJECT_INVALID or a placeholder\r\n    if (dataType === NWScriptDataType.OBJECT && (initialValue === 0 || initialValue === 1 || initialValue === undefined)) {\r\n      hasInitializer = false;\r\n      initialValue = undefined;\r\n    }\r\n\r\n        // Calculate global variable BP offset (will be recalculated after all globals are found)\r\n        // For now, use a placeholder - we'll fix it in a second pass\r\n        const offset = 0; // Placeholder, will be recalculated\r\n\r\n    return {\r\n      offset: offset,\r\n      dataType: dataType,\r\n      initialValue: initialValue,\r\n      hasInitializer: hasInitializer,\r\n      instructionAddress: rsadd.address\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all detected global variable initializations\r\n   */\r\n  getGlobalInits(): NWScriptGlobalInit[] {\r\n    return this.globalInits;\r\n  }\r\n\r\n  /**\r\n   * Check if an instruction address is part of an initialization sequence\r\n   */\r\n  isInitializationInstruction(address: number): boolean {\r\n    return this.processedAddresses.has(address);\r\n  }\r\n\r\n  /**\r\n   * Get the initialization for a specific offset\r\n   */\r\n  getInitForOffset(offset: number): NWScriptGlobalInit | null {\r\n    return this.globalInits.find(init => init.offset === offset) || null;\r\n  }\r\n\r\n  /**\r\n   * Identify the global initialization blocks using CFG\r\n   * CRITICAL: SAVEBP is NOT in the entry block. It's inside the first JSR target function,\r\n   * near the end, before JSRing to the real main/StartingConditional.\r\n   * \r\n   * Pattern:\r\n   * - Entry: JSR(first_function) -> RETN\r\n   * - First function: [globals] ... SAVEBP -> JSR(main) -> RESTOREBP -> MOVSP -> RETN\r\n   * \r\n   * Returns blocks from the first JSR target up to (but not including) SAVEBP\r\n   */\r\n  private identifyGlobalInitBlocks(): { blocks: NWScriptBasicBlock[], savebpAddress: number | null } {\r\n    if (!this.cfg || !this.cfg.entryBlock) {\r\n      return { blocks: [], savebpAddress: null };\r\n    }\r\n\r\n    const entryBlock = this.cfg.entryBlock;\r\n    \r\n    // Get the first JSR from entry block\r\n    let firstJSR: NWScriptInstruction | null = null;\r\n    let current = entryBlock.startInstruction;\r\n    while (current && current.address <= entryBlock.endInstruction.address) {\r\n      if (current.code === OP_JSR && current.offset !== undefined) {\r\n        firstJSR = current;\r\n        break;\r\n      }\r\n      current = current.nextInstr;\r\n    }\r\n    \r\n    if (!firstJSR) {\r\n      // No JSR in entry block - no globals\r\n      return { blocks: [], savebpAddress: null };\r\n    }\r\n    \r\n    // Get the first JSR target address\r\n    const firstJSRTarget = firstJSR.address + firstJSR.offset;\r\n    const firstJSRBlock = this.cfg.getBlockForAddress(firstJSRTarget);\r\n    \r\n    if (!firstJSRBlock) {\r\n      return { blocks: [], savebpAddress: null };\r\n    }\r\n    \r\n    // Check if the first JSR target contains SAVEBP -> JSR pattern\r\n    // This indicates it's a global init function\r\n    let savebpAddress: number | null = null;\r\n    let savebpBlock: NWScriptBasicBlock | null = null;\r\n    \r\n    // Search for SAVEBP in blocks reachable from first JSR target\r\n    const visited = new Set<NWScriptBasicBlock>();\r\n    const queue: NWScriptBasicBlock[] = [firstJSRBlock];\r\n    \r\n    while (queue.length > 0 && !savebpAddress) {\r\n      const block = queue.shift()!;\r\n      if (visited.has(block)) continue;\r\n      visited.add(block);\r\n      \r\n      // Check if this block contains SAVEBP\r\n      for (const instr of block.instructions) {\r\n        if (instr.code === OP_SAVEBP) {\r\n          // Found SAVEBP - now search for JSR that comes after it\r\n          // JSR might be in the same block or a successor block\r\n          savebpAddress = instr.address;\r\n          savebpBlock = block;\r\n          \r\n          // Search for JSR after SAVEBP\r\n          // First check within the same block\r\n          let foundJSR = false;\r\n          let next = instr.nextInstr;\r\n          while (next && next.address <= block.endInstruction.address) {\r\n            if (next.code === OP_JSR) {\r\n              foundJSR = true;\r\n              break;\r\n            }\r\n            if (next.code === OP_RESTOREBP) {\r\n              // Hit RESTOREBP before JSR - invalid pattern\r\n              savebpAddress = null;\r\n              savebpBlock = null;\r\n              break;\r\n            }\r\n            next = next.nextInstr;\r\n          }\r\n          \r\n          // If not found in same block, search successor blocks\r\n          if (!foundJSR && savebpAddress) {\r\n            const jsrSearchVisited = new Set<NWScriptBasicBlock>();\r\n            const jsrSearchQueue: NWScriptBasicBlock[] = Array.from(block.successors);\r\n            \r\n            while (jsrSearchQueue.length > 0 && !foundJSR && savebpAddress) {\r\n              const succBlock = jsrSearchQueue.shift()!;\r\n              if (jsrSearchVisited.has(succBlock)) continue;\r\n              jsrSearchVisited.add(succBlock);\r\n              \r\n              // Check if this block contains JSR after SAVEBP\r\n              for (const succInstr of succBlock.instructions) {\r\n                if (succInstr.code === OP_JSR && succInstr.address > instr.address) {\r\n                  foundJSR = true;\r\n                  break;\r\n                }\r\n                if (succInstr.code === OP_RESTOREBP && succInstr.address > instr.address) {\r\n                  // Hit RESTOREBP before JSR - invalid pattern\r\n                  savebpAddress = null;\r\n                  savebpBlock = null;\r\n                  foundJSR = false;\r\n                  break;\r\n                }\r\n              }\r\n              \r\n              // Continue searching if we haven't found JSR yet\r\n              if (!foundJSR && savebpAddress) {\r\n                for (const succSucc of succBlock.successors) {\r\n                  if (!jsrSearchVisited.has(succSucc)) {\r\n                    const hasRetn = succSucc.instructions.some(i => i.code === OP_RETN);\r\n                    if (!hasRetn) {\r\n                      jsrSearchQueue.push(succSucc);\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            \r\n            // If we didn't find JSR, invalidate SAVEBP\r\n            if (!foundJSR) {\r\n              savebpAddress = null;\r\n              savebpBlock = null;\r\n            }\r\n          }\r\n          \r\n          if (savebpAddress) break;\r\n        }\r\n      }\r\n      \r\n      // Continue searching if we haven't found SAVEBP yet\r\n      if (!savebpAddress) {\r\n        for (const successor of block.successors) {\r\n          if (!visited.has(successor)) {\r\n            // Skip RETURN edges - these go back to the caller (outside the function)\r\n            const edge = this.cfg.getEdge(block, successor);\r\n            if (edge && edge.type === EdgeType.RETURN) {\r\n              continue;\r\n            }\r\n            \r\n            // Stop if we hit a RETN (end of function)\r\n            const hasRetn = successor.instructions.some(instr => instr.code === OP_RETN);\r\n            if (!hasRetn) {\r\n              queue.push(successor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Fallback: linear scan from first JSR target if CFG search failed\r\n    if (!savebpAddress && firstJSRBlock) {\r\n      let instr: NWScriptInstruction | null = firstJSRBlock.startInstruction;\r\n      while (instr) {\r\n        if (instr.code === OP_SAVEBP) {\r\n          savebpAddress = instr.address;\r\n          savebpBlock = this.cfg.getBlockForAddress(instr.address) || firstJSRBlock;\r\n          break;\r\n        }\r\n        if (instr.code === OP_RETN) break;\r\n        instr = instr.nextInstr;\r\n      }\r\n    }\r\n    \r\n    // If we didn't find SAVEBP, this is not a global init function\r\n    if (!savebpAddress || !savebpBlock) {\r\n      return { blocks: [], savebpAddress: null };\r\n    }\r\n    \r\n    // Collect blocks from first JSR target up to (but not including) SAVEBP block\r\n    // Variables in these blocks are globals\r\n    // CRITICAL: We must only follow execution edges within the function, NOT return edges\r\n    const blocks: NWScriptBasicBlock[] = [];\r\n    const blockVisited = new Set<NWScriptBasicBlock>();\r\n    const blockQueue: NWScriptBasicBlock[] = [firstJSRBlock];\r\n    \r\n    // Get the return point of the entry JSR (the RETN after JSR in entry block)\r\n    // We should NOT follow edges to this block as it's outside the function\r\n    const entryJSRReturnBlock = this.cfg.subroutineReturns.get(firstJSR.address);\r\n\r\n    while (blockQueue.length > 0) {\r\n      const block = blockQueue.shift()!;\r\n      if (blockVisited.has(block)) continue;\r\n      blockVisited.add(block);\r\n      \r\n      // Check if any instruction in this block is at or after SAVEBP address\r\n      const blockHasSavebp = block.instructions.some(instr => \r\n        instr.address >= savebpAddress!\r\n      );\r\n      \r\n      if (blockHasSavebp) {\r\n        // This block contains SAVEBP - we still want to include it\r\n        // because it may contain global variable initializations BEFORE SAVEBP\r\n        // The instruction filtering above (line 79) will exclude instructions at/after SAVEBP\r\n        blocks.push(block);\r\n        // Don't follow successors from SAVEBP block (they're after globals)\r\n        continue;\r\n      }\r\n      \r\n      // Block is entirely before SAVEBP - include it\r\n      blocks.push(block);\r\n\r\n      // Follow successors, but stop at SAVEBP block\r\n      // CRITICAL: Only follow execution edges within the function, NOT return edges\r\n      // Return edges go back to the caller and are outside the function\r\n      for (const successor of block.successors) {\r\n        // Include SAVEBP block if it hasn't been visited yet (it contains globals before SAVEBP)\r\n        if (!blockVisited.has(successor)) {\r\n          // Skip RETURN edges - these go back to the caller (outside the function)\r\n          const edge = this.cfg.getEdge(block, successor);\r\n          if (edge && edge.type === EdgeType.RETURN) {\r\n            continue;\r\n          }\r\n          \r\n          // Skip the entry JSR return point (RETN in entry block) - it's outside the function\r\n          if (entryJSRReturnBlock && successor === entryJSRReturnBlock) {\r\n            continue;\r\n          }\r\n          \r\n          // Skip CALL edges to other functions (though we should stop at SAVEBP before reaching them)\r\n          if (edge && edge.type === EdgeType.CALL) {\r\n            // Only skip if it's not the first JSR target (which we're already in)\r\n            if (successor.startInstruction.address !== firstJSRTarget) {\r\n              continue;\r\n            }\r\n          }\r\n          \r\n          // Check if successor is before SAVEBP or is the SAVEBP block itself\r\n          // We include the SAVEBP block because it may contain globals before SAVEBP\r\n          const successorBeforeSavebp = successor.instructions.every(instr => \r\n            instr.address < savebpAddress!\r\n          );\r\n          const isSavebpBlock = successor === savebpBlock;\r\n          if (successorBeforeSavebp || isSavebpBlock) {\r\n            blockQueue.push(successor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { blocks, savebpAddress };\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptORChainDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":92,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":92,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `NWScriptInstruction`.","line":95,"column":38,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":95,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on a type that cannot be resolved.","line":98,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":98,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on a type that cannot be resolved.","line":103,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":103,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on a type that cannot be resolved.","line":103,"column":41,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":103,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":109,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":109,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .address on a type that cannot be resolved.","line":109,"column":38,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":109,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `number`.","line":113,"column":28,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":113,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .address on a type that cannot be resolved.","line":113,"column":34,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":113,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `NWScriptDataType`.","line":169,"column":45,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":169,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .INTEGER on a type that cannot be resolved.","line":169,"column":62,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":169,"endColumn":69},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":200,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":200,"endColumn":49},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":200,"column":51,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":200,"endColumn":62},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":201,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":201,"endColumn":50},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":201,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":201,"endColumn":64},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":214,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":214,"endColumn":49},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":214,"column":51,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":214,"endColumn":62},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":215,"column":38,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":215,"endColumn":50},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":215,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":215,"endColumn":64}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport type { NWScriptBasicBlock } from \"@/nwscript/decompiler/NWScriptBasicBlock\";\r\nimport { NWScriptExpression, NWScriptExpressionType } from \"@/nwscript/decompiler/NWScriptExpression\";\r\nimport { NWScriptExpressionBuilder } from \"@/nwscript/decompiler/NWScriptExpressionBuilder\";\r\nimport type { NWScriptFunctionParameter } from \"@/nwscript/decompiler/NWScriptFunctionAnalyzer\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/decompiler/NWScriptInstruction\";\r\nimport { OP_EQUAL, OP_LOGORII, OP_JZ, OP_JNZ } from '@/nwscript/decompiler/NWScriptOPCodes';\r\nimport { NWScriptDataType } from \"@/nwscript/enums/nwscript/NWScriptDataType\";\n\r\n/**\r\n * Detects and simplifies OR chains in NWScript bytecode.\r\n * Pattern: EQUALII -> [optional JZ] -> EQUALII -> LOGORII -> [repeat] -> final JZ\r\n * \r\n * This optimizes expressions like:\r\n *   (param == const1 || param == const2 || param == const3)\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptORChainDetector.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptORChainDetector {\r\n  private functionParameters: NWScriptFunctionParameter[] = [];\r\n\r\n  /**\r\n   * Set function parameters for proper variable name mapping\r\n   */\r\n  setFunctionParameters(parameters: NWScriptFunctionParameter[]): void {\r\n    this.functionParameters = parameters;\r\n  }\r\n\r\n  /**\r\n   * Detect and simplify OR chain in a block's instructions\r\n   * Returns a simplified OR expression if a chain is detected, null otherwise\r\n   */\r\n  detectORChain(block: NWScriptBasicBlock): NWScriptExpression | null {\r\n    if (!block.conditionInstruction) {\r\n      return null;\r\n    }\r\n\r\n    const instructions = block.instructions;\r\n    const conditionInstr = block.conditionInstruction;\r\n    \r\n    // Find the index of the condition instruction\r\n    const conditionIndex = instructions.indexOf(conditionInstr);\r\n    if (conditionIndex < 0) {\r\n      return null;\r\n    }\r\n\r\n    // Analyze instructions up to the condition instruction\r\n    const relevantInstructions = instructions.slice(0, conditionIndex + 1);\r\n    \r\n    // Detect OR chain pattern\r\n    const orChain = this.analyzeORChainPattern(relevantInstructions, conditionInstr);\r\n    \r\n    if (orChain && orChain.comparisons.length > 1) {\r\n      // Build OR expression tree from all comparisons\r\n      return this.buildORExpression(orChain.comparisons);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Analyze instructions for OR chain pattern\r\n   * Improved algorithm that tracks the expression stack state correctly\r\n   */\r\n  private analyzeORChainPattern(\r\n    instructions: NWScriptInstruction[],\r\n    conditionInstr: NWScriptInstruction\r\n  ): { comparisons: NWScriptExpression[], redundantJZ: number[] } | null {\r\n    const redundantJZ: number[] = [];\r\n    \r\n    // Track the expression builder state\r\n    const exprBuilder = new NWScriptExpressionBuilder();\r\n    exprBuilder.setFunctionParameters(this.functionParameters);\r\n    \r\n    // Track JZ instructions and their conditions\r\n    const jzConditions = new Map<number, NWScriptExpression>();\r\n    \r\n    // Count LOGORII operations\r\n    let logoriiCount = 0;\r\n    \r\n    // Process instructions up to (but not including) the condition instruction\r\n    const conditionIndex = instructions.indexOf(conditionInstr);\r\n    if (conditionIndex < 0) {\r\n      return null;\r\n    }\r\n    \r\n    for (let i = 0; i <= conditionIndex; i++) {\r\n      const instr = instructions[i];\r\n      \r\n      // Process instruction to build expression stack\r\n      exprBuilder.processInstruction(instr);\r\n      \r\n      // Count LOGORII operations\r\n      if (instr.code === OP_LOGORII) {\r\n        logoriiCount++;\r\n      }\r\n      \r\n      // Track JZ instructions and their conditions (for redundant check detection)\r\n      if (instr.code === OP_JZ || instr.code === OP_JNZ) {\r\n        const condition = exprBuilder.peek();\r\n        if (condition) {\r\n          // Check if we've seen this condition before (redundant check)\r\n          for (const [jzAddr, prevCondition] of jzConditions.entries()) {\r\n            if (this.expressionsEqual(condition, prevCondition)) {\r\n              redundantJZ.push(instr.address);\r\n              break;\r\n            }\r\n          }\r\n          jzConditions.set(instr.address, condition);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Get the final expression from the stack (should be the OR chain result)\r\n    const finalExpr = exprBuilder.peek();\r\n    \r\n    if (!finalExpr) {\r\n      return null;\r\n    }\r\n    \r\n    // Extract all comparisons from the final expression\r\n    const comparisons = this.extractComparisonsFromExpression(finalExpr);\r\n    \r\n    // If we found multiple comparisons and LOGORII operations, it's an OR chain\r\n    // We need at least 2 comparisons and at least 1 LOGORII\r\n    if (comparisons.length >= 2 && logoriiCount >= 1) {\r\n      return { comparisons, redundantJZ };\r\n    }\r\n    \r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Extract all comparison expressions from an expression tree\r\n   * Handles OR chains: (a == b || c == d || e == f)\r\n   */\r\n  private extractComparisonsFromExpression(expr: NWScriptExpression): NWScriptExpression[] {\r\n    const comparisons: NWScriptExpression[] = [];\r\n    \r\n    const collect = (e: NWScriptExpression | null): void => {\r\n      if (!e) return;\r\n      \r\n      if (e.type === NWScriptExpressionType.LOGICAL && e.operator === '||') {\r\n        // Recursively collect from left and right of OR expression\r\n        collect(e.left);\r\n        collect(e.right);\r\n      } else if (e.type === NWScriptExpressionType.COMPARISON) {\r\n        // This is a comparison - add it to the list\r\n        comparisons.push(e);\r\n      }\r\n      // For other types, don't collect (they're not part of the OR chain)\r\n    };\r\n    \r\n    collect(expr);\r\n    return comparisons;\r\n  }\r\n\r\n  /**\r\n   * Build an OR expression tree from multiple comparisons\r\n   * Creates a left-associative OR tree: (a || b || c) = ((a || b) || c)\r\n   */\r\n  private buildORExpression(comparisons: NWScriptExpression[]): NWScriptExpression {\r\n    if (comparisons.length === 0) {\r\n      // Fallback - shouldn't happen\r\n      return NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n    }\r\n    \r\n    if (comparisons.length === 1) {\r\n      return comparisons[0];\r\n    }\r\n    \r\n    // Build left-associative OR tree\r\n    let result = comparisons[0];\r\n    for (let i = 1; i < comparisons.length; i++) {\r\n      result = NWScriptExpression.logical('||', result, comparisons[i]);\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if two expressions are equal (for detecting redundant checks)\r\n   */\r\n  private expressionsEqual(expr1: NWScriptExpression, expr2: NWScriptExpression): boolean {\r\n    if (expr1.type !== expr2.type) {\r\n      return false;\r\n    }\r\n    \r\n    switch (expr1.type) {\r\n      case NWScriptExpressionType.COMPARISON:\r\n        // Compare comparison expressions\r\n        if (expr1.operator !== expr2.operator) {\r\n          return false;\r\n        }\r\n        // For now, do a simple check - could be improved\r\n        return this.expressionsEqual(expr1.left!, expr2.left!) &&\r\n               this.expressionsEqual(expr1.right!, expr2.right!);\r\n      \r\n      case NWScriptExpressionType.CONSTANT:\r\n        return expr1.value === expr2.value && expr1.dataType === expr2.dataType;\r\n      \r\n      case NWScriptExpressionType.VARIABLE:\r\n        return expr1.variableName === expr2.variableName && \r\n               expr1.isGlobal === expr2.isGlobal;\r\n      \r\n      case NWScriptExpressionType.LOGICAL:\r\n        if (expr1.operator !== expr2.operator) {\r\n          return false;\r\n        }\r\n        return this.expressionsEqual(expr1.left!, expr2.left!) &&\r\n               this.expressionsEqual(expr1.right!, expr2.right!);\r\n      \r\n      default:\r\n        // For other types, do a simple comparison\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simplify an expression by detecting and replacing OR chains\r\n   * This is a post-processing step that can be applied to any expression\r\n   */\r\n  simplifyExpression(expr: NWScriptExpression): NWScriptExpression {\r\n    if (expr.type === NWScriptExpressionType.LOGICAL && expr.operator === '||') {\r\n      // Check if this is part of an OR chain\r\n      const orChain = this.extractORChain(expr);\r\n      if (orChain.length > 2) {\r\n        // Rebuild as a single OR chain\r\n        return this.buildORExpression(orChain);\r\n      }\r\n    }\r\n    \r\n    // Recursively simplify left and right\r\n    if (expr.left) {\r\n      expr.left = this.simplifyExpression(expr.left);\r\n    }\r\n    if (expr.right) {\r\n      expr.right = this.simplifyExpression(expr.right);\r\n    }\r\n    \r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Extract all comparison expressions from an OR chain\r\n   */\r\n  private extractORChain(expr: NWScriptExpression): NWScriptExpression[] {\r\n    const comparisons: NWScriptExpression[] = [];\r\n    \r\n    const collectComparisons = (e: NWScriptExpression): void => {\r\n      if (e.type === NWScriptExpressionType.LOGICAL && e.operator === '||') {\r\n        // Recursively collect from left and right\r\n        if (e.left) collectComparisons(e.left);\r\n        if (e.right) collectComparisons(e.right);\r\n      } else if (e.type === NWScriptExpressionType.COMPARISON) {\r\n        // This is a comparison - add it to the list\r\n        comparisons.push(e);\r\n      }\r\n    };\r\n    \r\n    collectComparisons(expr);\r\n    return comparisons;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\nwscript\\decompiler\\NWScriptStackSimulator.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":240,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":240,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":241,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":241,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":264,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":264,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":265,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":265,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":287,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":287,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":288,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":288,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":310,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":310,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":311,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":311,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":340,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":340,"endColumn":30},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":341,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":341,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":369,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":369,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":432,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":432,"endColumn":65},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":438,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":438,"endColumn":66},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":485,"column":30,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":485,"endColumn":70},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":707,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":707,"endColumn":35}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NWScriptDataType } from \"@/enums/nwscript/NWScriptDataType\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\r\nimport { NWScriptExpression } from \"@/nwscript/decompiler/NWScriptExpression\";\r\nimport type { NWScriptFunctionParameter } from \"@/nwscript/decompiler/NWScriptFunctionAnalyzer\";\r\nimport type { NWScriptInstruction } from \"@/nwscript/NWScriptInstruction\";\r\n\r\n\r\nconst log = createScopedLogger(LogScope.NWScript);\r\nimport {\r\n  OP_CONST, OP_ACTION, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MODII,\r\n  OP_EQUAL, OP_NEQUAL, OP_GT, OP_GEQ, OP_LT, OP_LEQ,\r\n  OP_LOGANDII, OP_LOGORII, OP_BOOLANDII, OP_INCORII, OP_EXCORII,\r\n  OP_SHLEFTII, OP_SHRIGHTII, OP_USHRIGHTII,\r\n  OP_NEG, OP_COMPI, OP_NOTI,\r\n  OP_CPTOPBP, OP_CPTOPSP, OP_CPDOWNSP, OP_CPDOWNBP,\r\n  OP_MOVSP, OP_DESTRUCT, OP_RSADD,\r\n  OP_DECISP, OP_INCISP, OP_DECIBP, OP_INCIBP\r\n} from '@/nwscript/NWScriptOPCodes';\r\n\r\n/**\r\n * Represents an item on the stack\r\n */\r\ninterface StackItem {\r\n  expression: NWScriptExpression;\r\n  address: number; // Instruction address that created this item\r\n}\r\n\r\n/**\r\n * Simulates the NWScript stack during conversion.\r\n * Tracks stack pointer (SP) and stack contents accurately.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file NWScriptStackSimulator.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class NWScriptStackSimulator {\r\n  /**\r\n   * The stack (array of stack items)\r\n   * Index 0 is the bottom of the stack, higher indices are closer to the top\r\n   */\r\n  private stack: StackItem[] = [];\r\n\r\n  /**\r\n   * Current stack pointer (SP) - points to the top of the stack\r\n   * In NWScript, SP points to the next available slot\r\n   */\r\n  private stackPointer: number = 0;\r\n\r\n  /**\r\n   * Current base pointer (BP) - for global variable access\r\n   */\r\n  private basePointer: number = 0;\r\n\r\n  /**\r\n   * Function parameters (for mapping CPTOPBP offsets to parameter names)\r\n   */\r\n  private functionParameters: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Global variables (for mapping CPTOPBP positive offsets to global variable names)\r\n   */\r\n  private globalVariables: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Local variables (for mapping CPTOPSP offsets to local variable names)\r\n   * This is a static mapping based on heuristics - kept for backward compatibility\r\n   */\r\n  private localVariables: Map<number, { name: string, dataType: NWScriptDataType }> = new Map();\r\n  \r\n  /**\r\n   * Stack position to variable index mapping (for dynamic stack-aware variable resolution)\r\n   * Key: stack position (absolute), Value: variable index\r\n   * This is set by the converter and used for accurate CPTOPSP resolution\r\n   */\r\n  private variableStackPositions: Map<number, number> = new Map();\r\n  \r\n  /**\r\n   * Local variable initializations (for looking up variable info by index)\r\n   * Set by the converter to provide variable names and types\r\n   */\r\n  private localVariableInits: Array<{ offset: number, dataType: NWScriptDataType, hasInitializer: boolean, initialValue?: number | string | boolean }> = [];\r\n\r\n  /**\r\n   * Track stack state at each instruction address (for debugging/analysis)\r\n   * OPTIMIZATION: Only save snapshots when explicitly requested (e.g., for debugging)\r\n   */\r\n  private stackSnapshots: Map<number, StackItem[]> = new Map();\r\n  private enableSnapshots: boolean = false; // Disabled by default for performance\r\n\r\n  /**\r\n   * Enable or disable stack snapshots (for debugging)\r\n   */\r\n  setSnapshotEnabled(enabled: boolean): void {\r\n    this.enableSnapshots = enabled;\r\n    if (!enabled) {\r\n      this.stackSnapshots.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process an instruction and update the stack state\r\n   */\r\n  processInstruction(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    // OPTIMIZATION: Only save snapshot if snapshots are enabled (for debugging)\r\n    if (this.enableSnapshots) {\r\n      this.saveSnapshot(instruction.address);\r\n    }\r\n\r\n    switch (instruction.code) {\r\n      case OP_CONST:\r\n        return this.handleConst(instruction);\r\n      \r\n      case OP_ADD:\r\n      case OP_SUB:\r\n      case OP_MUL:\r\n      case OP_DIV:\r\n      case OP_MODII:\r\n        return this.handleBinaryOp(instruction);\r\n      \r\n      case OP_EQUAL:\r\n      case OP_NEQUAL:\r\n      case OP_GT:\r\n      case OP_GEQ:\r\n      case OP_LT:\r\n      case OP_LEQ:\r\n        return this.handleComparison(instruction);\r\n      \r\n      case OP_LOGANDII:\r\n      case OP_LOGORII:\r\n      case OP_BOOLANDII:\r\n        return this.handleLogical(instruction);\r\n      \r\n      case OP_INCORII:\r\n      case OP_EXCORII:\r\n        return this.handleBitwise(instruction);\r\n      \r\n      case OP_SHLEFTII:\r\n      case OP_SHRIGHTII:\r\n      case OP_USHRIGHTII:\r\n        return this.handleShiftOp(instruction);\r\n      \r\n      case OP_NEG:\r\n      case OP_COMPI:\r\n      case OP_NOTI:\r\n        return this.handleUnaryOp(instruction);\r\n      \r\n      case OP_ACTION:\r\n        return this.handleAction(instruction);\r\n      \r\n      case OP_CPTOPBP:\r\n      case OP_CPTOPSP:\r\n        return this.handleVariableRead(instruction);\r\n      \r\n      case OP_CPDOWNSP:\r\n        return this.handleLocalWrite(instruction);\r\n      \r\n      case OP_CPDOWNBP:\r\n        return this.handleGlobalWrite(instruction);\r\n      \r\n      case OP_MOVSP:\r\n        this.handleMovsp(instruction);\r\n        return null;\r\n      \r\n      case OP_DESTRUCT:\r\n        this.handleDestruct(instruction);\r\n        return null;\r\n      \r\n      case OP_RSADD:\r\n        this.handleRsadd(instruction);\r\n        return null;\r\n      \r\n      case OP_DECISP:\r\n      case OP_INCISP:\r\n        this.handleLocalIncrement(instruction);\r\n        return null;\r\n      \r\n      case OP_DECIBP:\r\n      case OP_INCIBP:\r\n        this.handleGlobalIncrement(instruction);\r\n        return null;\r\n      \r\n      default:\r\n        // Other instructions don't affect the stack\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle CONST instruction (push constant onto stack)\r\n   */\r\n  private handleConst(instruction: NWScriptInstruction): NWScriptExpression {\r\n    let value: number | string;\r\n    let dataType: NWScriptDataType;\r\n\r\n    switch (instruction.type) {\r\n      case 3: // INTEGER\r\n        value = instruction.integer;\r\n        dataType = NWScriptDataType.INTEGER;\r\n        break;\r\n      case 4: // FLOAT\r\n        value = instruction.float;\r\n        dataType = NWScriptDataType.FLOAT;\r\n        break;\r\n      case 5: // STRING\r\n        value = instruction.string;\r\n        dataType = NWScriptDataType.STRING;\r\n        break;\r\n      case 6: // OBJECT\r\n        value = instruction.object;\r\n        dataType = NWScriptDataType.OBJECT;\r\n        break;\r\n      default:\r\n        value = 0;\r\n        dataType = NWScriptDataType.INTEGER;\r\n    }\r\n\r\n    const expr = NWScriptExpression.constant(value, dataType);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle binary arithmetic operations\r\n   */\r\n  private handleBinaryOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 2) {\r\n      // Not enough operands - create placeholder\r\n      const right = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = this.getBinaryOperator(instruction.code);\r\n      const dataType = this.getResultType(instruction.type);\r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, dataType);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.pop()!;\r\n    const left = this.pop()!;\r\n    const operator = this.getBinaryOperator(instruction.code);\r\n    const dataType = this.getResultType(instruction.type);\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left.expression, right.expression, dataType);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle comparison operations\r\n   */\r\n  private handleComparison(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 2) {\r\n      const right = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = this.getComparisonOperator(instruction.code);\r\n      const expr = NWScriptExpression.comparison(operator, left, right);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.pop()!;\r\n    const left = this.pop()!;\r\n    const operator = this.getComparisonOperator(instruction.code);\r\n    \r\n    const expr = NWScriptExpression.comparison(operator, left.expression, right.expression);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle logical operations\r\n   */\r\n  private handleLogical(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 2) {\r\n      const right = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = this.getLogicalOperator(instruction.code);\r\n      const expr = NWScriptExpression.logical(operator, left, right);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.pop()!;\r\n    const left = this.pop()!;\r\n    const operator = this.getLogicalOperator(instruction.code);\r\n    \r\n    const expr = NWScriptExpression.logical(operator, left.expression, right.expression);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle bitwise operations\r\n   */\r\n  private handleBitwise(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 2) {\r\n      const right = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      const operator = instruction.code === OP_INCORII ? '|' : '^';\r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.pop()!;\r\n    const left = this.pop()!;\r\n    const operator = instruction.code === OP_INCORII ? '|' : '^';\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left.expression, right.expression, NWScriptDataType.INTEGER);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle shift operations\r\n   */\r\n  private handleShiftOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 2) {\r\n      const right = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const left = this.pop()?.expression || NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      \r\n      let operator: string;\r\n      switch (instruction.code) {\r\n        case OP_SHLEFTII: operator = '<<'; break;\r\n        case OP_SHRIGHTII: operator = '>>'; break;\r\n        case OP_USHRIGHTII: operator = '>>>'; break;\r\n        default: operator = '?';\r\n      }\r\n      \r\n      const expr = NWScriptExpression.binaryOp(operator, left, right, NWScriptDataType.INTEGER);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const right = this.pop()!;\r\n    const left = this.pop()!;\r\n    \r\n    let operator: string;\r\n    switch (instruction.code) {\r\n      case OP_SHLEFTII: operator = '<<'; break;\r\n      case OP_SHRIGHTII: operator = '>>'; break;\r\n      case OP_USHRIGHTII: operator = '>>>'; break;\r\n      default: operator = '?';\r\n    }\r\n    \r\n    const expr = NWScriptExpression.binaryOp(operator, left.expression, right.expression, NWScriptDataType.INTEGER);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle unary operations\r\n   */\r\n  private handleUnaryOp(instruction: NWScriptInstruction): NWScriptExpression {\r\n    if (this.stack.length < 1) {\r\n      const operand = NWScriptExpression.constant(0, NWScriptDataType.INTEGER);\r\n      const operator = this.getUnaryOperator(instruction.code);\r\n      const dataType = instruction.type === 0x03 ? NWScriptDataType.INTEGER : NWScriptDataType.FLOAT;\r\n      const expr = NWScriptExpression.unaryOp(operator, operand, dataType);\r\n      this.push(expr, instruction.address);\r\n      return expr;\r\n    }\r\n\r\n    const item = this.pop()!;\r\n    const operator = this.getUnaryOperator(instruction.code);\r\n    const dataType = instruction.type === 0x03 ? NWScriptDataType.INTEGER : NWScriptDataType.FLOAT;\r\n    \r\n    const expr = NWScriptExpression.unaryOp(operator, item.expression, dataType);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle ACTION (function call)\r\n   */\r\n  private handleAction(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    if (!instruction.actionDefinition) {\r\n      return null;\r\n    }\r\n\r\n    const actionDef = instruction.actionDefinition;\r\n    const argCount = instruction.argCount || 0;\r\n    const args: NWScriptExpression[] = [];\r\n\r\n    // Pop arguments from stack\r\n    // In NWScript, arguments appear to be pushed in forward order (first arg first)\r\n    // So when we pop them, we get them in reverse order (last arg first)\r\n    // We use push to collect them, then reverse to get correct order\r\n    for (let i = 0; i < argCount && this.stack.length > 0; i++) {\r\n      const item = this.pop();\r\n      if (item) {\r\n        args.unshift(item.expression); // unshift to maintain correct order\r\n      }\r\n    }\r\n    \r\n    // Reverse to get correct argument order (first arg first)\r\n    args.reverse();\r\n\r\n    const functionName = actionDef.name || `Action_${instruction.action}`;\r\n    const returnType = actionDef.type || NWScriptDataType.VOID;\r\n    \r\n    const expr = NWScriptExpression.functionCall(functionName, args, returnType);\r\n    \r\n    // Push return value if not void\r\n    if (returnType !== NWScriptDataType.VOID) {\r\n      this.push(expr, instruction.address);\r\n    }\r\n    \r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle variable read (CPTOPBP/CPTOPSP)\r\n   */\r\n  private handleVariableRead(instruction: NWScriptInstruction): NWScriptExpression {\r\n    const isGlobal = instruction.code === OP_CPTOPBP;\r\n    let varName: string;\r\n    let dataType: NWScriptDataType;\r\n    \r\n    if (isGlobal && instruction.offset !== undefined) {\r\n      // Check if this is a function parameter (negative offset)\r\n      const offset = instruction.offset;\r\n      const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n      \r\n      if (offsetSigned < 0 && this.functionParameters.has(offsetSigned)) {\r\n        // This is a function parameter (negative offset relative to BP)\r\n        const param = this.functionParameters.get(offsetSigned)!;\r\n        varName = param.name;\r\n        dataType = param.dataType;\r\n      } else if (offsetSigned < 0 && this.globalVariables.has(offsetSigned)) {\r\n        // This is a global variable (negative offset relative to BP)\r\n        // ALL stack offsets are negative - we're always looking down from the top\r\n        const globalVar = this.globalVariables.get(offsetSigned)!;\r\n        varName = globalVar.name;\r\n        dataType = globalVar.dataType;\r\n      } else {\r\n        // Unknown - generate a generic name\r\n        varName = this.generateVariableName(true, offset);\r\n        dataType = NWScriptDataType.INTEGER; // Default, could be improved\r\n      }\r\n    } else {\r\n      // Local variable (CPTOPSP)\r\n      // CRITICAL: CPTOPSP reads from stack[SP + offset] where SP is the CURRENT stack pointer\r\n      // We should resolve this dynamically using the actual stack state, not static offsets\r\n      const offset = instruction.offset || 0;\r\n      const offsetSigned = offset > 0x7FFFFFFF ? offset - 0x100000000 : offset;\r\n      \r\n      // Calculate the actual stack position this instruction reads from\r\n      const sourceStackPos = this.stackPointer + offsetSigned;\r\n      \r\n      // First, try to resolve using the dynamic stack position map (stack-aware)\r\n      const varIndex = this.variableStackPositions.get(sourceStackPos);\r\n      if (varIndex !== undefined && this.localVariableInits[varIndex]) {\r\n        // Found variable using stack-aware resolution\r\n        const init = this.localVariableInits[varIndex];\r\n        varName = `localVar_${varIndex}`;\r\n        dataType = init.dataType;\r\n      } else {\r\n        // Stack-aware fallback: Check all variable positions with tolerance\r\n        // The stack may have grown between RSADD and CPTOPSP, so check all recorded positions\r\n        let foundVar = false;\r\n        for (const [varPos, idx] of this.variableStackPositions.entries()) {\r\n          const distance = Math.abs(sourceStackPos - varPos);\r\n          // Allow tolerance (8 bytes) since the stack may have grown\r\n          if (distance <= 8 && this.localVariableInits[idx]) {\r\n            const init = this.localVariableInits[idx];\r\n            varName = `localVar_${idx}`;\r\n            dataType = init.dataType;\r\n            foundVar = true;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (!foundVar) {\r\n          // Last resort: Fallback to static offset-based mapping (for backward compatibility)\r\n          // This should rarely be needed if stack-aware tracking is working correctly\r\n          const offsetUnsigned = offset < 0 ? offset + 0x100000000 : offset;\r\n          if (this.localVariables.has(offsetUnsigned)) {\r\n            // Use mapped local variable name from static mapping\r\n            const localVar = this.localVariables.get(offsetUnsigned)!;\r\n            varName = localVar.name;\r\n            dataType = localVar.dataType;\r\n          } else {\r\n            // Generate a generic name as absolute last resort\r\n            varName = this.generateVariableName(false, offset);\r\n            dataType = NWScriptDataType.INTEGER; // Default, could be improved\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    const expr = NWScriptExpression.variable(varName, dataType, isGlobal);\r\n    this.push(expr, instruction.address);\r\n    return expr;\r\n  }\r\n\r\n  /**\r\n   * Handle local variable write (CPDOWNSP)\r\n   */\r\n  private handleLocalWrite(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    if (this.stack.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // CPDOWNSP copies from top of stack to a location down the stack\r\n    // The value remains on the stack\r\n    const topItem = this.peek();\r\n    if (topItem) {\r\n      // The value is written to stack[SP + offset]\r\n      // For now, we just keep the value on the stack\r\n      // The actual write is tracked by NWScriptVariableTracker\r\n      return topItem.expression;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Handle global variable write (CPDOWNBP)\r\n   */\r\n  private handleGlobalWrite(instruction: NWScriptInstruction): NWScriptExpression | null {\r\n    if (this.stack.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // CPDOWNBP copies from top of stack to a global variable\r\n    // The value remains on the stack\r\n    const topItem = this.peek();\r\n    if (topItem) {\r\n      // The actual write is tracked by NWScriptVariableTracker\r\n      return topItem.expression;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Handle MOVSP (move stack pointer)\r\n   */\r\n  private handleMovsp(instruction: NWScriptInstruction): void {\r\n    const offset = instruction.offset || 0;\r\n    \r\n    if (offset > 0) {\r\n      // Positive offset: remove items from stack (cleanup)\r\n      const count = Math.floor(offset / 4); // Each item is 4 bytes\r\n      for (let i = 0; i < count && this.stack.length > 0; i++) {\r\n        this.pop();\r\n      }\r\n    } else if (offset < 0) {\r\n      // Negative offset: reserve space (add empty slots)\r\n      // This is typically for variable declarations\r\n      const count = Math.floor(-offset / 4);\r\n      // We don't add actual items, just track the space\r\n      // The stack pointer effectively moves, but we track it via stackPointer\r\n    }\r\n    \r\n    // Update stack pointer\r\n    this.stackPointer += offset;\r\n  }\r\n\r\n  /**\r\n   * Handle DESTRUCT (destructure operation)\r\n   * \r\n   * DESTRUCT removes sizeToDestroy bytes from the top of the stack,\r\n   * but saves sizeOfElementToSave bytes starting at offsetToSaveElement\r\n   * from the start of that region. The saved element(s) remain on the stack.\r\n   * \r\n   * SP is decremented by sizeToDestroy\r\n   */\r\n  private handleDestruct(instruction: NWScriptInstruction): void {\r\n    const sizeToDestroy = instruction.sizeToDestroy || 0;\r\n    const offsetToSaveElement = instruction.offsetToSaveElement || 0;\r\n    const sizeOfElementToSave = instruction.sizeOfElementToSave || 0;\r\n    \r\n    // Convert bytes to number of items (each item is 4 bytes)\r\n    const totalItemsToRemove = Math.floor(sizeToDestroy / 4);\r\n    const offsetItems = Math.floor(offsetToSaveElement / 4);\r\n    const itemsToSave = Math.floor(sizeOfElementToSave / 4);\r\n    \r\n    if (totalItemsToRemove === 0 || this.stack.length === 0) {\r\n      log.warn('DESTRUCT', sizeToDestroy, offsetToSaveElement, sizeOfElementToSave, this.stack.length);\r\n      // Nothing to remove, but still update stack pointer\r\n      return;\r\n    }\r\n    \r\n    const saveStartFromTop = offsetItems;\r\n    const saveEndFromTop = saveStartFromTop + itemsToSave;\r\n    \r\n    const savedItems: StackItem[] = [];\r\n    if (itemsToSave > 0 && this.stack.length >= saveEndFromTop) {\r\n      const saveStartIndex = this.stack.length - saveEndFromTop;\r\n      const saveEndIndex = this.stack.length - saveStartFromTop;\r\n      \r\n      // This preserves the relative order when pushed back\r\n      for (let i = saveStartIndex; i < saveEndIndex; i++) {\r\n        savedItems.push(this.stack[i]);\r\n      }\r\n    }\r\n    \r\n    // Remove the entire region from the top (pop totalItemsToRemove items)\r\n    // This decreases stackPointer by sizeToDestroy\r\n    for (let i = 0; i < totalItemsToRemove && this.stack.length > 0; i++) {\r\n      this.pop();\r\n    }\r\n    \r\n    // Push the saved items back onto the stack\r\n    // This increases stackPointer by sizeOfElementToSave\r\n    for (const item of savedItems) {\r\n      this.push(item.expression, item.address);\r\n    }\r\n\r\n    this.stackPointer -= sizeToDestroy;\r\n  }\r\n\r\n  /**\r\n   * Handle RSADD (reserve space on stack)\r\n   */\r\n  private handleRsadd(instruction: NWScriptInstruction): void {\r\n    // RSADD actually pushes a default value onto the stack (0, 0.0, '', etc.)\r\n    // This matches the runtime behavior where RSADD pushes a value\r\n    // The variable will live at this stack position\r\n    \r\n    // Determine the default value based on instruction type\r\n    let defaultValue: number | string | undefined;\r\n    let dataType: NWScriptDataType;\r\n    \r\n    switch (instruction.type) {\r\n      case 3: // INTEGER\r\n        defaultValue = 0;\r\n        dataType = NWScriptDataType.INTEGER;\r\n        break;\r\n      case 4: // FLOAT\r\n        defaultValue = 0.0;\r\n        dataType = NWScriptDataType.FLOAT;\r\n        break;\r\n      case 5: // STRING\r\n        defaultValue = '';\r\n        dataType = NWScriptDataType.STRING;\r\n        break;\r\n      case 6: // OBJECT\r\n        defaultValue = undefined;\r\n        dataType = NWScriptDataType.OBJECT;\r\n        break;\r\n      case 16: // EFFECT\r\n        defaultValue = undefined;\r\n        dataType = NWScriptDataType.EFFECT;\r\n        break;\r\n      case 17: // EVENT\r\n        defaultValue = undefined;\r\n        dataType = NWScriptDataType.EVENT;\r\n        break;\r\n      case 18: // LOCATION\r\n        defaultValue = undefined;\r\n        dataType = NWScriptDataType.LOCATION;\r\n        break;\r\n      case 19: // TALENT\r\n        defaultValue = undefined;\r\n        dataType = NWScriptDataType.TALENT;\r\n        break;\r\n      default:\r\n        // Default to integer\r\n        defaultValue = 0;\r\n        dataType = NWScriptDataType.INTEGER;\r\n        break;\r\n    }\r\n    \r\n    // Push the default value onto the stack\r\n    // This creates a stack item that represents the variable's initial value\r\n    const expr = NWScriptExpression.constant(defaultValue, dataType);\r\n    this.push(expr, instruction.address);\r\n  }\r\n\r\n  /**\r\n   * Handle local variable increment/decrement\r\n   */\r\n  private handleLocalIncrement(instruction: NWScriptInstruction): void {\r\n    // DECISP/INCISP modify a local variable\r\n    // They don't directly affect the stack, but the variable tracker handles this\r\n  }\r\n\r\n  /**\r\n   * Handle global variable increment/decrement\r\n   */\r\n  private handleGlobalIncrement(instruction: NWScriptInstruction): void {\r\n    // DECIBP/INCIBP modify a global variable\r\n    // They don't directly affect the stack, but the variable tracker handles this\r\n  }\r\n\r\n  /**\r\n   * Push an expression onto the stack\r\n   */\r\n  push(expression: NWScriptExpression, address: number): void {\r\n    this.stack.push({ expression, address });\r\n    this.stackPointer += 4; // Each item is 4 bytes\r\n  }\r\n\r\n  /**\r\n   * Pop an expression from the stack\r\n   */\r\n  pop(): StackItem | null {\r\n    if (this.stack.length === 0) {\r\n      return null;\r\n    }\r\n    const item = this.stack.pop()!;\r\n    this.stackPointer -= 4;\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Peek at the top of the stack without popping\r\n   */\r\n  peek(): StackItem | null {\r\n    if (this.stack.length === 0) {\r\n      return null;\r\n    }\r\n    return this.stack[this.stack.length - 1];\r\n  }\r\n\r\n  /**\r\n   * Get the current stack size (number of items)\r\n   */\r\n  getStackSize(): number {\r\n    return this.stack.length;\r\n  }\r\n\r\n  /**\r\n   * Get the current stack pointer value\r\n   */\r\n  getStackPointer(): number {\r\n    return this.stackPointer;\r\n  }\r\n  \r\n  /**\r\n   * Get global variables map (for passing to other components)\r\n   */\r\n  getGlobalVariables(): Map<number, { name: string, dataType: NWScriptDataType }> {\r\n    return this.globalVariables;\r\n  }\r\n  \r\n  /**\r\n   * Get local variables map (for passing to other components)\r\n   */\r\n  getLocalVariables(): Map<number, { name: string, dataType: NWScriptDataType }> {\r\n    return this.localVariables;\r\n  }\r\n\r\n  /**\r\n   * Get the current base pointer value\r\n   */\r\n  getBasePointer(): number {\r\n    return this.basePointer;\r\n  }\r\n\r\n  /**\r\n   * Set the base pointer\r\n   */\r\n  setBasePointer(bp: number): void {\r\n    this.basePointer = bp;\r\n  }\r\n\r\n  /**\r\n   * Clear the stack\r\n   */\r\n  clear(): void {\r\n    this.stack = [];\r\n    this.stackPointer = 0;\r\n    this.basePointer = 0;\r\n    this.stackSnapshots.clear();\r\n    this.functionParameters.clear();\r\n  }\r\n\r\n  /**\r\n   * Set function parameters for parameter name mapping\r\n   */\r\n  setFunctionParameters(parameters: NWScriptFunctionParameter[]): void {\r\n    this.functionParameters.clear();\r\n    for (const param of parameters) {\r\n      this.functionParameters.set(param.offset, { name: param.name, dataType: param.dataType });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Set global variables for variable name mapping\r\n   * Maps BP offsets (positive) to global variable names\r\n   */\r\n  setGlobalVariables(globalVars: Map<number, { name: string, dataType: NWScriptDataType }>): void {\r\n    this.globalVariables = globalVars;\r\n  }\r\n  \r\n  /**\r\n   * Set local variables for variable name mapping\r\n   * Maps SP offsets to local variable names\r\n   */\r\n  setLocalVariables(localVars: Map<number, { name: string, dataType: NWScriptDataType }>): void {\r\n    this.localVariables = localVars;\r\n  }\r\n  \r\n  /**\r\n   * Set the stack position to variable index mapping for dynamic variable resolution\r\n   * This allows CPTOPSP to resolve variables based on actual stack state, not static offsets\r\n   */\r\n  setVariableStackPositions(positions: Map<number, number>): void {\r\n    this.variableStackPositions = positions;\r\n  }\r\n  \r\n  /**\r\n   * Set local variable initializations for variable info lookup\r\n   */\r\n  setLocalVariableInits(inits: Array<{ offset: number, dataType: NWScriptDataType, hasInitializer: boolean, initialValue?: number | string | boolean }>): void {\r\n    this.localVariableInits = inits;\r\n  }\r\n\r\n  /**\r\n   * Save a snapshot of the stack state\r\n   */\r\n  private saveSnapshot(address: number): void {\r\n    // Deep copy the stack\r\n    this.stackSnapshots.set(address, this.stack.map(item => ({ ...item })));\r\n  }\r\n\r\n  /**\r\n   * Get a stack snapshot at a specific address\r\n   */\r\n  getSnapshot(address: number): StackItem[] | null {\r\n    return this.stackSnapshots.get(address) || null;\r\n  }\r\n\r\n  /**\r\n   * Get binary operator string\r\n   */\r\n  private getBinaryOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_ADD: return '+';\r\n      case OP_SUB: return '-';\r\n      case OP_MUL: return '*';\r\n      case OP_DIV: return '/';\r\n      case OP_MODII: return '%';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get comparison operator string\r\n   */\r\n  private getComparisonOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_EQUAL: return '==';\r\n      case OP_NEQUAL: return '!=';\r\n      case OP_GT: return '>';\r\n      case OP_GEQ: return '>=';\r\n      case OP_LT: return '<';\r\n      case OP_LEQ: return '<=';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get logical operator string\r\n   */\r\n  private getLogicalOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_LOGANDII: return '&&';\r\n      case OP_LOGORII: return '||';\r\n      case OP_BOOLANDII: return '&&';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get unary operator string\r\n   */\r\n  private getUnaryOperator(opCode: number): string {\r\n    switch (opCode) {\r\n      case OP_NEG: return '-';\r\n      case OP_COMPI: return '~';\r\n      case OP_NOTI: return '!';\r\n      default: return '?';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get result data type from instruction type\r\n   */\r\n  private getResultType(type: number): NWScriptDataType {\r\n    switch (type) {\r\n      case 3: return NWScriptDataType.INTEGER;\r\n      case 4: return NWScriptDataType.FLOAT;\r\n      case 5: return NWScriptDataType.STRING;\r\n      case 6: return NWScriptDataType.OBJECT;\r\n      default: return NWScriptDataType.INTEGER;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a variable name\r\n   */\r\n  private generateVariableName(isGlobal: boolean, offset: number): string {\r\n    if (isGlobal) {\r\n      return `g_var_${offset}`;\r\n    } else {\r\n      return `var_${offset}`;\r\n    }\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\odyssey\\OdysseyModelAnimation.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type `any[]` to a variable of type `IOdysseyAnimationEvent[]`.","line":75,"column":5,"nodeType":"AssignmentExpression","messageId":"unsafeAssignment","endLine":75,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\n\r\nimport { IOdysseyAnimationEvent } from '@/interface/odyssey/IOdysseyAnimationEvent';\r\nimport { ITwoDAAnimation } from \"@/interface/twoDA/ITwoDAAnimation\";\r\nimport { TwoDAManager } from \"@/managers/TwoDAManager\";\nimport type { OdysseyModel } from '@/odyssey/OdysseyModel';\r\nimport { OdysseyModelAnimationNode } from '@/odyssey/OdysseyModelAnimationNode';\r\nimport { OdysseyModelUtility } from '@/odyssey/OdysseyModelUtility';\n\r\n\r\n/**\r\n * OdysseyModelAnimation class.\r\n * \r\n * The OdysseyModelAnimation class holds the values used in animations.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyModelAnimation.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class OdysseyModelAnimation {\r\n  _position: THREE.Vector3 = new THREE.Vector3();\r\n  _quaternion: THREE.Quaternion = new THREE.Quaternion();\r\n  functionPointer0: number;\r\n  functionPointer1: number;\r\n  name: string;\r\n  rootNodeOffset: number;\r\n  nodeCount: number;\r\n  refCount: number;\r\n  geometryType: number;\r\n  unknown4: Uint8Array;\r\n  length: number;\r\n  transition: number;\r\n  modelName: string;\r\n  events: IOdysseyAnimationEvent[] = [];\r\n  nodes: OdysseyModelAnimationNode[] = [];\r\n  rootNode: OdysseyModelAnimationNode;\r\n  type: string;\r\n  \r\n  odysseyModel: OdysseyModel;\r\n\r\n  constructor(){\r\n    this.type = 'OdysseyModelAnimation';\r\n    this.rootNode = new OdysseyModelAnimationNode();\r\n\r\n    this._position = new THREE.Vector3();\r\n    this._quaternion = new THREE.Quaternion();\r\n  }\r\n\r\n  readBinary(odysseyModel: OdysseyModel){\r\n    this.odysseyModel = odysseyModel;\r\n\r\n    //GeometryHeader\r\n    this.functionPointer0 = this.odysseyModel.mdlReader.readUInt32(); //4Byte Function pointer\r\n    this.functionPointer1 = this.odysseyModel.mdlReader.readUInt32(); //4Byte Function pointer\r\n\r\n    this.name = this.odysseyModel.mdlReader.readChars(32).replace(/\\0[\\s\\S]*$/g,'');\r\n    this.rootNodeOffset = this.odysseyModel.mdlReader.readUInt32();\r\n    this.nodeCount = this.odysseyModel.mdlReader.readUInt32();\r\n\r\n    this.odysseyModel.mdlReader.skip(24); //Skip unknown array definitions\r\n\r\n    this.refCount = this.odysseyModel.mdlReader.readUInt32();\r\n    this.geometryType = this.odysseyModel.mdlReader.readByte(); //Model Type\r\n    this.unknown4 = this.odysseyModel.mdlReader.readBytes(3); //Padding\r\n\r\n    //Animation\r\n    this.length = this.odysseyModel.mdlReader.readSingle();\r\n    this.transition = this.odysseyModel.mdlReader.readSingle();\r\n    this.modelName = this.odysseyModel.mdlReader.readChars(32).replace(/\\0[\\s\\S]*$/g,'').toLowerCase();\r\n\r\n    const _eventsDef = OdysseyModelUtility.ReadArrayDefinition(this.odysseyModel.mdlReader);\r\n    //anim.events = OdysseyModelUtility.ReadArrayFloats(this.mdlReader, this.fileHeader.ModelDataOffset + _eventsDef.offset, _eventsDef.count);\r\n    this.events = new Array(_eventsDef.count);\r\n    this.odysseyModel.mdlReader.skip(4); //Unknown uint32\r\n\r\n    if (_eventsDef.count > 0) {\r\n      this.odysseyModel.mdlReader.seek(this.odysseyModel.fileHeader.modelDataOffset + _eventsDef.offset);\r\n      for (let i = 0; i < _eventsDef.count; i++) {\r\n        this.events[i] = { \r\n          length: this.odysseyModel.mdlReader.readSingle(), \r\n          name: this.odysseyModel.mdlReader.readChars(32).replace(/\\0[\\s\\S]*$/g,'') \r\n        };\r\n      }\r\n    }\r\n\r\n    //Animation Node\r\n    this.nodes = [];\r\n    this.rootNode = this.readAnimationNode(this.odysseyModel.fileHeader.modelDataOffset + this.rootNodeOffset);\r\n\r\n  }\r\n\r\n  readAnimationNode(offset: number){\r\n    this.odysseyModel.mdlReader.seek(offset);\r\n\r\n    const node = new OdysseyModelAnimationNode(this);\r\n    node.readBinary(this.odysseyModel);\r\n    this.nodes.push(node);\r\n\r\n    //Child Animation Nodes\r\n    const len = node.childOffsets.length;\r\n    for (let i = 0; i < len; i++) {\r\n      node.children.push(\r\n        this.readAnimationNode( this.odysseyModel.fileHeader.modelDataOffset + node.childOffsets[i] )\r\n      );\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /** Shape accepted by From() for cloning an animation (e.g. from another OdysseyModelAnimation). */\r\n  static From(original: {\r\n    rootNode: OdysseyModelAnimationNode;\r\n    nodes: OdysseyModelAnimationNode[];\r\n    ModelName?: string;\r\n    events?: IOdysseyAnimationEvent[];\r\n    name?: string;\r\n    length?: number;\r\n    transition?: number;\r\n  }): OdysseyModelAnimation {\r\n    const anim = new OdysseyModelAnimation();\r\n    anim.rootNode = original.rootNode;\r\n    anim.nodes = original.nodes ?? [];\r\n    anim.modelName = original.ModelName ?? '';\r\n    anim.events = original.events ?? [];\r\n    anim.name = (original.name ?? '').toLowerCase().trim() || '';\r\n    anim.length = original.length ?? 0;\r\n    anim.transition = original.transition ?? 0;\r\n\r\n    return anim;\r\n  }\r\n\r\n  getDamageDelay(){\r\n    for(let i = 0, len = this.events.length; i < len; i++){\r\n      if(this.events[i].name == 'Hit'){\r\n        return this.events[i].length;\r\n      }\r\n    }\r\n    return 0.5;\r\n  }\r\n\r\n  static GetAnimation2DA(name = ''): ITwoDAAnimation | undefined {\r\n    const animations2DA = TwoDAManager.datatables.get('animations');\r\n    if (animations2DA) {\r\n      const key = name.toLowerCase();\r\n      for (let i = 0, len = animations2DA.RowCount; i < len; i++) {\r\n        const row = animations2DA.getRow(i);\r\n        if (row && row.getString('name').toLowerCase() === key) {\r\n          return {\r\n            name: row.getString('name'),\r\n            stationary: row.getString('stationary'),\r\n            pause: row.getString('pause'),\r\n            walking: row.getString('walking'),\r\n            looping: row.getString('looping'),\r\n            running: row.getString('running'),\r\n            fireforget: row.getString('fireforget'),\r\n            overlay: row.getString('overlay'),\r\n            playoutofplace: row.getString('playoutofplace'),\r\n            dialog: row.getString('dialog'),\r\n            damage: row.getString('damage'),\r\n            parry: row.getString('parry'),\r\n            dodge: row.getString('dodge'),\r\n            attack: row.getString('attack'),\r\n            hideequippeditems: row.getString('hideequippeditems'),\r\n          };\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\odyssey\\OdysseyModelUtility.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type `any[]` to a variable of type `number[]`.","line":22,"column":11,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":22,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type `any[]` to a variable of type `number[]`.","line":35,"column":11,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":35,"endColumn":46}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SurfaceMaterial } from \"@/engine/SurfaceMaterial\";\r\nimport { IOdysseyArrayDefinition } from \"@/interface/odyssey/IOdysseyArrayDefinition\";\r\nimport { BinaryReader } from \"@/utility/binary/BinaryReader\";\r\n\r\n/**\r\n * OdysseyModelUtility class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyModelUtility.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class OdysseyModelUtility {\r\n  \r\n  static SURFACEMATERIALS: SurfaceMaterial[] = [];\r\n\r\n  static ReadArray(stream: BinaryReader, offset: number, count: number){\r\n    const posCache = stream.position;\r\n    stream.position = offset;\r\n\r\n    const values: number[] = new Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n      values[i] = stream.readUInt32();\r\n    }\r\n\r\n    stream.position = posCache;\r\n    return values;\r\n  }\r\n\r\n  static ReadArrayFloats(stream: BinaryReader, offset: number, count: number){\r\n    const posCache = stream.position;\r\n    stream.position = offset;\r\n\r\n    const values: number[] = new Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n      values[i] = stream.readSingle();\r\n    }\r\n\r\n    stream.position = posCache;\r\n    return values;\r\n  }\r\n\r\n  //Gets the Array Offset & Length\r\n  static ReadArrayDefinition(stream: BinaryReader): IOdysseyArrayDefinition {\r\n    return {\r\n      offset: stream.readUInt32() & 0xFFFFFFFF, \r\n      count: stream.readUInt32() & 0xFFFFFFFF, \r\n      count2: stream.readUInt32() & 0xFFFFFFFF\r\n    };\r\n  }\r\n\r\n  static ReadStrings(stream: BinaryReader, offsets: number[], offset: number) {\r\n    const posCache = stream.position;\r\n    const strings: string[] = [];\r\n\r\n    for (let i = 0; i < offsets.length; i++){\r\n      stream.position = offset + offsets[i];\r\n\r\n      let str = \"\";\r\n      let char;\r\n\r\n      while ((char = stream.readChar()).charCodeAt(0) != 0)\r\n        str = str + char;\r\n\r\n      strings[i] = str;\r\n    }\r\n\r\n    stream.position = posCache;\r\n    return strings;\r\n  }\r\n  \r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\odyssey\\WalkmeshPerimeter.ts","messages":[{"ruleId":"@typescript-eslint/no-useless-constructor","severity":2,"message":"Useless constructor.","line":18,"column":3,"nodeType":"MethodDefinition","messageId":"noUselessConstructor","endLine":20,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WalkmeshEdge } from \"@/odyssey/WalkmeshEdge\";\r\n\r\n/**\r\n * WalkmeshPerimeter class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file WalkmeshPerimeter.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class WalkmeshPerimeter {\r\n  closed: boolean = false;\r\n  start: number = -1;\r\n  next: number = -1;\r\n  edges: WalkmeshEdge[] = [];\r\n\r\n  constructor(){\r\n\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\resource\\BIKObject.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `PixelFormat`.","line":194,"column":73,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":194,"endColumn":94},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `PixelFormat`.","line":195,"column":77,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":195,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `PixelFormat`.","line":196,"column":77,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":196,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":268,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":268,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":285,"column":11,"nodeType":"MemberExpression","messageId":"errorCall","endLine":285,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":326,"column":29,"nodeType":"MemberExpression","messageId":"errorCall","endLine":326,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":329,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":329,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":329,"column":28,"nodeType":"MemberExpression","messageId":"errorCall","endLine":329,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":330,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":330,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":331,"column":24,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":331,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":331,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":331,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `BIKVideoFrameData`.","line":332,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":332,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":332,"column":40,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":332,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":337,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":337,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":337,"column":28,"nodeType":"MemberExpression","messageId":"errorCall","endLine":337,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":338,"column":17,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":338,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":339,"column":36,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":339,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":340,"column":79,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":340,"endColumn":85},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":342,"column":24,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":342,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":342,"column":37,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":342,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `Uint8Array<ArrayBufferLike>`.","line":345,"column":35,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":345,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .frames on a type that cannot be resolved.","line":345,"column":42,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":345,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on a type that cannot be resolved.","line":376,"column":33,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":376,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":498,"column":7,"nodeType":"MemberExpression","messageId":"errorCall","endLine":498,"endColumn":22}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\nimport { AudioEngine } from \"@/audio/AudioEngine\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\nconst log = createScopedLogger(LogScope.Resource);\nimport { AudioEngineChannel } from \"@/enums/audio/AudioEngineChannel\";\n\n/**\n * BIKObject class.\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file BIKObject.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\n/** Video frame data passed to updateFrame (e.g. from WebCodecs VideoFrame). */\nexport interface BIKVideoFrameData {\n  linesize: number[];\n  data: ArrayBuffer[];\n}\n\nexport class BIKObject {\n  abs_path: boolean;\n  frames: unknown[];\n  frameIndex: number;\n  width: number;\n  height: number;\n  fps: number;\n  yTex: THREE.DataTexture | undefined;\n  uTex: THREE.DataTexture | undefined;\n  vTex: THREE.DataTexture | undefined;\n  min_buffer: number;\n  max_buffer: number;\n  geometry: THREE.BufferGeometry;\n  material: THREE.ShaderMaterial;\n  videoPlane: THREE.Object3D | undefined;\n  backPlane: THREE.Object3D | undefined;\n  scene: THREE.Scene | undefined;\n  audio_array: AudioBuffer[];\n  audio_nodes: unknown[];\n  frame_array: BIKVideoFrameData[];\n  file: string;\n  audioCtx: AudioContext | undefined;\n  onComplete: (() => void) | undefined;\n  decode_complete: boolean;\n  demuxer: unknown;\n  video_decoder: unknown;\n  hasAudio: boolean;\n  audio_decoder: unknown;\n  audio: { playback_rate: number; channels: number };\n  nextAudioTime: number;\n  playbackPosition: number;\n  timer: number;\n  needsRenderUpdate: boolean;\n  isPlaying: boolean;\n  nextPacket: unknown;\n  disposed: boolean;\n\n  constructor(args: { abs_path?: boolean } = {}) {\n\n    args = Object.assign({\n      abs_path: false\n    }, args);\n\n    this.abs_path = args.abs_path;\n\n    this.frames = [];\n    this.frameIndex = 0;\n\n    this.width = 640;\n    this.height = 480;\n    this.fps = 29.97;\n\n    this.yTex = undefined;\n    this.uTex = undefined;\n    this.vTex = undefined;\n\n    this.min_buffer = 10;\n    this.max_buffer = 20;\n\n    this.geometry = new THREE.PlaneGeometry(1, 1, 1, 1);\n    this.material = new THREE.RawShaderMaterial({\n      vertexShader: `\n        precision highp float;\n        uniform mat4 modelViewMatrix; // optional\n        uniform mat4 projectionMatrix; // optional\n        attribute vec3 position;\n        attribute vec4 color;\n        attribute vec2 uv;\n        varying vec2 v_texCoord;\n        varying mat3 trans;\n        void main()\t{\n          v_texCoord = vec2(uv.x, 1.0 - uv.y);\n          trans = mat3(\n            1.0, 1.0, 1.0,\n            0.0, -0.34414, 1.772,\n            1.402, -0.71414, 0.0\n          );\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n      `,\n      fragmentShader: `\n        precision highp float;\n\n        varying vec2 v_texCoord;\n        uniform sampler2D yTex;\n        uniform sampler2D uTex;\n        uniform sampler2D vTex;\n\n        //https://www.roxlu.com/2014/039/decoding-h264-and-yuv420p-playback\n\n        void main() {\n          vec3 R_cf = vec3(1.164383,  0.000000,  1.596027);\n          vec3 G_cf = vec3(1.164383, -0.391762, -0.812968);\n          vec3 B_cf = vec3(1.164383,  2.017232,  0.000000);\n          vec3 offset = vec3(-0.0625, -0.5, -0.5);\n\n          float y = texture2D(yTex, v_texCoord).r;\n          float u = texture2D(uTex, v_texCoord).r;\n          float v = texture2D(vTex, v_texCoord).r;\n          vec3 yuv = vec3(y,u,v);\n          yuv += offset;\n          vec4 fragcolor = vec4(0.0, 0.0, 0.0, 1.0);\n          fragcolor.r = dot(yuv, R_cf);\n          fragcolor.g = dot(yuv, G_cf);\n          fragcolor.b = dot(yuv, B_cf);\n          gl_FragColor = fragcolor;\n        }\n\n\n      `,\n      uniforms: {\n        yTex: { value: this.yTex },\n        uTex: { value: this.uTex },\n        vTex: { value: this.vTex },\n      }\n    });\n\n    this.videoPlane = new THREE.Mesh(this.geometry, this.material);\n    this.videoPlane.position.z = 100;\n\n    this.backPlane = new THREE.Mesh(\n      new THREE.PlaneGeometry(1, 1, 1, 1),\n      new THREE.MeshBasicMaterial({ color: 0x000000 })\n    );\n\n    this.scene = new THREE.Scene();\n    this.scene.add(this.backPlane);\n    this.scene.add(this.videoPlane);\n\n    this.videoPlane.position.z = 99;\n    this.resize();\n\n    this.audio_array = [];\n    this.audio_nodes = [];\n    this.frame_array = [];\n\n  }\n\n  resize(width?: number, height?: number){\n\n    if(!width)\n      width = window.innerWidth;\n\n    if(!height)\n      height = window.innerHeight;\n\n    this.videoPlane.scale.x = this.width * (width / this.width);\n    this.videoPlane.scale.y = this.height * (width / this.width);\n\n    this.backPlane.scale.x = width;\n    this.backPlane.scale.y = height;\n  }\n\n  initVideoTexture(){\n    const yBuffer = new Uint8Array(this.width * this.height);\n    const uBuffer = new Uint8Array(this.width/2 * this.height/2);\n    const vBuffer = new Uint8Array(this.width/2 * this.height/2);\n\n    uBuffer.fill(128);\n    vBuffer.fill(128);\n\n    if(this.yTex)\n      this.yTex.dispose()\n\n    if(this.uTex)\n      this.uTex.dispose()\n\n    if(this.vTex)\n      this.vTex.dispose()\n\n    this.yTex = new THREE.DataTexture(yBuffer, this.width, this.height, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter);\n    this.uTex = new THREE.DataTexture(uBuffer, this.width/2, this.height/2, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter);\n    this.vTex = new THREE.DataTexture(vBuffer, this.width/2, this.height/2, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter);\n\n    this.material.uniforms.yTex.value = this.yTex;\n    this.material.uniforms.uTex.value = this.uTex;\n    this.material.uniforms.vTex.value = this.vTex;\n\n    this.yTex.needsUpdate = true;\n    this.uTex.needsUpdate = true;\n    this.vTex.needsUpdate = true;\n\n    this.material.uniformsNeedsUpdate = true;\n  }\n\n  async play(file: string = '', onComplete?: () => void) {\n    return;\n    // Beamcoder has been removed from the project.\n    // I plan on writing a bink decoder at some point,\n    // which will be more lightweight than the beamcoder library was.\n\n    // this.file = file;\n\n    // let _path = this.abs_path ? this.file : path.join('Movies', this.file);\n\n    // this.audioCtx = AudioEngine.GetAudioEngine().audioCtx;\n    // this.stop();\n    // this.onComplete = onComplete;\n    // AudioEngine.GetAudioEngine().voGain.disconnect(this.audioCtx.destination);\n    // AudioEngine.GetAudioEngine().musicGain.disconnect(this.audioCtx.destination);\n    // AudioEngine.GetAudioEngine().sfxGain.disconnect(this.audioCtx.destination);\n    // this.frames = [];\n    // this.decode_complete = false;\n    // this.demuxer = await beamcoder.demuxer(_path); // Create a demuxer for a file\n    // this.video_decoder = beamcoder.decoder({demuxer: this.demuxer, stream_index: 0 }); // Codec asserted. Can pass in demuxer.\n\n    // if(this.demuxer.streams.length == 2){\n    //   this.hasAudio = true;\n    //   this.audio_decoder = beamcoder.decoder({demuxer: this.demuxer, stream_index: 1 }); // Codec asserted. Can pass in demuxer.\n    //   this.audio = {\n    //     playback_rate: this.audio_decoder.sample_rate,\n    //     channels: this.audio_decoder.channels\n    //   }\n    // }\n\n    // this.width = this.video_decoder.width;\n    // this.height = this.video_decoder.height;\n    // this.resize();\n    // this.initVideoTexture();\n\n    // this.audio_array = [];\n    // this.audio_nodes = [];\n    // this.frame_array = [];\n\n    // this.nextAudioTime = 0;\n    // this.playbackPosition = 0;\n    // this.timer = 0;\n    // this.needsRenderUpdate = false;\n\n    // await this.fetchNextPackets();\n\n    // this.isPlaying = true;\n    // //this.decode();\n\n  }\n\n  stop(){\n    this.isPlaying = false;\n    this.timer = 0;\n    // global.clearTimeout(this.timeout);\n\n    //clean up audio nodes\n    while(this.audio_nodes.length){\n      let node = this.audio_nodes.shift();\n      node.disconnect();\n      node.buffer = undefined;\n      node = undefined;\n    }\n\n    AudioEngine.Mute(AudioEngineChannel.SFX | AudioEngineChannel.MUSIC | AudioEngineChannel.GUI | AudioEngineChannel.VO);\n\n    if(typeof this.onComplete === 'function')\n      this.onComplete();\n\n    this.initVideoTexture();\n\n    this.onComplete = undefined;\n  }\n\n  async seek(time = 0){\n    this.stop();\n    await this.demuxer.seek({ time: time });\n    this.audio_array = [];\n    this.audio_nodes = [];\n    this.frame_array = [];\n    await this.fetchNextPackets();\n    this.decode();\n  }\n\n  updateFrame(frame: BIKVideoFrameData | null | undefined): void {\n    if (frame) {\n      const ySize = frame.linesize[0] * this.height;\n      const uSize = frame.linesize[1] * this.height/2;\n      const vSize = frame.linesize[2] * this.height/2;\n\n      this.yTex.image.data = new Uint8Array(frame.data[0]);\n      this.uTex.image.data = new Uint8Array(frame.data[1]);\n      this.vTex.image.data = new Uint8Array(frame.data[2]);\n\n      this.yTex.image.width = frame.linesize[0];\n      this.uTex.image.width = frame.linesize[1];\n      this.vTex.image.width = frame.linesize[2];\n\n      this.yTex.needsUpdate = true;\n      this.uTex.needsUpdate = true;\n      this.vTex.needsUpdate = true;\n\n      this.material.uniformsNeedsUpdate = true;\n    }\n  }\n\n  async getAllPackets(){\n    while(!this.decode_complete){\n      await this.decodeNextPacket();\n    }\n  }\n\n  async decodeNextPacket(){\n\n    if(this.decode_complete)\n      return;\n\n    this.nextPacket = await this.demuxer.read(); // Read next frame. Note: returns null for EOF\n    if (this.nextPacket && this.nextPacket.stream_index == 0) {\n      //VIDEO_FRAME\n      const frames = await this.video_decoder.decode(this.nextPacket);\n      if(frames.frames.length){\n        for(let i = 0, len = frames.frames.length; i < len; i++){\n          this.frame_array.push(frames.frames[i]);\n        }\n      }\n    }else if (this.nextPacket && this.nextPacket.stream_index == 1) {\n      //AUDIO\n      const frames = await this.audio_decoder.decode(this.nextPacket);\n      if(frames.frames.length){\n        const frameLength = frames.frames[0].data[0].length/4;\n        const buffer = this.audioCtx.createBuffer(this.audio.channels, frames.frames.length * frameLength, this.audio.playback_rate);\n\n        for(let i = 0, len = frames.frames.length; i < len; i++){\n          for(let channel = 0; channel < this.audio.channels; channel++){\n            buffer.copyToChannel(\n              this.toFloat32Array(frames.frames[i].data[channel]),\n              channel,\n              i * frameLength\n            );\n          }\n        }\n\n        // let sampleNode = this.audioCtx.createBufferSource();\n        // sampleNode.buffer = buffer;\n        // sampleNode.loop = false;\n        // sampleNode.connect( AudioEngine.GetAudioEngine().movieGain );\n        // sampleNode.onended = function(){\n        //   sampleNode.buffer = undefined;\n        //   sampleNode.disconnect();\n        // };\n\n        this.audio_array.push(buffer);\n        //this.audio_nodes.push(sampleNode);\n\n      }\n    }else{\n      log.info('nextPacket', this.nextPacket);\n      this.decode_complete = true;\n    }\n  }\n\n  async fetchNextPackets(){\n    if(this.frame_array.length < this.min_buffer){\n      const count = this.max_buffer - this.frame_array.length;\n      for(let i = 0; i < count; i++){\n        await this.decodeNextPacket();\n        if(this.demuxer.streams.length == 2)\n          await this.decodeNextPacket();\n      }\n    }\n  }\n\n  async update(delta = 0){\n    this.playbackPosition += delta;\n    const frameTimer = (this.fps/1000);\n\n    //Process audio buffer queue\n    this.processAudioQueue();\n\n    if( this.timer >= frameTimer){\n      this.timer = 0;\n      await this.decode();\n    }else{\n      this.needsRenderUpdate = false;\n    }\n    this.timer += delta;\n  }\n\n  processAudioQueue(){\n    //Process audio buffer queue\n    if(this.audio_array.length){\n\n      let buffered = this.audio_array.shift();\n\n      while(this.audio_array.length){\n        const nextBuffer = this.audio_array.shift();\n        buffered = this.appendBuffer(buffered, nextBuffer);\n\n        //let current_time = this.audioCtx.currentTime;\n        //let sampleNode = this.audio_array.shift();\n\n        // if(!this.nextAudioTime)\n        //   this.nextAudioTime = current_time;\n\n        // sampleNode.start( this.nextAudioTime, 0 );\n        // this.nextAudioTime = this.nextAudioTime + sampleNode.buffer.duration;\n      }\n\n      const bufferedNode = this.audioCtx.createBufferSource();\n      bufferedNode.buffer = buffered;\n      bufferedNode.loop = false;\n      bufferedNode.connect( AudioEngine.movieChannel.getGainNode() );\n      bufferedNode.onended = function(){\n        bufferedNode.buffer = undefined;\n        bufferedNode.disconnect();\n      };\n\n      const current_time = this.audioCtx.currentTime;\n      if(!this.nextAudioTime)\n        this.nextAudioTime = current_time;\n\n      bufferedNode.start( this.nextAudioTime, 0 );\n      this.nextAudioTime = this.nextAudioTime + bufferedNode.buffer.duration;\n    }\n  }\n\n  //https://stackoverflow.com/questions/14143652/web-audio-api-append-concatenate-different-audiobuffers-and-play-them-as-one-son\n  appendBuffer(buffer1: AudioBuffer, buffer2: AudioBuffer): AudioBuffer {\n    const numberOfChannels = Math.min( buffer1.numberOfChannels, buffer2.numberOfChannels );\n    const tmp = this.audioCtx.createBuffer( numberOfChannels, (buffer1.length + buffer2.length), buffer1.sampleRate );\n    for (let i=0; i<numberOfChannels; i++) {\n      const channel = tmp.getChannelData(i);\n      channel.set( buffer1.getChannelData(i), 0);\n      channel.set( buffer2.getChannelData(i), buffer1.length);\n    }\n    return tmp;\n  }\n\n  async decode(){\n    this.isPlaying = true;\n    if(this.frame_array.length || this.audio_array.length){\n      //Process next video frame in the queue\n      this.updateFrame(this.frame_array.shift());\n      await this.fetchNextPackets();\n      this.needsRenderUpdate = true;\n    }else{\n      this.stop();\n    }\n  }\n\n  toFloat32Array(channel: Uint8Array){\n    if(channel instanceof Uint8Array){\n      const l = channel.length/4;\n      let i;\n      const buffer = new Buffer(channel);\n      const float32 = new Float32Array(l);\n\n      for(i = 0; i < l; i++){\n        float32[i] = buffer.readFloatLE(i*4);\n      }\n      return float32;\n    }\n    throw 'toFloat32Array missing Uint8Array';\n  }\n\n\n  dispose(){\n\n    this.disposed = true;\n\n    this.scene.remove(this.videoPlane);\n    this.scene.remove(this.backPlane);\n    this.geometry.dispose();\n    this.material.dispose();\n    this.yTex.dispose();\n    this.uTex.dispose();\n    this.vTex.dispose();\n\n    this.scene = undefined;\n    this.geometry = undefined;\n    this.material = undefined;\n    this.yTex = undefined;\n    this.uTex = undefined;\n    this.vTex = undefined;\n\n    //clean up audio nodes\n    while(this.audio_nodes.length){\n      let node = this.audio_nodes.shift();\n      node.disconnect();\n      node.buffer = undefined;\n      node = undefined;\n    }\n\n    this.audio_array = [];\n    this.frame_array = [];\n\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\shaders\\pass\\OdysseyShaderPass.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":38,"column":3,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":38,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe construction of a type that could not be resolved.","line":38,"column":17,"nodeType":"NewExpression","messageId":"errorNew","endLine":38,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on a type that cannot be resolved.","line":46,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":46,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":51,"column":4,"nodeType":"MemberExpression","messageId":"errorCall","endLine":51,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .render on a type that cannot be resolved.","line":51,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":51,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":58,"column":4,"nodeType":"MemberExpression","messageId":"errorCall","endLine":58,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .render on a type that cannot be resolved.","line":58,"column":16,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":58,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a type that could not be resolved.","line":68,"column":3,"nodeType":"MemberExpression","messageId":"errorCall","endLine":68,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dispose on a type that cannot be resolved.","line":68,"column":15,"nodeType":"Identifier","messageId":"errorMemberExpression","endLine":68,"endColumn":22}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport * as THREE from \"three\";\r\nimport { Pass, FullScreenQuad } from \"three/examples/jsm/postprocessing/Pass\";\r\n\r\nimport { OdysseyShader } from \"@/shaders/pass/OdysseyShader\";\r\n\r\n//Extend the default THREE.FilmPass shader pass\r\n\r\n/**\r\n * OdysseyShaderPass class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyShaderPass.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class OdysseyShaderPass extends Pass {\r\n\r\n  uniforms: { [uniform: string]: THREE.IUniform<THREE.Texture | null | number | THREE.Vector3> };\r\n  material: THREE.ShaderMaterial;\r\n  fsQuad: FullScreenQuad;\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tconst shader = OdysseyShader;\r\n\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t} );\r\n\r\n\t\tthis.fsQuad = new FullScreenQuad( this.material );\r\n\r\n\t}\r\n\r\n\trender( renderer: THREE.WebGLRenderer, writeBuffer: THREE.WebGLRenderTarget, readBuffer: THREE.WebGLRenderTarget, deltaTime: number /*, maskActive */ ) {\r\n\r\n\t\tthis.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ 'time' ].value += deltaTime;\r\n\t\tthis.fsQuad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\r\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.material.dispose();\r\n\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\three\\odyssey\\OdysseyEmitter3D.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":154,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":154,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":154,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":154,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":155,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":155,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setPosition on an `any` value.","line":155,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":155,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .x on an `any` value.","line":286,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":286,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .y on an `any` value.","line":289,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":289,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":313,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":313,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":313,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":313,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":314,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":314,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":314,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":314,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":315,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":315,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":315,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":315,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":316,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":316,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fromArray on an `any` value.","line":316,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":316,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":317,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":317,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .fromArray on an `any` value.","line":317,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":754,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":754,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":754,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":754,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":755,"column":7,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":755,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setPosition on an `any` value.","line":755,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":755,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1126,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1126,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":1126,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1126,"endColumn":47}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport { OdysseyModelControllerType } from \"@/enums/odyssey/OdysseyModelControllerType\";\r\nimport { TextureLoader } from \"@/loaders/TextureLoader\";\nimport { OdysseyModelNode, OdysseyModelNodeEmitter } from \"@/odyssey\";\r\nimport type { OdysseyController } from \"@/odyssey/controllers\";\r\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\n\n\nconst log = createScopedLogger(LogScope.Loader);\nimport { OdysseyObject3D } from \"@/three/odyssey/OdysseyObject3D\";\r\n\r\n/** Context passed to emitter for depth/camera (e.g. currentCamera, depthTarget). currentCamera may be omitted when context provides camera. */\r\nexport interface IOdysseyEmitterContext {\r\n  currentCamera?: THREE.Camera;\r\n  camera?: THREE.Camera;\r\n  depthTarget?: { depthTexture?: THREE.DepthTexture | unknown };\r\n}\r\n\r\n/**\r\n * OdysseyEmitter3D class.\r\n * \r\n * THREE.js representation of OdysseyEmitter\r\n * The OdysseyEmitter3D class will handle emitter nodes.\r\n * It only handles Billboard_to_World_Z and Billboard_to_Local_Z emitters\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyEmitter3D.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class OdysseyEmitter3D extends OdysseyObject3D {\r\n  \r\n  static BirthTime: number = 1;\r\n  static PlaneGeometry: THREE.PlaneGeometry = new THREE.PlaneGeometry(1, 1, 1, 1);\r\n  updateType: string;\r\n  _birthTimer: number = 0;\r\n  maxParticleCount: number;\r\n\r\n  //Geometry BufferAttributes\r\n  offsets: THREE.BufferAttribute|THREE.InstancedBufferAttribute;\r\n  velocities: THREE.BufferAttribute|THREE.InstancedBufferAttribute;\r\n  props: THREE.BufferAttribute|THREE.InstancedBufferAttribute;\r\n  ids: THREE.BufferAttribute|THREE.InstancedBufferAttribute;\r\n\r\n  particleCount: number;\r\n  referenceNode: OdysseyObject3D = new OdysseyObject3D();\r\n  _lightningDelay: number = 0;\r\n  lightningZigZag: number;\r\n  lightningScale: number;\r\n  lightningDelay: number = 0;\r\n  d: number = 0;\r\n  vx: number = 0;\r\n  vy: number = 0;\r\n  vz: number = 0;\r\n  d2: number = 0;\r\n  context: IOdysseyEmitterContext | undefined = undefined;\r\n  lifeExp: number = 0;\r\n\r\n  birthRate: number = 0;\r\n  birthRateRandom: number = 0;\r\n\r\n  velocity: number = 0;\r\n  randVelocity: number = 0;\r\n  drag: number = 0;\r\n  mass: number = 0;\r\n  lightningRadius: number = 0;\r\n  spread: number = 0;\r\n  size: THREE.Vector3 = new THREE.Vector3();\r\n  isDetonated: boolean;\r\n  particleIndex: number;\r\n  vec3: THREE.Vector3;\r\n  sizeXY: THREE.Vector2;\r\n  node: OdysseyModelNodeEmitter;\r\n  geometry: THREE.BufferGeometry;\r\n  material: THREE.ShaderMaterial;\r\n  \r\n  colorStart: THREE.Color = new THREE.Color(1, 1, 1);\r\n  colorMid: THREE.Color = new THREE.Color(1, 1, 1);\r\n  colorEnd: THREE.Color = new THREE.Color(1, 1, 1);\r\n\r\n  threshold: number = 0;\r\n  gravity: number = 0;\r\n  sizes: [number, number, number] = [0, 0, 0];\r\n  opacity: [number, number, number] = [0, 0, 0];\r\n  angle: number = 0;\r\n  _detonate: number = 0;\r\n  fps: number = 0;\r\n  lightningSubDiv: number = 0;\r\n  speed_min: number;\r\n  speed_max: number;\r\n  xangle: number;\r\n  zangle: number;\r\n  mesh: THREE.Points|THREE.Mesh;\r\n  attributes: Record<string, unknown> = {};\r\n  targetSize: number = 0;\r\n  controlPTCount: number = 0;\r\n  controlPTDelay: number = 0;\r\n  tangentSpread: number = 0;\r\n  tangentLength: number = 0;\r\n  controlPTRadius: number = 0;\r\n  speed: number;\r\n\r\n  override type = 'OdysseyEmitter' as const;\r\n\r\n  constructor(odysseyNode: OdysseyModelNode){\r\n    super();\r\n\r\n    this.isDetonated = false;\r\n    this.particleIndex = 0;\r\n  \r\n    this.vec3 = new THREE.Vector3(0.0, 0.0, 0.0);\r\n    this.sizeXY = new THREE.Vector2(0.0, 0.0);\r\n    this.node = odysseyNode as OdysseyModelNodeEmitter;\r\n  \r\n    this.material = undefined;\r\n    this.mesh = undefined;\r\n  \r\n    switch(this.node.renderMode){\r\n      case 'Normal':\r\n      case 'Motion_Blur':\r\n      case 'Linked':\r\n        this.geometry = new THREE.BufferGeometry();\r\n      break;\r\n      default:\r\n        this.geometry = new THREE.InstancedBufferGeometry();\r\n        this.geometry.index = OdysseyEmitter3D.PlaneGeometry.index;\r\n        this.geometry.attributes.position = OdysseyEmitter3D.PlaneGeometry.attributes.position;\r\n        this.geometry.attributes.uv = OdysseyEmitter3D.PlaneGeometry.attributes.uv;\r\n      break;\r\n    }\r\n  \r\n    // this.geometry.ignoreRaycast = true;\r\n  \r\n    //Particles\r\n    this.particleCount = 0;\r\n    this.maxParticleCount = 0;\r\n    // this.positions = [];\r\n    // this.ages = [];\r\n  \r\n    //Properties\r\n    this.size = new THREE.Vector3();\r\n    this.sizes = [0, 0, 0] as [number, number, number];\r\n    this.spread = 0;\r\n    this.opacity = [0, 0, 0];\r\n    this.lifeExp = -1;\r\n    this._detonate = 0;\r\n    this.birthRate = 0;\r\n\r\n    \r\n\r\n    this.addEventListener( 'added', ( _event ) => {\r\n      this.material.uniforms.matrix.value.copy(this.parent.matrix);\r\n      this.material.uniforms.matrix.value.setPosition(0, 0, 0);\r\n\r\n      /*if(this.node.Update != 'Explosion' && this.node.Render != 'Linked'){\r\n        for(let i = 0; i < this.birthRate; i++){\r\n          this.spawnParticle(i);\r\n        }\r\n      }*/\r\n\r\n      this.material.uniformsNeedUpdate = true;\r\n      this.attributeChanged('mass');\r\n    } );\r\n  \r\n    if(odysseyNode instanceof OdysseyModelNode){\r\n  \r\n      this.updateType = this.node.updateMode;\r\n  \r\n      this.material = new THREE.ShaderMaterial({\r\n        uniforms: THREE.UniformsUtils.merge( [\r\n          THREE.ShaderLib['odyssey-emitter'].uniforms, {\r\n            textureAnimation: { value: new THREE.Vector4(this.node.gridX || 1, this.node.gridY || 1, (this.node.gridX || 1) * (this.node.gridY || 1), 1) },\r\n          }\r\n        ]),\r\n        vertexShader: THREE.ShaderLib['odyssey-emitter'].vertexShader,\r\n        fragmentShader: THREE.ShaderLib['odyssey-emitter'].fragmentShader,\r\n        side: THREE.FrontSide,\r\n        transparent: true,\r\n        fog: false,\r\n        visible: true\r\n      });\r\n  \r\n      if(this.node.twoSidedTex || this.node.renderMode == 'Linked'){\r\n        this.material.side = THREE.DoubleSide;\r\n      }\r\n  \r\n      //this.material.defines.USE_FOG = '';\r\n  \r\n      TextureLoader.enQueueParticle(this.node.textureResRef, this);\r\n  \r\n      this.node.controllers.forEach( (controller: OdysseyController ) => {\r\n        if(controller.data.length){\r\n          switch(controller.type){\r\n            case OdysseyModelControllerType.Position:\r\n              //positionOffset.copy(controller.data[0]);\r\n            break;\r\n            case OdysseyModelControllerType.Orientation:\r\n              //controllerOptions.orientation = new THREE.Quaternion(controller.data[0].x, controller.data[0].y, controller.data[0].z, controller.data[0].w);\r\n            break;\r\n            case OdysseyModelControllerType.ColorStart:\r\n              this.colorStart.r = controller.data[0].x;\r\n              this.colorStart.g = controller.data[0].y;\r\n              this.colorStart.b = controller.data[0].z;\r\n            break;\r\n            case OdysseyModelControllerType.ColorMid:\r\n              this.colorMid.r = controller.data[0].x;\r\n              this.colorMid.g = controller.data[0].y;\r\n              this.colorMid.b = controller.data[0].z;\r\n            break;\r\n            case OdysseyModelControllerType.ColorEnd:\r\n              this.colorEnd.r = controller.data[0].x;\r\n              this.colorEnd.g = controller.data[0].y;\r\n              this.colorEnd.b = controller.data[0].z;\r\n            break;\r\n            case OdysseyModelControllerType.XSize:\r\n              //if(this.node.Render == 'Aligned_to_Particle_Dir'){\r\n                this.size.x = controller.data[0].value < 1 ? controller.data[0].value : (controller.data[0].value*.01);\r\n              //}else{\r\n              //  this.size.y = controller.data[0].value < 1 ? controller.data[0].value : (controller.data[0].value*.01);\r\n              //}\r\n            break;\r\n            case OdysseyModelControllerType.YSize:\r\n              //if(this.node.Render == 'Aligned_to_Particle_Dir'){\r\n                this.size.y = controller.data[0].value < 1 ? controller.data[0].value : (controller.data[0].value*.01);\r\n              //}else{\r\n              //  this.size.x = controller.data[0].value < 1 ? controller.data[0].value : (controller.data[0].value*.01);\r\n              //}\r\n            break;\r\n            case OdysseyModelControllerType.Spread:\r\n              this.spread = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LifeExp:\r\n              this.lifeExp = controller.data[0].value >= 0 ? controller.data[0].value : -1;\r\n            break;\r\n            case OdysseyModelControllerType.BirthRate:\r\n              this.birthRate = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Drag:\r\n              this.drag = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Threshold:\r\n              this.threshold = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Gravity:\r\n              this.gravity = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Mass:\r\n              this.mass = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Velocity:\r\n              this.velocity = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.RandomVelocity:\r\n              this.randVelocity = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.SizeStart:\r\n              this.sizes[0] = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.SizeMid:\r\n              this.sizes[1] = (controller.data[0].value);\r\n            break;\r\n            case OdysseyModelControllerType.SizeEnd:\r\n              this.sizes[2] = (controller.data[0].value);\r\n            break;\r\n            case OdysseyModelControllerType.AlphaStart:\r\n              this.opacity[0] = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.AlphaMid:\r\n              this.opacity[1] = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.AlphaEnd:\r\n              this.opacity[2] = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.ParticleRot:\r\n              this.angle = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.Detonate:\r\n              this._detonate = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.FPS:\r\n              this.fps = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.FrameStart:\r\n              this.material.uniforms.frameRange.value.x = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.FrameEnd:\r\n              this.material.uniforms.frameRange.value.y = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LightningZigZag:\r\n              this.lightningZigZag = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LightningDelay:\r\n              this.lightningDelay = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LightningRadius:\r\n              this.lightningRadius = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LightningSubDiv:\r\n              this.lightningSubDiv = controller.data[0].value;\r\n            break;\r\n            case OdysseyModelControllerType.LightningScale:\r\n              this.lightningScale = controller.data[0].value;\r\n            break;\r\n          }\r\n        }\r\n      });\r\n  \r\n      this.maxParticleCount = this.birthRate * (this.lifeExp >= 0 ? this.lifeExp : 1);\r\n      this.material.uniforms.tDepth.value = this.context?.depthTarget?.depthTexture;\r\n      this.material.uniforms.maxAge.value = (this.lifeExp >= 0 ? this.lifeExp : -1);\r\n      this.material.uniforms.colorStart.value.copy(this.colorStart);\r\n      this.material.uniforms.colorMid.value.copy(this.colorMid);\r\n      this.material.uniforms.colorEnd.value.copy(this.colorEnd);\r\n      this.material.uniforms.opacity.value.fromArray(this.opacity);\r\n      this.material.uniforms.scale.value.fromArray(this.sizes);\r\n      this.material.uniforms.rotate.value = this.angle;\r\n      this.material.uniforms.drag.value = this.drag;\r\n      this.material.uniforms.velocity.value = this.velocity;\r\n      this.material.uniforms.randVelocity.value = this.randVelocity;\r\n  \r\n      if(this.node.renderMode == 'Linked'){\r\n        this.birthRate = 0;\r\n      }\r\n  \r\n      if(this.node.updateMode == 'Lightning'){\r\n        this.material.defines.LIGHTNING = '';\r\n      }\r\n  \r\n      if(this.fps){\r\n        this.material.defines.FPS = '';\r\n        this.material.uniforms.fps.value = this.fps;\r\n      }\r\n  \r\n      this.material.defines[this.node.renderMode] = '';\r\n  \r\n      this._birthTimer = 1/this.birthRate;\r\n  \r\n      switch(this.node.blendMode){\r\n        case 'Normal':\r\n          this.material.blending = THREE.NormalBlending;\r\n        break;\r\n        case 'Lighten':\r\n        case 'Punch-Through':\r\n          this.material.blending = THREE.AdditiveBlending;\r\n          this.material.depthWrite = false;\r\n          this.material.needsUpdate = true;\r\n        break;\r\n      }\r\n  \r\n      const offsets: number[] = [];\r\n      const props: number[] = [];\r\n      const velocities: number[] = [];\r\n      const ids: number[] = [];\r\n\r\n      this.maxParticleCount = this.getMaxParticleCount();\r\n  \r\n      //Start Velocity Calculations\r\n      this.speed_min = this.velocity;\r\n      this.speed_max = this.randVelocity;\r\n  \r\n      this.xangle = this.spread;\r\n      this.zangle = this.spread;\r\n      this.vx = Math.sin(this.xangle);\r\n      this.vy = Math.sin(this.zangle);\r\n      this.vz = Math.cos(this.xangle) + Math.cos(this.zangle);\r\n  \r\n      this.d = this.speed_min / (Math.abs(this.vx) + Math.abs(this.vy) + Math.abs(this.vz));\r\n      this.d2 = this.speed_max / (Math.abs(this.vx) + Math.abs(this.vy) + Math.abs(this.vz));\r\n      //End Velocity Calculations\r\n  \r\n      switch(this.node.renderMode){\r\n        case 'Normal':\r\n        case 'Motion_Blur':\r\n          this.material.defines.POINTS = '';\r\n  \r\n          this.offsets = new THREE.BufferAttribute( new Float32Array( offsets ), 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.BufferAttribute( new Float32Array( velocities ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.BufferAttribute( new Float32Array( props ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.InstancedBufferAttribute( new Float32Array( ids ), 1 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.geometry.setAttribute( 'position', this.offsets );\r\n          this.geometry.setAttribute( 'velocity', this.velocities );\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          this.geometry.setAttribute( 'ids', this.ids );\r\n          \r\n          this.mesh = new THREE.Points( this.geometry, this.material );\r\n        break;\r\n        case 'Linked':\r\n          this.material.defines.LINKED = '';\r\n  \r\n          this.offsets = new THREE.BufferAttribute( new Float32Array( offsets ), 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.BufferAttribute( new Float32Array( velocities ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.BufferAttribute( new Float32Array( props ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.BufferAttribute( new Float32Array( ids ), 1 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.geometry.setAttribute( 'position', this.offsets );\r\n          this.geometry.setAttribute( 'offset', this.velocities );\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          //this.geometry.setAttribute( 'ids', this.ids );\r\n          \r\n          this.mesh = new THREE.Mesh( this.geometry, this.material );\r\n          //Need to fix!!! THREE JS update broke this\r\n          //this.mesh.setDrawMode(THREE.TriangleStripDrawMode);\r\n        break;\r\n        default:\r\n          this.offsets = new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.InstancedBufferAttribute( new Float32Array( velocities ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.InstancedBufferAttribute( new Float32Array( props ), 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.InstancedBufferAttribute( new Float32Array( ids ), 1 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.geometry.setAttribute( 'offset', this.offsets );\r\n          this.geometry.setAttribute( 'velocity', this.velocities );\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          this.geometry.setAttribute( 'ids', this.ids );\r\n      \r\n          this.mesh = new THREE.Mesh( this.geometry, this.material );\r\n        break;\r\n      }\r\n  \r\n      this.mesh.renderOrder = 9999;\r\n  \r\n      this.mesh.frustumCulled = true;\r\n      this.material.uniformsNeedUpdate = true;\r\n      this.add(this.mesh);\r\n  \r\n    }\r\n  }\r\n\r\n  getMaxParticleCount(){\r\n    if(this.node.renderMode == 'Linked'){ //Max attribute array size\r\n      if(this.updateType == 'Lightning'){\r\n        return 10 * 2;\r\n      }else{\r\n        return ((Math.ceil(this.lifeExp) * Math.ceil(this.birthRate)) * 2) * 3;\r\n      }\r\n    }else{\r\n      return (Math.ceil( (this.lifeExp >= 0 ? this.lifeExp : 1) ) * Math.ceil(this.birthRate));\r\n    }\r\n  }\r\n\r\n  getRandomPosition(){\r\n    const spread = new THREE.Vector3(0, 0, 0).copy(this.size);//.applyQuaternion(this.parent.quaternion);\r\n    const quaternion = new THREE.Quaternion(0, 0, 0, 1);\r\n    /*if(this.parent)\r\n      this.parent.getWorldQuaternion(parentQuaternion);*/\r\n    \r\n    if(this.node.renderMode == 'Normal' || this.node.renderMode == 'Motion_Blur'){\r\n      const pos = new THREE.Vector3().copy(this.parent.position);\r\n      this.getWorldQuaternion(quaternion);\r\n      this.getWorldPosition(pos);\r\n      return new THREE.Vector3(\r\n        ( Math.random() * spread.x - ( spread.x * 0.5 ) ),\r\n        ( Math.random() * spread.y - ( spread.y * 0.5 ) ),\r\n        ( Math.random() * spread.z - ( spread.z * 0.5 ) )\r\n      ).applyQuaternion(this.parent.quaternion).add(pos);\r\n    }else if(this.node.renderMode == 'Linked'){\r\n\r\n      this.getWorldQuaternion(quaternion);\r\n      const pos = new THREE.Vector3();//.copy(this.parent.position);\r\n      this.getWorldPosition(pos);\r\n      return pos;//.applyQuaternion(quaternion);\r\n\r\n    }\r\n    return new THREE.Vector3(\r\n      this.position.x + ( Math.random() * spread.x - ( spread.x * 0.5 ) ),\r\n      this.position.y + ( Math.random() * spread.y - ( spread.y * 0.5 ) ),\r\n      this.position.z + ( Math.random() * spread.z - ( spread.z * 0.5 ) )\r\n    ).applyQuaternion(this.quaternion);\r\n  }\r\n\r\n  randomFloat(min: number, max: number){\r\n    return min + ( Math.random() * max - ( max * 0.5 ) );\r\n  }\r\n\r\n  getRandomMaxAge(){\r\n    return this.lifeExp;//Math.floor(Math.random() * this.lifeExp) + (this.lifeExp * 0);\r\n  }\r\n\r\n  //Update the emitter\r\n  tick(delta: number = 0){\r\n\r\n    if(!delta){\r\n      delta = 1/30;\r\n    }\r\n\r\n    //this.material.uniforms.mass.value.z -= 0.5 * delta;\r\n    //this.material.uniformsNeedUpdate = true;\r\n\r\n    if ( this.parent === null ) {\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\t} else {\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\t}\r\n\r\n    let updatePositions = false;\r\n    let updateVelocity = false;\r\n    let updateProperties = false;\r\n\r\n    this.material.uniforms.time.value += delta;\r\n    this._birthTimer -= delta;\r\n    if(this._birthTimer < 0)\r\n      this._birthTimer = 0;\r\n\r\n    const maxParticleCount = this.getMaxParticleCount();\r\n    const resizeArrays = (maxParticleCount > this.offsets.count);\r\n    this.maxParticleCount = maxParticleCount;\r\n\r\n    if(resizeArrays){\r\n      //Create new larger arrays\r\n      const offsets = new Float32Array(this.maxParticleCount * 3);\r\n      const velocities = new Float32Array(this.maxParticleCount * 4);\r\n      const props = new Float32Array(this.maxParticleCount * 4);\r\n      const ids = new Float32Array(this.maxParticleCount * 1);\r\n\r\n      //Copy the existing values into the new arrays\r\n      offsets.set(this.offsets.array);\r\n      if(this.node.renderMode != 'Linked')\r\n        velocities.set(this.velocities.array);\r\n      props.set(this.props.array);\r\n\r\n      //Create new InstancedBufferAttribute / BufferAttribute objects with the new arrays\r\n      switch(this.node.renderMode){\r\n        case 'Normal':\r\n        case 'Motion_Blur':\r\n          this.offsets = new THREE.BufferAttribute( offsets, 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.BufferAttribute( velocities, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.BufferAttribute( props, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.InstancedBufferAttribute( ids, 1 ).setUsage( THREE.DynamicDrawUsage );\r\n          \r\n          this.geometry.setAttribute( 'position', this.offsets );\r\n          this.geometry.setAttribute( 'velocity', this.velocities );\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          this.geometry.setAttribute( 'ids', this.ids );\r\n        break;\r\n        case 'Linked':\r\n          this.offsets = new THREE.BufferAttribute( offsets, 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.BufferAttribute( velocities, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.BufferAttribute( props, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.InstancedBufferAttribute( ids, 1 ).setUsage( THREE.DynamicDrawUsage );\r\n          \r\n          this.geometry.setAttribute( 'position', this.offsets );\r\n          this.geometry.setAttribute( 'offset', this.velocities ); //Offsets use the velocity array in linked mode\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          this.geometry.setAttribute( 'ids', this.ids );\r\n        break;\r\n        default:\r\n          this.offsets = new THREE.InstancedBufferAttribute( offsets, 3 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.velocities = new THREE.InstancedBufferAttribute( velocities, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.props = new THREE.InstancedBufferAttribute( props, 4 ).setUsage( THREE.DynamicDrawUsage );\r\n          this.ids = new THREE.InstancedBufferAttribute( ids, 1 ).setUsage( THREE.DynamicDrawUsage );\r\n\r\n          this.geometry.setAttribute( 'offset', this.offsets );\r\n          this.geometry.setAttribute( 'velocity', this.velocities );\r\n          this.geometry.setAttribute( 'props', this.props );\r\n          this.geometry.setAttribute( 'ids', this.ids );\r\n        break;\r\n      }\r\n\r\n      updatePositions = true;\r\n      if(this.node.renderMode != 'Linked')\r\n        updateVelocity = true;\r\n\r\n      updateProperties = true;\r\n    }\r\n\r\n    if(this.updateType == 'Lightning'){\r\n      this.tickLightning(delta);\r\n      return;\r\n    }\r\n\r\n    let birthCount = 0;\r\n    let spawnableParticleCount = this.offsets.count;\r\n    let quaternion;\r\n\r\n    let attrPerVertex = 1;\r\n    if(this.node.renderMode == 'Linked'){\r\n      attrPerVertex = 3;\r\n      spawnableParticleCount = (this.offsets.count/attrPerVertex) || 0;\r\n      if(!this.birthRate){\r\n        this.particleIndex = 0;\r\n      }\r\n\r\n    }\r\n\r\n    let birthed = false;\r\n\r\n    let firstLink = undefined;\r\n    let lastLink = undefined;\r\n    let finalLink = undefined;\r\n\r\n    for(let i = 0; i < spawnableParticleCount; i++){\r\n\r\n      if(this.node.renderMode == 'Linked'){\r\n\r\n        let age = this.props.getX(i * attrPerVertex) || 0;\r\n        const maxAge = this.props.getY(i * attrPerVertex) || this.lifeExp;\r\n        const alive = this.props.getZ(i * attrPerVertex) == 1;\r\n\r\n        if(i < spawnableParticleCount){\r\n\r\n          if(alive){\r\n            lastLink = i;\r\n            if(!firstLink){\r\n              firstLink = i;\r\n            }\r\n\r\n            if(age >= maxAge){\r\n              if(!finalLink){\r\n                finalLink = i;\r\n              }\r\n\r\n              age = 0;\r\n              //mark particle as alive\r\n              this.props.setZ(i*attrPerVertex, 1);\r\n            }else{\r\n              age += delta;\r\n            }\r\n          }else if(i == this.particleIndex){\r\n\r\n            //If the birthtimer has expired and we can still spawn more particles this frame\r\n            if( this.birthRate && !this._birthTimer && !birthed ){\r\n              //Birth and reset the particle\r\n              this.spawnParticle(i);\r\n              this.particleIndex++;\r\n              updatePositions = true;\r\n              updateVelocity = true;\r\n              birthed = true;\r\n            }\r\n\r\n            //Make sure the age is set to zero\r\n            age = 0;\r\n          }\r\n          this.props.setX(i*attrPerVertex, age || 0);\r\n          updateProperties = true;\r\n\r\n        }else{\r\n\r\n          if(alive){\r\n            if(age >= maxAge){\r\n              age = 0;\r\n              this.particleCount -= 1;\r\n              //mark particle as dead\r\n              this.props.setZ(i*attrPerVertex, 0);\r\n            }else{\r\n              this.velocities.setW(i, this.velocities.getW(i) + delta * 10);\r\n              updateVelocity = true;\r\n              age += delta;\r\n            }\r\n          }else{\r\n            age = 0;\r\n          }\r\n          this.props.setX(i*attrPerVertex, age || 0);\r\n          updateProperties = true;\r\n\r\n        }\r\n\r\n        //Clone the props for the current vertex group\r\n        for(let pI = 1; pI < attrPerVertex; pI++){\r\n          this.props.setX((i*attrPerVertex) + pI, this.props.getX(i*attrPerVertex));\r\n          this.props.setY((i*attrPerVertex) + pI, this.props.getY(i*attrPerVertex));\r\n          this.props.setZ((i*attrPerVertex) + pI, this.props.getZ(i*attrPerVertex));\r\n          this.props.setW((i*attrPerVertex) + pI, this.props.getW(i*attrPerVertex));\r\n        }\r\n        updateProperties = true;\r\n\r\n      }else{\r\n\r\n        let age = this.props.getX(i) || 0;\r\n        const maxAge = this.props.getY(i) || (this.lifeExp >= 0 ? this.lifeExp : -1);\r\n        const alive = this.props.getZ(i) == 1;\r\n\r\n        if(i < this.maxParticleCount){\r\n\r\n          if(this.node.updateMode == 'Single'){\r\n            age += delta;\r\n            this.props.setX(i, age || 0);\r\n            this.props.setY(i, 1.0);\r\n            this.props.setZ(i, 1);\r\n            updateProperties = true;\r\n          }else{\r\n            if(alive){\r\n              if(age >= maxAge){\r\n                age = 0;\r\n                this.particleCount -= 1;\r\n                //mark particle as dead\r\n                this.props.setZ(i, 0);\r\n              }else{\r\n                age += delta;\r\n                if(age > maxAge) age = maxAge;\r\n              }\r\n            }else{\r\n\r\n              let canSpawn = !this._birthTimer;\r\n              let maxSpawn = 1;//this.birthRate * (1/this.birthRate);\r\n\r\n              if(this.node.updateMode == 'Explosion'){\r\n                canSpawn = this.isDetonated;\r\n                maxSpawn = this.birthRate;\r\n              }\r\n\r\n              //If the birthtimer has expired and we can still spawn more particles this frame\r\n              if(canSpawn && birthCount < maxSpawn){\r\n                //Birth and reset the particle\r\n                this.spawnParticle(i);\r\n                updatePositions = true;\r\n                if(this.node.renderMode != 'Linked')\r\n                  updateVelocity = true;\r\n                birthCount++;\r\n              }\r\n\r\n              //Make sure the age is set to zero\r\n              age = 0;\r\n            }\r\n          }\r\n\r\n          this.props.setX(i, age || 0);\r\n          updateProperties = true;\r\n\r\n        }else{\r\n          if(this.node.updateMode != 'Single'){\r\n            if(alive){\r\n              if(age >= maxAge){\r\n                age = 0;\r\n                this.particleCount -= 1;\r\n                //mark particle as dead\r\n                this.props.setZ(i, 0);\r\n              }else{\r\n                age += delta;\r\n              }\r\n            }else{\r\n              age = 0;\r\n            }\r\n            this.props.setX(i, age || 0);\r\n            updateProperties = true;\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n    \r\n\r\n    if(this.node.renderMode == 'Linked'){\r\n      for(let i = 0; i < this.maxParticleCount; i++){\r\n        if(i >= this.particleIndex){\r\n          this.offsets.setX(i, this.offsets.getX(this.particleIndex-1 || 0));\r\n          this.offsets.setY(i, this.offsets.getY(this.particleIndex-1 || 0));\r\n          this.offsets.setZ(i, this.offsets.getZ(this.particleIndex-1 || 0));\r\n        }\r\n      }\r\n    }\r\n\r\n    if(this.node.renderMode == \"Aligned_to_Particle_Dir\"){\r\n      this.material.uniforms.matrix.value.copy(this.parent.matrix);\r\n      this.material.uniforms.matrix.value.setPosition(0, 0, 0);\r\n      this.material.uniformsNeedUpdate = true;\r\n    }\r\n\r\n    if(updatePositions)\r\n      this.offsets.needsUpdate = true;\r\n\r\n    if(updateVelocity)\r\n      this.velocities.needsUpdate = true;\r\n\r\n    if(updateProperties)\r\n      this.props.needsUpdate = true;\r\n\r\n    if(!this._birthTimer)\r\n      this._birthTimer = 1/this.birthRate;\r\n\r\n    if(this._birthTimer == Infinity)\r\n      this._birthTimer = 1;\r\n\r\n    if(this.geometry.boundingSphere)\r\n      this.geometry.boundingSphere.radius = ( (this.size.length() || 1) + Math.abs(this.velocity) + Math.abs(this.randVelocity) + Math.abs(this.drag) + Math.abs(this.mass)  ) * (Math.max.apply(null, this.sizes) * 2);\r\n\r\n    this.isDetonated = false;\r\n\r\n    this.sortParticles();\r\n\r\n  }\r\n\r\n  setReferenceNode( referenceNode: OdysseyObject3D ){\r\n    if(referenceNode instanceof OdysseyObject3D){\r\n      this.referenceNode = referenceNode;\r\n    }\r\n  }\r\n\r\n  tickLightning(delta: number = 0){\r\n    if(this._lightningDelay == undefined){\r\n      this._lightningDelay = 0.00;\r\n    }\r\n\r\n    const lightningZigZag = this.lightningZigZag + 1;\r\n    const start = new THREE.Vector3(0.0, 0.0, 0.0);\r\n    this.getWorldPosition(start);\r\n    const target = new THREE.Vector3(0, 0, 0);\r\n    this.referenceNode.getWorldPosition(target);\r\n\r\n    const scale = 0.5;\r\n\r\n    const gridX1 = 2;\r\n    const indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    const velocities = [];\r\n    const props = [];\r\n    const spread = (this.lightningScale || 0);\r\n    let age = 0;\r\n\r\n    if(this._lightningDelay >= this.lightningDelay){\r\n      //Reset the parent quaternion if it is rotated\r\n      if(this.parent.quaternion.x || this.parent.quaternion.y || this.parent.quaternion.z || this.parent.quaternion.w != 1)\r\n        this.parent.quaternion.set(0, 0, 0, 1);\r\n\r\n      this._lightningDelay = 0;\r\n      for(let iy = 0; iy < lightningZigZag; iy++){\r\n        const percentage = iy/lightningZigZag;\r\n        let x = start.x + ( (target.x - start.x) * percentage);\r\n        let y = start.y - ( (target.y - start.y) * percentage);\r\n        let z = start.z + ( (target.z - start.z) * percentage);\r\n\r\n        if(iy){\r\n          x = this.randomFloat(x, spread);\r\n          y = this.randomFloat(y, spread);\r\n          z = this.randomFloat(z, spread);\r\n        }else if(iy+1 == lightningZigZag){\r\n          x = this.randomFloat(x, this.lightningRadius);\r\n          y = this.randomFloat(y, this.lightningRadius);\r\n          z = this.randomFloat(z, this.lightningRadius);\r\n        }\r\n\r\n        /* \r\n          //FORCE STORM like up and then spread\r\n          let t = (iy / lightningZigZag);\r\n          t = t*t*t;\r\n\r\n          if(iy == 0 || iy == 1){\r\n            if(iy == 1){\r\n              z += 0.5;\r\n            }\r\n          }else {\r\n            z += 1 * (1 - t);\r\n          }\r\n        */\r\n\r\n        for ( let ix = 0; ix < 2; ix ++ ) {\r\n\r\n          //let x = (ix * xStep) * scale - half_scale;\r\n          let xO = scale/2;\r\n          if(ix == 1){\r\n            xO = -scale/2;\r\n          }\r\n\r\n          vertices.push( x + xO, - y, z );\r\n          normals.push( 0, 0, 1 );\r\n          uvs.push( ix / 1 );\r\n          uvs.push( 1 - ( iy / lightningZigZag-1 ) );\r\n\r\n          velocities.push(0, 0, 0, 0);\r\n\r\n          if(!this.geometry.attributes.props){\r\n            age = 0;\r\n          }else{\r\n            age = ((this.geometry.attributes.props as THREE.BufferAttribute).getX( 0 ) || 0) + delta;\r\n          }\r\n\r\n          if(age >= 1)\r\n            age = 0;\r\n\r\n          props.push(age + delta, 1, 1, 0);\r\n\r\n        }\r\n\r\n        // indices\r\n        for(let iy = 0; iy < lightningZigZag-1; iy++){\r\n          for ( let ix = 0; ix < 1; ix++ ) {\r\n            const a = ix + gridX1 * iy;\r\n            const b = ix + gridX1 * ( iy + 1 );\r\n            const c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n            const d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n            // faces\r\n            indices.push( a, b, d );\r\n            indices.push( b, c, d );\r\n          }\r\n        }\r\n\r\n        // build geometry\r\n        this.geometry.setIndex(indices);\r\n        this.geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n        this.geometry.setAttribute( 'offset', new THREE.Float32BufferAttribute( velocities, 4 ) );\r\n        this.geometry.setAttribute( 'props', new THREE.Float32BufferAttribute( props, 4 ) );\r\n        this.geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\r\n        this.geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\r\n\r\n        //Update the boundingSphere so that the effect isn't culled whiled on camera\r\n        if(this.geometry.boundingSphere)\r\n          this.geometry.boundingSphere.radius = start.distanceTo(target);\r\n\r\n        this.velocities.needsUpdate = true;\r\n        this.props.needsUpdate = true;\r\n      }\r\n    }else{\r\n      this._lightningDelay += delta;\r\n      for(let iy = 0; iy < lightningZigZag; iy++){\r\n        for ( let ix = 0; ix < 2; ix++ ) {\r\n          if(!this.geometry.attributes.props){\r\n            age = 0;\r\n          }else{\r\n            age = ((this.geometry.attributes.props as THREE.BufferAttribute).getX( 0 ) || 0) + delta;\r\n          }\r\n\r\n          if(age >= 1)\r\n            age = 0;\r\n\r\n          props.push(age + delta, 1, 1, 0);\r\n        }\r\n      }\r\n      this.geometry.setAttribute( 'props', new THREE.Float32BufferAttribute( props, 4 ) );\r\n    }\r\n  }\r\n\r\n  setLinkedVertexPosition(i = 0, position = new THREE.Vector3){\r\n    //Vertex Positions\r\n    this.offsets.setX(i, position.x || 0);\r\n    this.offsets.setY(i, position.y || 0);\r\n    this.offsets.setZ(i, position.z || 0);\r\n    //Vertex Offsets\r\n    this.velocities.setX(i, 1);\r\n    this.velocities.setY(i, 1);\r\n    this.velocities.setZ(i, 1);\r\n\r\n    let index = this.geometry.getIndex();\r\n    const indices = [];\r\n    for ( let oldI = 0; oldI < this.offsets.count; oldI++ ) {\r\n      indices.push( oldI );\r\n    }\r\n    this.geometry.setIndex( indices );\r\n    index = this.geometry.getIndex();\r\n\r\n    const newIndices = [];\r\n    const numberOfTriangles = this.offsets.count - 2;\r\n    // gl.TRIANGLE_STRIP\r\n    for ( let newI = 0; newI < numberOfTriangles; newI++ ) {\r\n      if ( newI % 2 === 0 ) {\r\n        newIndices.push( index.getX( newI ) );\r\n        newIndices.push( index.getX( newI + 1 ) );\r\n        newIndices.push( index.getX( newI + 2 ) );\r\n      } else {\r\n        newIndices.push( index.getX( newI + 2 ) );\r\n        newIndices.push( index.getX( newI + 1 ) );\r\n        newIndices.push( index.getX( newI ) );\r\n      }\r\n    }\r\n    //log.info(newIndices);\r\n    this.geometry.setIndex(newIndices);\r\n    this.geometry.clearGroups();\r\n  }\r\n\r\n  spawnParticle(i = 0){\r\n    //Birth and reset the particle\r\n    const newPosition = this.getRandomPosition();\r\n    if(this.node.renderMode != 'Linked'){\r\n      this.offsets.setX(i, newPosition.x);\r\n      this.offsets.setY(i, newPosition.y);\r\n      this.offsets.setZ(i, newPosition.z);\r\n    }else{\r\n\r\n      if(this.node.name == 'omenemitter05'){\r\n        //log.info(this.node.name, i);\r\n      }\r\n\r\n      //These will be scaled inside the shader\r\n      const linked_verts = [\r\n        [-1, 1, 0],\r\n        [1, 1, 0],\r\n        [-1, -1, 0],\r\n        [1, -1, 0]\r\n      ];\r\n\r\n      //BEGIN TEST FIX\r\n      this.setLinkedVertexPosition(i, newPosition);\r\n      //END TEST FIX\r\n      //this.setLinkedVertexPositionOLD(i, newPosition);\r\n\r\n    }\r\n\r\n    if(this.velocity){\r\n      if(this.node.updateMode == 'Explosion' && this.node.renderMode != 'Linked'){\r\n        this.velocities.setX(i, this.randomFloat(this.d * this.vx, this.spread));\r\n        this.velocities.setY(i, this.randomFloat(this.d * this.vy, this.spread));\r\n        this.velocities.setZ(i, this.randomFloat(this.d * this.vz, this.spread));\r\n      }else{\r\n        const quaternion = new THREE.Quaternion();\r\n        this.getWorldQuaternion(quaternion);\r\n        this.vec3.set(\r\n          this.randomFloat(this.d * this.vx, this.d2 * this.vx),\r\n          this.randomFloat(this.d * this.vy, this.d2 * this.vy), \r\n          this.randomFloat(this.d * this.vz, this.d2 * this.vz)\r\n        ).applyQuaternion(quaternion);\r\n\r\n        if(this.node.renderMode != 'Linked'){\r\n          this.velocities.setX(i, this.vec3.x);\r\n          this.velocities.setY(i, this.vec3.y);\r\n          this.velocities.setZ(i, this.vec3.z);\r\n        }\r\n      }\r\n    }else{\r\n      if(this.node.renderMode != 'Linked'){\r\n        this.velocities.setX(i, 0);\r\n        this.velocities.setY(i, 0);\r\n        this.velocities.setZ(i, 0);\r\n      }\r\n    }\r\n\r\n    const maxAge = this.getRandomMaxAge();\r\n    if(this.node.renderMode != 'Linked'){\r\n      this.velocities.setW(i, this.mass);\r\n\r\n      //set the particles maxAge\r\n      this.props.setY(i, this.getRandomMaxAge());\r\n      //mark particle as alive\r\n      this.props.setZ(i, 1);\r\n    }else{\r\n      for(let vi = 0; vi < 3; vi++){\r\n        //set the particles maxAge\r\n        this.props.setY((i * 3) + vi, (this.lifeExp >= 0 ? this.lifeExp : 100));\r\n        //mark particle as alive\r\n        this.props.setZ((i * 3) + vi, 1);\r\n      }\r\n    }\r\n\r\n    this.ids.setX(i, i);\r\n\r\n    this.particleCount++;\r\n\r\n  }\r\n\r\n  //https://github.com/mrdoob/three.js/blob/master/examples/webgl_custom_attributes_points2.html#L173\r\n  sortParticles(){\r\n\r\n    if(!(this.mesh instanceof THREE.Points))\r\n      return;\r\n\r\n    if(this.node.renderMode == 'Linked')\r\n      return;\r\n\r\n    if(!this.context)\r\n      return;\r\n\r\n    const camera = this.context.currentCamera ?? this.context.camera;\r\n    if(!camera) return;\r\n\r\n    const vector = new THREE.Vector3();\r\n\r\n    // Model View Projection matrix\r\n\r\n    const matrix = new THREE.Matrix4();\r\n    matrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n    matrix.multiply( this.mesh.matrixWorld );\r\n\r\n    //\r\n\r\n    let index = this.geometry.getIndex();\r\n    const positions = (this.geometry.getAttribute( 'position' ) as THREE.BufferAttribute).array;\r\n    const length = positions.length / 3;\r\n    if ( index === null ) {\r\n      const array = new Uint16Array( length );\r\n      for ( let i = 0; i < length; i ++ ) {\r\n        array[ i ] = i;\r\n      }\r\n      index = new THREE.BufferAttribute( array, 1 );\r\n      this.geometry.setIndex( index );\r\n    }\r\n\r\n    const sortArray = [];\r\n    for ( let i = 0; i < length; i ++ ) {\r\n      vector.fromArray( positions, i * 3 );\r\n      vector.applyMatrix4( matrix );\r\n      sortArray.push( [ vector.z, i ] );\r\n    }\r\n\r\n    function numericalSort( a: [number, number], b: [number, number] ) {\r\n      return b[ 0 ] - a[ 0 ];\r\n    }\r\n\r\n    sortArray.sort( numericalSort );\r\n    const indices = index.array as number[] | Uint16Array;\r\n    for ( let i = 0; i < length; i ++ ) {\r\n      indices[ i ] = sortArray[ i ][ 1 ];\r\n    }\r\n    \r\n    this.geometry.index.needsUpdate = true;\r\n    \r\n  }\r\n\r\n  detonate(){\r\n    this.isDetonated = true;\r\n    //this.material.uniforms.mass.value.z = 0;\r\n    const spawnableParticleCount = this.offsets.count;\r\n    for(let i = 0; i < spawnableParticleCount; i++){\r\n      this.props.setX(i, 0);\r\n    }\r\n    this.props.needsUpdate = true;\r\n    this.material.uniforms.time.value = 0;\r\n    this.material.uniformsNeedUpdate = true;\r\n  }\r\n\r\n  getBirthTimer(){\r\n    return 1/this.birthRate;\r\n  }\r\n\r\n  //Disable the emitter\r\n  disable(){\r\n\r\n  }\r\n\r\n  attributeChanged(attr: string){\r\n    const quat = new THREE.Quaternion();\r\n    switch(attr){\r\n      case 'mass':\r\n        this.parent.getWorldQuaternion(quat);\r\n        this.vec3.set(0, 0, this.mass).applyQuaternion(this.quaternion);\r\n        this.material.uniforms.mass.value.copy(this.vec3);\r\n        this.material.uniformsNeedUpdate = true;\r\n      break;\r\n    }\r\n\r\n  }\r\n\r\n  setLinkedVertexPositionOLD(i = 0, newPosition = new THREE.Vector3){\r\n    /*for(let vi = 0; vi < 3; vi++){\r\n\r\n      const offset = [\r\n        [newPosition.x, newPosition.y, newPosition.z],\r\n        [newPosition.x, newPosition.y, newPosition.z],\r\n        [newPosition.x, newPosition.y, newPosition.z],\r\n        //[newPosition.x, newPosition.y, newPosition.z]\r\n      ];\r\n\r\n      //These will be scaled inside the shader\r\n      const vertex_offset = [\r\n        [-1, 1, 0],\r\n        [1, 1, 0],\r\n        [-1, -1, 0],\r\n        [1, -1, 0]\r\n      ];\r\n\r\n      if(i > 0){\r\n        \r\n        //Previous positions\r\n        offset[0][0] = this.offsets.getX(((i-1) * 3) + 0);\r\n        offset[0][1] = this.offsets.getY(((i-1) * 3) + 0);\r\n        offset[0][2] = this.offsets.getZ(((i-1) * 3) + 0);\r\n        \r\n        offset[1][0] = this.offsets.getX(((i-1) * 3) + 1);\r\n        offset[1][1] = this.offsets.getY(((i-1) * 3) + 1);\r\n        offset[1][2] = this.offsets.getZ(((i-1) * 3) + 1);\r\n        \r\n        offset[2][0] = this.offsets.getX(((i-1) * 3) + 2);\r\n        offset[2][1] = this.offsets.getY(((i-1) * 3) + 2);\r\n        offset[2][2] = this.offsets.getZ(((i-1) * 3) + 2);\r\n        \r\n        //Previous Vertex Positions\r\n        vertex_offset[0][0] = this.velocities.getX(((i-1) * 3) + 0);\r\n        vertex_offset[0][1] = this.velocities.getY(((i-1) * 3) + 0);\r\n        vertex_offset[0][2] = this.velocities.getZ(((i-1) * 3) + 0);\r\n        \r\n        vertex_offset[1][0] = this.velocities.getX(((i-1) * 3) + 1);\r\n        vertex_offset[1][1] = this.velocities.getY(((i-1) * 3) + 1);\r\n        vertex_offset[1][2] = this.velocities.getZ(((i-1) * 3) + 1);\r\n        \r\n        vertex_offset[2][0] = this.velocities.getX(((i-1) * 3) + 2);\r\n        vertex_offset[2][1] = this.velocities.getY(((i-1) * 3) + 2);\r\n        vertex_offset[2][2] = this.velocities.getZ(((i-1) * 3) + 2);\r\n\r\n        if(i % 2){ //ODD\r\n          switch(vi){\r\n            case 0:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, offset[2][0]);\r\n              this.offsets.setY((i * 3) + vi, offset[2][1]);\r\n              this.offsets.setZ((i * 3) + vi, offset[2][2]);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, vertex_offset[2][0]);\r\n              this.velocities.setY((i * 3) + vi, vertex_offset[2][1]);\r\n              this.velocities.setZ((i * 3) + vi, vertex_offset[2][2]);\r\n            break;\r\n            case 1:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, offset[1][0]);\r\n              this.offsets.setY((i * 3) + vi, offset[1][1]);\r\n              this.offsets.setZ((i * 3) + vi, offset[1][2]);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, vertex_offset[1][0]);\r\n              this.velocities.setY((i * 3) + vi, vertex_offset[1][1]);\r\n              this.velocities.setZ((i * 3) + vi, vertex_offset[1][2]);\r\n            break;\r\n            default:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, newPosition.x);\r\n              this.offsets.setY((i * 3) + vi, newPosition.y);\r\n              this.offsets.setZ((i * 3) + vi, newPosition.z);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, linked_verts[0][0]);\r\n              this.velocities.setY((i * 3) + vi, linked_verts[0][1]);\r\n              this.velocities.setZ((i * 3) + vi, linked_verts[0][2]);\r\n            break;\r\n          }\r\n        }else{ //EVEN\r\n          switch(vi){\r\n            case 0:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, offset[0][0]);\r\n              this.offsets.setY((i * 3) + vi, offset[0][1]);\r\n              this.offsets.setZ((i * 3) + vi, offset[0][2]);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, vertex_offset[0][0]);\r\n              this.velocities.setY((i * 3) + vi, vertex_offset[0][1]);\r\n              this.velocities.setZ((i * 3) + vi, vertex_offset[0][2]);\r\n            break;\r\n            case 1:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, offset[2][0]);\r\n              this.offsets.setY((i * 3) + vi, offset[2][1]);\r\n              this.offsets.setZ((i * 3) + vi, offset[2][2]);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, vertex_offset[2][0]);\r\n              this.velocities.setY((i * 3) + vi, vertex_offset[2][1]);\r\n              this.velocities.setZ((i * 3) + vi, vertex_offset[2][2]);\r\n            break;\r\n            default:\r\n              //Vertex Positions\r\n              this.offsets.setX((i * 3) + vi, newPosition.x);\r\n              this.offsets.setY((i * 3) + vi, newPosition.y);\r\n              this.offsets.setZ((i * 3) + vi, newPosition.z);\r\n              //Vertex Offsets\r\n              this.velocities.setX((i * 3) + vi, linked_verts[1][0]);\r\n              this.velocities.setY((i * 3) + vi, linked_verts[1][1]);\r\n              this.velocities.setZ((i * 3) + vi, linked_verts[1][2]);\r\n            break;\r\n          }\r\n        }\r\n      }else{\r\n        //Vertex Positions\r\n        this.offsets.setX((i * 3) + vi, newPosition.x);\r\n        this.offsets.setY((i * 3) + vi, newPosition.y);\r\n        this.offsets.setZ((i * 3) + vi, newPosition.z);\r\n        //Vertex Offsets\r\n        this.velocities.setX((i * 3) + vi, linked_verts[vi][0]);\r\n        this.velocities.setY((i * 3) + vi, linked_verts[vi][1]);\r\n        this.velocities.setZ((i * 3) + vi, linked_verts[vi][2]);\r\n\r\n      }\r\n      \r\n    }\r\n\r\n    let index = this.geometry.getIndex();\r\n    let indices = [];\r\n    for ( let oldI = 0; oldI < this.offsets.count; oldI++ ) {\r\n      indices.push( oldI );\r\n    }\r\n    this.geometry.setIndex( indices );\r\n    index = this.geometry.getIndex();\r\n\r\n    let newIndices = [];\r\n    let numberOfTriangles = this.offsets.count - 2;\r\n    // gl.TRIANGLE_STRIP\r\n    for ( let newI = 0; newI < numberOfTriangles; newI++ ) {\r\n      if ( newI % 2 === 0 ) {\r\n        newIndices.push( index.getX( newI ) );\r\n        newIndices.push( index.getX( newI + 1 ) );\r\n        newIndices.push( index.getX( newI + 2 ) );\r\n      } else {\r\n        newIndices.push( index.getX( newI + 2 ) );\r\n        newIndices.push( index.getX( newI + 1 ) );\r\n        newIndices.push( index.getX( newI ) );\r\n      }\r\n    }\r\n    //log.info(newIndices);\r\n    this.geometry.setIndex(newIndices);\r\n    this.geometry.clearGroups();*/\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\three\\odyssey\\OdysseyFace3.ts","messages":[{"ruleId":"@typescript-eslint/unified-signatures","severity":2,"message":"This overload and the one on line 107 can be combined into one signature taking `THREE.Color | THREE.Color[]`.","line":116,"column":3,"nodeType":"Identifier","messageId":"singleParameterDifference","endLine":116,"endColumn":31},{"ruleId":"@typescript-eslint/unified-signatures","severity":2,"message":"This overload and the one on line 106 can be combined into one signature taking `THREE.Vector3 | THREE.Vector3[]`.","line":124,"column":3,"nodeType":"Identifier","messageId":"singleParameterDifference","endLine":124,"endColumn":34}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from \"three\";\n\r\nimport type { SurfaceMaterial } from \"@/engine/SurfaceMaterial\";\r\nimport { IAdjacentWalkableFaces } from \"@/interface/odyssey\";\r\nimport type { OdysseyWalkMesh } from \"@/odyssey/OdysseyWalkMesh\";\r\n\r\n/**\r\n * OdysseyFace3 class.\r\n * \r\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\r\n * \r\n * @file OdysseyFace3.ts\r\n * @author KobaltBlu <https://github.com/KobaltBlu>\r\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\r\n */\r\nexport class OdysseyFace3 {\r\n\twalkIndex:number = 0;\r\n\tcoeff: number = 0;\r\n\twalkmesh: OdysseyWalkMesh;\r\n\tsurfacemat: SurfaceMaterial;\r\n\r\n\tadjacent: number[] = [];\r\n\tadjacentDiff: number[] = [];\r\n\r\n\tblocksLineOfSight: boolean = false;\r\n\twalkCheck: boolean = false;\r\n\twalk: boolean = false;\r\n\r\n\ttriangle: THREE.Triangle;\r\n\r\n\tadjacentWalkableFaces: IAdjacentWalkableFaces = {\r\n\t\ta: undefined,\r\n\t\tb: undefined,\r\n\t\tc: undefined,\r\n\t};\r\n\t\r\n  distance: number;\r\n\r\n\t/**\r\n\t * Vertex A index.\r\n\t */\r\n\ta: number;\r\n\r\n\t/**\r\n\t * Vertex B index.\r\n\t */\r\n\tb: number;\r\n\r\n\t/**\r\n\t * Vertex C index.\r\n\t */\r\n\tc: number;\r\n\r\n\t/**\r\n\t * Face normal.\r\n\t * @default new THREE.THREE.Vector3()\r\n\t */\r\n\tnormal: THREE.Vector3 = new THREE.Vector3();\r\n\r\n\t/**\r\n\t * Array of 3 vertex normals.\r\n\t * @default []\r\n\t */\r\n\tvertexNormals: THREE.Vector3[];\r\n\r\n\t/**\r\n\t * Face centroid\r\n\t * @default []\r\n\t */\r\n\tcentroid: THREE.Vector3 = new THREE.Vector3();\r\n\r\n\t/**\r\n\t * Face color.\r\n\t * @default new THREE.Color()\r\n\t */\r\n\tcolor: THREE.Color = new THREE.Color();\r\n\r\n\t/**\r\n\t * Array of 3 vertex colors.\r\n\t * @default []\r\n\t */\r\n\tvertexColors: THREE.Color[];\r\n\r\n\t/**\r\n\t * Material index (points to {@link Mesh.material}).\r\n\t * @default 0\r\n\t */\r\n\tmaterialIndex: number;\r\n\r\n\tperimeter = {\r\n\t\ta: false, b: false, c: false\r\n\t};\r\n\r\n\t/**\r\n\t * @param a Vertex A index.\r\n\t * @param b Vertex B index.\r\n\t * @param c Vertex C index.\r\n\t * @param normal Face normal or array of vertex normals.\r\n\t * @param color Face color or array of vertex colors.\r\n\t * @param materialIndex Material index.\r\n\t */\r\n\tconstructor(\r\n\t\ta: number,\r\n\t\tb: number,\r\n\t\tc: number,\r\n\t\tnormal?: THREE.Vector3,\r\n\t\tcolor?: THREE.Color,\r\n\t\tmaterialIndex?: number\r\n\t);\r\n\r\n\tconstructor(\r\n\t\ta: number,\r\n\t\tb: number,\r\n\t\tc: number,\r\n\t\tnormal?: THREE.Vector3,\r\n\t\tvertexColors?: THREE.Color[],\r\n\t\tmaterialIndex?: number\r\n\t);\r\n\r\n\tconstructor(\r\n\t\ta: number,\r\n\t\tb: number,\r\n\t\tc: number,\r\n\t\tvertexNormals?: THREE.Vector3[],\r\n\t\tcolor?: THREE.Color,\r\n\t\tmaterialIndex?: number\r\n\t);\r\n\r\n\tconstructor(\r\n\t\ta: number,\r\n\t\tb: number,\r\n\t\tc: number,\r\n\t\tvertexNormals?: THREE.Vector3|THREE.Vector3[],\r\n\t\tvertexColors?: THREE.Color|THREE.Color[],\r\n\t\tmaterialIndex?: number\r\n\t){\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\tthis.materialIndex = materialIndex;\r\n\t\tif(Array.isArray(vertexNormals)){\r\n\t\t\tthis.vertexNormals = vertexNormals;\r\n\t\t}else{\r\n\t\t\tthis.normal = vertexNormals || new THREE.Vector3();\r\n\t\t}\r\n\r\n\t\tif(Array.isArray(vertexColors)){\r\n\t\t\tthis.vertexColors = vertexColors;\r\n\t\t}else{\r\n\t\t\tthis.color = vertexColors || new THREE.Color();\r\n\t\t}\r\n  }\r\n\r\n\tpointInFace2d(pt: THREE.Vector3){\r\n    const v1 = this.walkmesh.vertices[this.a];\r\n    const v2 = this.walkmesh.vertices[this.b];\r\n    const v3 = this.walkmesh.vertices[this.c];\r\n\r\n    const d1 = this.sign(pt, v1, v2);\r\n    const d2 = this.sign(pt, v2, v3);\r\n    const d3 = this.sign(pt, v3, v1);\r\n\r\n    const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\r\n    const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\r\n\r\n    return !(has_neg && has_pos);\r\n  }\r\n\r\n\t#tmpEdge = new THREE.Vector3();\r\n\t#tmpPointToStart = new THREE.Vector3();\r\n\t#tmpPointToEnd = new THREE.Vector3();\r\n\r\n\tpointIsOnEdge(point: THREE.Vector3, side: 'a'|'b'|'c') {\r\n\t\tconst edgeStart = side == 'a' ? this.walkmesh.vertices[this.a] : \r\n\t\t\tside == 'b' ? this.walkmesh.vertices[this.b] : this.walkmesh.vertices[this.c];\r\n\t\tconst edgeEnd = side == 'a' ? this.walkmesh.vertices[this.b] : \r\n\t\t\tside == 'b' ? this.walkmesh.vertices[this.c] : this.walkmesh.vertices[this.a];\r\n\r\n    this.#tmpEdge.set(0, 0, 0).subVectors(edgeEnd, edgeStart);\r\n    this.#tmpPointToStart.set(0, 0, 0).subVectors(point, edgeStart);\r\n    this.#tmpPointToEnd.set(0, 0, 0).subVectors(point, edgeEnd);\r\n\r\n    // Check if the point lies on the edge segment\r\n    return (\r\n\t\t\tthis.#tmpPointToStart.cross(this.#tmpEdge).length() < 1e-6 && // Point is collinear\r\n\t\t\tthis.#tmpPointToStart.dot(this.#tmpEdge) >= 0 && // Point is not before edgeStart\r\n\t\t\tthis.#tmpPointToEnd.dot(this.#tmpEdge) <= 0 // Point is not after edgeEnd\r\n    );\r\n\t}\r\n\r\n  sign(p1: THREE.Vector2 | { x: number; y: number }, p2: THREE.Vector2 | { x: number; y: number }, p3: THREE.Vector2 | { x: number; y: number }){\r\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\r\n  }\r\n\r\n\tclone(): this {\r\n    return this;\r\n  }\r\n\r\n\tcopy( source: OdysseyFace3 ): this {\r\n    return this;\r\n  }\r\n\r\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\GitHub\\KotOR.js\\src\\three\\odyssey\\OdysseyModel3D.ts","messages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for ../../types/three-examples.d.ts, use `import` style instead.","line":1,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":1,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":46,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":46,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":46,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":46,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":47,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":47,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":47,"column":29,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":47,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":47,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":47,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":48,"column":79,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":48,"endColumn":107},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":48,"column":79,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":48,"endColumn":105},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":48,"column":97,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":48,"endColumn":105},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":49,"column":201,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":49,"endColumn":229},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":49,"column":201,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":49,"endColumn":227},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .toString on an `any` value.","line":49,"column":219,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":227},{"ruleId":"@typescript-eslint/no-this-alias","severity":2,"message":"Unexpected aliasing of 'this' to local variable.","line":219,"column":7,"nodeType":"Identifier","messageId":"thisAssignment","endLine":219,"endColumn":11},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":242,"column":21,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":242,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":243,"column":36,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":243,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":244,"column":15,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":244,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dispose on an `any` value.","line":244,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":244,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `Material`.","line":247,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":247,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":248,"column":13,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":248,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dispose on an `any` value.","line":248,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":248,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":250,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":250,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dispose on an `any` value.","line":250,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":250,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":489,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":489,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bone_parts on an `any` value.","line":490,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":490,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":494,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":494,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bone_parts on an `any` value.","line":495,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":495,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":496,"column":17,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":496,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [odysseyModelNode.bone_parts[j]] on an `any` value.","line":496,"column":38,"nodeType":"MemberExpression","messageId":"unsafeMemberExpression","endLine":496,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Computed name [odysseyModelNode.bone_parts[j]] resolves to an `any` value.","line":496,"column":38,"nodeType":"MemberExpression","messageId":"unsafeComputedMemberAccess","endLine":496,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bone_parts on an `any` value.","line":496,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":496,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":497,"column":43,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":497,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":500,"column":13,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":500,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .bone_inverse_matrix on an `any` value.","line":500,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":500,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `Matrix4[]`.","line":504,"column":76,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":504,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":622,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":622,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":623,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":623,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":623,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":623,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":628,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":628,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":630,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":630,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .material on an `any` value.","line":630,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":630,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":662,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":662,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .geometry on an `any` value.","line":662,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":662,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .r on an `any` value.","line":708,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":708,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":709,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":709,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1413,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1413,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on an `any` value.","line":1413,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1413,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1416,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1416,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on an `any` value.","line":1416,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1416,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1442,"column":13,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1442,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .setRGB on an `any` value.","line":1442,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1442,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1445,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":1445,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1494,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1494,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .set on an `any` value.","line":1494,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1494,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1527,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1527,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .copy on an `any` value.","line":1527,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1527,"endColumn":47}],"suppressedMessages":[],"errorCount":55,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference path=\"../../types/three-examples.d.ts\" />\nimport * as THREE from \"three\";\nimport { Lensflare, LensflareElement } from \"three/examples/jsm/objects/Lensflare\";\nimport * as BufferGeometryUtilsImport from \"three/examples/jsm/utils/BufferGeometryUtils\";\n/** Runtime three.js exports mergeBufferGeometries; @types/three uses mergeGeometries. Use mergeBufferGeometries for compatibility. */\nconst BufferGeometryUtils = BufferGeometryUtilsImport as typeof BufferGeometryUtilsImport & {\n  mergeBufferGeometries(geometries: THREE.BufferGeometry[], useGroups?: boolean): THREE.BufferGeometry;\n};\n\nimport { TextureType } from \"@/enums/loaders/TextureType\";\nimport { OdysseyModelAnimationManagerState } from \"@/enums/odyssey/OdysseyModelAnimationManagerState\";\nimport { OdysseyModelClass } from \"@/enums/odyssey/OdysseyModelClass\";\nimport { OdysseyModelControllerType } from \"@/enums/odyssey/OdysseyModelControllerType\";\nimport { OdysseyModelMDXFlag } from \"@/enums/odyssey/OdysseyModelMDXFlag\";\nimport { OdysseyModelNodeType } from \"@/enums/odyssey/OdysseyModelNodeType\";\nimport { type IGameContext } from \"@/interface/engine/IGameContext\";\nimport { IOdysseyModelLoaderOptions } from \"@/interface/odyssey\";\nimport type { IOdysseyControllerFrameGeneric } from \"@/interface/odyssey/controller/IOdysseyControllerFrameGeneric\";\nimport { IOdysseyModelHeader } from \"@/interface/odyssey/IOdysseyModelHeader\";\nimport { ITwoDAAnimation } from \"@/interface/twoDA/ITwoDAAnimation\";\nimport { MDLLoader, TextureLoader } from \"@/loaders\";\nimport { TwoDAManager } from \"@/managers/TwoDAManager\";\nimport { OdysseyController } from \"@/odyssey/controllers\";\nimport { type OdysseyModel } from \"@/odyssey/OdysseyModel\";\nimport { OdysseyModelAnimation } from \"@/odyssey/OdysseyModelAnimation\";\nimport { OdysseyModelAnimationManager } from \"@/odyssey/OdysseyModelAnimationManager\";\nimport { type OdysseyModelNode } from \"@/odyssey/OdysseyModelNode\";\nimport { type OdysseyModelNodeAABB } from \"@/odyssey/OdysseyModelNodeAABB\";\nimport { type OdysseyModelNodeDangly } from \"@/odyssey/OdysseyModelNodeDangly\";\nimport { type OdysseyModelNodeLight } from \"@/odyssey/OdysseyModelNodeLight\";\nimport { type OdysseyModelNodeMesh } from \"@/odyssey/OdysseyModelNodeMesh\";\nimport { type OdysseyModelNodeReference } from \"@/odyssey/OdysseyModelNodeReference\";\nimport { type OdysseyModelNodeSaber } from \"@/odyssey/OdysseyModelNodeSaber\";\nimport { type OdysseyModelNodeSkin } from \"@/odyssey/OdysseyModelNodeSkin\";\nimport { type OdysseyWalkMesh } from \"@/odyssey/OdysseyWalkMesh\";\nimport { OdysseyEmitter3D } from \"@/three/odyssey/OdysseyEmitter3D\";\nimport { createScopedLogger, LogScope } from \"@/utility/Logger\";\nimport { OdysseyLight3D } from \"@/three/odyssey/OdysseyLight3D\";\nimport { OdysseyObject3D } from \"@/three/odyssey/OdysseyObject3D\";\n\n\nconst log = createScopedLogger(LogScope.Loader);\nimport { OdysseyTexture } from \"@/three/odyssey/OdysseyTexture\";\n\nfunction odysseyOnBeforeCompile(this: THREE.ShaderMaterial, shader: { vertexShader: string; fragmentShader: string }) {\n  const lightCount = this.uniforms.animPointLights.value.length;\n  const numAnimatedLights = (lightCount || 0).toString();\n  shader.vertexShader = shader.vertexShader.replace(/NUM_ANIM_POINT_LIGHTS/g, numAnimatedLights.toString());\n  shader.fragmentShader = (numAnimatedLights > 0 ? `#define NUM_ANIM_POINT_LIGHTS ${numAnimatedLights}\\n #define USE_ANIMATED_LIGHTS\\n` : '') + shader.fragmentShader.replace(/NUM_ANIM_POINT_LIGHTS/g, numAnimatedLights.toString());\n}\n\n/**\n * OdysseyModel3D class.\n *\n * THREE.js representation of OdysseyModel\n *\n * The OdysseyModel3D class takes an OdysseyModel object and converts it into a THREE.js object\n *\n * KotOR JS - A remake of the Odyssey Game Engine that powered KotOR I & II\n *\n * @file OdysseyModel3D.ts\n * @author KobaltBlu <https://github.com/KobaltBlu>\n * @license {@link https://www.gnu.org/licenses/gpl-3.0.txt|GPLv3}\n */\nexport class OdysseyModel3D extends OdysseyObject3D {\n\n  type = 'OdysseyModel';\n  box = new THREE.Box3;\n  sphere = new THREE.Sphere();\n  context: IGameContext = undefined;\n  meshes: THREE.Mesh[] = [];\n  danglyMeshes: THREE.Mesh[] = [];\n  odysseyAnimations: OdysseyModelAnimation[] = [];\n  odysseyAnimationMap: Map<string, OdysseyModelAnimation> = new Map<string, OdysseyModelAnimation>();\n  emitters: OdysseyEmitter3D[] = [];\n  lights: OdysseyLight3D[] = [];\n  aabb: OdysseyModelNodeAABB | undefined = undefined;\n  materials: THREE.Material[] = [];\n  parentModel: OdysseyModel3D | undefined = undefined;\n\n  effects: { update(delta: number): void }[] = [];\n\n  puppeteer: unknown = undefined;\n  oddFrame = false;\n\n  names: string[] = [];\n  supermodels: OdysseyModel3D[] = [];\n\n  target: THREE.Object3D | null = null;\n  controlled = false;\n\n  skins: THREE.SkinnedMesh[] = [];\n  forceShieldGeometry: THREE.SkinnedMesh[] = [];\n  childModels: OdysseyModel3D[] = [];\n\n  //Beta AnimationManager\n  animationManager: OdysseyModelAnimationManager = new OdysseyModelAnimationManager(this);\n\n  wasOffscreen = false;\n  animateFrame = true;\n\n  nodes: Map<string, OdysseyObject3D> = new Map<string, OdysseyObject3D>();\n\n  animNodeCache: { [key: string]: OdysseyObject3D } = {\n\n  };\n\n  talkdummy: OdysseyObject3D;\n  cutscenedummy: OdysseyObject3D;\n  rootdummy: OdysseyObject3D;\n  headhook: OdysseyObject3D;\n  camerahook: OdysseyObject3D;\n  camerahookm: OdysseyObject3D;\n  camerahookf: OdysseyObject3D;\n  freelookhook: OdysseyObject3D;\n  lookathook: OdysseyObject3D;\n  lightsaberhook: OdysseyObject3D;\n  deflecthook: OdysseyObject3D;\n  maskhook: OdysseyObject3D;\n  gogglehook: OdysseyObject3D;\n  rhand: OdysseyObject3D;\n  lhand: OdysseyObject3D;\n  impact: OdysseyObject3D;\n  impact_bolt: OdysseyObject3D;\n  headconjure: OdysseyObject3D;\n  handconjure: OdysseyObject3D;\n  trans: OdysseyObject3D;\n  bullethook0: OdysseyObject3D;\n  bullethook1: OdysseyObject3D;\n  bullethook2: OdysseyObject3D;\n  bullethook3: OdysseyObject3D;\n  gunhook0: OdysseyObject3D;\n  gunhook1: OdysseyObject3D;\n  gunhook2: OdysseyObject3D;\n  gunhook3: OdysseyObject3D;\n  modelhook: OdysseyObject3D;\n  hturn_g: OdysseyObject3D;\n\n  bonesInitialized = false;\n  Scale: number;\n  modelHeader: IOdysseyModelHeader = {} as IOdysseyModelHeader;\n  affectedByFog: boolean;\n  options: IOdysseyModelLoaderOptions | Record<string, unknown> = {};\n  oldAnim: OdysseyModelAnimation;\n  mergedGeometries: THREE.BufferGeometry[];\n  mergedDanglyGeometries: THREE.BufferGeometry[];\n  mergedMaterials: THREE.Material[];\n  mergedDanglyMaterials: THREE.Material[];\n  mergedBufferGeometry: THREE.BufferGeometry;\n\n  // Material-based geometry grouping for optimized merging\n  geometryGroupsByMaterial: Map<THREE.Material, THREE.BufferGeometry[]>;\n  mergedMesh: THREE.Mesh;\n  mergedBufferDanglyGeometry: THREE.BufferGeometry;\n  mergedDanglyMesh: THREE.Mesh;\n  walkmesh: THREE.Mesh;\n  wok: OdysseyWalkMesh;\n  animLoops: OdysseyModelAnimation[] = [];\n  hasCollision: boolean;\n  animLoop: OdysseyModelAnimation | null = null;\n\n  attachHead(head: OdysseyModel3D) {\n\n    const rootNode = head.children[0];\n    // log.info('attachHead', rootNode);\n    const remapper: [OdysseyObject3D, OdysseyObject3D][] = [];\n    if (rootNode) {\n      rootNode.traverse((node: OdysseyObject3D) => {\n        // log.info('traverse', node);\n        if (node == rootNode) return;\n\n        if (node instanceof THREE.SkinnedMesh) {\n          node.userData.boneNames = [...head.nodes.keys()];\n          this.skins.push(node);\n          const m_node = node.parent;\n          const n_parent = this.nodes.get(m_node.parent?.name);\n          if (n_parent) remapper.push([m_node as OdysseyObject3D, n_parent]);\n        } else if (node instanceof THREE.Mesh) {\n          const m_node = node.parent;\n          const n_parent = this.nodes.get(m_node.parent?.name);\n          if (n_parent) remapper.push([m_node as OdysseyObject3D, n_parent]);\n        } else if (node instanceof THREE.Light) {\n          const n_parent = this.nodes.get(node.parent?.name);\n          if (n_parent) remapper.push([node, n_parent]);\n        } else if (node instanceof OdysseyObject3D) {\n          if (!this.nodes.has(node.name)) {\n            this.nodes.set(node.name, node);\n          }\n        }\n\n        if (node.name == 'hturn_g') {\n          this.hturn_g = node;\n        }\n\n      });\n\n      for (let i = 0; i < remapper.length; i++) {\n        remapper[i][0].removeFromParent();\n        remapper[i][1].add(remapper[i][0]);\n      }\n\n      this.headhook.add(rootNode);\n\n      //fix skins\n      this.buildSkeleton();\n    }\n\n  }\n\n  disableEmitters() {\n    for (let i = 0; i < this.emitters.length; i++) {\n      this.emitters[i].disable();\n    }\n  }\n\n  dispose(node?: THREE.Object3D) {\n\n    if (node == null)\n      node = this;\n\n    while (this.childModels.length) {\n      const childModel3D = this.childModels.shift();\n      if (childModel3D) {\n        childModel3D.dispose();\n      }\n    }\n\n    for (let i = 0; i < this.emitters.length; i++) {\n      const emitter = this.emitters[i] as OdysseyEmitter3D & { group?: THREE.BufferGeometry };\n      if (emitter.group)\n        this.emitters[i].removeFromParent();\n    }\n\n    // log.info('dispose', node)\n    for (let i = node.children.length; i > 0; i--) {\n      const object = node.children[i - 1];\n      node.remove(object);\n      if (object.type === 'Mesh' || object.type === 'SkinnedMesh' || object.type === 'Points') {\n        if (object instanceof THREE.Mesh) {\n          if (Array.isArray(object.material)) {\n            while (object.material.length) {\n              const material = object.material.splice(0, 1)[0];\n              this.disposeMaterial(material);\n              material.dispose();\n            }\n          } else {\n            this.disposeMaterial(object.material);\n            object.material.dispose();\n          }\n          object.geometry.dispose();\n        }\n      } else if (object.type === 'OdysseyLight') {\n        if (!!this.context && !!this.context.lightManager) {\n          this.context.lightManager.removeLight(node as OdysseyLight3D);\n        }\n      } else {\n        const objWithMesh = object as THREE.Object3D & { mesh?: THREE.Mesh };\n        if (Object.prototype.hasOwnProperty.call(objWithMesh, 'mesh')) {\n          objWithMesh.mesh = undefined;\n        }\n      }\n\n      const objWithEmitter = object as OdysseyObject3D;\n      if (objWithEmitter.emitter) {\n        const emitter = objWithEmitter.emitter as OdysseyEmitter3D & { group?: THREE.BufferGeometry };\n        if (this.modelHeader.classification == 1) {\n          if (emitter.group) {\n            emitter.group.dispose();\n          }\n        } else {\n          if (emitter.group) {\n            objWithEmitter.emitter.remove();\n          }\n        }\n      }\n\n      this.dispose(object);\n    }\n\n    if (node instanceof OdysseyModel3D) {\n      this.meshes = [];\n      this.danglyMeshes = [];\n      this.odysseyAnimations = [];\n      this.emitters = [];\n      this.lights = [];\n      this.aabb = undefined;\n      this.materials = [];\n      this.skins = [];\n\n      this.puppeteer = undefined;\n      this.names = [];\n      this.supermodels = [];\n      this.target = null;\n      this.controlled = false;\n      this.animationManager.currentAnimation = undefined;\n      this.animNodeCache = {};\n      this.options = {};\n\n      this.headhook = null;\n      this.lhand = null;\n      this.rhand = null;\n\n      if (this.parent instanceof OdysseyModel3D) {\n        this.parent.remove(this);\n      }\n      //log.info(node);\n\n      this.disposeForceShieldGeometry();\n\n    }\n\n  }\n\n  disposeMaterial(material: THREE.Material) {\n    if (material instanceof THREE.ShaderMaterial) {\n      const disposeTex = (u: { value?: THREE.Texture } | undefined) => {\n        const v = u?.value;\n        if (v && typeof (v as THREE.Texture).dispose === 'function') (v as THREE.Texture).dispose();\n      };\n      disposeTex(material.uniforms.map as { value?: THREE.Texture });\n      disposeTex(material.uniforms.envMap as { value?: THREE.Texture });\n      disposeTex(material.uniforms.alphaMap as { value?: THREE.Texture });\n      disposeTex(material.uniforms.lightMap as { value?: THREE.Texture });\n      disposeTex(material.uniforms.bumpMap as { value?: THREE.Texture });\n    }\n  }\n\n  update(delta: number = 0) {\n\n    // if ((GameState.debug as { disableAnimation?: boolean }).disableAnimation) return;\n\n    for (let i = 0, len = this.effects.length; i < len; i++) {\n      this.effects[i].update(delta);\n    }\n\n    this.animationManager.update(delta);\n\n    //Update the time uniform on materials in this array\n    for (let i = 0; i < this.materials.length; i++) {\n      const material = this.materials[i];\n      if (material instanceof THREE.ShaderMaterial) {\n        if (material.type == 'ShaderMaterial') {\n          material.uniforms.time.value = this.context.deltaTime;\n        }\n      }\n    }\n\n    //Update emitters\n    for (let i = 0; i < this.emitters.length; i++) {\n      this.emitters[i].tick(delta);\n    }\n\n    //Update childModels\n    for (let i = 0; i < this.childModels.length; i++) {\n      this.childModels[i].update(delta);\n    }\n\n    this.oddFrame = !this.oddFrame;\n\n  }\n\n  setEmitterTarget(node: OdysseyModel3D) {\n    if (node instanceof OdysseyModel3D) {\n      for (let i = 0; i < this.emitters.length; i++) {\n        if (this.emitters[i].referenceNode instanceof OdysseyModel3D) {\n          // node.getWorldPosition(\n          //   this.emitters[i].referenceNode.position\n          // );\n          this.emitters[i].referenceNode = node;\n        }\n      }\n    }\n  }\n\n  setPuppeteer(pup: OdysseyModel3D = undefined) {\n    this.puppeteer = pup;\n  }\n\n  removePuppeteer() {\n    this.puppeteer = undefined;\n  }\n\n  poseAnimation(anim: OdysseyModelAnimation | string | number) {\n    let animation: OdysseyModelAnimation;\n    if (typeof anim === 'number') {\n      animation = this.odysseyAnimations[anim];\n    } else if (typeof anim === 'string') {\n      animation = this.odysseyAnimationMap.get(anim.toLowerCase().trim());\n    } else {\n      animation = anim;\n    }\n\n    if (animation instanceof OdysseyModelAnimation) {\n      this.animationManager.currentAnimation = animation;\n\n      const animNodesLen = animation.nodes.length;\n      for (let i = 0; i < animNodesLen; i++) {\n        this.poseAnimationNode(animation, animation.nodes[i]);\n      }\n    }\n  }\n\n  playAnimation(anim: OdysseyModelAnimation | string | number, loop: boolean = false) {\n    const state: OdysseyModelAnimationManagerState = {\n      loop: loop,\n      cFrame: 0,\n      elapsed: 0,\n      elapsedCount: 0,\n      lastTime: 0,\n      delta: 0,\n      lastEvent: -1,\n      events: []\n    };\n\n    const resolvedAnim: OdysseyModelAnimation | undefined =\n      typeof anim === 'number' ? this.odysseyAnimations[anim]\n      : typeof anim === 'string' ? this.odysseyAnimationMap.get(anim.toLowerCase().trim())\n      : (anim as OdysseyModelAnimation);\n    if (resolvedAnim) {\n      this.animationManager.setCurrentAnimation(resolvedAnim, state);\n    }\n\n    if (typeof this.animationManager.currentAnimation != 'undefined') {\n      if (!this.animationManager.lastAnimation) {\n        this.animationManager.setLastAnimation(this.animationManager.currentAnimation, state)\n      }\n\n      const animations2DA = TwoDAManager.datatables.get('animations');\n      const animRowsLen = animations2DA.RowCount ?? animations2DA.getHeight();\n      for (let i = 0; i < animRowsLen; i++) {\n        const row = animations2DA.rows[i];\n        if (row && String(row['name'] ?? row['__rowlabel']) === this.animationManager.currentAnimation.name) {\n          this.animationManager.currentAnimationState.animation = row;\n          break;\n        }\n      }\n      return this.animationManager.currentAnimation;\n    }\n    return undefined;\n  }\n\n  playOverlayAnimation(anim: OdysseyModelAnimation | string | number, data: ITwoDAAnimation) {\n    const state: OdysseyModelAnimationManagerState = {\n      loop: data.looping == '1',\n      cFrame: 0,\n      elapsed: 0,\n      elapsedCount: 0,\n      lastTime: 0,\n      delta: 0,\n      lastEvent: -1,\n      events: []\n    };\n\n    if (typeof anim === 'number') {\n      this.animationManager.setOverlayAnimation(this.odysseyAnimations[anim], state);\n    } else if (typeof anim === 'string') {\n      this.animationManager.setOverlayAnimation(this.odysseyAnimationMap.get(anim.toLowerCase().trim()), state);\n    } else {\n      this.animationManager.setOverlayAnimation(anim, state);\n    }\n\n    if (typeof this.animationManager.overlayAnimationState != 'undefined') {\n      this.animationManager.overlayAnimationState.animation = data;\n    }\n  }\n\n  stopAnimation() {\n    this.animationManager.stopAnimation();\n  }\n\n  getAnimationName(): string {\n    if (typeof this.animationManager.currentAnimation !== 'undefined') {\n      return this.animationManager.currentAnimation.name;\n    }\n    return undefined;\n  }\n\n  buildSkeleton() {\n    this.bonesInitialized = false;\n    this.oldAnim = this.animationManager.currentAnimation;\n    this.animationManager.currentAnimation = undefined;\n    this.pose();\n\n    for (let i = 0; i < this.skins.length; i++) {\n      const skinNode = this.skins[i];\n      if (typeof skinNode.userData.boneNames === 'undefined') {\n        skinNode.userData.boneNames = [...this.nodes.keys()];\n      }\n      const odysseyModelNode = skinNode.userData.odysseyModelNode;\n      if (typeof odysseyModelNode?.bone_parts !== 'undefined') {\n        const bones = [];\n        const inverses = [];\n        // let parts = Array.from(this.nodes.values());\n        const boneNames = skinNode.userData.boneNames;\n        for (let j = 0; j < odysseyModelNode.bone_parts.length; j++) {\n          const boneName = boneNames[odysseyModelNode.bone_parts[j]];\n          const boneNode = this.nodes.get(boneName);\n          if (typeof boneNode != 'undefined') {\n            bones[j] = boneNode;\n            inverses[j] = odysseyModelNode.bone_inverse_matrix[j];\n          }\n        }\n        // (skinNode.geometry as THREE.BufferGeometry & { bones?: THREE.Bone[] }).bones = bones;\n        skinNode.bind(new THREE.Skeleton(bones as unknown as THREE.Bone[], inverses));\n        skinNode.skeleton.update();\n        skinNode.updateMatrixWorld();\n      }\n    }\n\n    this.bonesInitialized = true;\n    this.animationManager.currentAnimation = this.oldAnim;\n  }\n\n  pose(node: OdysseyModel3D | THREE.Object3D = undefined) {\n    this.bonesInitialized = false;\n    if (node) {\n      try {\n        const nodeWithControllers = node as OdysseyObject3D;\n        if (nodeWithControllers.controllers) {\n          nodeWithControllers.controllers.forEach((controller: OdysseyController) => {\n            if (controller.data.length) {\n              const frame: IOdysseyControllerFrameGeneric = controller.data[0];\n              switch (controller.type) {\n                case OdysseyModelControllerType.Position:\n                  node.position.set(frame.x ?? 0, frame.y ?? 0, frame.z ?? 0);\n                  break;\n                case OdysseyModelControllerType.Orientation:\n                  node.quaternion.set(frame.x ?? 0, frame.y ?? 0, frame.z ?? 0, frame.w ?? 1);\n                  break;\n                case OdysseyModelControllerType.Scale:\n                  node.scale.set(frame.value ?? 1, frame.value ?? 1, frame.value ?? 1);\n                  break;\n              }\n            }\n          });\n        }\n        //node.updateMatrix();\n        node.updateMatrixWorld(true);\n      } catch { /* pose may throw on malformed controller data */ }\n\n      for (let i = 0; i < node.children.length; i++) {\n        this.pose(node.children[i] as OdysseyModel3D | THREE.Object3D);\n      }\n    } else {\n      for (let i = 0; i < this.children.length; i++) {\n        this.pose(this.children[i] as OdysseyModel3D | THREE.Object3D);\n      }\n    }\n  }\n\n  playEvent(event: string, index: number = 0) {\n    //log.info(event)\n    if (event == 'detonate') {\n      let idx = 0;\n      for (let i = 0; i < this.emitters.length; i++) {\n        const emitter = this.emitters[i];\n        if (emitter.type == 'OdysseyEmitter') {\n          if (emitter.updateType == 'Explosion') {\n            if (idx == index) {\n              emitter.detonate();\n            }\n            idx++;\n          }\n        }\n      }\n    } else {\n      this.dispatchEvent({ type: 'playEvent', event: event } as unknown as Parameters<THREE.Object3D['dispatchEvent']>[0]);\n    }\n\n  }\n\n  poseAnimationNode(anim: OdysseyModelAnimation | undefined, node: OdysseyModelNode | { name: string }) {\n\n    if (!this.bonesInitialized)\n      return;\n\n    const modelNode = this.nodes.get(node.name);\n\n    if (typeof modelNode != 'undefined') {\n      modelNode.controllers.forEach((controller: OdysseyController) => {\n        //for(let cIDX in node.controllers){\n\n        //let controller = node.controllers[cIDX];\n\n        const data = controller.data[0];\n        switch (controller.type) {\n          case OdysseyModelControllerType.Position: {\n            let offsetX = 0;\n            let offsetY = 0;\n            let offsetZ = 0;\n            if (typeof modelNode.controllers.get(OdysseyModelControllerType.Position) != 'undefined') {\n              offsetX = modelNode.controllers.get(OdysseyModelControllerType.Position).data[0].x;\n              offsetY = modelNode.controllers.get(OdysseyModelControllerType.Position).data[0].y;\n              offsetZ = modelNode.controllers.get(OdysseyModelControllerType.Position).data[0].z;\n            }\n            modelNode.position.set((data.x + offsetX) * this.Scale, (data.y + offsetY) * this.Scale, (data.z + offsetZ) * this.Scale);\n            break;\n          }\n          case OdysseyModelControllerType.Orientation: {\n            let offsetQX = 0;\n            let offsetQY = 0;\n            let offsetQZ = 0;\n            let offsetQW = 1;\n            if (typeof modelNode.controllers.get(OdysseyModelControllerType.Orientation) != 'undefined') {\n              offsetQX = modelNode.controllers.get(OdysseyModelControllerType.Orientation).data[0].x;\n              offsetQY = modelNode.controllers.get(OdysseyModelControllerType.Orientation).data[0].y;\n              offsetQZ = modelNode.controllers.get(OdysseyModelControllerType.Orientation).data[0].z;\n              offsetQW = modelNode.controllers.get(OdysseyModelControllerType.Orientation).data[0].w;\n            }\n            if (data.x == 0 && data.y == 0 && data.z == 0 && data.w == 1) {\n              data.x = offsetQX;\n              data.y = offsetQY;\n              data.z = offsetQZ;\n              data.w = offsetQW;\n            }\n\n            modelNode.quaternion.set(data.x, data.y, data.z, data.w);\n            break;\n          }\n          case OdysseyModelControllerType.SelfIllumColor:\n            if (modelNode.userData.mesh) {\n              if (modelNode.userData.mesh.material instanceof THREE.ShaderMaterial) {\n                modelNode.userData.mesh.material.uniforms.selfIllumColor.value.setRGB(\n                  data.x,\n                  data.y,\n                  data.z\n                );\n                modelNode.userData.mesh.material.defines.SELFILLUMCOLOR = \"\";\n              } else {\n                modelNode.userData.mesh.material.emissive.setRGB(\n                  data.x,\n                  data.y,\n                  data.z\n                );\n              }\n            }\n            break;\n          case OdysseyModelControllerType.Color:\n            if ((modelNode.odysseyModelNode.nodeType & OdysseyModelNodeType.Light) == OdysseyModelNodeType.Light) {\n              (modelNode.odysseyModelNode as OdysseyModelNodeLight).color.setRGB(\n                data.x,\n                data.y,\n                data.z\n              );\n            }\n            break;\n          case OdysseyModelControllerType.Multiplier:\n            if ((modelNode.odysseyModelNode.nodeType & OdysseyModelNodeType.Light) == OdysseyModelNodeType.Light) {\n              (modelNode.odysseyModelNode as OdysseyModelNodeLight).multiplier = data.value;\n            }\n            break;\n          case OdysseyModelControllerType.Radius:\n            if ((modelNode.odysseyModelNode.nodeType & OdysseyModelNodeType.Light) == OdysseyModelNodeType.Light) {\n              (modelNode.odysseyModelNode as OdysseyModelNodeLight).radius = data.value;\n            }\n            break;\n        }\n\n      });\n      modelNode.updateMatrix();\n      if (modelNode.userData.mesh) {\n        modelNode.userData.mesh.geometry.computeBoundingSphere();\n      }\n\n    }\n\n  }\n\n  disableMatrixUpdate() {\n    this.traverse((node) => {\n      if (node instanceof OdysseyModel3D) {\n        node.matrixAutoUpdate = false;\n      }\n    });\n    this.matrixAutoUpdate = true;\n  }\n\n  enableMatrixUpdate() {\n    this.traverse((node) => {\n      if (node instanceof OdysseyModel3D) {\n        node.matrixAutoUpdate = true;\n      }\n    });\n    this.matrixAutoUpdate = true;\n  }\n\n  generateForceShieldGeometry(shieldTexName = '') {\n    //Start by making sure there are not any lingering forceShieldGeometries\n    this.disposeForceShieldGeometry();\n\n    //Clone the skins\n    for (let i = 0, len = this.skins.length; i < len; i++) {\n      const originalSkinMesh = this.skins[i];\n      const skinMesh = originalSkinMesh.clone();\n      const skinMaterial = new THREE.ShaderMaterial({\n        fragmentShader: THREE.ShaderLib.odyssey.fragmentShader,\n        vertexShader: THREE.ShaderLib.odyssey.vertexShader,\n        uniforms: THREE.UniformsUtils.clone(THREE.ShaderLib.odyssey.uniforms),\n        side: THREE.FrontSide,\n        lights: true,\n        fog: true,\n        skinning: true\n      } as THREE.ShaderMaterialParameters);\n      skinMaterial.defines.FORCE_SHIELD = '';\n      skinMaterial.defines.AURORA = '';\n      skinMaterial.defines.USE_UV = '';\n      skinMaterial.defines.USE_SKINNING = '';\n      skinMaterial.uniforms.diffuse.value.r = 0.5;\n      skinMaterial.onBeforeCompile = odysseyOnBeforeCompile.bind(skinMaterial);\n\n      // skinMaterial.opacity = 0.5;\n      // skinMaterial.transparent = true;\n      // skinMaterial.blending = 2;\n      // skinMaterial.needsUpdate = true;\n\n      if (typeof shieldTexName == 'string' && shieldTexName.length) {\n        skinMaterial.userData.shield = shieldTexName;\n        TextureLoader.enQueue(shieldTexName, skinMaterial, TextureType.TEXTURE);\n      }\n\n      //Reuse the same skeleton\n      skinMesh.skeleton = originalSkinMesh.skeleton;\n      //Apply the new material\n      skinMesh.material = skinMaterial;\n\n      originalSkinMesh.matrixAutoUpdate = true;\n      skinMesh.matrixAutoUpdate = true;\n\n      originalSkinMesh.parent.add(skinMesh);\n      this.forceShieldGeometry.push(skinMesh);\n    }\n\n    //Load the Texture Queue\n    //TextureLoader.LoadQueue();\n  }\n\n  disposeForceShieldGeometry() {\n    while (this.forceShieldGeometry.length) {\n      const object = this.forceShieldGeometry.splice(0, 1)[0];\n      this.remove(object);\n\n      if (Array.isArray(object.material)) {\n        while (object.material.length) {\n          const material = object.material.splice(0, 1)[0];\n          this.disposeMaterial(material);\n          material.dispose();\n        }\n      } else {\n        this.disposeMaterial(object.material);\n        object.material.dispose();\n      }\n      object.geometry.dispose();\n    }\n  }\n\n  traverseIgnore(ignoreName: string = '', callback?: (obj: THREE.Object3D) => void) {\n\n    if (this.name == ignoreName)\n      return;\n\n    if (typeof callback == 'function')\n      callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      const child = children[i] as THREE.Object3D & { traverseIgnore?: (ignoreName: string, callback?: (obj: THREE.Object3D) => void) => void };\n      if (typeof child.traverseIgnore === 'function') {\n        child.traverseIgnore(ignoreName, callback);\n      }\n    }\n\n  }\n\n  static async SuperModelLoader(resref: string, odysseyModel: OdysseyModel3D): Promise<OdysseyModel3D> {\n    const supermodel: OdysseyModel = await MDLLoader.loader.load(resref);\n    if (!supermodel) {\n      return odysseyModel;\n    }\n\n    //--------------------------------------//\n    // Supermodel: Animations Merge - Begin\n    //--------------------------------------//\n    for (let i = 0, ilen = supermodel.animations.length; i < ilen; i++) {\n      const animName = supermodel.animations[i].name;\n      const hasAnim = odysseyModel.odysseyAnimationMap.has(animName);\n      if (!hasAnim) {\n        const anim = OdysseyModelAnimation.From(supermodel.animations[i]);\n        odysseyModel.odysseyAnimations.push(anim);\n        odysseyModel.odysseyAnimationMap.set(anim.name, anim);\n      }\n    }\n    //------------------------------------//\n    // Supermodel: Animations Merge - End\n    //------------------------------------//\n\n    const superModelName = supermodel.modelHeader.superModelName;\n    if (superModelName) {\n      return OdysseyModel3D.SuperModelLoader(superModelName, odysseyModel);\n    }\n    return odysseyModel;\n  }\n\n  static async FromMDL(model: OdysseyModel, _options: IOdysseyModelLoaderOptions = {} as IOdysseyModelLoaderOptions): Promise<OdysseyModel3D> {\n    return new Promise<OdysseyModel3D>((resolve: (value: OdysseyModel3D) => void, reject: (reason?: unknown) => void) => {\n\n      const _default: IOdysseyModelLoaderOptions = {\n        textureVar: '****',\n        castShadow: false,\n        receiveShadow: false,\n        manageLighting: true,\n        // context: Game,\n        mergeStatic: false, //Use on room models\n        static: false, //Static placeable\n        parseChildren: true,\n        isChildrenDynamic: false,\n      } as IOdysseyModelLoaderOptions;\n\n      const options: IOdysseyModelLoaderOptions = { ..._default, ..._options };\n\n      if (model) {\n\n        const odysseyModel = new OdysseyModel3D();\n        odysseyModel.context = options.context as IGameContext | undefined;\n        odysseyModel.name = model.geometryHeader.modelName.toLowerCase().trim();\n        odysseyModel.options = options;\n        odysseyModel.odysseyAnimations = [];//model.animations.slice();\n        if (!(odysseyModel.odysseyAnimations instanceof Array)) {\n          odysseyModel.odysseyAnimations = [];\n        } else {\n          for (let i = 0; i < model.animations.length; i++) {\n            odysseyModel.odysseyAnimations[i] = OdysseyModelAnimation.From(model.animations[i]);\n            odysseyModel.odysseyAnimationMap.set(odysseyModel.odysseyAnimations[i].name, odysseyModel.odysseyAnimations[i]);\n          }\n        }\n        odysseyModel.Scale = 1;\n        odysseyModel.names = model.names;\n        odysseyModel.modelHeader = model.modelHeader;\n        odysseyModel.affectedByFog = model.modelHeader.fogged ? true : false;\n\n        if (options.mergeStatic) {\n          odysseyModel.mergedGeometries = [];\n          odysseyModel.mergedDanglyGeometries = [];\n          odysseyModel.mergedMaterials = [];\n          odysseyModel.mergedDanglyMaterials = [];\n\n          // Material-based geometry grouping for optimized merging\n          odysseyModel.geometryGroupsByMaterial = new Map<THREE.Material, THREE.BufferGeometry[]>();\n        }\n\n        odysseyModel.add(OdysseyModel3D.NodeParser(odysseyModel, odysseyModel, model.rootNode, options));\n\n        odysseyModel.userData.uuids = OdysseyModel3D.getUUIDs(odysseyModel);\n\n        if (options.mergeStatic) {\n\n          //Merge Basic Geometries by Material\n          if (odysseyModel.geometryGroupsByMaterial.size > 0) {\n            const finalGeometries: THREE.BufferGeometry[] = [];\n            const finalMaterials: THREE.Material[] = [];\n\n            // Process each material group\n            for (const [material, geometries] of odysseyModel.geometryGroupsByMaterial) {\n              if (!geometries.length) { continue; }\n\n              // Pre-merge geometries that use the same material\n              const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries, true);\n              finalGeometries.push(mergedGeometry);\n              finalMaterials.push(material);\n\n              // Dispose of individual geometries\n              for (const geometry of geometries) {\n                geometry.dispose();\n              }\n            }\n\n            // Final merge of all pre-merged geometries\n            if (finalGeometries.length > 0) {\n              odysseyModel.mergedBufferGeometry = BufferGeometryUtils.mergeBufferGeometries(finalGeometries, true);\n              odysseyModel.mergedMesh = new THREE.Mesh(odysseyModel.mergedBufferGeometry, finalMaterials);\n              odysseyModel.mergedMesh.receiveShadow = true;\n              odysseyModel.add(odysseyModel.mergedMesh as THREE.Object3D);\n\n              // Dispose of pre-merged geometries\n              for (const geometry of finalGeometries) {\n                geometry.dispose();\n              }\n            }\n\n            // Clear the material groups\n            odysseyModel.geometryGroupsByMaterial.clear();\n          }\n\n          //Merge Dangly Geometries\n          if (odysseyModel.mergedDanglyGeometries.length) {\n\n            odysseyModel.mergedBufferDanglyGeometry = BufferGeometryUtils.mergeBufferGeometries(odysseyModel.mergedDanglyGeometries, true);\n            odysseyModel.mergedDanglyMesh = new THREE.Mesh(odysseyModel.mergedBufferDanglyGeometry, odysseyModel.mergedDanglyMaterials);\n            //odysseyModel.mergedDanglyMesh.receiveShadow = true;\n            odysseyModel.add(odysseyModel.mergedDanglyMesh as THREE.Object3D);\n\n            for (let i = 0, len = odysseyModel.mergedDanglyGeometries.length; i < len; i++) {\n              odysseyModel.mergedDanglyGeometries[i].dispose();\n            }\n            odysseyModel.mergedDanglyGeometries = [];\n\n          }\n\n          //Prune all the empty nodes\n          const pruneList: THREE.Object3D[] = [];\n          odysseyModel.traverseIgnore(odysseyModel.name + 'a', (node: THREE.Object3D) => {\n            const objNode = node as OdysseyObject3D;\n            if (objNode.NodeType === 33 && !node.children.length) {\n              pruneList.push(node);\n            }\n          });\n          let pruneCount = pruneList.length;\n          //log.info('pruneList', pruneList, pruneCount);\n          while (pruneCount--) {\n            const node = pruneList.splice(0, 1)[0];\n            node.removeFromParent();\n          }\n\n        }\n\n        odysseyModel.buildSkeleton();\n\n        const finish = () => {\n          odysseyModel.box.setFromArray([\n            model.modelHeader.boundingMinX,\n            model.modelHeader.boundingMinY,\n            model.modelHeader.boundingMinZ,\n            model.modelHeader.boundingMaxX,\n            model.modelHeader.boundingMaxY,\n            model.modelHeader.boundingMaxZ,\n          ]);\n          if (typeof _options.onComplete === 'function') _options.onComplete(odysseyModel);\n          resolve(odysseyModel);\n        };\n\n        if (model.modelHeader.superModelName.indexOf(\"null\") == -1 && model.modelHeader.superModelName != '') {\n          OdysseyModel3D.SuperModelLoader(model.modelHeader.superModelName.toLowerCase(), odysseyModel).then(finish).catch(reject);\n        } else {\n          finish();\n        }\n      } else {\n        if (typeof _options.onComplete === 'function') _options.onComplete();\n        reject('model is not of type OdysseyModel');\n      }\n    });\n\n  }\n\n  static NodeParser(odysseyModel: OdysseyModel3D, parentNode: THREE.Object3D, odysseyNode: OdysseyModelNode, options: IOdysseyModelLoaderOptions) {\n\n    //Skip over LightMap Omnilight and Spotlight references because they are blank nodes\n    //Don't know if this will have any side effects yet\n    if (odysseyNode.name.toLowerCase().indexOf('lmomnilight') >= 0 || odysseyNode.name.toLowerCase().indexOf('lmspotlight') >= 0) {\n      return;\n    }\n\n    const node = new OdysseyObject3D(odysseyNode);\n    node.NodeType = odysseyNode.nodeType;\n\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB) {\n      odysseyModel.aabb = odysseyNode as OdysseyModelNodeAABB;\n    }\n\n    node.controllers = odysseyNode.controllers;\n\n    if (odysseyNode.controllers.has(OdysseyModelControllerType.Orientation)) {\n      node.controllerHelpers.hasOrientation = true;\n      node.controllerHelpers.orientation = odysseyNode.controllers.get(OdysseyModelControllerType.Orientation);\n    }\n\n    if (odysseyNode.controllers.has(OdysseyModelControllerType.Position)) {\n      node.controllerHelpers.hasPosition = true;\n      node.controllerHelpers.position = odysseyNode.controllers.get(OdysseyModelControllerType.Position);\n    }\n\n    if (odysseyNode.controllers.has(OdysseyModelControllerType.Scale)) {\n      node.controllerHelpers.hasScale = true;\n      node.controllerHelpers.scale = odysseyNode.controllers.get(OdysseyModelControllerType.Scale);\n    }\n\n    node.position.set(odysseyNode.position.x, odysseyNode.position.y, odysseyNode.position.z);\n    node.quaternion.set(odysseyNode.quaternion.x, odysseyNode.quaternion.y, odysseyNode.quaternion.z, odysseyNode.quaternion.w);\n\n    node.name = odysseyNode.name.toLowerCase();\n\n    if (node.name == odysseyModel.name.toLowerCase() + 'a') {\n      options.isChildrenDynamic = true;\n    }\n\n    if (!odysseyModel.nodes.has(node.name))\n      odysseyModel.nodes.set(node.name, node);\n\n    parentNode.add(node);\n\n    //-----------//\n    // MESH NODE\n    //-----------//\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.Mesh) == OdysseyModelNodeType.Mesh && odysseyNode) {\n      OdysseyModel3D.NodeMeshBuilder(odysseyModel, node, odysseyNode as OdysseyModelNodeMesh, options);\n    }\n\n    //------------//\n    // LIGHT NODE\n    //------------//\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.Light) == OdysseyModelNodeType.Light && odysseyNode) {\n      node.light = OdysseyModel3D.NodeLightBuilder(odysseyModel, node, odysseyNode as OdysseyModelNodeLight, options);\n    }\n\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.Emitter) == OdysseyModelNodeType.Emitter && odysseyNode) {\n      node.emitter = new OdysseyEmitter3D(odysseyNode);\n      node.emitter.context = odysseyModel.context;\n      node.emitter.name = odysseyNode.name + '_em'\n      node.add(node.emitter);\n      odysseyModel.emitters.push(node.emitter);\n    }\n\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.Reference) == OdysseyModelNodeType.Reference && odysseyNode) {\n      //log.info('OdysseyModel', 'Reference Node', options.parent);\n      if (parentNode.parent instanceof OdysseyEmitter3D) {\n        parentNode.parent.emitter.setReferenceNode(node)\n      } else {\n        const refNode = odysseyNode as OdysseyModelNodeReference;\n        log.info('Loading child model: ' + refNode.modelName);\n        MDLLoader.loader.load(refNode.modelName).then((childModel) => {\n          if (childModel) {\n            const opts = odysseyModel.options as IOdysseyModelLoaderOptions;\n            OdysseyModel3D.FromMDL(childModel, { context: opts?.context, editorMode: opts?.editorMode === true }).then((childModel3D) => {\n              if (childModel3D) {\n                node.add(childModel3D);\n                odysseyModel.childModels.push(childModel3D);\n              }\n            }).catch((e) => {\n              log.error(e);\n            });\n          }\n        }).catch((e) => {\n          log.error(e);\n        });\n      }\n    }\n\n    switch (node.name) {\n      case 'talkdummy':\n        odysseyModel.talkdummy = node;\n        break;\n      case 'cutscenedummy':\n        odysseyModel.cutscenedummy = node;\n        break;\n      case 'rootdummy':\n        odysseyModel.rootdummy = node;\n        break;\n      case 'headhook':\n        odysseyModel.headhook = node;\n        break;\n      case 'camerahook':\n        odysseyModel.camerahook = node;\n        break;\n      case 'camerahookm':\n        odysseyModel.camerahookm = node;\n        break;\n      case 'camerahookf':\n        odysseyModel.camerahookf = node;\n        break;\n      case 'freelookhook':\n        odysseyModel.freelookhook = node;\n        break;\n      case 'lookathook':\n        odysseyModel.lookathook = node;\n        break;\n      case 'lightsaberhook':\n        odysseyModel.lightsaberhook = node;\n        break;\n      case 'deflecthook':\n        odysseyModel.deflecthook = node;\n        break;\n      case 'maskhook':\n        odysseyModel.maskhook = node;\n        break;\n      case 'gogglehook':\n        odysseyModel.gogglehook = node;\n        break;\n      case 'rhand':\n        odysseyModel.rhand = node;\n        break;\n      case 'lhand':\n        odysseyModel.lhand = node;\n        break;\n      case 'impact':\n        odysseyModel.impact = node;\n        break;\n      case 'impact_bolt':\n        odysseyModel.impact_bolt = node;\n        break;\n      case 'headconjure':\n        odysseyModel.headconjure = node;\n        break;\n      case 'handconjure':\n        odysseyModel.handconjure = node;\n        break;\n      case 'trans':\n        odysseyModel.trans = node;\n        break;\n      case 'bullethook0':\n        odysseyModel.bullethook0 = node;\n        break;\n      case 'bullethook1':\n        odysseyModel.bullethook1 = node;\n        break;\n      case 'bullethook2':\n        odysseyModel.bullethook2 = node;\n        break;\n      case 'bullethook3':\n        odysseyModel.bullethook3 = node;\n        break;\n      case 'gunhook0':\n        odysseyModel.gunhook0 = node;\n        break;\n      case 'gunhook1':\n        odysseyModel.gunhook1 = node;\n        break;\n      case 'gunhook2':\n        odysseyModel.gunhook2 = node;\n        break;\n      case 'gunhook3':\n        odysseyModel.gunhook3 = node;\n        break;\n      case 'modelhook':\n        odysseyModel.modelhook = node;\n        break;\n      case 'hturn_g':\n        odysseyModel.hturn_g = node;\n        break;\n    }\n\n    node.matrixInverse = new THREE.Matrix4();\n    node.matrixInverse.copy(node.matrix).invert();\n    //node.matrixInverse.getInverse( node.matrix.clone() );\n\n    if (options.parseChildren) {\n      for (let i = 0; i < odysseyNode.children.length; i++) {\n        OdysseyModel3D.NodeParser(odysseyModel, node, odysseyNode.children[i], options);\n      }\n    }\n\n    return node;\n\n  }\n\n  static NodeMeshBuilder(\n    odysseyModel: OdysseyModel3D,\n    parentNode: THREE.Object3D,\n    odysseyNode: OdysseyModelNodeMesh | OdysseyModelNodeDangly | OdysseyModelNodeSkin | OdysseyModelNodeAABB | OdysseyModelNodeSaber,\n    options: IOdysseyModelLoaderOptions\n  ) {\n    try {\n      //Create geometry only if the mesh is visible or it is a walkmesh\n\n      //Make sure there is at least one face before we attempt to build the mesh\n      if (odysseyNode.faces.length) {\n\n        if (!odysseyNode.isAnimDummyNode) {\n          //de-opt geometry if no uv's are present, we currently cannot handle this issue.\n          if (!odysseyNode.tvectors[0].length) odysseyNode.isAnimDummyNode = true;\n        }\n\n        //Optimization: Only create a mesh if it is actually rendered. Ignore this for placeable models\n        //This breaks shadows because the original game uses the bones of the model to cast shadows.\n        //This can possibly be remedied by setting skin meshes to cast shadows.\n        if ((odysseyNode.flagRender || options.editorMode) || (odysseyModel.modelHeader.classification == OdysseyModelClass.PLACEABLE)) {\n\n          //-------------------------//\n          // BEGIN: GEOMETRY BUILDER\n          //-------------------------//\n\n          let geometry = undefined;\n\n          //-------------------//\n          // BUFFERED GEOMETRY\n          //-------------------//\n          if ((odysseyNode.nodeType & OdysseyModelNodeType.AABB) != OdysseyModelNodeType.AABB) {\n\n            geometry = new THREE.BufferGeometry();\n            geometry.setIndex(odysseyNode.indices); //Works with indices\n\n            //Positions\n            geometry.setAttribute('position', new THREE.Float32BufferAttribute(odysseyNode.vertices, 3)); //Works with indices\n\n            //Normals\n            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(odysseyNode.normals, 3));//.copyArray( odysseyNode.normals ) ); //Works with indices\n\n            //Color\n            // // const color = new Float32Array( odysseyNode.vertices.length ); //Works with indices\n            // geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( odysseyNode.vertices, 3 ) );//.copyArray( new Array(odysseyNode.vertices.length).fill(1, 0, odysseyNode.vertices.length) ) ); //Works with indices\n\n            //UV1\n            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(odysseyNode.tvectors[0], 2));//.copyArray( odysseyNode.tvectors[0] ) ); //Works with indices\n\n            //UV2\n            geometry.setAttribute('uv2', new THREE.Float32BufferAttribute(odysseyNode.tvectors[1], 2));//.copyArray( odysseyNode.tvectors[1] ) ); //Works with indices\n\n            //--------------------------//\n            // SKIN GEOMETRY ATTRIBUTES\n            //--------------------------//\n            if ((odysseyNode.nodeType & OdysseyModelNodeType.Skin) == OdysseyModelNodeType.Skin) {\n              //Skin Index\n              geometry.setAttribute('skinIndex', new THREE.Float32BufferAttribute((odysseyNode as OdysseyModelNodeSkin).boneIdx, 4))\n\n              //Skin Weight\n              geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute((odysseyNode as OdysseyModelNodeSkin).weights, 4));\n            }\n\n            //----------------------------//\n            // DANGLY GEOMETRY ATTRIBUTES\n            //----------------------------//\n            if ((odysseyNode.nodeType & OdysseyModelNodeType.Dangly) == OdysseyModelNodeType.Dangly) {\n              //Contstraint\n              geometry.setAttribute('constraint', new THREE.Float32BufferAttribute((odysseyNode as OdysseyModelNodeDangly).danglyVec4, 4));//.copyArray( (odysseyNode as OdysseyModelNodeDangly).danglyVec4 ) ); //Works with indices\n            }\n\n            //Compute Geometry Tangents\n            if ((odysseyNode.nodeType & OdysseyModelNodeType.Saber) != OdysseyModelNodeType.Saber) {\n              // BufferGeometryUtils.computeTangents(geometry);\n            }\n\n          } else {\n            geometry = new THREE.BufferGeometry();\n\n            const vertices = odysseyNode.faces.map(f => {\n              return [\n                odysseyNode.vertices[(f.a * 3) + 0], odysseyNode.vertices[(f.a * 3) + 1], odysseyNode.vertices[(f.a * 3) + 2],\n                odysseyNode.vertices[(f.b * 3) + 0], odysseyNode.vertices[(f.b * 3) + 1], odysseyNode.vertices[(f.b * 3) + 2],\n                odysseyNode.vertices[(f.c * 3) + 0], odysseyNode.vertices[(f.c * 3) + 1], odysseyNode.vertices[(f.c * 3) + 2],\n              ]\n            }).flat();\n\n            //Positions\n            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n            const normals = odysseyNode.faces.map(f => {\n              return [f.normal.x, f.normal.y, f.normal.z]\n            }).flat();\n\n            //Normals\n            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\n            const colors = odysseyNode.faces.map(f => {\n              return [\n                f.color.r, f.color.g, f.color.b,\n                f.color.r, f.color.g, f.color.b,\n                f.color.r, f.color.g, f.color.b,\n              ]\n            }).flat();\n\n            //Color\n            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n          }\n\n          //-------------------------//\n          // BEGIN: MATERIAL BUILDER\n          //-------------------------//\n          const material = OdysseyModel3D.NodeMaterialBuilder(odysseyModel, parentNode, odysseyNode, options);\n\n          //---------------------//\n          // BEGIN: MESH BUILDER\n          //---------------------//\n\n          let mesh = undefined;\n\n          //-----------//\n          // SKIN MESH\n          //-----------//\n          if ((odysseyNode.nodeType & OdysseyModelNodeType.Skin) == OdysseyModelNodeType.Skin) {\n            material.defines.USE_SKINNING = '';\n            mesh = new THREE.SkinnedMesh(geometry, material);\n            odysseyModel.skins.push(mesh);\n          }\n\n          //------------//\n          // BASIC MESH\n          //------------//\n          if (!mesh && geometry && material)\n            mesh = new THREE.Mesh(geometry, material);\n\n          if (!mesh) {\n            log.error('OdysseyModel3D', 'Failed to generate mesh node', odysseyNode);\n          }\n\n          //Need to see if this affects memory usage\n          mesh.userData.odysseyModel = odysseyModel;\n\n          // if((odysseyNode.NodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB && odysseyNode instanceof OdysseyModelNodeAABB){\n          //   odysseyModel.walkmesh = (mesh as THREE.Mesh);\n          //   mesh.material.visible = false;\n          // }\n\n          //RenderOrder\n          // if(odysseyNode.BackgroundGeometry){\n          //   mesh.renderOrder = 1000;\n          // }else if(options.isChildrenDynamic){\n          //   mesh.renderOrder = 5000;\n          // }\n\n          //----------------//\n          // MERGE GEOMETRY\n          //----------------//\n          if (!((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB) && !odysseyNode.backgroundGeometry && options.mergeStatic && !odysseyNode.isAnimDummyNode && odysseyNode.faces.length) {\n\n            parentNode.getWorldPosition(mesh.position);\n            parentNode.getWorldQuaternion(mesh.quaternion);\n            mesh.updateMatrix(); // as needed\n\n            //apply matrix to positions\n            (geometry.getAttribute('position') as THREE.BufferAttribute).applyMatrix4(mesh.matrix);\n\n            //apply matrix to normals\n            const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrix);\n            (geometry.getAttribute('normal') as THREE.BufferAttribute).applyNormalMatrix(normalMatrix);\n            geometry.normalizeNormals();\n\n            if ((odysseyNode.nodeType & OdysseyModelNodeType.Dangly) == OdysseyModelNodeType.Dangly) {\n              odysseyModel.mergedDanglyGeometries.push(geometry);\n              odysseyModel.mergedDanglyMaterials.push(material);\n            } else {\n              // Group regular geometries by material\n              if (!odysseyModel.geometryGroupsByMaterial.has(material)) {\n                odysseyModel.geometryGroupsByMaterial.set(material, []);\n              }\n              odysseyModel.geometryGroupsByMaterial.get(material).push(geometry);\n            }\n\n            //Unset the mesh variable so it can't be added to the node\n            mesh = undefined;\n          }\n\n          //------------------//\n          // ADD MESH TO NODE\n          //------------------//\n          if (mesh instanceof THREE.Mesh) {\n            (mesh as THREE.Mesh & { odysseyNode?: OdysseyModelNode }).odysseyNode = odysseyNode;\n            mesh.userData.odysseyModelNode = odysseyNode;\n            mesh.matrixAutoUpdate = true;\n            if (!((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB)) {\n              parentNode.add(mesh);\n              parentNode.userData.mesh = mesh;\n            }\n            if (!((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB)) {\n              mesh.castShadow = odysseyNode.flagShadow;// && !options.static;//options.castShadow;\n              mesh.receiveShadow = options.receiveShadow;\n            }\n          }\n\n        }\n\n      }\n\n    } catch (e) {\n      log.error('OdysseyModel3D failed to generate mesh', odysseyNode, e);\n    }\n  }\n\n  cachedMaterials: Map<string, THREE.Material> = new Map<string, THREE.Material>();\n  static NodeMaterialCacheId(odysseyNode: OdysseyModelNodeMesh): string {\n    return `T1:${odysseyNode.textureMap1 || 'NONE'}|T2:${odysseyNode.textureMap2 || 'NONE'}|T3:${odysseyNode.textureMap3 || 'NONE'}|T4:${odysseyNode.textureMap4 || 'NONE'}`;\n  }\n\n  static NodeMaterialBuilder(odysseyModel: OdysseyModel3D, parentNode: THREE.Object3D, odysseyNode: OdysseyModelNodeMesh, options: IOdysseyModelLoaderOptions) {\n\n    let tMap1 = odysseyNode.textureMap1 + '';\n    const tMap2 = odysseyNode.textureMap2 + '';\n    let fallbackTexture = null;\n\n    if (options.textureVar != '' && options.textureVar.indexOf('****') == -1) {\n      fallbackTexture = tMap1;\n      tMap1 = options.textureVar;\n    }\n\n    if (tMap1 || tMap2) {\n      //odysseyNode.Diffuse.r = odysseyNode.Diffuse.g = odysseyNode.Diffuse.b = 0.8;\n    }\n    let material: THREE.Material;\n    if ((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB) {\n      material = new THREE.MeshBasicMaterial({\n        vertexColors: true,\n        fog: false,\n        side: THREE.FrontSide,\n      });\n    } else {\n      const cacheId = OdysseyModel3D.NodeMaterialCacheId(odysseyNode);\n      if (odysseyModel.cachedMaterials.has(cacheId) && options.mergeStatic && !odysseyNode.isAnimDummyNode) {\n        // return odysseyModel.cachedMaterials.get(cacheId);\n      }\n\n      material = new THREE.ShaderMaterial({\n        fragmentShader: THREE.ShaderLib.odyssey.fragmentShader,\n        vertexShader: THREE.ShaderLib.odyssey.vertexShader,\n        uniforms: THREE.UniformsUtils.clone(THREE.ShaderLib.odyssey.uniforms),\n        side: THREE.FrontSide,\n        lights: true,\n        fog: odysseyModel.affectedByFog,\n      });\n\n      if (material instanceof THREE.ShaderMaterial) {\n        material.uniforms.shininess.value = 0.0000001;\n        (material.extensions as { derivatives?: boolean }).derivatives = true;\n        //material.extensions.fragDepth = true;\n        if (options.useTweakColor) {\n          material.uniforms.diffuse.value = new THREE.Color(odysseyNode.diffuse.r, odysseyNode.diffuse.g, odysseyNode.diffuse.b);\n          material.uniforms.tweakColor.value.setRGB((options.tweakColor & 255) / 255, ((options.tweakColor >> 8) & 255) / 255, ((options.tweakColor >> 16) & 255) / 255);\n          material.defines.USE_TWEAK_COLOR = '';\n        } else {\n          material.uniforms.tweakColor.value.setRGB(1, 1, 1);\n          material.uniforms.diffuse.value = new THREE.Color(1, 1, 1);//odysseyNode.Diffuse.r, odysseyNode.Diffuse.g, odysseyNode.Diffuse.b );\n        }\n        material.uniforms.time.value = Number((options?.context as { time?: number } | undefined)?.time) || 0;\n        material.defines = material.defines || {};\n        material.defines.AURORA = \"\";\n\n        if (options.isForceShield) {\n          material.defines.FORCE_SHIELD = \"\";\n          material.defines.IGNORE_LIGHTING = \"\";\n        }\n\n        if (odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.UV1 ||\n          odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.UV2 ||\n          odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.UV3 ||\n          odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.UV4 ||\n          ((odysseyNode.nodeType & OdysseyModelNodeType.Saber) == OdysseyModelNodeType.Saber)\n        ) {\n          material.defines.USE_UV = \"\";\n        }\n\n        if (odysseyNode.controllers.has(OdysseyModelControllerType.SelfIllumColor)) {\n          const selfIllumColor = odysseyNode.controllers.get(OdysseyModelControllerType.SelfIllumColor);\n          const frame = selfIllumColor.data[0];\n          if (frame) {\n            material.defines.SELFILLUMCOLOR = \"\";\n            material.uniforms.selfIllumColor.value.setRGB(frame.x, frame.y, frame.z);\n          }\n        }\n        material.onBeforeCompile = odysseyOnBeforeCompile.bind(material);\n      }\n\n      if (!odysseyNode.flagRender && !((odysseyNode.nodeType & OdysseyModelNodeType.AABB) == OdysseyModelNodeType.AABB)) {\n        material.visible = false;\n      }\n\n      odysseyModel.materials.push(material);\n\n      if (odysseyNode.hasLightmap && tMap2.length) {\n        material.userData.lightmap = tMap2;\n        TextureLoader.enQueue(tMap2, material, TextureType.LIGHTMAP);\n      }\n\n      if ((!(odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.TANGENT1) &&\n        !(odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.TANGENT2) &&\n        !(odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.TANGENT3) &&\n        !(odysseyNode.MDXDataBitmap & OdysseyModelMDXFlag.TANGENT4) &&\n        !odysseyNode.flagShadow && !options.castShadow) || odysseyNode.backgroundGeometry || options.static) {\n        if (!options.lighting) {\n          material.defines.IGNORE_LIGHTING = \"\";\n        }\n      }\n\n      if ((odysseyNode.nodeType & OdysseyModelNodeType.Saber) == OdysseyModelNodeType.Saber) {\n        material.defines.IGNORE_LIGHTING = \"\";\n        material.defines.SABER = \"\";\n      }\n\n      if (options.isHologram) {\n        material.defines.HOLOGRAM = \"\";\n        material.transparent = true;\n        if (odysseyNode.hideInHolograms) {\n          material.visible = false;\n        }\n      }\n\n      if (material instanceof THREE.ShaderMaterial) {\n        //Set dangly uniforms\n        if ((odysseyNode.nodeType & OdysseyModelNodeType.Dangly) == OdysseyModelNodeType.Dangly && odysseyNode) {\n          const node: OdysseyModelNodeDangly = odysseyNode as OdysseyModelNodeDangly;\n          material.uniforms.danglyDisplacement.value = node.danglyDisplacement;\n          material.uniforms.danglyTightness.value = node.danglyTightness;\n          material.uniforms.danglyPeriod.value = node.danglyPeriod;\n          material.defines.DANGLY = '';\n        }\n\n        //Set animated uv uniforms\n        if (odysseyNode.nAnimateUV) {\n          material.uniforms.animatedUV.value.set(odysseyNode.fUVDirectionX, odysseyNode.fUVDirectionY, odysseyNode.fUVJitter, odysseyNode.fUVJitterSpeed);\n          material.defines.ANIMATED_UV = '';\n        }\n      }\n\n      if (odysseyNode.transparencyHint) {\n        material.transparent = true;\n      }\n\n      odysseyNode.controllers.forEach((controller) => {\n        switch (controller.type) {\n          case OdysseyModelControllerType.Alpha:\n\n            if (material instanceof THREE.ShaderMaterial) {\n              material.uniforms.opacity.value = controller.data[0].value;\n            } else {\n              material.opacity = controller.data[0].value;\n            }\n\n            if (controller.data[0].value < 1) {\n              material.transparent = true;\n            } else {\n              material.transparent = false;\n            }\n            break;\n        }\n      });\n\n      if (!!tMap1 && tMap1 != 'toolcolors') {\n        material.userData.map = tMap1;\n        TextureLoader.enQueue(tMap1, material, TextureType.TEXTURE, undefined, fallbackTexture);\n      } else {\n        if (material instanceof THREE.ShaderMaterial) {\n          material.uniforms.diffuse.value.copy(odysseyNode.diffuse);\n        }\n      }\n\n      material.needsUpdate = true;\n      odysseyModel.cachedMaterials.set(cacheId, material);\n    }\n    return material;\n  }\n\n  static NodeLightBuilder(odysseyModel: OdysseyModel3D, parentNode: THREE.Object3D, odysseyNode: OdysseyModelNodeLight, options: IOdysseyModelLoaderOptions): THREE.Light | OdysseyLight3D {\n\n\n\n    //if(GameKey != \"TSL\"){\n    //  odysseyNode.intensity = odysseyNode.intensity > 1 ? odysseyNode.intensity * .01 : odysseyNode.intensity;\n    //}else{\n    // odysseyNode.intensity = odysseyNode.intensity * odysseyNode.multiplier;// > 1 ? odysseyNode.intensity * .01 : odysseyNode.intensity;\n    //}\n\n    let lightNode: THREE.Light | OdysseyLight3D;\n\n    if (!options.manageLighting) {\n      if (odysseyNode.ambientFlag) {\n        lightNode = new THREE.AmbientLight(odysseyNode.color);\n        lightNode.intensity = odysseyNode.multiplier * 0.5;\n      } else {\n        lightNode = new THREE.PointLight(odysseyNode.color, 1, 1, 1);\n        (lightNode.shadow.camera as THREE.PerspectiveCamera).far = odysseyNode.radius;\n      }\n      lightNode.userData = {\n        decay: 1,\n        controllers: odysseyNode.controllers,\n        helper: { visiable: false },\n      }\n      lightNode.visible = true;\n\n      lightNode.userData.radius = 5.0;\n      lightNode.userData.multiplier = 1;\n      lightNode.intensity = 1;\n\n      parentNode.add(lightNode);\n      OdysseyModel3D.NodeLensflareBuilder(odysseyModel, lightNode, odysseyNode, options);\n    } else {\n      lightNode = new OdysseyLight3D(odysseyNode);\n      lightNode.odysseyModel = odysseyModel;\n      lightNode.isAnimated = odysseyNode.isAnimDummyNode;\n      lightNode.position.copy(odysseyNode.position);\n      parentNode.add(lightNode);\n\n      lightNode.parentUUID = odysseyModel.uuid;\n      lightNode.userData.odysseyModel = odysseyModel;\n      lightNode.userData.odysseyNode = odysseyNode;\n\n      lightNode.priority = odysseyNode.lightPriority;\n      lightNode.isAmbient = odysseyNode.ambientFlag ? true : false;\n      lightNode.isDynamic = odysseyNode.dynamicFlag ? true : false;\n      lightNode.affectDynamic = odysseyNode.affectDynamicFlag ? true : false;\n      lightNode.castShadow = odysseyNode.shadowFlag ? true : false;\n      lightNode.genFlare = odysseyNode.generateFlareFlag ? true : false;\n      lightNode.isFading = odysseyNode.fadingLightFlag;\n      lightNode.maxIntensity = 1;\n      lightNode.color = odysseyNode.color;\n      OdysseyModel3D.NodeLensflareBuilder(odysseyModel, lightNode, odysseyNode, options);\n      if (!!odysseyModel.context && !!odysseyModel.context.lightManager) {\n        odysseyModel.context.lightManager.addLight(lightNode);\n      }\n    }\n\n    odysseyNode.controllers.forEach((controller) => {\n      switch (controller.type) {\n        case OdysseyModelControllerType.Color:\n          lightNode.color = new THREE.Color(controller.data[0].x, controller.data[0].y, controller.data[0].z);\n          break;\n        case OdysseyModelControllerType.Position:\n          //odysseyNode.position.set(controller.data[0].x, controller.data[0].y, controller.data[0].z);\n          break;\n        case OdysseyModelControllerType.Radius:\n          if (lightNode instanceof THREE.PointLight) {\n            lightNode.userData.radius = controller.data[0].value;\n            lightNode.distance = lightNode.userData.radius * lightNode.userData.multiplier;\n          } else if (lightNode instanceof THREE.AmbientLight) {\n            //Not supported on AmbientLights\n          } else if (lightNode instanceof OdysseyLight3D) {\n            lightNode.radius = controller.data[0].value;\n          }\n          break;\n        case OdysseyModelControllerType.Multiplier:\n          if (lightNode instanceof THREE.PointLight) {\n            lightNode.userData.multiplier = controller.data[0].value;\n            lightNode.distance = lightNode.userData.radius * lightNode.userData.multiplier;\n          } else if (lightNode instanceof THREE.AmbientLight) {\n            lightNode.userData.multiplier = controller.data[0].value;\n            lightNode.intensity = lightNode.userData.multiplier * 0.5;\n          } else if (lightNode instanceof OdysseyLight3D) {\n            lightNode.multiplier = controller.data[0].value;\n          }\n          break;\n      }\n    });\n\n    return lightNode;\n  }\n\n  static NodeLensflareBuilder(odysseyModel: OdysseyModel3D, parentNode: THREE.Light | OdysseyLight3D, odysseyNode: OdysseyModelNodeLight, options: IOdysseyModelLoaderOptions) {\n    if (odysseyNode.flare.radius) {\n      const lensFlare = new Lensflare();\n\n      for (let i = 0, len = odysseyNode.flare.textures.length; i < len; i++) {\n        TextureLoader.enQueue(odysseyNode.flare.textures[i], null, TextureType.TEXTURE, (texture: OdysseyTexture) => {\n          lensFlare.addElement(new LensflareElement(texture, odysseyNode.flare.sizes[i], odysseyNode.flare.positions[i], odysseyNode.flare.colorShifts[i]));\n        });\n      }\n\n      if (!options.manageLighting) {\n        //parentNode.add(lensFlare);\n      } else {\n        parentNode.userData.lensFlare = lensFlare;\n      }\n    }\n  }\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
