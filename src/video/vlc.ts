import { BitReaderLE } from './bitreader';
import { bink_tree_bits, bink_tree_lens } from './binkdata';

export interface Tree {
  vlc_num: number;
  syms: number[]; // 16 entries
}

// Read dynamic tree mapping as in FFmpeg read_tree
export function readTree(br: BitReaderLE): Tree {
  if (br.bitsLeft() < 4) throw new RangeError('tree: not enough bits');
  const vlc_num = br.readBits(4) & 0xF;
  const syms = new Array<number>(16).fill(0);
  if (vlc_num === 0) {
    for (let i = 0; i < 16; i++) syms[i] = i;
    return { vlc_num, syms };
  }
  if (br.readBit()) {
    // explicit list
    if (br.bitsLeft() < 3) throw new RangeError('tree: not enough bits len');
    let len = br.readBits(3);
    const used = new Array<boolean>(16).fill(false);
    for (let i = 0; i <= len; i++) {
      if (br.bitsLeft() < 4) throw new RangeError('tree: not enough bits sym');
      const v = br.readBits(4) & 0xF;
      syms[i] = v; used[v] = true;
    }
    for (let v = 0; v < 16 && len < 15; v++) {
      if (!used[v]) syms[++len] = v;
    }
  } else {
    // generated by successive merges
    let len = br.readBits(2);
    let input: number[] = new Array(16); for (let i = 0; i < 16; i++) input[i] = i;
    let output = new Array<number>(16);
    for (let i = 0; i <= len; i++) {
      const size = 1 << i;
      for (let t = 0; t < 16; t += size << 1) {
        merge(br, output, t, input, t, size);
      }
      const tmp = input; input = output; output = tmp;
    }
    for (let i = 0; i < 16; i++) syms[i] = input[i];
  }
  // Optional: lightweight sanity check
  if (vlc_num < 0 || vlc_num >= bink_tree_lens.length) {
    // eslint-disable-next-line no-console
    console.warn('[BINK][readTree] invalid vlc_num', vlc_num);
  }
  return { vlc_num, syms };
}

function merge(br: BitReaderLE, dst: number[], dstOff: number, src: number[], srcOff: number, size: number) {
  let p1 = srcOff, p2 = srcOff + size, i1 = size, i2 = size, d = dstOff;
  while (i1 && i2) {
    const bit = br.readBit();
    if (!bit) { dst[d++] = src[p1++]; i1--; } else { dst[d++] = src[p2++]; i2--; }
  }
  while (i1--) dst[d++] = src[p1++];
  while (i2--) dst[d++] = src[p2++];
}

// Pre-compute VLC code mappings for faster lookup
const VLC_CACHE: Array<Array<{ code: number, len: number, sym: number }>> = [];
(function buildVLCCache() {
  for (let vlcNum = 0; vlcNum < bink_tree_lens.length; vlcNum++) {
    const lens = bink_tree_lens[vlcNum];
    const bits = bink_tree_bits[vlcNum];
    const cache: Array<{ code: number, len: number, sym: number }> = [];

    for (let sym = 0; sym < 16; sym++) {
      const len = lens[sym];
      if (len > 0) {
        const code = bits[sym] & ((1 << len) - 1);
        cache.push({ code, len, sym });
      }
    }

    // Sort by length for faster matching (shorter codes first)
    cache.sort((a, b) => a.len - b.len);
    VLC_CACHE[vlcNum] = cache;
  }
})();

// Decode a 4-bit symbol using pre-defined tree `vlc_num` and LE codes - optimized
export function getVLC(br: BitReaderLE, vlc_num: number): number {
  const cache = VLC_CACHE[vlc_num];
  const available = br.bitsLeft();

  if (available <= 0) throw new RangeError('VLC: no bits left');

  // Try codes in order of increasing length
  for (const entry of cache) {
    if (entry.len > available) break;
    const peek = br.peekBits(entry.len);
    if (peek === entry.code) {
      br.skipBits(entry.len);
      return entry.sym & 0xF;
    }
  }

  // Fallback for edge cases
  const lens = bink_tree_lens[vlc_num];
  const bits = bink_tree_bits[vlc_num];
  let maxbits = 0;
  for (let i = 0; i < 16; i++) if (lens[i] > maxbits) maxbits = lens[i];

  if (available >= maxbits) {
    const pos = br.getBitPos();
    const look = br.peekBits(Math.min(24, available));
    // eslint-disable-next-line no-console
    console.error('[BINK][VLC] no match', { vlc_num, pos, available, maxbits, nextBitsLE: '0x' + look.toString(16) });
  }
  throw new RangeError('VLC: no match');
}

export function getHuff(br: BitReaderLE, tree: Tree): number {
  const sym = getVLC(br, tree.vlc_num);
  return tree.syms[sym] & 0xF;
}
